{"remainingRequest":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/babel-loader/lib/index.js!/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-engine/src/view/range.js","dependencies":[{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-engine/src/view/range.js","mtime":499162500000},{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js","mtime":499162500000},{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/babel-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:LyoqCiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDE5LCBDS1NvdXJjZSAtIEZyZWRlcmljbyBLbmFiYmVuLiBBbGwgcmlnaHRzIHJlc2VydmVkLgogKiBGb3IgbGljZW5zaW5nLCBzZWUgTElDRU5TRS5tZCBvciBodHRwczovL2NrZWRpdG9yLmNvbS9sZWdhbC9ja2VkaXRvci1vc3MtbGljZW5zZQogKi8KCi8qKgogKiBAbW9kdWxlIGVuZ2luZS92aWV3L3JhbmdlCiAqLwppbXBvcnQgUG9zaXRpb24gZnJvbSAnLi9wb3NpdGlvbic7CmltcG9ydCBUcmVlV2Fsa2VyIGZyb20gJy4vdHJlZXdhbGtlcic7Ci8qKgogKiBSYW5nZSBpbiB0aGUgdmlldyB0cmVlLiBBIHJhbmdlIGlzIHJlcHJlc2VudGVkIGJ5IGl0cyBzdGFydCBhbmQgZW5kIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvcG9zaXRpb25+UG9zaXRpb24gcG9zaXRpb25zfS4KICoKICogSW4gb3JkZXIgdG8gY3JlYXRlIGEgbmV3IHBvc2l0aW9uIGluc3RhbmNlIHVzZSB0aGUgYGNyZWF0ZVBvc2l0aW9uKigpYCBmYWN0b3J5IG1ldGhvZHMgYXZhaWxhYmxlIGluOgogKgogKiAqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdmlld35WaWV3fQogKiAqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZG93bmNhc3R3cml0ZXJ+RG93bmNhc3RXcml0ZXJ9CiAqICoge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy91cGNhc3R3cml0ZXJ+VXBjYXN0V3JpdGVyfQogKi8KCmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJhbmdlIHsKICAvKioKICAgKiBDcmVhdGVzIGEgcmFuZ2Ugc3Bhbm5pbmcgZnJvbSBgc3RhcnRgIHBvc2l0aW9uIHRvIGBlbmRgIHBvc2l0aW9uLgogICAqCiAgICogKipOb3RlOioqIENvbnN0cnVjdG9yIGNyZWF0ZXMgaXQncyBvd24ge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbn0gaW5zdGFuY2VzIGJhc2luZyBvbiBwYXNzZWQgdmFsdWVzLgogICAqCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvcG9zaXRpb25+UG9zaXRpb259IHN0YXJ0IFN0YXJ0IHBvc2l0aW9uLgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L3Bvc2l0aW9uflBvc2l0aW9ufSBbZW5kXSBFbmQgcG9zaXRpb24uIElmIG5vdCBzZXQsIHJhbmdlIHdpbGwgYmUgY29sbGFwc2VkIGF0IHRoZSBgc3RhcnRgIHBvc2l0aW9uLgogICAqLwogIGNvbnN0cnVjdG9yKHN0YXJ0LCBlbmQgPSBudWxsKSB7CiAgICAvKioKICAgICAqIFN0YXJ0IHBvc2l0aW9uLgogICAgICoKICAgICAqIEByZWFkb25seQogICAgICogQG1lbWJlciB7bW9kdWxlOmVuZ2luZS92aWV3L3Bvc2l0aW9uflBvc2l0aW9ufQogICAgICovCiAgICB0aGlzLnN0YXJ0ID0gc3RhcnQuY2xvbmUoKTsKICAgIC8qKgogICAgICogRW5kIHBvc2l0aW9uLgogICAgICoKICAgICAqIEByZWFkb25seQogICAgICogQG1lbWJlciB7bW9kdWxlOmVuZ2luZS92aWV3L3Bvc2l0aW9uflBvc2l0aW9ufQogICAgICovCgogICAgdGhpcy5lbmQgPSBlbmQgPyBlbmQuY2xvbmUoKSA6IHN0YXJ0LmNsb25lKCk7CiAgfQogIC8qKgogICAqIEl0ZXJhYmxlIGludGVyZmFjZS4KICAgKgogICAqIEl0ZXJhdGVzIG92ZXIgYWxsIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvaXRlbX5JdGVtIHZpZXcgaXRlbXN9IHRoYXQgYXJlIGluIHRoaXMgcmFuZ2UgYW5kIHJldHVybnMKICAgKiB0aGVtIHRvZ2V0aGVyIHdpdGggYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBsaWtlIGxlbmd0aCBvciB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3Bvc2l0aW9uflBvc2l0aW9uIHBvc2l0aW9uc30sCiAgICogZ3JvdXBlZCBhcyB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3RyZWV3YWxrZXJ+VHJlZVdhbGtlclZhbHVlfS4KICAgKgogICAqIFRoaXMgaXRlcmF0b3IgdXNlcyB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3RyZWV3YWxrZXJ+VHJlZVdhbGtlciBUcmVlV2Fsa2VyfSB3aXRoIGBib3VuZGFyaWVzYCBzZXQgdG8gdGhpcyByYW5nZSBhbmQKICAgKiBgaWdub3JlRWxlbWVudEVuZGAgb3B0aW9uCiAgICogc2V0IHRvIGB0cnVlYC4KICAgKgogICAqIEByZXR1cm5zIHtJdGVyYWJsZS48bW9kdWxlOmVuZ2luZS92aWV3L3RyZWV3YWxrZXJ+VHJlZVdhbGtlclZhbHVlPn0KICAgKi8KCgogICpbU3ltYm9sLml0ZXJhdG9yXSgpIHsKICAgIHlpZWxkKiBuZXcgVHJlZVdhbGtlcih7CiAgICAgIGJvdW5kYXJpZXM6IHRoaXMsCiAgICAgIGlnbm9yZUVsZW1lbnRFbmQ6IHRydWUKICAgIH0pOwogIH0KICAvKioKICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHJhbmdlIGlzIGNvbGxhcHNlZCwgdGhhdCBpcyBpdCBzdGFydCBhbmQgZW5kIHBvc2l0aW9ucyBhcmUgZXF1YWwuCiAgICoKICAgKiBAdHlwZSB7Qm9vbGVhbn0KICAgKi8KCgogIGdldCBpc0NvbGxhcHNlZCgpIHsKICAgIHJldHVybiB0aGlzLnN0YXJ0LmlzRXF1YWwodGhpcy5lbmQpOwogIH0KICAvKioKICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyByYW5nZSBpcyBmbGF0LCB0aGF0IGlzIGlmIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvcmFuZ2V+UmFuZ2Ujc3RhcnQgc3RhcnR9IHBvc2l0aW9uIGFuZAogICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvcmFuZ2V+UmFuZ2UjZW5kIGVuZH0gcG9zaXRpb24gYXJlIGluIHRoZSBzYW1lIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvcG9zaXRpb25+UG9zaXRpb24jcGFyZW50IHBhcmVudH0uCiAgICoKICAgKiBAdHlwZSB7Qm9vbGVhbn0KICAgKi8KCgogIGdldCBpc0ZsYXQoKSB7CiAgICByZXR1cm4gdGhpcy5zdGFydC5wYXJlbnQgPT09IHRoaXMuZW5kLnBhcmVudDsKICB9CiAgLyoqCiAgICogUmFuZ2Ugcm9vdCBlbGVtZW50LgogICAqCiAgICogQHR5cGUge21vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnR8bW9kdWxlOmVuZ2luZS92aWV3L2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudH0KICAgKi8KCgogIGdldCByb290KCkgewogICAgcmV0dXJuIHRoaXMuc3RhcnQucm9vdDsKICB9CiAgLyoqCiAgICogQ3JlYXRlcyBhIG1heGltYWwgcmFuZ2UgdGhhdCBoYXMgdGhlIHNhbWUgY29udGVudCBhcyB0aGlzIHJhbmdlIGJ1dCBpcyBleHBhbmRlZCBpbiBib3RoIHdheXMgKGF0IHRoZSBiZWdpbm5pbmcKICAgKiBhbmQgYXQgdGhlIGVuZCkuCiAgICoKICAgKiBGb3IgZXhhbXBsZToKICAgKgogICAqCQk8cD5Gb288L3A+PHA+PGI+e0Jhcn08L2I+PC9wPiAtPiA8cD5Gb288L3A+WzxwPjxiPkJhcjwvYj5dPC9wPgogICAqCQk8cD48Yj5mb288L2I+e2Jhcn08c3Bhbj48L3NwYW4+PC9wPiAtPiA8cD48Yj5mb29bPC9iPmJhcjxzcGFuPjwvc3Bhbj5dPC9wPgogICAqCiAgICogTm90ZSB0aGF0IGluIHRoZSBzYW1wbGUgYWJvdmU6CiAgICoKICAgKiAtIGA8cD5gIGhhdmUgdHlwZSBvZiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2NvbnRhaW5lcmVsZW1lbnR+Q29udGFpbmVyRWxlbWVudH0sCiAgICogLSBgPGI+YCBoYXZlIHR5cGUgb2Yge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9hdHRyaWJ1dGVlbGVtZW50fkF0dHJpYnV0ZUVsZW1lbnR9LAogICAqIC0gYDxzcGFuPmAgaGF2ZSB0eXBlIG9mIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdWllbGVtZW50flVJRWxlbWVudH0uCiAgICoKICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS92aWV3L3JhbmdlflJhbmdlfSBFbmxhcmdlZCByYW5nZS4KICAgKi8KCgogIGdldEVubGFyZ2VkKCkgewogICAgbGV0IHN0YXJ0ID0gdGhpcy5zdGFydC5nZXRMYXN0TWF0Y2hpbmdQb3NpdGlvbihlbmxhcmdlVHJpbVNraXAsIHsKICAgICAgZGlyZWN0aW9uOiAnYmFja3dhcmQnCiAgICB9KTsKICAgIGxldCBlbmQgPSB0aGlzLmVuZC5nZXRMYXN0TWF0Y2hpbmdQb3NpdGlvbihlbmxhcmdlVHJpbVNraXApOyAvLyBGaXggcG9zaXRpb25zLCBpbiBjYXNlIGlmIHRoZXkgYXJlIGluIFRleHQgbm9kZS4KCiAgICBpZiAoc3RhcnQucGFyZW50LmlzKCd0ZXh0JykgJiYgc3RhcnQuaXNBdFN0YXJ0KSB7CiAgICAgIHN0YXJ0ID0gUG9zaXRpb24uX2NyZWF0ZUJlZm9yZShzdGFydC5wYXJlbnQpOwogICAgfQoKICAgIGlmIChlbmQucGFyZW50LmlzKCd0ZXh0JykgJiYgZW5kLmlzQXRFbmQpIHsKICAgICAgZW5kID0gUG9zaXRpb24uX2NyZWF0ZUFmdGVyKGVuZC5wYXJlbnQpOwogICAgfQoKICAgIHJldHVybiBuZXcgUmFuZ2Uoc3RhcnQsIGVuZCk7CiAgfQogIC8qKgogICAqIENyZWF0ZXMgYSBtaW5pbXVtIHJhbmdlIHRoYXQgaGFzIHRoZSBzYW1lIGNvbnRlbnQgYXMgdGhpcyByYW5nZSBidXQgaXMgdHJpbW1lZCBpbiBib3RoIHdheXMgKGF0IHRoZSBiZWdpbm5pbmcKICAgKiBhbmQgYXQgdGhlIGVuZCkuCiAgICoKICAgKiBGb3IgZXhhbXBsZToKICAgKgogICAqCQk8cD5Gb288L3A+WzxwPjxiPkJhcjwvYj5dPC9wPiAtPiA8cD5Gb288L3A+PHA+PGI+e0Jhcn08L2I+PC9wPgogICAqCQk8cD48Yj5mb29bPC9iPmJhcjxzcGFuPjwvc3Bhbj5dPC9wPiAtPiA8cD48Yj5mb288L2I+e2Jhcn08c3Bhbj48L3NwYW4+PC9wPgogICAqCiAgICogTm90ZSB0aGF0IGluIHRoZSBzYW1wbGUgYWJvdmU6CiAgICoKICAgKiAtIGA8cD5gIGhhdmUgdHlwZSBvZiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2NvbnRhaW5lcmVsZW1lbnR+Q29udGFpbmVyRWxlbWVudH0sCiAgICogLSBgPGI+YCBoYXZlIHR5cGUgb2Yge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9hdHRyaWJ1dGVlbGVtZW50fkF0dHJpYnV0ZUVsZW1lbnR9LAogICAqIC0gYDxzcGFuPmAgaGF2ZSB0eXBlIG9mIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdWllbGVtZW50flVJRWxlbWVudH0uCiAgICoKICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS92aWV3L3JhbmdlflJhbmdlfSBTaHJpbmsgcmFuZ2UuCiAgICovCgoKICBnZXRUcmltbWVkKCkgewogICAgbGV0IHN0YXJ0ID0gdGhpcy5zdGFydC5nZXRMYXN0TWF0Y2hpbmdQb3NpdGlvbihlbmxhcmdlVHJpbVNraXApOwoKICAgIGlmIChzdGFydC5pc0FmdGVyKHRoaXMuZW5kKSB8fCBzdGFydC5pc0VxdWFsKHRoaXMuZW5kKSkgewogICAgICByZXR1cm4gbmV3IFJhbmdlKHN0YXJ0LCBzdGFydCk7CiAgICB9CgogICAgbGV0IGVuZCA9IHRoaXMuZW5kLmdldExhc3RNYXRjaGluZ1Bvc2l0aW9uKGVubGFyZ2VUcmltU2tpcCwgewogICAgICBkaXJlY3Rpb246ICdiYWNrd2FyZCcKICAgIH0pOwogICAgY29uc3Qgbm9kZUFmdGVyU3RhcnQgPSBzdGFydC5ub2RlQWZ0ZXI7CiAgICBjb25zdCBub2RlQmVmb3JlRW5kID0gZW5kLm5vZGVCZWZvcmU7IC8vIEJlY2F1c2UgVHJlZVdhbGtlciBwcmVmZXJzIHBvc2l0aW9ucyBuZXh0IHRvIHRleHQgbm9kZSwgd2UgbmVlZCB0byBtb3ZlIHRoZW0gbWFudWFsbHkgaW50byB0aGVzZSB0ZXh0IG5vZGVzLgoKICAgIGlmIChub2RlQWZ0ZXJTdGFydCAmJiBub2RlQWZ0ZXJTdGFydC5pcygndGV4dCcpKSB7CiAgICAgIHN0YXJ0ID0gbmV3IFBvc2l0aW9uKG5vZGVBZnRlclN0YXJ0LCAwKTsKICAgIH0KCiAgICBpZiAobm9kZUJlZm9yZUVuZCAmJiBub2RlQmVmb3JlRW5kLmlzKCd0ZXh0JykpIHsKICAgICAgZW5kID0gbmV3IFBvc2l0aW9uKG5vZGVCZWZvcmVFbmQsIG5vZGVCZWZvcmVFbmQuZGF0YS5sZW5ndGgpOwogICAgfQoKICAgIHJldHVybiBuZXcgUmFuZ2Uoc3RhcnQsIGVuZCk7CiAgfQogIC8qKgogICAqIFR3byByYW5nZXMgYXJlIGVxdWFsIGlmIHRoZWlyIHN0YXJ0IGFuZCBlbmQgcG9zaXRpb25zIGFyZSBlcXVhbC4KICAgKgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L3JhbmdlflJhbmdlfSBvdGhlclJhbmdlIFJhbmdlIHRvIGNvbXBhcmUgd2l0aC4KICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIHJhbmdlcyBhcmUgZXF1YWwsIGBmYWxzZWAgb3RoZXJ3aXNlCiAgICovCgoKICBpc0VxdWFsKG90aGVyUmFuZ2UpIHsKICAgIHJldHVybiB0aGlzID09IG90aGVyUmFuZ2UgfHwgdGhpcy5zdGFydC5pc0VxdWFsKG90aGVyUmFuZ2Uuc3RhcnQpICYmIHRoaXMuZW5kLmlzRXF1YWwob3RoZXJSYW5nZS5lbmQpOwogIH0KICAvKioKICAgKiBDaGVja3Mgd2hldGhlciB0aGlzIHJhbmdlIGNvbnRhaW5zIGdpdmVuIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvcG9zaXRpb25+UG9zaXRpb24gcG9zaXRpb259LgogICAqCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvcG9zaXRpb25+UG9zaXRpb259IHBvc2l0aW9uIFBvc2l0aW9uIHRvIGNoZWNrLgogICAqIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgZ2l2ZW4ge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbiBwb3NpdGlvbn0gaXMgY29udGFpbmVkIGluIHRoaXMgcmFuZ2UsCiAgICogYGZhbHNlYCBvdGhlcndpc2UuCiAgICovCgoKICBjb250YWluc1Bvc2l0aW9uKHBvc2l0aW9uKSB7CiAgICByZXR1cm4gcG9zaXRpb24uaXNBZnRlcih0aGlzLnN0YXJ0KSAmJiBwb3NpdGlvbi5pc0JlZm9yZSh0aGlzLmVuZCk7CiAgfQogIC8qKgogICAqIENoZWNrcyB3aGV0aGVyIHRoaXMgcmFuZ2UgY29udGFpbnMgZ2l2ZW4ge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9yYW5nZX5SYW5nZSByYW5nZX0uCiAgICoKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9yYW5nZX5SYW5nZX0gb3RoZXJSYW5nZSBSYW5nZSB0byBjaGVjay4KICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtsb29zZT1mYWxzZV0gV2hldGhlciB0aGUgY2hlY2sgaXMgbG9vc2Ugb3Igc3RyaWN0LiBJZiB0aGUgY2hlY2sgaXMgc3RyaWN0IChgZmFsc2VgKSwgY29tcGFyZWQgcmFuZ2UgY2Fubm90CiAgICogc3RhcnQgb3IgZW5kIGF0IHRoZSBzYW1lIHBvc2l0aW9uIGFzIHRoaXMgcmFuZ2UgYm91bmRhcmllcy4gSWYgdGhlIGNoZWNrIGlzIGxvb3NlIChgdHJ1ZWApLCBjb21wYXJlZCByYW5nZSBjYW4gc3RhcnQsIGVuZCBvcgogICAqIGV2ZW4gYmUgZXF1YWwgdG8gdGhpcyByYW5nZS4gTm90ZSB0aGF0IGNvbGxhcHNlZCByYW5nZXMgYXJlIGFsd2F5cyBjb21wYXJlZCBpbiBzdHJpY3QgbW9kZS4KICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIGdpdmVuIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvcmFuZ2V+UmFuZ2UgcmFuZ2V9IGJvdW5kYXJpZXMgYXJlIGNvbnRhaW5lZCBieSB0aGlzIHJhbmdlLCBgZmFsc2VgCiAgICogb3RoZXJ3aXNlLgogICAqLwoKCiAgY29udGFpbnNSYW5nZShvdGhlclJhbmdlLCBsb29zZSA9IGZhbHNlKSB7CiAgICBpZiAob3RoZXJSYW5nZS5pc0NvbGxhcHNlZCkgewogICAgICBsb29zZSA9IGZhbHNlOwogICAgfQoKICAgIGNvbnN0IGNvbnRhaW5zU3RhcnQgPSB0aGlzLmNvbnRhaW5zUG9zaXRpb24ob3RoZXJSYW5nZS5zdGFydCkgfHwgbG9vc2UgJiYgdGhpcy5zdGFydC5pc0VxdWFsKG90aGVyUmFuZ2Uuc3RhcnQpOwogICAgY29uc3QgY29udGFpbnNFbmQgPSB0aGlzLmNvbnRhaW5zUG9zaXRpb24ob3RoZXJSYW5nZS5lbmQpIHx8IGxvb3NlICYmIHRoaXMuZW5kLmlzRXF1YWwob3RoZXJSYW5nZS5lbmQpOwogICAgcmV0dXJuIGNvbnRhaW5zU3RhcnQgJiYgY29udGFpbnNFbmQ7CiAgfQogIC8qKgogICAqIENvbXB1dGVzIHdoaWNoIHBhcnQocykgb2YgdGhpcyB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3JhbmdlflJhbmdlIHJhbmdlfSBpcyBub3QgYSBwYXJ0IG9mIGdpdmVuCiAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9yYW5nZX5SYW5nZSByYW5nZX0uCiAgICogUmV0dXJuZWQgYXJyYXkgY29udGFpbnMgemVybywgb25lIG9yIHR3byB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3JhbmdlflJhbmdlIHJhbmdlc30uCiAgICoKICAgKiBFeGFtcGxlczoKICAgKgogICAqCQlsZXQgZm9vID0gZG93bmNhc3RXcml0ZXIuY3JlYXRlVGV4dCggJ2ZvbycgKTsKICAgKgkJbGV0IGltZyA9IGRvd25jYXN0V3JpdGVyLmNyZWF0ZUNvbnRhaW5lckVsZW1lbnQoICdpbWcnICk7CiAgICoJCWxldCBiYXIgPSBkb3duY2FzdFdyaXRlci5jcmVhdGVUZXh0KCAnYmFyJyApOwogICAqCQlsZXQgcCA9IGRvd25jYXN0V3JpdGVyLmNyZWF0ZUNvbnRhaW5lckVsZW1lbnQoICdwJywgbnVsbCwgWyBmb28sIGltZywgYmFyIF0gKTsKICAgKgogICAqCQlsZXQgcmFuZ2UgPSB2aWV3LmNyZWF0ZVJhbmdlKCB2aWV3LmNyZWF0ZVBvc2l0aW9uQXQoIGZvbywgMiApLCB2aWV3LmNyZWF0ZVBvc2l0aW9uQXQoIGJhciwgMSApOyAvLyAibyIsIGltZywgImIiIGFyZSBpbiByYW5nZS4KICAgKgkJbGV0IG90aGVyUmFuZ2UgPSB2aWV3LmNyZWF0ZVJhbmdlKCAvLyAib28iLCBpbWcsICJiYSIgYXJlIGluIHJhbmdlLgogICAqCQkJdmlldy5jcmVhdGVQb3NpdGlvbkF0KCBmb28sIDEgKSwKICAgKgkJCXZpZXcuY3JlYXRlUG9zaXRpb25BdCggYmFyLCAyICkKICAgKgkJKTsKICAgKgkJbGV0IHRyYW5zZm9ybWVkID0gcmFuZ2UuZ2V0RGlmZmVyZW5jZSggb3RoZXJSYW5nZSApOwogICAqCQkvLyB0cmFuc2Zvcm1lZCBhcnJheSBoYXMgbm8gcmFuZ2VzIGJlY2F1c2UgYG90aGVyUmFuZ2VgIGNvbnRhaW5zIGByYW5nZWAKICAgKgogICAqCQlvdGhlclJhbmdlID0gdmlldy5jcmVhdGVSYW5nZSggdmlldy5jcmVhdGVQb3NpdGlvbkF0KCBmb28sIDEgKSwgdmlldy5jcmVhdGVQb3NpdGlvbkF0KCBwLCAyICk7IC8vICJvbyIsIGltZyBhcmUgaW4gcmFuZ2UuCiAgICoJCXRyYW5zZm9ybWVkID0gcmFuZ2UuZ2V0RGlmZmVyZW5jZSggb3RoZXJSYW5nZSApOwogICAqCQkvLyB0cmFuc2Zvcm1lZCBhcnJheSBoYXMgb25lIHJhbmdlOiBmcm9tICggcCwgMiApIHRvICggYmFyLCAxICkKICAgKgogICAqCQlvdGhlclJhbmdlID0gdmlldy5jcmVhdGVSYW5nZSggdmlldy5jcmVhdGVQb3NpdGlvbkF0KCBwLCAxICksIHZpZXcuY3JlYXRlUG9zaXRpb25BdCggcCwgMiApICk7IC8vIGltZyBpcyBpbiByYW5nZS4KICAgKgkJdHJhbnNmb3JtZWQgPSByYW5nZS5nZXREaWZmZXJlbmNlKCBvdGhlclJhbmdlICk7CiAgICoJCS8vIHRyYW5zZm9ybWVkIGFycmF5IGhhcyB0d28gcmFuZ2VzOiBmcm9tICggZm9vLCAxICkgdG8gKCBwLCAxICkgYW5kIGZyb20gKCBwLCAyICkgdG8gKCBiYXIsIDEgKQogICAqCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvcmFuZ2V+UmFuZ2V9IG90aGVyUmFuZ2UgUmFuZ2UgdG8gZGlmZmVyZW50aWF0ZSBhZ2FpbnN0LgogICAqIEByZXR1cm5zIHtBcnJheS48bW9kdWxlOmVuZ2luZS92aWV3L3JhbmdlflJhbmdlPn0gVGhlIGRpZmZlcmVuY2UgYmV0d2VlbiByYW5nZXMuCiAgICovCgoKICBnZXREaWZmZXJlbmNlKG90aGVyUmFuZ2UpIHsKICAgIGNvbnN0IHJhbmdlcyA9IFtdOwoKICAgIGlmICh0aGlzLmlzSW50ZXJzZWN0aW5nKG90aGVyUmFuZ2UpKSB7CiAgICAgIC8vIFJhbmdlcyBpbnRlcnNlY3QuCiAgICAgIGlmICh0aGlzLmNvbnRhaW5zUG9zaXRpb24ob3RoZXJSYW5nZS5zdGFydCkpIHsKICAgICAgICAvLyBHaXZlbiByYW5nZSBzdGFydCBpcyBpbnNpZGUgdGhpcyByYW5nZS4gVGhpcyBtZWFucyB0aGF0IHdlIGhhdmUgdG8KICAgICAgICAvLyBhZGQgc2hydW5rZW4gcmFuZ2UgLSBmcm9tIHRoZSBzdGFydCB0byB0aGUgbWlkZGxlIG9mIHRoaXMgcmFuZ2UuCiAgICAgICAgcmFuZ2VzLnB1c2gobmV3IFJhbmdlKHRoaXMuc3RhcnQsIG90aGVyUmFuZ2Uuc3RhcnQpKTsKICAgICAgfQoKICAgICAgaWYgKHRoaXMuY29udGFpbnNQb3NpdGlvbihvdGhlclJhbmdlLmVuZCkpIHsKICAgICAgICAvLyBHaXZlbiByYW5nZSBlbmQgaXMgaW5zaWRlIHRoaXMgcmFuZ2UuIFRoaXMgbWVhbnMgdGhhdCB3ZSBoYXZlIHRvCiAgICAgICAgLy8gYWRkIHNocnVua2VuIHJhbmdlIC0gZnJvbSB0aGUgbWlkZGxlIG9mIHRoaXMgcmFuZ2UgdG8gdGhlIGVuZC4KICAgICAgICByYW5nZXMucHVzaChuZXcgUmFuZ2Uob3RoZXJSYW5nZS5lbmQsIHRoaXMuZW5kKSk7CiAgICAgIH0KICAgIH0gZWxzZSB7CiAgICAgIC8vIFJhbmdlcyBkbyBub3QgaW50ZXJzZWN0LCByZXR1cm4gdGhlIG9yaWdpbmFsIHJhbmdlLgogICAgICByYW5nZXMucHVzaCh0aGlzLmNsb25lKCkpOwogICAgfQoKICAgIHJldHVybiByYW5nZXM7CiAgfQogIC8qKgogICAqIFJldHVybnMgYW4gaW50ZXJzZWN0aW9uIG9mIHRoaXMge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9yYW5nZX5SYW5nZSByYW5nZX0gYW5kIGdpdmVuIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvcmFuZ2V+UmFuZ2UgcmFuZ2V9LgogICAqIEludGVyc2VjdGlvbiBpcyBhIGNvbW1vbiBwYXJ0IG9mIGJvdGggb2YgdGhvc2UgcmFuZ2VzLiBJZiByYW5nZXMgaGFzIG5vIGNvbW1vbiBwYXJ0LCByZXR1cm5zIGBudWxsYC4KICAgKgogICAqIEV4YW1wbGVzOgogICAqCiAgICoJCWxldCBmb28gPSBkb3duY2FzdFdyaXRlci5jcmVhdGVUZXh0KCAnZm9vJyApOwogICAqCQlsZXQgaW1nID0gZG93bmNhc3RXcml0ZXIuY3JlYXRlQ29udGFpbmVyRWxlbWVudCggJ2ltZycgKTsKICAgKgkJbGV0IGJhciA9IGRvd25jYXN0V3JpdGVyLmNyZWF0ZVRleHQoICdiYXInICk7CiAgICoJCWxldCBwID0gZG93bmNhc3RXcml0ZXIuY3JlYXRlQ29udGFpbmVyRWxlbWVudCggJ3AnLCBudWxsLCBbIGZvbywgaW1nLCBiYXIgXSApOwogICAqCiAgICoJCWxldCByYW5nZSA9IHZpZXcuY3JlYXRlUmFuZ2UoIHZpZXcuY3JlYXRlUG9zaXRpb25BdCggZm9vLCAyICksIHZpZXcuY3JlYXRlUG9zaXRpb25BdCggYmFyLCAxICk7IC8vICJvIiwgaW1nLCAiYiIgYXJlIGluIHJhbmdlLgogICAqCQlsZXQgb3RoZXJSYW5nZSA9IHZpZXcuY3JlYXRlUmFuZ2UoIHZpZXcuY3JlYXRlUG9zaXRpb25BdCggZm9vLCAxICksIHZpZXcuY3JlYXRlUG9zaXRpb25BdCggcCwgMiApOyAvLyAib28iLCBpbWcgYXJlIGluIHJhbmdlLgogICAqCQlsZXQgdHJhbnNmb3JtZWQgPSByYW5nZS5nZXRJbnRlcnNlY3Rpb24oIG90aGVyUmFuZ2UgKTsgLy8gcmFuZ2UgZnJvbSAoIGZvbywgMSApIHRvICggcCwgMiApLgogICAqCiAgICoJCW90aGVyUmFuZ2UgPSB2aWV3LmNyZWF0ZVJhbmdlKCB2aWV3LmNyZWF0ZVBvc2l0aW9uQXQoIGJhciwgMSApLCB2aWV3LmNyZWF0ZVBvc2l0aW9uQXQoIGJhciwgMyApOyAiYXIiIGlzIGluIHJhbmdlLgogICAqCQl0cmFuc2Zvcm1lZCA9IHJhbmdlLmdldEludGVyc2VjdGlvbiggb3RoZXJSYW5nZSApOyAvLyBudWxsIC0gbm8gY29tbW9uIHBhcnQuCiAgICoKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9yYW5nZX5SYW5nZX0gb3RoZXJSYW5nZSBSYW5nZSB0byBjaGVjayBmb3IgaW50ZXJzZWN0aW9uLgogICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL3ZpZXcvcmFuZ2V+UmFuZ2V8bnVsbH0gQSBjb21tb24gcGFydCBvZiBnaXZlbiByYW5nZXMgb3IgYG51bGxgIGlmIHJhbmdlcyBoYXZlIG5vIGNvbW1vbiBwYXJ0LgogICAqLwoKCiAgZ2V0SW50ZXJzZWN0aW9uKG90aGVyUmFuZ2UpIHsKICAgIGlmICh0aGlzLmlzSW50ZXJzZWN0aW5nKG90aGVyUmFuZ2UpKSB7CiAgICAgIC8vIFJhbmdlcyBpbnRlcnNlY3QsIHNvIGEgY29tbW9uIHJhbmdlIHdpbGwgYmUgcmV0dXJuZWQuCiAgICAgIC8vIEF0IG1vc3QsIGl0IHdpbGwgYmUgc2FtZSBhcyB0aGlzIHJhbmdlLgogICAgICBsZXQgY29tbW9uUmFuZ2VTdGFydCA9IHRoaXMuc3RhcnQ7CiAgICAgIGxldCBjb21tb25SYW5nZUVuZCA9IHRoaXMuZW5kOwoKICAgICAgaWYgKHRoaXMuY29udGFpbnNQb3NpdGlvbihvdGhlclJhbmdlLnN0YXJ0KSkgewogICAgICAgIC8vIEdpdmVuIHJhbmdlIHN0YXJ0IGlzIGluc2lkZSB0aGlzIHJhbmdlLiBUaGlzIG1lYW5zIHRoYU50IHdlIGhhdmUgdG8KICAgICAgICAvLyBzaHJpbmsgY29tbW9uIHJhbmdlIHRvIHRoZSBnaXZlbiByYW5nZSBzdGFydC4KICAgICAgICBjb21tb25SYW5nZVN0YXJ0ID0gb3RoZXJSYW5nZS5zdGFydDsKICAgICAgfQoKICAgICAgaWYgKHRoaXMuY29udGFpbnNQb3NpdGlvbihvdGhlclJhbmdlLmVuZCkpIHsKICAgICAgICAvLyBHaXZlbiByYW5nZSBlbmQgaXMgaW5zaWRlIHRoaXMgcmFuZ2UuIFRoaXMgbWVhbnMgdGhhdCB3ZSBoYXZlIHRvCiAgICAgICAgLy8gc2hyaW5rIGNvbW1vbiByYW5nZSB0byB0aGUgZ2l2ZW4gcmFuZ2UgZW5kLgogICAgICAgIGNvbW1vblJhbmdlRW5kID0gb3RoZXJSYW5nZS5lbmQ7CiAgICAgIH0KCiAgICAgIHJldHVybiBuZXcgUmFuZ2UoY29tbW9uUmFuZ2VTdGFydCwgY29tbW9uUmFuZ2VFbmQpOwogICAgfSAvLyBSYW5nZXMgZG8gbm90IGludGVyc2VjdCwgc28gdGhleSBkbyBub3QgaGF2ZSBjb21tb24gcGFydC4KCgogICAgcmV0dXJuIG51bGw7CiAgfQogIC8qKgogICAqIENyZWF0ZXMgYSB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3RyZWV3YWxrZXJ+VHJlZVdhbGtlciBUcmVlV2Fsa2VyfSBpbnN0YW5jZSB3aXRoIHRoaXMgcmFuZ2UgYXMgYSBib3VuZGFyeS4KICAgKgogICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9iamVjdCB3aXRoIGNvbmZpZ3VyYXRpb24gb3B0aW9ucy4gU2VlIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdHJlZXdhbGtlcn5UcmVlV2Fsa2VyfS4KICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbn0gW29wdGlvbnMuc3RhcnRQb3NpdGlvbl0KICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNpbmdsZUNoYXJhY3RlcnM9ZmFsc2VdCiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zaGFsbG93PWZhbHNlXQogICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuaWdub3JlRWxlbWVudEVuZD1mYWxzZV0KICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS92aWV3L3RyZWV3YWxrZXJ+VHJlZVdhbGtlcn0KICAgKi8KCgogIGdldFdhbGtlcihvcHRpb25zID0ge30pIHsKICAgIG9wdGlvbnMuYm91bmRhcmllcyA9IHRoaXM7CiAgICByZXR1cm4gbmV3IFRyZWVXYWxrZXIob3B0aW9ucyk7CiAgfQogIC8qKgogICAqIFJldHVybnMgYSB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L25vZGV+Tm9kZX0gb3Ige0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnR9CiAgICogd2hpY2ggaXMgYSBjb21tb24gYW5jZXN0b3Igb2YgcmFuZ2UncyBib3RoIGVuZHMgKGluIHdoaWNoIHRoZSBlbnRpcmUgcmFuZ2UgaXMgY29udGFpbmVkKS4KICAgKgogICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL3ZpZXcvbm9kZX5Ob2RlfG1vZHVsZTplbmdpbmUvdmlldy9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnR8bnVsbH0KICAgKi8KCgogIGdldENvbW1vbkFuY2VzdG9yKCkgewogICAgcmV0dXJuIHRoaXMuc3RhcnQuZ2V0Q29tbW9uQW5jZXN0b3IodGhpcy5lbmQpOwogIH0KICAvKioKICAgKiBDbG9uZXMgdGhpcyByYW5nZS4KICAgKgogICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL3ZpZXcvcmFuZ2V+UmFuZ2V9CiAgICovCgoKICBjbG9uZSgpIHsKICAgIHJldHVybiBuZXcgUmFuZ2UodGhpcy5zdGFydCwgdGhpcy5lbmQpOwogIH0KICAvKioKICAgKiBSZXR1cm5zIGFuIGl0ZXJhdG9yIHRoYXQgaXRlcmF0ZXMgb3ZlciBhbGwge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9pdGVtfkl0ZW0gdmlldyBpdGVtc30gdGhhdCBhcmUgaW4gdGhpcyByYW5nZSBhbmQgcmV0dXJucwogICAqIHRoZW0uCiAgICoKICAgKiBUaGlzIG1ldGhvZCB1c2VzIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdHJlZXdhbGtlcn5UcmVlV2Fsa2VyfSB3aXRoIGBib3VuZGFyaWVzYCBzZXQgdG8gdGhpcyByYW5nZSBhbmQgYGlnbm9yZUVsZW1lbnRFbmRgIG9wdGlvbgogICAqIHNldCB0byBgdHJ1ZWAuIEhvd2V2ZXIgaXQgcmV0dXJucyBvbmx5IHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvaXRlbX5JdGVtIGl0ZW1zfSwKICAgKiBub3Qge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy90cmVld2Fsa2VyflRyZWVXYWxrZXJWYWx1ZX0uCiAgICoKICAgKiBZb3UgbWF5IHNwZWNpZnkgYWRkaXRpb25hbCBvcHRpb25zIGZvciB0aGUgdHJlZSB3YWxrZXIuIFNlZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3RyZWV3YWxrZXJ+VHJlZVdhbGtlcn0gZm9yCiAgICogYSBmdWxsIGxpc3Qgb2YgYXZhaWxhYmxlIG9wdGlvbnMuCiAgICoKICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPYmplY3Qgd2l0aCBjb25maWd1cmF0aW9uIG9wdGlvbnMuIFNlZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3RyZWV3YWxrZXJ+VHJlZVdhbGtlcn0uCiAgICogQHJldHVybnMge0l0ZXJhYmxlLjxtb2R1bGU6ZW5naW5lL3ZpZXcvaXRlbX5JdGVtPn0KICAgKi8KCgogICpnZXRJdGVtcyhvcHRpb25zID0ge30pIHsKICAgIG9wdGlvbnMuYm91bmRhcmllcyA9IHRoaXM7CiAgICBvcHRpb25zLmlnbm9yZUVsZW1lbnRFbmQgPSB0cnVlOwogICAgY29uc3QgdHJlZVdhbGtlciA9IG5ldyBUcmVlV2Fsa2VyKG9wdGlvbnMpOwoKICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdHJlZVdhbGtlcikgewogICAgICB5aWVsZCB2YWx1ZS5pdGVtOwogICAgfQogIH0KICAvKioKICAgKiBSZXR1cm5zIGFuIGl0ZXJhdG9yIHRoYXQgaXRlcmF0ZXMgb3ZlciBhbGwge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbiBwb3NpdGlvbnN9IHRoYXQgYXJlIGJvdW5kYXJpZXMgb3IKICAgKiBjb250YWluZWQgaW4gdGhpcyByYW5nZS4KICAgKgogICAqIFRoaXMgbWV0aG9kIHVzZXMge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy90cmVld2Fsa2VyflRyZWVXYWxrZXJ9IHdpdGggYGJvdW5kYXJpZXNgIHNldCB0byB0aGlzIHJhbmdlLiBIb3dldmVyIGl0IHJldHVybnMgb25seQogICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvcG9zaXRpb25+UG9zaXRpb24gcG9zaXRpb25zfSwgbm90IHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdHJlZXdhbGtlcn5UcmVlV2Fsa2VyVmFsdWV9LgogICAqCiAgICogWW91IG1heSBzcGVjaWZ5IGFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgdGhlIHRyZWUgd2Fsa2VyLiBTZWUge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy90cmVld2Fsa2VyflRyZWVXYWxrZXJ9IGZvcgogICAqIGEgZnVsbCBsaXN0IG9mIGF2YWlsYWJsZSBvcHRpb25zLgogICAqCiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT2JqZWN0IHdpdGggY29uZmlndXJhdGlvbiBvcHRpb25zLiBTZWUge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy90cmVld2Fsa2VyflRyZWVXYWxrZXJ9LgogICAqIEByZXR1cm5zIHtJdGVyYWJsZS48bW9kdWxlOmVuZ2luZS92aWV3L3Bvc2l0aW9uflBvc2l0aW9uPn0KICAgKi8KCgogICpnZXRQb3NpdGlvbnMob3B0aW9ucyA9IHt9KSB7CiAgICBvcHRpb25zLmJvdW5kYXJpZXMgPSB0aGlzOwogICAgY29uc3QgdHJlZVdhbGtlciA9IG5ldyBUcmVlV2Fsa2VyKG9wdGlvbnMpOwogICAgeWllbGQgdHJlZVdhbGtlci5wb3NpdGlvbjsKCiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHRyZWVXYWxrZXIpIHsKICAgICAgeWllbGQgdmFsdWUubmV4dFBvc2l0aW9uOwogICAgfQogIH0KICAvKioKICAgKiBDaGVja3Mgd2hldGhlciB0aGlzIG9iamVjdCBpcyBvZiB0aGUgZ2l2ZW4gdHlwZS4KICAgKgogICAqCQlyYW5nZS5pcyggJ3JhbmdlJyApOyAvLyAtPiB0cnVlCiAgICoJCXJhbmdlLmlzKCAndmlldzpyYW5nZScgKTsgLy8gLT4gdHJ1ZQogICAqCiAgICoJCXJhbmdlLmlzKCAnbW9kZWw6cmFuZ2UnICk7IC8vIC0+IGZhbHNlCiAgICoJCXJhbmdlLmlzKCAnZWxlbWVudCcgKTsgLy8gLT4gZmFsc2UKICAgKgkJcmFuZ2UuaXMoICdzZWxlY3Rpb24nICk7IC8vIC0+IGZhbHNlCiAgICoKICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L25vZGV+Tm9kZSNpcyBDaGVjayB0aGUgZW50aXJlIGxpc3Qgb2YgdmlldyBvYmplY3RzfSB3aGljaCBpbXBsZW1lbnQgdGhlIGBpcygpYCBtZXRob2QuCiAgICoKICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZQogICAqIEByZXR1cm5zIHtCb29sZWFufQogICAqLwoKCiAgaXModHlwZSkgewogICAgcmV0dXJuIHR5cGUgPT0gJ3JhbmdlJyB8fCB0eXBlID09ICd2aWV3OnJhbmdlJzsKICB9CiAgLyoqCiAgICogQ2hlY2tzIGFuZCByZXR1cm5zIHdoZXRoZXIgdGhpcyByYW5nZSBpbnRlcnNlY3RzIHdpdGggdGhlIGdpdmVuIHJhbmdlLgogICAqCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvcmFuZ2V+UmFuZ2V9IG90aGVyUmFuZ2UgUmFuZ2UgdG8gY29tcGFyZSB3aXRoLgogICAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHJhbmdlcyBpbnRlcnNlY3QuCiAgICovCgoKICBpc0ludGVyc2VjdGluZyhvdGhlclJhbmdlKSB7CiAgICByZXR1cm4gdGhpcy5zdGFydC5pc0JlZm9yZShvdGhlclJhbmdlLmVuZCkgJiYgdGhpcy5lbmQuaXNBZnRlcihvdGhlclJhbmdlLnN0YXJ0KTsKICB9CiAgLyoqCiAgICogQ3JlYXRlcyBhIHJhbmdlIGZyb20gdGhlIGdpdmVuIHBhcmVudHMgYW5kIG9mZnNldHMuCiAgICoKICAgKiBAcHJvdGVjdGVkCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvbm9kZX5Ob2RlfG1vZHVsZTplbmdpbmUvdmlldy9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnR9IHN0YXJ0RWxlbWVudCBTdGFydCBwb3NpdGlvbgogICAqIHBhcmVudCBlbGVtZW50LgogICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydE9mZnNldCBTdGFydCBwb3NpdGlvbiBvZmZzZXQuCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvbm9kZX5Ob2RlfG1vZHVsZTplbmdpbmUvdmlldy9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnR9IGVuZEVsZW1lbnQgRW5kIHBvc2l0aW9uCiAgICogcGFyZW50IGVsZW1lbnQuCiAgICogQHBhcmFtIHtOdW1iZXJ9IGVuZE9mZnNldCBFbmQgcG9zaXRpb24gb2Zmc2V0LgogICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL3ZpZXcvcmFuZ2V+UmFuZ2V9IENyZWF0ZWQgcmFuZ2UuCiAgICovCgoKICBzdGF0aWMgX2NyZWF0ZUZyb21QYXJlbnRzQW5kT2Zmc2V0cyhzdGFydEVsZW1lbnQsIHN0YXJ0T2Zmc2V0LCBlbmRFbGVtZW50LCBlbmRPZmZzZXQpIHsKICAgIHJldHVybiBuZXcgdGhpcyhuZXcgUG9zaXRpb24oc3RhcnRFbGVtZW50LCBzdGFydE9mZnNldCksIG5ldyBQb3NpdGlvbihlbmRFbGVtZW50LCBlbmRPZmZzZXQpKTsKICB9CiAgLyoqCiAgICogQ3JlYXRlcyBhIG5ldyByYW5nZSwgc3ByZWFkaW5nIGZyb20gc3BlY2lmaWVkIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvcG9zaXRpb25+UG9zaXRpb24gcG9zaXRpb259IHRvIGEgcG9zaXRpb24gbW92ZWQgYnkKICAgKiBnaXZlbiBgc2hpZnRgLiBJZiBgc2hpZnRgIGlzIGEgbmVnYXRpdmUgdmFsdWUsIHNoaWZ0ZWQgcG9zaXRpb24gaXMgdHJlYXRlZCBhcyB0aGUgYmVnaW5uaW5nIG9mIHRoZSByYW5nZS4KICAgKgogICAqIEBwcm90ZWN0ZWQKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbn0gcG9zaXRpb24gQmVnaW5uaW5nIG9mIHRoZSByYW5nZS4KICAgKiBAcGFyYW0ge051bWJlcn0gc2hpZnQgSG93IGxvbmcgdGhlIHJhbmdlIHNob3VsZCBiZS4KICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS92aWV3L3JhbmdlflJhbmdlfQogICAqLwoKCiAgc3RhdGljIF9jcmVhdGVGcm9tUG9zaXRpb25BbmRTaGlmdChwb3NpdGlvbiwgc2hpZnQpIHsKICAgIGNvbnN0IHN0YXJ0ID0gcG9zaXRpb247CiAgICBjb25zdCBlbmQgPSBwb3NpdGlvbi5nZXRTaGlmdGVkQnkoc2hpZnQpOwogICAgcmV0dXJuIHNoaWZ0ID4gMCA/IG5ldyB0aGlzKHN0YXJ0LCBlbmQpIDogbmV3IHRoaXMoZW5kLCBzdGFydCk7CiAgfQogIC8qKgogICAqIENyZWF0ZXMgYSByYW5nZSBpbnNpZGUgYW4ge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnQgZWxlbWVudH0gd2hpY2ggc3RhcnRzIGJlZm9yZSB0aGUgZmlyc3QgY2hpbGQgb2YKICAgKiB0aGF0IGVsZW1lbnQgYW5kIGVuZHMgYWZ0ZXIgdGhlIGxhc3QgY2hpbGQgb2YgdGhhdCBlbGVtZW50LgogICAqCiAgICogQHByb3RlY3RlZAogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHdoaWNoIGlzIGEgcGFyZW50IGZvciB0aGUgcmFuZ2UuCiAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy9yYW5nZX5SYW5nZX0KICAgKi8KCgogIHN0YXRpYyBfY3JlYXRlSW4oZWxlbWVudCkgewogICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUZyb21QYXJlbnRzQW5kT2Zmc2V0cyhlbGVtZW50LCAwLCBlbGVtZW50LCBlbGVtZW50LmNoaWxkQ291bnQpOwogIH0KICAvKioKICAgKiBDcmVhdGVzIGEgcmFuZ2UgdGhhdCBzdGFydHMgYmVmb3JlIGdpdmVuIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvaXRlbX5JdGVtIHZpZXcgaXRlbX0gYW5kIGVuZHMgYWZ0ZXIgaXQuCiAgICoKICAgKiBAcHJvdGVjdGVkCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvaXRlbX5JdGVtfSBpdGVtCiAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy9yYW5nZX5SYW5nZX0KICAgKi8KCgogIHN0YXRpYyBfY3JlYXRlT24oaXRlbSkgewogICAgY29uc3Qgc2l6ZSA9IGl0ZW0uaXMoJ3RleHRQcm94eScpID8gaXRlbS5vZmZzZXRTaXplIDogMTsKICAgIHJldHVybiB0aGlzLl9jcmVhdGVGcm9tUG9zaXRpb25BbmRTaGlmdChQb3NpdGlvbi5fY3JlYXRlQmVmb3JlKGl0ZW0pLCBzaXplKTsKICB9Cgp9IC8vIEZ1bmN0aW9uIHVzZWQgYnkgZ2V0RW5sYXJnZWQgYW5kIGdldFRyaW1tZWQgbWV0aG9kcy4KCmZ1bmN0aW9uIGVubGFyZ2VUcmltU2tpcCh2YWx1ZSkgewogIGlmICh2YWx1ZS5pdGVtLmlzKCdhdHRyaWJ1dGVFbGVtZW50JykgfHwgdmFsdWUuaXRlbS5pcygndWlFbGVtZW50JykpIHsKICAgIHJldHVybiB0cnVlOwogIH0KCiAgcmV0dXJuIGZhbHNlOwp9"},{"version":3,"sources":["/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-engine/src/view/range.js"],"names":["Position","TreeWalker","Range","constructor","start","end","clone","Symbol","iterator","boundaries","ignoreElementEnd","isCollapsed","isEqual","isFlat","parent","root","getEnlarged","getLastMatchingPosition","enlargeTrimSkip","direction","is","isAtStart","_createBefore","isAtEnd","_createAfter","getTrimmed","isAfter","nodeAfterStart","nodeAfter","nodeBeforeEnd","nodeBefore","data","length","otherRange","containsPosition","position","isBefore","containsRange","loose","containsStart","containsEnd","getDifference","ranges","isIntersecting","push","getIntersection","commonRangeStart","commonRangeEnd","getWalker","options","getCommonAncestor","getItems","treeWalker","value","item","getPositions","nextPosition","type","_createFromParentsAndOffsets","startElement","startOffset","endElement","endOffset","_createFromPositionAndShift","shift","getShiftedBy","_createIn","element","childCount","_createOn","size","offsetSize"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/range\n */\n\nimport Position from './position';\nimport TreeWalker from './treewalker';\n\n/**\n * Range in the view tree. A range is represented by its start and end {@link module:engine/view/position~Position positions}.\n *\n * In order to create a new position instance use the `createPosition*()` factory methods available in:\n *\n * * {@link module:engine/view/view~View}\n * * {@link module:engine/view/downcastwriter~DowncastWriter}\n * * {@link module:engine/view/upcastwriter~UpcastWriter}\n */\nexport default class Range {\n\t/**\n\t * Creates a range spanning from `start` position to `end` position.\n\t *\n\t * **Note:** Constructor creates it's own {@link module:engine/view/position~Position} instances basing on passed values.\n\t *\n\t * @param {module:engine/view/position~Position} start Start position.\n\t * @param {module:engine/view/position~Position} [end] End position. If not set, range will be collapsed at the `start` position.\n\t */\n\tconstructor( start, end = null ) {\n\t\t/**\n\t\t * Start position.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/view/position~Position}\n\t\t */\n\t\tthis.start = start.clone();\n\n\t\t/**\n\t\t * End position.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/view/position~Position}\n\t\t */\n\t\tthis.end = end ? end.clone() : start.clone();\n\t}\n\n\t/**\n\t * Iterable interface.\n\t *\n\t * Iterates over all {@link module:engine/view/item~Item view items} that are in this range and returns\n\t * them together with additional information like length or {@link module:engine/view/position~Position positions},\n\t * grouped as {@link module:engine/view/treewalker~TreeWalkerValue}.\n\t *\n\t * This iterator uses {@link module:engine/view/treewalker~TreeWalker TreeWalker} with `boundaries` set to this range and\n\t * `ignoreElementEnd` option\n\t * set to `true`.\n\t *\n\t * @returns {Iterable.<module:engine/view/treewalker~TreeWalkerValue>}\n\t */\n\t* [ Symbol.iterator ]() {\n\t\tyield* new TreeWalker( { boundaries: this, ignoreElementEnd: true } );\n\t}\n\n\t/**\n\t * Returns whether the range is collapsed, that is it start and end positions are equal.\n\t *\n\t * @type {Boolean}\n\t */\n\tget isCollapsed() {\n\t\treturn this.start.isEqual( this.end );\n\t}\n\n\t/**\n\t * Returns whether this range is flat, that is if {@link module:engine/view/range~Range#start start} position and\n\t * {@link module:engine/view/range~Range#end end} position are in the same {@link module:engine/view/position~Position#parent parent}.\n\t *\n\t * @type {Boolean}\n\t */\n\tget isFlat() {\n\t\treturn this.start.parent === this.end.parent;\n\t}\n\n\t/**\n\t * Range root element.\n\t *\n\t * @type {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment}\n\t */\n\tget root() {\n\t\treturn this.start.root;\n\t}\n\n\t/**\n\t * Creates a maximal range that has the same content as this range but is expanded in both ways (at the beginning\n\t * and at the end).\n\t *\n\t * For example:\n\t *\n\t *\t\t<p>Foo</p><p><b>{Bar}</b></p> -> <p>Foo</p>[<p><b>Bar</b>]</p>\n\t *\t\t<p><b>foo</b>{bar}<span></span></p> -> <p><b>foo[</b>bar<span></span>]</p>\n\t *\n\t * Note that in the sample above:\n\t *\n\t * - `<p>` have type of {@link module:engine/view/containerelement~ContainerElement},\n\t * - `<b>` have type of {@link module:engine/view/attributeelement~AttributeElement},\n\t * - `<span>` have type of {@link module:engine/view/uielement~UIElement}.\n\t *\n\t * @returns {module:engine/view/range~Range} Enlarged range.\n\t */\n\tgetEnlarged() {\n\t\tlet start = this.start.getLastMatchingPosition( enlargeTrimSkip, { direction: 'backward' } );\n\t\tlet end = this.end.getLastMatchingPosition( enlargeTrimSkip );\n\n\t\t// Fix positions, in case if they are in Text node.\n\t\tif ( start.parent.is( 'text' ) && start.isAtStart ) {\n\t\t\tstart = Position._createBefore( start.parent );\n\t\t}\n\n\t\tif ( end.parent.is( 'text' ) && end.isAtEnd ) {\n\t\t\tend = Position._createAfter( end.parent );\n\t\t}\n\n\t\treturn new Range( start, end );\n\t}\n\n\t/**\n\t * Creates a minimum range that has the same content as this range but is trimmed in both ways (at the beginning\n\t * and at the end).\n\t *\n\t * For example:\n\t *\n\t *\t\t<p>Foo</p>[<p><b>Bar</b>]</p> -> <p>Foo</p><p><b>{Bar}</b></p>\n\t *\t\t<p><b>foo[</b>bar<span></span>]</p> -> <p><b>foo</b>{bar}<span></span></p>\n\t *\n\t * Note that in the sample above:\n\t *\n\t * - `<p>` have type of {@link module:engine/view/containerelement~ContainerElement},\n\t * - `<b>` have type of {@link module:engine/view/attributeelement~AttributeElement},\n\t * - `<span>` have type of {@link module:engine/view/uielement~UIElement}.\n\t *\n\t * @returns {module:engine/view/range~Range} Shrink range.\n\t */\n\tgetTrimmed() {\n\t\tlet start = this.start.getLastMatchingPosition( enlargeTrimSkip );\n\n\t\tif ( start.isAfter( this.end ) || start.isEqual( this.end ) ) {\n\t\t\treturn new Range( start, start );\n\t\t}\n\n\t\tlet end = this.end.getLastMatchingPosition( enlargeTrimSkip, { direction: 'backward' } );\n\t\tconst nodeAfterStart = start.nodeAfter;\n\t\tconst nodeBeforeEnd = end.nodeBefore;\n\n\t\t// Because TreeWalker prefers positions next to text node, we need to move them manually into these text nodes.\n\t\tif ( nodeAfterStart && nodeAfterStart.is( 'text' ) ) {\n\t\t\tstart = new Position( nodeAfterStart, 0 );\n\t\t}\n\n\t\tif ( nodeBeforeEnd && nodeBeforeEnd.is( 'text' ) ) {\n\t\t\tend = new Position( nodeBeforeEnd, nodeBeforeEnd.data.length );\n\t\t}\n\n\t\treturn new Range( start, end );\n\t}\n\n\t/**\n\t * Two ranges are equal if their start and end positions are equal.\n\t *\n\t * @param {module:engine/view/range~Range} otherRange Range to compare with.\n\t * @returns {Boolean} `true` if ranges are equal, `false` otherwise\n\t */\n\tisEqual( otherRange ) {\n\t\treturn this == otherRange || ( this.start.isEqual( otherRange.start ) && this.end.isEqual( otherRange.end ) );\n\t}\n\n\t/**\n\t * Checks whether this range contains given {@link module:engine/view/position~Position position}.\n\t *\n\t * @param {module:engine/view/position~Position} position Position to check.\n\t * @returns {Boolean} `true` if given {@link module:engine/view/position~Position position} is contained in this range,\n\t * `false` otherwise.\n\t */\n\tcontainsPosition( position ) {\n\t\treturn position.isAfter( this.start ) && position.isBefore( this.end );\n\t}\n\n\t/**\n\t * Checks whether this range contains given {@link module:engine/view/range~Range range}.\n\t *\n\t * @param {module:engine/view/range~Range} otherRange Range to check.\n\t * @param {Boolean} [loose=false] Whether the check is loose or strict. If the check is strict (`false`), compared range cannot\n\t * start or end at the same position as this range boundaries. If the check is loose (`true`), compared range can start, end or\n\t * even be equal to this range. Note that collapsed ranges are always compared in strict mode.\n\t * @returns {Boolean} `true` if given {@link module:engine/view/range~Range range} boundaries are contained by this range, `false`\n\t * otherwise.\n\t */\n\tcontainsRange( otherRange, loose = false ) {\n\t\tif ( otherRange.isCollapsed ) {\n\t\t\tloose = false;\n\t\t}\n\n\t\tconst containsStart = this.containsPosition( otherRange.start ) || ( loose && this.start.isEqual( otherRange.start ) );\n\t\tconst containsEnd = this.containsPosition( otherRange.end ) || ( loose && this.end.isEqual( otherRange.end ) );\n\n\t\treturn containsStart && containsEnd;\n\t}\n\n\t/**\n\t * Computes which part(s) of this {@link module:engine/view/range~Range range} is not a part of given\n\t * {@link module:engine/view/range~Range range}.\n\t * Returned array contains zero, one or two {@link module:engine/view/range~Range ranges}.\n\t *\n\t * Examples:\n\t *\n\t *\t\tlet foo = downcastWriter.createText( 'foo' );\n\t *\t\tlet img = downcastWriter.createContainerElement( 'img' );\n\t *\t\tlet bar = downcastWriter.createText( 'bar' );\n\t *\t\tlet p = downcastWriter.createContainerElement( 'p', null, [ foo, img, bar ] );\n\t *\n\t *\t\tlet range = view.createRange( view.createPositionAt( foo, 2 ), view.createPositionAt( bar, 1 ); // \"o\", img, \"b\" are in range.\n\t *\t\tlet otherRange = view.createRange( // \"oo\", img, \"ba\" are in range.\n\t *\t\t\tview.createPositionAt( foo, 1 ),\n\t *\t\t\tview.createPositionAt( bar, 2 )\n\t *\t\t);\n\t *\t\tlet transformed = range.getDifference( otherRange );\n\t *\t\t// transformed array has no ranges because `otherRange` contains `range`\n\t *\n\t *\t\totherRange = view.createRange( view.createPositionAt( foo, 1 ), view.createPositionAt( p, 2 ); // \"oo\", img are in range.\n\t *\t\ttransformed = range.getDifference( otherRange );\n\t *\t\t// transformed array has one range: from ( p, 2 ) to ( bar, 1 )\n\t *\n\t *\t\totherRange = view.createRange( view.createPositionAt( p, 1 ), view.createPositionAt( p, 2 ) ); // img is in range.\n\t *\t\ttransformed = range.getDifference( otherRange );\n\t *\t\t// transformed array has two ranges: from ( foo, 1 ) to ( p, 1 ) and from ( p, 2 ) to ( bar, 1 )\n\t *\n\t * @param {module:engine/view/range~Range} otherRange Range to differentiate against.\n\t * @returns {Array.<module:engine/view/range~Range>} The difference between ranges.\n\t */\n\tgetDifference( otherRange ) {\n\t\tconst ranges = [];\n\n\t\tif ( this.isIntersecting( otherRange ) ) {\n\t\t\t// Ranges intersect.\n\n\t\t\tif ( this.containsPosition( otherRange.start ) ) {\n\t\t\t\t// Given range start is inside this range. This means that we have to\n\t\t\t\t// add shrunken range - from the start to the middle of this range.\n\t\t\t\tranges.push( new Range( this.start, otherRange.start ) );\n\t\t\t}\n\n\t\t\tif ( this.containsPosition( otherRange.end ) ) {\n\t\t\t\t// Given range end is inside this range. This means that we have to\n\t\t\t\t// add shrunken range - from the middle of this range to the end.\n\t\t\t\tranges.push( new Range( otherRange.end, this.end ) );\n\t\t\t}\n\t\t} else {\n\t\t\t// Ranges do not intersect, return the original range.\n\t\t\tranges.push( this.clone() );\n\t\t}\n\n\t\treturn ranges;\n\t}\n\n\t/**\n\t * Returns an intersection of this {@link module:engine/view/range~Range range} and given {@link module:engine/view/range~Range range}.\n\t * Intersection is a common part of both of those ranges. If ranges has no common part, returns `null`.\n\t *\n\t * Examples:\n\t *\n\t *\t\tlet foo = downcastWriter.createText( 'foo' );\n\t *\t\tlet img = downcastWriter.createContainerElement( 'img' );\n\t *\t\tlet bar = downcastWriter.createText( 'bar' );\n\t *\t\tlet p = downcastWriter.createContainerElement( 'p', null, [ foo, img, bar ] );\n\t *\n\t *\t\tlet range = view.createRange( view.createPositionAt( foo, 2 ), view.createPositionAt( bar, 1 ); // \"o\", img, \"b\" are in range.\n\t *\t\tlet otherRange = view.createRange( view.createPositionAt( foo, 1 ), view.createPositionAt( p, 2 ); // \"oo\", img are in range.\n\t *\t\tlet transformed = range.getIntersection( otherRange ); // range from ( foo, 1 ) to ( p, 2 ).\n\t *\n\t *\t\totherRange = view.createRange( view.createPositionAt( bar, 1 ), view.createPositionAt( bar, 3 ); \"ar\" is in range.\n\t *\t\ttransformed = range.getIntersection( otherRange ); // null - no common part.\n\t *\n\t * @param {module:engine/view/range~Range} otherRange Range to check for intersection.\n\t * @returns {module:engine/view/range~Range|null} A common part of given ranges or `null` if ranges have no common part.\n\t */\n\tgetIntersection( otherRange ) {\n\t\tif ( this.isIntersecting( otherRange ) ) {\n\t\t\t// Ranges intersect, so a common range will be returned.\n\t\t\t// At most, it will be same as this range.\n\t\t\tlet commonRangeStart = this.start;\n\t\t\tlet commonRangeEnd = this.end;\n\n\t\t\tif ( this.containsPosition( otherRange.start ) ) {\n\t\t\t\t// Given range start is inside this range. This means thaNt we have to\n\t\t\t\t// shrink common range to the given range start.\n\t\t\t\tcommonRangeStart = otherRange.start;\n\t\t\t}\n\n\t\t\tif ( this.containsPosition( otherRange.end ) ) {\n\t\t\t\t// Given range end is inside this range. This means that we have to\n\t\t\t\t// shrink common range to the given range end.\n\t\t\t\tcommonRangeEnd = otherRange.end;\n\t\t\t}\n\n\t\t\treturn new Range( commonRangeStart, commonRangeEnd );\n\t\t}\n\n\t\t// Ranges do not intersect, so they do not have common part.\n\t\treturn null;\n\t}\n\n\t/**\n\t * Creates a {@link module:engine/view/treewalker~TreeWalker TreeWalker} instance with this range as a boundary.\n\t *\n\t * @param {Object} options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}.\n\t * @param {module:engine/view/position~Position} [options.startPosition]\n\t * @param {Boolean} [options.singleCharacters=false]\n\t * @param {Boolean} [options.shallow=false]\n\t * @param {Boolean} [options.ignoreElementEnd=false]\n\t * @returns {module:engine/view/treewalker~TreeWalker}\n\t */\n\tgetWalker( options = {} ) {\n\t\toptions.boundaries = this;\n\n\t\treturn new TreeWalker( options );\n\t}\n\n\t/**\n\t * Returns a {@link module:engine/view/node~Node} or {@link module:engine/view/documentfragment~DocumentFragment}\n\t * which is a common ancestor of range's both ends (in which the entire range is contained).\n\t *\n\t * @returns {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment|null}\n\t */\n\tgetCommonAncestor() {\n\t\treturn this.start.getCommonAncestor( this.end );\n\t}\n\n\t/**\n\t * Clones this range.\n\t *\n\t * @returns {module:engine/view/range~Range}\n\t */\n\tclone() {\n\t\treturn new Range( this.start, this.end );\n\t}\n\n\t/**\n\t * Returns an iterator that iterates over all {@link module:engine/view/item~Item view items} that are in this range and returns\n\t * them.\n\t *\n\t * This method uses {@link module:engine/view/treewalker~TreeWalker} with `boundaries` set to this range and `ignoreElementEnd` option\n\t * set to `true`. However it returns only {@link module:engine/view/item~Item items},\n\t * not {@link module:engine/view/treewalker~TreeWalkerValue}.\n\t *\n\t * You may specify additional options for the tree walker. See {@link module:engine/view/treewalker~TreeWalker} for\n\t * a full list of available options.\n\t *\n\t * @param {Object} options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}.\n\t * @returns {Iterable.<module:engine/view/item~Item>}\n\t */\n\t* getItems( options = {} ) {\n\t\toptions.boundaries = this;\n\t\toptions.ignoreElementEnd = true;\n\n\t\tconst treeWalker = new TreeWalker( options );\n\n\t\tfor ( const value of treeWalker ) {\n\t\t\tyield value.item;\n\t\t}\n\t}\n\n\t/**\n\t * Returns an iterator that iterates over all {@link module:engine/view/position~Position positions} that are boundaries or\n\t * contained in this range.\n\t *\n\t * This method uses {@link module:engine/view/treewalker~TreeWalker} with `boundaries` set to this range. However it returns only\n\t * {@link module:engine/view/position~Position positions}, not {@link module:engine/view/treewalker~TreeWalkerValue}.\n\t *\n\t * You may specify additional options for the tree walker. See {@link module:engine/view/treewalker~TreeWalker} for\n\t * a full list of available options.\n\t *\n\t * @param {Object} options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}.\n\t * @returns {Iterable.<module:engine/view/position~Position>}\n\t */\n\t* getPositions( options = {} ) {\n\t\toptions.boundaries = this;\n\n\t\tconst treeWalker = new TreeWalker( options );\n\n\t\tyield treeWalker.position;\n\n\t\tfor ( const value of treeWalker ) {\n\t\t\tyield value.nextPosition;\n\t\t}\n\t}\n\n\t/**\n\t * Checks whether this object is of the given type.\n\t *\n\t *\t\trange.is( 'range' ); // -> true\n\t *\t\trange.is( 'view:range' ); // -> true\n\t *\n\t *\t\trange.is( 'model:range' ); // -> false\n\t *\t\trange.is( 'element' ); // -> false\n\t *\t\trange.is( 'selection' ); // -> false\n\t *\n\t * {@link module:engine/view/node~Node#is Check the entire list of view objects} which implement the `is()` method.\n\t *\n\t * @param {String} type\n\t * @returns {Boolean}\n\t */\n\tis( type ) {\n\t\treturn type == 'range' || type == 'view:range';\n\t}\n\n\t/**\n\t * Checks and returns whether this range intersects with the given range.\n\t *\n\t * @param {module:engine/view/range~Range} otherRange Range to compare with.\n\t * @returns {Boolean} True if ranges intersect.\n\t */\n\tisIntersecting( otherRange ) {\n\t\treturn this.start.isBefore( otherRange.end ) && this.end.isAfter( otherRange.start );\n\t}\n\n\t/**\n\t * Creates a range from the given parents and offsets.\n\t *\n\t * @protected\n\t * @param {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment} startElement Start position\n\t * parent element.\n\t * @param {Number} startOffset Start position offset.\n\t * @param {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment} endElement End position\n\t * parent element.\n\t * @param {Number} endOffset End position offset.\n\t * @returns {module:engine/view/range~Range} Created range.\n\t */\n\tstatic _createFromParentsAndOffsets( startElement, startOffset, endElement, endOffset ) {\n\t\treturn new this(\n\t\t\tnew Position( startElement, startOffset ),\n\t\t\tnew Position( endElement, endOffset )\n\t\t);\n\t}\n\n\t/**\n\t * Creates a new range, spreading from specified {@link module:engine/view/position~Position position} to a position moved by\n\t * given `shift`. If `shift` is a negative value, shifted position is treated as the beginning of the range.\n\t *\n\t * @protected\n\t * @param {module:engine/view/position~Position} position Beginning of the range.\n\t * @param {Number} shift How long the range should be.\n\t * @returns {module:engine/view/range~Range}\n\t */\n\tstatic _createFromPositionAndShift( position, shift ) {\n\t\tconst start = position;\n\t\tconst end = position.getShiftedBy( shift );\n\n\t\treturn shift > 0 ? new this( start, end ) : new this( end, start );\n\t}\n\n\t/**\n\t * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of\n\t * that element and ends after the last child of that element.\n\t *\n\t * @protected\n\t * @param {module:engine/view/element~Element} element Element which is a parent for the range.\n\t * @returns {module:engine/view/range~Range}\n\t */\n\tstatic _createIn( element ) {\n\t\treturn this._createFromParentsAndOffsets( element, 0, element, element.childCount );\n\t}\n\n\t/**\n\t * Creates a range that starts before given {@link module:engine/view/item~Item view item} and ends after it.\n\t *\n\t * @protected\n\t * @param {module:engine/view/item~Item} item\n\t * @returns {module:engine/view/range~Range}\n\t */\n\tstatic _createOn( item ) {\n\t\tconst size = item.is( 'textProxy' ) ? item.offsetSize : 1;\n\n\t\treturn this._createFromPositionAndShift( Position._createBefore( item ), size );\n\t}\n}\n\n// Function used by getEnlarged and getTrimmed methods.\nfunction enlargeTrimSkip( value ) {\n\tif ( value.item.is( 'attributeElement' ) || value.item.is( 'uiElement' ) ) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n"]}]}