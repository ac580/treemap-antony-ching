{"remainingRequest":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/babel-loader/lib/index.js!/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-engine/src/conversion/conversion.js","dependencies":[{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-engine/src/conversion/conversion.js","mtime":499162500000},{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js","mtime":499162500000},{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/babel-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:LyoqCiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDE5LCBDS1NvdXJjZSAtIEZyZWRlcmljbyBLbmFiYmVuLiBBbGwgcmlnaHRzIHJlc2VydmVkLgogKiBGb3IgbGljZW5zaW5nLCBzZWUgTElDRU5TRS5tZCBvciBodHRwczovL2NrZWRpdG9yLmNvbS9sZWdhbC9ja2VkaXRvci1vc3MtbGljZW5zZQogKi8KCi8qKgogKiBAbW9kdWxlIGVuZ2luZS9jb252ZXJzaW9uL2NvbnZlcnNpb24KICovCmltcG9ydCBDS0VkaXRvckVycm9yIGZyb20gJ0Bja2VkaXRvci9ja2VkaXRvcjUtdXRpbHMvc3JjL2NrZWRpdG9yZXJyb3InOwppbXBvcnQgVXBjYXN0SGVscGVycyBmcm9tICcuL3VwY2FzdGhlbHBlcnMnOwppbXBvcnQgRG93bmNhc3RIZWxwZXJzIGZyb20gJy4vZG93bmNhc3RoZWxwZXJzJzsKLyoqCiAqIEEgdXRpbGl0eSBjbGFzcyB0aGF0IGhlbHBzIGFkZCBjb252ZXJ0ZXJzIHRvIHVwY2FzdCBhbmQgZG93bmNhc3QgZGlzcGF0Y2hlcnMuCiAqCiAqIFdlIHJlY29tbWVuZCByZWFkaW5nIHRoZSB7QGdsaW5rIGZyYW1ld29yay9ndWlkZXMvYXJjaGl0ZWN0dXJlL2VkaXRpbmctZW5naW5lIEVkaXRpbmcgZW5naW5lIGFyY2hpdGVjdHVyZX0gZ3VpZGUgZmlyc3QgdG8KICogdW5kZXJzdGFuZCB0aGUgY29yZSBjb25jZXB0cyBvZiB0aGUgY29udmVyc2lvbiBtZWNoYW5pc21zLgogKgogKiBBbiBpbnN0YW5jZSBvZiB0aGUgY29udmVyc2lvbiBtYW5hZ2VyIGlzIGF2YWlsYWJsZSBpbiB0aGUKICoge0BsaW5rIG1vZHVsZTpjb3JlL2VkaXRvci9lZGl0b3J+RWRpdG9yI2NvbnZlcnNpb24gYGVkaXRvci5jb252ZXJzaW9uYH0gcHJvcGVydHkKICogYW5kIGJ5IGRlZmF1bHQgaGFzIHRoZSBmb2xsb3dpbmcgZ3JvdXBzIG9mIGRpc3BhdGNoZXJzIChpLmUuIGRpcmVjdGlvbnMgb2YgY29udmVyc2lvbik6CiAqCiAqICogYGRvd25jYXN0YCAoZWRpdGluZyBhbmQgZGF0YSBkb3duY2FzdHMpCiAqICogYGVkaXRpbmdEb3duY2FzdGAKICogKiBgZGF0YURvd25jYXN0YAogKiAqIGB1cGNhc3RgCiAqCiAqICMgT25lLXdheSBjb252ZXJ0ZXJzCiAqCiAqIFRvIGFkZCBhIGNvbnZlcnRlciB0byBhIHNwZWNpZmljIGdyb3VwLCB1c2UgdGhlIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vY29udmVyc2lvbn5Db252ZXJzaW9uI2ZvciBgZm9yKClgfQogKiBtZXRob2Q6CiAqCiAqCQkvLyBBZGQgYSBjb252ZXJ0ZXIgdG8gZWRpdGluZyBkb3duY2FzdCBhbmQgZGF0YSBkb3duY2FzdC4KICoJCWVkaXRvci5jb252ZXJzaW9uLmZvciggJ2Rvd25jYXN0JyApLmVsZW1lbnRUb0VsZW1lbnQoIGNvbmZpZyApICk7CiAqCiAqCQkvLyBBZGQgYSBjb252ZXJ0ZXIgdG8gdGhlIGRhdGEgcGlwZXBsaW5lIG9ubHk6CiAqCQllZGl0b3IuY29udmVyc2lvbi5mb3IoICdkYXRhRG93bmNhc3QnICkuZWxlbWVudFRvRWxlbWVudCggZGF0YUNvbnZlcnNpb25Db25maWcgKSApOwogKgogKgkJLy8gQW5kIGEgc2xpZ2h0bHkgZGlmZmVyZW50IG9uZSBmb3IgdGhlIGVkaXRpbmcgcGlwZWxpbmU6CiAqCQllZGl0b3IuY29udmVyc2lvbi5mb3IoICdlZGl0aW5nRG93bmNhc3QnICkuZWxlbWVudFRvRWxlbWVudCggZWRpdGluZ0NvbnZlcnNpb25Db25maWcgKSApOwogKgogKiBTZWUge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi9jb252ZXJzaW9ufkNvbnZlcnNpb24jZm9yIGBmb3IoKWB9IG1ldGhvZCBkb2N1bWVudGF0aW9uIHRvIGxlYXJuIG1vcmUgYWJvdXQKICogYXZhaWxhYmxlIGNvbnZlcnNpb24gaGVscGVycyBhbmQgaG93IHRvIHVzZSB5b3VyIGN1c3RvbSBvbmVzLgogKgogKiAjIFR3by13YXkgY29udmVydGVycwogKgogKiBCZXNpZGVzIHVzaW5nIG9uZS13YXkgY29udmVydGVycyB2aWEgdGhlIGBmb3IoKWAgbWV0aG9kLCB5b3UgY2FuIGFsc28gdXNlIG90aGVyIG1ldGhvZHMgYXZhaWxhYmxlIGluIHRoaXMKICogY2xhc3MgdG8gYWRkIHR3by13YXkgY29udmVydGVycyAodXBjYXN0IGFuZCBkb3duY2FzdCk6CiAqCiAqICoge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi9jb252ZXJzaW9ufkNvbnZlcnNpb24jZWxlbWVudFRvRWxlbWVudCBgZWxlbWVudFRvRWxlbWVudCgpYH0gJm5kYXNoOwogKiBNb2RlbCBlbGVtZW50IHRvIHZpZXcgZWxlbWVudCBhbmQgdmljZSB2ZXJzYS4KICogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL2NvbnZlcnNpb25+Q29udmVyc2lvbiNhdHRyaWJ1dGVUb0VsZW1lbnQgYGF0dHJpYnV0ZVRvRWxlbWVudCgpYH0gJm5kYXNoOwogKiBNb2RlbCBhdHRyaWJ1dGUgdG8gdmlldyBlbGVtZW50IGFuZCB2aWNlIHZlcnNhLgogKiAqIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vY29udmVyc2lvbn5Db252ZXJzaW9uI2F0dHJpYnV0ZVRvQXR0cmlidXRlIGBhdHRyaWJ1dGVUb0F0dHJpYnV0ZSgpYH0gJm5kYXNoOwogKiBNb2RlbCBhdHRyaWJ1dGUgdG8gdmlldyBlbGVtZW50IGFuZCB2aWNlIHZlcnNhLgogKi8KCmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbnZlcnNpb24gewogIC8qKgogICAqIENyZWF0ZXMgYSBuZXcgY29udmVyc2lvbiBpbnN0YW5jZS4KICAgKgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL2Rvd25jYXN0ZGlzcGF0Y2hlcn5Eb3duY2FzdERpc3BhdGNoZXJ8CiAgICogQXJyYXkuPG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi9kb3duY2FzdGRpc3BhdGNoZXJ+RG93bmNhc3REaXNwYXRjaGVyPn0gZG93bmNhc3REaXNwYXRjaGVycwogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL3VwY2FzdGRpc3BhdGNoZXJ+VXBjYXN0RGlzcGF0Y2hlcnwKICAgKiBBcnJheS48bW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL3VwY2FzdGRpc3BhdGNoZXJ+VXBjYXN0RGlzcGF0Y2hlcj59IHVwY2FzdERpc3BhdGNoZXJzCiAgICovCiAgY29uc3RydWN0b3IoZG93bmNhc3REaXNwYXRjaGVycywgdXBjYXN0RGlzcGF0Y2hlcnMpIHsKICAgIC8qKgogICAgICogTWFwcyBkaXNwYXRjaGVycyBncm91cCBuYW1lIHRvIENvbnZlcnNpb25IZWxwZXJzIGluc3RhbmNlcy4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQG1lbWJlciB7TWFwLjxTdHJpbmcsbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL2NvbnZlcnNpb25oZWxwZXJzfkNvbnZlcnNpb25IZWxwZXJzPn0KICAgICAqLwogICAgdGhpcy5faGVscGVycyA9IG5ldyBNYXAoKTsgLy8gRGVmaW5lIGRlZmF1bHQgJ2Rvd25jYXN0JyAmICd1cGNhc3QnIGRpc3BhdGNoZXJzIGdyb3Vwcy4gVGhvc2UgZ3JvdXBzIGFyZSBhbHdheXMgYXZhaWxhYmxlIGFzIHR3by13YXkgY29udmVydGVycyBuZWVkcyB0aGVtLgoKICAgIHRoaXMuX2Rvd25jYXN0ID0gQXJyYXkuaXNBcnJheShkb3duY2FzdERpc3BhdGNoZXJzKSA/IGRvd25jYXN0RGlzcGF0Y2hlcnMgOiBbZG93bmNhc3REaXNwYXRjaGVyc107CgogICAgdGhpcy5fY3JlYXRlQ29udmVyc2lvbkhlbHBlcnMoewogICAgICBuYW1lOiAnZG93bmNhc3QnLAogICAgICBkaXNwYXRjaGVyczogdGhpcy5fZG93bmNhc3QsCiAgICAgIGlzRG93bmNhc3Q6IHRydWUKICAgIH0pOwoKICAgIHRoaXMuX3VwY2FzdCA9IEFycmF5LmlzQXJyYXkodXBjYXN0RGlzcGF0Y2hlcnMpID8gdXBjYXN0RGlzcGF0Y2hlcnMgOiBbdXBjYXN0RGlzcGF0Y2hlcnNdOwoKICAgIHRoaXMuX2NyZWF0ZUNvbnZlcnNpb25IZWxwZXJzKHsKICAgICAgbmFtZTogJ3VwY2FzdCcsCiAgICAgIGRpc3BhdGNoZXJzOiB0aGlzLl91cGNhc3QsCiAgICAgIGlzRG93bmNhc3Q6IGZhbHNlCiAgICB9KTsKICB9CiAgLyoqCiAgICogRGVmaW5lIGFuIGFsaWFzIGZvciByZWdpc3RlcmVkIGRpc3BhdGNoZXIuCiAgICoKICAgKgkJY29uc3QgY29udmVyc2lvbiA9IG5ldyBDb252ZXJzaW9uKAogICAqCQkJWyBkYXRhRG93bmNhc3REaXNwYXRjaGVyLCBlZGl0aW5nRG93bmNhc3REaXNwYXRjaGVyIF0sCiAgICoJCQl1cGNhc3REaXNwYXRjaGVyCiAgICoJCSk7CiAgICoKICAgKgkJY29udmVyc2lvbi5hZGRBbGlhcyggJ2RhdGFEb3duY2FzdCcsIGRhdGFEb3duY2FzdERpc3BhdGNoZXIgKTsKICAgKgogICAqIEBwYXJhbSB7U3RyaW5nfSBhbGlhcyBBbiBhbGlhcyBvZiBhIGRpc3BhdGNoZXIuCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vZG93bmNhc3RkaXNwYXRjaGVyfkRvd25jYXN0RGlzcGF0Y2hlcnwKICAgKiBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vdXBjYXN0ZGlzcGF0Y2hlcn5VcGNhc3REaXNwYXRjaGVyfSBkaXNwYXRjaGVyIERpc3BhdGNoZXIgd2hpY2ggc2hvdWxkIGhhdmUgYW4gYWxpYXMuCiAgICovCgoKICBhZGRBbGlhcyhhbGlhcywgZGlzcGF0Y2hlcikgewogICAgY29uc3QgaXNEb3duY2FzdCA9IHRoaXMuX2Rvd25jYXN0LmluY2x1ZGVzKGRpc3BhdGNoZXIpOwoKICAgIGNvbnN0IGlzVXBjYXN0ID0gdGhpcy5fdXBjYXN0LmluY2x1ZGVzKGRpc3BhdGNoZXIpOwoKICAgIGlmICghaXNVcGNhc3QgJiYgIWlzRG93bmNhc3QpIHsKICAgICAgLyoqCiAgICAgICAqIFRyeWluZyB0byByZWdpc3RlciBhbmQgYWxpYXMgZm9yIGEgZGlzcGF0Y2hlciB0aGF0IG5hcyBub3QgYmVlbiByZWdpc3RlcmVkLgogICAgICAgKgogICAgICAgKiBAZXJyb3IgY29udmVyc2lvbi1hZGQtYWxpYXMtZGlzcGF0Y2hlci1ub3QtcmVnaXN0ZXJlZAogICAgICAgKi8KICAgICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ2NvbnZlcnNpb24tYWRkLWFsaWFzLWRpc3BhdGNoZXItbm90LXJlZ2lzdGVyZWQ6ICcgKyAnVHJ5aW5nIHRvIHJlZ2lzdGVyIGFuZCBhbGlhcyBmb3IgYSBkaXNwYXRjaGVyIHRoYXQgbmFzIG5vdCBiZWVuIHJlZ2lzdGVyZWQuJywgdGhpcyk7CiAgICB9CgogICAgdGhpcy5fY3JlYXRlQ29udmVyc2lvbkhlbHBlcnMoewogICAgICBuYW1lOiBhbGlhcywKICAgICAgZGlzcGF0Y2hlcnM6IFtkaXNwYXRjaGVyXSwKICAgICAgaXNEb3duY2FzdAogICAgfSk7CiAgfQogIC8qKgogICAqIFByb3ZpZGVzIGEgY2hhaW5hYmxlIEFQSSB0byBhc3NpZ24gY29udmVydGVycyB0byBjb252ZXJzaW9uIGRpc3BhdGNoZXJzIGdyb3VwLgogICAqCiAgICogSWYgdGhlIGdpdmVuIGdyb3VwIG5hbWUgaGFzIG5vdCBiZWVuIHJlZ2lzdGVyZWQsIHRoZQogICAqIHtAbGluayBtb2R1bGU6dXRpbHMvY2tlZGl0b3JlcnJvcn5DS0VkaXRvckVycm9yIGBjb252ZXJzaW9uLWZvci11bmtub3duLWdyb3VwYCBlcnJvcn0gaXMgdGhyb3duLgogICAqCiAgICogWW91IGNhbiB1c2UgY29udmVyc2lvbiBoZWxwZXJzIGF2YWlsYWJsZSBkaXJlY3RseSBpbiB0aGUgYGZvcigpYCBjaGFpbiBvciB5b3VyIGN1c3RvbSBvbmVzIHZpYQogICAqIHRoZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL2NvbnZlcnNpb25oZWxwZXJzfkNvbnZlcnNpb25IZWxwZXJzI2FkZCBgYWRkKClgfSBtZXRob2QuCiAgICoKICAgKiAjIFVzaW5nIGJ1bGl0LWluIGNvbnZlcnNpb24gaGVscGVycwogICAqCiAgICogVGhlIGBmb3IoKWAgY2hhaW4gY29tZXMgd2l0aCBhIHNldCBvZiBjb252ZXJzaW9uIGhlbHBlcnMgd2hpY2ggeW91IGNhbiB1c2UgbGlrZSB0aGlzOgogICAqCiAgICoJCWVkaXRvci5jb252ZXJzaW9uLmZvciggJ2Rvd25jYXN0JyApCiAgICoJCQkuZWxlbWVudFRvRWxlbWVudCggY29uZmlnMSApICAgICAgICAvLyBBZGRzIGFuIGVsZW1lbnQtdG8tZWxlbWVudCBkb3duY2FzdCBjb252ZXJ0ZXIuCiAgICoJCQkuYXR0cmlidXRlVG9FbGVtZW50KCBjb25maWcyICk7ICAgICAvLyBBZGRzIGFuIGF0dHJpYnV0ZS10by1lbGVtZW50IGRvd25jYXN0IGNvbnZlcnRlci4KICAgKgogICAqCQllZGl0b3IuY29udmVyc2lvbi5mb3IoICd1cGNhc3QnICkKICAgKgkJCS5lbGVtZW50VG9BdHRyaWJ1dGUoIGNvbmZpZzMgKTsgICAgIC8vIEFkZHMgYW4gZWxlbWVudC10by1hdHRyaWJ1dGUgdXBjYXN0IGNvbnZlcnRlci4KICAgKgogICAqIFJlZmVyIHRvIHRoZSBkb2N1bWVudGF0aW9uIG9mIGJ1aWx0LWluIGNvbnZlcnNpb24gaGVscGVycyB0byBsZWFybiBhYm91dCB0aGVpciBjb25maWd1cmF0aW9uIG9wdGlvbnMuCiAgICoKICAgKiAqIGRvd25jYXN0IChtb2RlbC10by12aWV3KSBjb252ZXJzaW9uIGhlbHBlcnM6CiAgICoKICAgKgkqIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vZG93bmNhc3RoZWxwZXJzfkRvd25jYXN0SGVscGVycyNlbGVtZW50VG9FbGVtZW50IGBlbGVtZW50VG9FbGVtZW50KClgfSwKICAgKgkqIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vZG93bmNhc3RoZWxwZXJzfkRvd25jYXN0SGVscGVycyNhdHRyaWJ1dGVUb0VsZW1lbnQgYGF0dHJpYnV0ZVRvRWxlbWVudCgpYH0sCiAgICoJKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL2Rvd25jYXN0aGVscGVyc35Eb3duY2FzdEhlbHBlcnMjYXR0cmlidXRlVG9BdHRyaWJ1dGUgYGF0dHJpYnV0ZVRvQXR0cmlidXRlKClgfS4KICAgKgkqIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vZG93bmNhc3RoZWxwZXJzfkRvd25jYXN0SGVscGVycyNtYXJrZXJUb0VsZW1lbnQgYG1hcmtlclRvRWxlbWVudCgpYH0uCiAgICoJKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL2Rvd25jYXN0aGVscGVyc35Eb3duY2FzdEhlbHBlcnMjbWFya2VyVG9IaWdobGlnaHQgYG1hcmtlclRvSGlnaGxpZ2h0KClgfS4KICAgKgogICAqICogdXBjYXN0ICh2aWV3LXRvLW1vZGVsKSBjb252ZXJzaW9uIGhlbHBlcnM6CiAgICoKICAgKgkqIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vdXBjYXN0aGVscGVyc35VcGNhc3RIZWxwZXJzI2VsZW1lbnRUb0VsZW1lbnQgYGVsZW1lbnRUb0VsZW1lbnQoKWB9LAogICAqCSoge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi91cGNhc3RoZWxwZXJzflVwY2FzdEhlbHBlcnMjZWxlbWVudFRvQXR0cmlidXRlIGBlbGVtZW50VG9BdHRyaWJ1dGUoKWB9LAogICAqCSoge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi91cGNhc3RoZWxwZXJzflVwY2FzdEhlbHBlcnMjYXR0cmlidXRlVG9BdHRyaWJ1dGUgYGF0dHJpYnV0ZVRvQXR0cmlidXRlKClgfS4KICAgKgkqIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vdXBjYXN0aGVscGVyc35VcGNhc3RIZWxwZXJzI2VsZW1lbnRUb01hcmtlciBgZWxlbWVudFRvTWFya2VyKClgfS4KICAgKgogICAqICMgVXNpbmcgY3VzdG9tIGNvbnZlcnNpb24gaGVscGVycwogICAqCiAgICogSWYgeW91IG5lZWQgdG8gaW1wbGVtZW50IGEgbm9udHlwaWNhbCBjb252ZXJ0ZXIsIHlvdSBjYW4gZG8gc28gYnkgY2FsbGluZzoKICAgKgogICAqCQllZGl0b3IuY29udmVyc2lvbi5mb3IoIGRpcmVjdGlvbiApLmFkZCggY3VzdG9tSGVscGVyICk7CiAgICoKICAgKiBUaGUgYC5hZGQoKWAgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIHBhcmFtZXRlciwgd2hpY2ggaXMgYSBmdW5jdGlvbi4gVGhpcyBmdW5jdGlvbiBzaG91bGQgYWNjZXB0IG9uZSBwYXJhbWV0ZXIgdGhhdAogICAqIGlzIGEgZGlzcGF0Y2hlciBpbnN0YW5jZS4gVGhlIGZ1bmN0aW9uIHNob3VsZCBhZGQgYW4gYWN0dWFsIGNvbnZlcnRlciB0byB0aGUgcGFzc2VkIGRpc3BhdGNoZXIgaW5zdGFuY2UuCiAgICoKICAgKiBFeGFtcGxlOgogICAqCiAgICoJCWVkaXRvci5jb252ZXJzaW9uLmZvciggJ3VwY2FzdCcgKS5hZGQoIGRpc3BhdGNoZXIgPT4gewogICAqCQkJZGlzcGF0Y2hlci5vbiggJ2VsZW1lbnQ6YScsICAoIGV2dCwgZGF0YSwgY29udmVyc2lvbkFwaSApID0+IHsKICAgKgkJCQkvLyBEbyBzb21ldGhpbmcgd2l0aCBhIHZpZXcgPGE+IGVsZW1lbnQuCiAgICoJCQl9ICk7CiAgICoJCX0gKTsKICAgKgogICAqIFJlZmVyIHRvIHRoZSBkb2N1bWVudGF0aW9uIG9mIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vdXBjYXN0ZGlzcGF0Y2hlcn5VcGNhc3REaXNwYXRjaGVyfQogICAqIGFuZCB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL2Rvd25jYXN0ZGlzcGF0Y2hlcn5Eb3duY2FzdERpc3BhdGNoZXJ9IHRvIGxlYXJuIGhvdyB0byB3cml0ZQogICAqIGN1c3RvbSBjb252ZXJ0ZXJzLgogICAqCiAgICogQHBhcmFtIHtTdHJpbmd9IGdyb3VwTmFtZSBUaGUgbmFtZSBvZiBkaXNwYXRjaGVycyBncm91cCB0byBhZGQgdGhlIGNvbnZlcnRlcnMgdG8uCiAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvY29udmVyc2lvbi9kb3duY2FzdGhlbHBlcnN+RG93bmNhc3RIZWxwZXJzfG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi91cGNhc3RoZWxwZXJzflVwY2FzdEhlbHBlcnN9CiAgICovCgoKICBmb3IoZ3JvdXBOYW1lKSB7CiAgICBpZiAoIXRoaXMuX2hlbHBlcnMuaGFzKGdyb3VwTmFtZSkpIHsKICAgICAgLyoqCiAgICAgICAqIFRyeWluZyB0byBhZGQgYSBjb252ZXJ0ZXIgdG8gYW4gdW5rbm93biBkaXNwYXRjaGVycyBncm91cC4KICAgICAgICoKICAgICAgICogQGVycm9yIGNvbnZlcnNpb24tZm9yLXVua25vd24tZ3JvdXAKICAgICAgICovCiAgICAgIHRocm93IG5ldyBDS0VkaXRvckVycm9yKCdjb252ZXJzaW9uLWZvci11bmtub3duLWdyb3VwOiBUcnlpbmcgdG8gYWRkIGEgY29udmVydGVyIHRvIGFuIHVua25vd24gZGlzcGF0Y2hlcnMgZ3JvdXAuJywgdGhpcyk7CiAgICB9CgogICAgcmV0dXJuIHRoaXMuX2hlbHBlcnMuZ2V0KGdyb3VwTmFtZSk7CiAgfQogIC8qKgogICAqIFNldHMgdXAgY29udmVydGVycyBiZXR3ZWVuIHRoZSBtb2RlbCBhbmQgdGhlIHZpZXcgdGhhdCBjb252ZXJ0IGEgbW9kZWwgZWxlbWVudCB0byBhIHZpZXcgZWxlbWVudCAoYW5kIHZpY2UgdmVyc2EpLgogICAqIEZvciBleGFtcGxlLCB0aGUgbW9kZWwgYDxwYXJhZ3JhcGg+Rm9vPC9wYXJhZ3JhcGg+YCBpcyBgPHA+Rm9vPC9wPmAgaW4gdGhlIHZpZXcuCiAgICoKICAgKgkJLy8gQSBzaW1wbGUgY29udmVyc2lvbiBmcm9tIHRoZSBgcGFyYWdyYXBoYCBtb2RlbCBlbGVtZW50IHRvIHRoZSBgPHA+YCB2aWV3IGVsZW1lbnQgKGFuZCB2aWNlIHZlcnNhKS4KICAgKgkJZWRpdG9yLmNvbnZlcnNpb24uZWxlbWVudFRvRWxlbWVudCggeyBtb2RlbDogJ3BhcmFncmFwaCcsIHZpZXc6ICdwJyB9ICk7CiAgICoKICAgKgkJLy8gT3ZlcnJpZGUgb3RoZXIgY29udmVydGVycyBieSBzcGVjaWZ5aW5nIGEgY29udmVydGVyIGRlZmluaXRpb24gd2l0aCBhIGhpZ2hlciBwcmlvcml0eS4KICAgKgkJZWRpdG9yLmNvbnZlcnNpb24uZWxlbWVudFRvRWxlbWVudCggeyBtb2RlbDogJ3BhcmFncmFwaCcsIHZpZXc6ICdkaXYnLCBjb252ZXJ0ZXJQcmlvcml0eTogJ2hpZ2gnIH0gKTsKICAgKgogICAqCQkvLyBWaWV3IHNwZWNpZmllZCBhcyBhbiBvYmplY3QgaW5zdGVhZCBvZiBhIHN0cmluZy4KICAgKgkJZWRpdG9yLmNvbnZlcnNpb24uZWxlbWVudFRvRWxlbWVudCggewogICAqCQkJbW9kZWw6ICdmYW5jeVBhcmFncmFwaCcsCiAgICoJCQl2aWV3OiB7CiAgICoJCQkJbmFtZTogJ3AnLAogICAqCQkJCWNsYXNzZXM6ICdmYW5jeScKICAgKgkJCX0KICAgKgkJfSApOwogICAqCiAgICoJCS8vIFVzZSBgdXBjYXN0QWxzb2AgdG8gZGVmaW5lIG90aGVyIHZpZXcgZWxlbWVudHMgdGhhdCBzaG91bGQgYWxzbyBiZSBjb252ZXJ0ZWQgdG8gYSBgcGFyYWdyYXBoYCBlbGVtZW50LgogICAqCQllZGl0b3IuY29udmVyc2lvbi5lbGVtZW50VG9FbGVtZW50KCB7CiAgICoJCQltb2RlbDogJ3BhcmFncmFwaCcsCiAgICoJCQl2aWV3OiAncCcsCiAgICoJCQl1cGNhc3RBbHNvOiBbCiAgICoJCQkJJ2RpdicsCiAgICoJCQkJewogICAqCQkJCQkvLyBBbnkgZWxlbWVudCB3aXRoIHRoZSBgZGlzcGxheTogYmxvY2tgIHN0eWxlLgogICAqCQkJCQlzdHlsZXM6IHsKICAgKgkJCQkJCWRpc3BsYXk6ICdibG9jaycKICAgKgkJCQkJfQogICAqCQkJCX0KICAgKgkJCV0KICAgKgkJfSApOwogICAqCiAgICoJCS8vIGB1cGNhc3RBbHNvYCBzZXQgYXMgY2FsbGJhY2sgZW5hYmxlcyBhIGNvbnZlcnNpb24gb2YgYSB3aWRlIHJhbmdlIG9mIGRpZmZlcmVudCB2aWV3IGVsZW1lbnRzLgogICAqCQllZGl0b3IuY29udmVyc2lvbi5lbGVtZW50VG9FbGVtZW50KCB7CiAgICoJCQltb2RlbDogJ2hlYWRpbmcnLAogICAqCQkJdmlldzogJ2gyJywKICAgKgkJCS8vIENvbnZlcnQgImhlYWRsaW5nLWxpa2UiIHBhcmFncmFwaHMgdG8gaGVhZGluZ3MuCiAgICoJCQl1cGNhc3RBbHNvOiB2aWV3RWxlbWVudCA9PiB7CiAgICoJCQkJY29uc3QgZm9udFNpemUgPSB2aWV3RWxlbWVudC5nZXRTdHlsZSggJ2ZvbnQtc2l6ZScgKTsKICAgKgogICAqCQkJCWlmICggIWZvbnRTaXplICkgewogICAqCQkJCQlyZXR1cm4gbnVsbDsKICAgKgkJCQl9CiAgICoKICAgKgkJCQljb25zdCBtYXRjaCA9IGZvbnRTaXplLm1hdGNoKCAvKFxkKylccypweC8gKTsKICAgKgogICAqCQkJCWlmICggIW1hdGNoICkgewogICAqCQkJCQlyZXR1cm4gbnVsbDsKICAgKgkJCQl9CiAgICoKICAgKgkJCQljb25zdCBzaXplID0gTnVtYmVyKCBtYXRjaFsgMSBdICk7CiAgICoKICAgKgkJCQlpZiAoIHNpemUgPiAyNiApIHsKICAgKgkJCQkJLy8gUmV0dXJuZWQgdmFsdWUgY2FuIGJlIGFuIG9iamVjdCB3aXRoIHRoZSBtYXRjaGVkIHByb3BlcnRpZXMuCiAgICoJCQkJCS8vIFRoZXNlIHByb3BlcnRpZXMgd2lsbCBiZSAiY29uc3VtZWQiIGR1cmluZyB0aGUgY29udmVyc2lvbi4KICAgKgkJCQkJLy8gU2VlIGBlbmdpbmUudmlldy5NYXRjaGVyfk1hdGNoZXJQYXR0ZXJuYCBhbmQgYGVuZ2luZS52aWV3Lk1hdGNoZXIjbWF0Y2hgIGZvciBtb3JlIGRldGFpbHMuCiAgICoKICAgKgkJCQkJcmV0dXJuIHsgbmFtZTogdHJ1ZSwgc3R5bGVzOiBbICdmb250LXNpemUnIF0gfTsKICAgKgkJCQl9CiAgICoKICAgKgkJCQlyZXR1cm4gbnVsbDsKICAgKgkJCX0KICAgKgkJfSApOwogICAqCiAgICogYGRlZmluaXRpb24ubW9kZWxgIGlzIGEgYFN0cmluZ2Agd2l0aCBhIG1vZGVsIGVsZW1lbnQgbmFtZSB0byBjb252ZXJ0IGZyb20gb3IgdG8uCiAgICogU2VlIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vY29udmVyc2lvbn5Db252ZXJ0ZXJEZWZpbml0aW9ufSB0byBsZWFybiBhYm91dCBvdGhlciBwYXJhbWV0ZXJzLgogICAqCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vY29udmVyc2lvbn5Db252ZXJ0ZXJEZWZpbml0aW9ufSBkZWZpbml0aW9uIFRoZSBjb252ZXJ0ZXIgZGVmaW5pdGlvbi4KICAgKi8KCgogIGVsZW1lbnRUb0VsZW1lbnQoZGVmaW5pdGlvbikgewogICAgLy8gU2V0IHVwIGRvd25jYXN0IGNvbnZlcnRlci4KICAgIHRoaXMuZm9yKCdkb3duY2FzdCcpLmVsZW1lbnRUb0VsZW1lbnQoZGVmaW5pdGlvbik7IC8vIFNldCB1cCB1cGNhc3QgY29udmVydGVyLgoKICAgIGZvciAoY29uc3QgewogICAgICBtb2RlbCwKICAgICAgdmlldwogICAgfSBvZiBfZ2V0QWxsVXBjYXN0RGVmaW5pdGlvbnMoZGVmaW5pdGlvbikpIHsKICAgICAgdGhpcy5mb3IoJ3VwY2FzdCcpLmVsZW1lbnRUb0VsZW1lbnQoewogICAgICAgIG1vZGVsLAogICAgICAgIHZpZXcsCiAgICAgICAgY29udmVydGVyUHJpb3JpdHk6IGRlZmluaXRpb24uY29udmVydGVyUHJpb3JpdHkKICAgICAgfSk7CiAgICB9CiAgfQogIC8qKgogICAqIFNldHMgdXAgY29udmVydGVycyBiZXR3ZWVuIHRoZSBtb2RlbCBhbmQgdGhlIHZpZXcgdGhhdCBjb252ZXJ0IGEgbW9kZWwgYXR0cmlidXRlIHRvIGEgdmlldyBlbGVtZW50IChhbmQgdmljZSB2ZXJzYSkuCiAgICogRm9yIGV4YW1wbGUsIGEgbW9kZWwgdGV4dCBub2RlIHdpdGggYCJGb28iYCBhcyBkYXRhIGFuZCB0aGUgYGJvbGRgIGF0dHJpYnV0ZSBpcyBgPHN0cm9uZz5Gb288L3N0cm9uZz5gIGluIHRoZSB2aWV3LgogICAqCiAgICoJCS8vIEEgc2ltcGxlIGNvbnZlcnNpb24gZnJvbSB0aGUgYGJvbGQ9dHJ1ZWAgYXR0cmlidXRlIHRvIHRoZSBgPHN0cm9uZz5gIHZpZXcgZWxlbWVudCAoYW5kIHZpY2UgdmVyc2EpLgogICAqCQllZGl0b3IuY29udmVyc2lvbi5hdHRyaWJ1dGVUb0VsZW1lbnQoIHsgbW9kZWw6ICdib2xkJywgdmlldzogJ3N0cm9uZycgfSApOwogICAqCiAgICoJCS8vIE92ZXJyaWRlIG90aGVyIGNvbnZlcnRlcnMgYnkgc3BlY2lmeWluZyBhIGNvbnZlcnRlciBkZWZpbml0aW9uIHdpdGggYSBoaWdoZXIgcHJpb3JpdHkuCiAgICoJCWVkaXRvci5jb252ZXJzaW9uLmF0dHJpYnV0ZVRvRWxlbWVudCggeyBtb2RlbDogJ2JvbGQnLCB2aWV3OiAnYicsIGNvbnZlcnRlclByaW9yaXR5OiAnaGlnaCcgfSApOwogICAqCiAgICoJCS8vIFZpZXcgc3BlY2lmaWVkIGFzIGFuIG9iamVjdCBpbnN0ZWFkIG9mIGEgc3RyaW5nLgogICAqCQllZGl0b3IuY29udmVyc2lvbi5hdHRyaWJ1dGVUb0VsZW1lbnQoIHsKICAgKgkJCW1vZGVsOiAnYm9sZCcsCiAgICoJCQl2aWV3OiB7CiAgICoJCQkJbmFtZTogJ3NwYW4nLAogICAqCQkJCWNsYXNzZXM6ICdib2xkJwogICAqCQkJfQogICAqCQl9ICk7CiAgICoKICAgKgkJLy8gVXNlIGBjb25maWcubW9kZWwubmFtZWAgdG8gZGVmaW5lIHRoZSBjb252ZXJzaW9uIG9ubHkgZnJvbSBhIGdpdmVuIG5vZGUgdHlwZSwgYCR0ZXh0YCBpbiB0aGlzIGNhc2UuCiAgICoJCS8vIFRoZSBzYW1lIGF0dHJpYnV0ZSBvbiBkaWZmZXJlbnQgZWxlbWVudHMgbWF5IHRoZW4gYmUgaGFuZGxlZCBieSBhIGRpZmZlcmVudCBjb252ZXJ0ZXIuCiAgICoJCWVkaXRvci5jb252ZXJzaW9uLmF0dHJpYnV0ZVRvRWxlbWVudCggewogICAqCQkJbW9kZWw6IHsKICAgKgkJCQlrZXk6ICd0ZXh0RGVjb3JhdGlvbicsCiAgICoJCQkJdmFsdWVzOiBbICd1bmRlcmxpbmUnLCAnbGluZVRocm91Z2gnIF0sCiAgICoJCQkJbmFtZTogJyR0ZXh0JwogICAqCQkJfSwKICAgKgkJCXZpZXc6IHsKICAgKgkJCQl1bmRlcmxpbmU6IHsKICAgKgkJCQkJbmFtZTogJ3NwYW4nLAogICAqCQkJCQlzdHlsZXM6IHsKICAgKgkJCQkJCSd0ZXh0LWRlY29yYXRpb24nOiAndW5kZXJsaW5lJwogICAqCQkJCQl9CiAgICoJCQkJfSwKICAgKgkJCQlsaW5lVGhyb3VnaDogewogICAqCQkJCQluYW1lOiAnc3BhbicsCiAgICoJCQkJCXN0eWxlczogewogICAqCQkJCQkJJ3RleHQtZGVjb3JhdGlvbic6ICdsaW5lLXRocm91Z2gnCiAgICoJCQkJCX0KICAgKgkJCQl9CiAgICoJCQl9CiAgICoJCX0gKTsKICAgKgogICAqCQkvLyBVc2UgYHVwY2FzdEFsc29gIHRvIGRlZmluZSBvdGhlciB2aWV3IGVsZW1lbnRzIHRoYXQgc2hvdWxkIGFsc28gYmUgY29udmVydGVkIHRvIHRoZSBgYm9sZGAgYXR0cmlidXRlLgogICAqCQllZGl0b3IuY29udmVyc2lvbi5hdHRyaWJ1dGVUb0VsZW1lbnQoIHsKICAgKgkJCW1vZGVsOiAnYm9sZCcsCiAgICoJCQl2aWV3OiAnc3Ryb25nJywKICAgKgkJCXVwY2FzdEFsc286IFsKICAgKgkJCQknYicsCiAgICoJCQkJewogICAqCQkJCQluYW1lOiAnc3BhbicsCiAgICoJCQkJCWNsYXNzZXM6ICdib2xkJwogICAqCQkJCX0sCiAgICoJCQkJewogICAqCQkJCQluYW1lOiAnc3BhbicsCiAgICoJCQkJCXN0eWxlczogewogICAqCQkJCQkJJ2ZvbnQtd2VpZ2h0JzogJ2JvbGQnCiAgICoJCQkJCX0KICAgKgkJCQl9LAogICAqCQkJCXZpZXdFbGVtZW50ID0+IHsKICAgKgkJCQkJY29uc3QgZm9udFdlaWdodCA9IHZpZXdFbGVtZW50LmdldFN0eWxlKCAnZm9udC13ZWlnaHQnICk7CiAgICoKICAgKgkJCQkJaWYgKCB2aWV3RWxlbWVudC5pcyggJ3NwYW4nICkgJiYgZm9udFdlaWdodCAmJiAvXGQrLy50ZXN0KCkgJiYgTnVtYmVyKCBmb250V2VpZ2h0ICkgPiA1MDAgKSB7CiAgICoJCQkJCQkvLyBSZXR1cm5lZCB2YWx1ZSBjYW4gYmUgYW4gb2JqZWN0IHdpdGggdGhlIG1hdGNoZWQgcHJvcGVydGllcy4KICAgKgkJCQkJCS8vIFRoZXNlIHByb3BlcnRpZXMgd2lsbCBiZSAiY29uc3VtZWQiIGR1cmluZyB0aGUgY29udmVyc2lvbi4KICAgKgkJCQkJCS8vIFNlZSBgZW5naW5lLnZpZXcuTWF0Y2hlcn5NYXRjaGVyUGF0dGVybmAgYW5kIGBlbmdpbmUudmlldy5NYXRjaGVyI21hdGNoYCBmb3IgbW9yZSBkZXRhaWxzLgogICAqCiAgICoJCQkJCQlyZXR1cm4gewogICAqCQkJCQkJCW5hbWU6IHRydWUsCiAgICoJCQkJCQkJc3R5bGVzOiBbICdmb250LXdlaWdodCcgXQogICAqCQkJCQkJfTsKICAgKgkJCQkJfQogICAqCQkJCX0KICAgKgkJCV0KICAgKgkJfSApOwogICAqCiAgICoJCS8vIENvbnZlcnNpb24gZnJvbSBhbmQgdG8gYSBtb2RlbCBhdHRyaWJ1dGUga2V5IHdob3NlIHZhbHVlIGlzIGFuIGVudW0gKGBmb250U2l6ZT1iaWd8c21hbGxgKS4KICAgKgkJLy8gYHVwY2FzdEFsc29gIHNldCBhcyBjYWxsYmFjayBlbmFibGVzIGEgY29udmVyc2lvbiBvZiBhIHdpZGUgcmFuZ2Ugb2YgZGlmZmVyZW50IHZpZXcgZWxlbWVudHMuCiAgICoJCWVkaXRvci5jb252ZXJzaW9uLmF0dHJpYnV0ZVRvRWxlbWVudCggewogICAqCQkJbW9kZWw6IHsKICAgKgkJCQlrZXk6ICdmb250U2l6ZScsCiAgICoJCQkJdmFsdWVzOiBbICdiaWcnLCAnc21hbGwnIF0KICAgKgkJCX0sCiAgICoJCQl2aWV3OiB7CiAgICoJCQkJYmlnOiB7CiAgICoJCQkJCW5hbWU6ICdzcGFuJywKICAgKgkJCQkJc3R5bGVzOiB7CiAgICoJCQkJCQknZm9udC1zaXplJzogJzEuMmVtJwogICAqCQkJCQl9CiAgICoJCQkJfSwKICAgKgkJCQlzbWFsbDogewogICAqCQkJCQluYW1lOiAnc3BhbicsCiAgICoJCQkJCXN0eWxlczogewogICAqCQkJCQkJJ2ZvbnQtc2l6ZSc6ICcwLjhlbScKICAgKgkJCQkJfQogICAqCQkJCX0KICAgKgkJCX0sCiAgICoJCQl1cGNhc3RBbHNvOiB7CiAgICoJCQkJYmlnOiB2aWV3RWxlbWVudCA9PiB7CiAgICoJCQkJCWNvbnN0IGZvbnRTaXplID0gdmlld0VsZW1lbnQuZ2V0U3R5bGUoICdmb250LXNpemUnICk7CiAgICoKICAgKgkJCQkJaWYgKCAhZm9udFNpemUgKSB7CiAgICoJCQkJCQlyZXR1cm4gbnVsbDsKICAgKgkJCQkJfQogICAqCiAgICoJCQkJCWNvbnN0IG1hdGNoID0gZm9udFNpemUubWF0Y2goIC8oXGQrKVxzKnB4LyApOwogICAqCiAgICoJCQkJCWlmICggIW1hdGNoICkgewogICAqCQkJCQkJcmV0dXJuIG51bGw7CiAgICoJCQkJCX0KICAgKgogICAqCQkJCQljb25zdCBzaXplID0gTnVtYmVyKCBtYXRjaFsgMSBdICk7CiAgICoKICAgKgkJCQkJaWYgKCB2aWV3RWxlbWVudC5pcyggJ3NwYW4nICkgJiYgc2l6ZSA+IDEwICkgewogICAqCQkJCQkJLy8gUmV0dXJuZWQgdmFsdWUgY2FuIGJlIGFuIG9iamVjdCB3aXRoIHRoZSBtYXRjaGVkIHByb3BlcnRpZXMuCiAgICoJCQkJCQkvLyBUaGVzZSBwcm9wZXJ0aWVzIHdpbGwgYmUgImNvbnN1bWVkIiBkdXJpbmcgdGhlIGNvbnZlcnNpb24uCiAgICoJCQkJCQkvLyBTZWUgYGVuZ2luZS52aWV3Lk1hdGNoZXJ+TWF0Y2hlclBhdHRlcm5gIGFuZCBgZW5naW5lLnZpZXcuTWF0Y2hlciNtYXRjaGAgZm9yIG1vcmUgZGV0YWlscy4KICAgKgogICAqCQkJCQkJcmV0dXJuIHsgbmFtZTogdHJ1ZSwgc3R5bGVzOiBbICdmb250LXNpemUnIF0gfTsKICAgKgkJCQkJfQogICAqCiAgICoJCQkJCXJldHVybiBudWxsOwogICAqCQkJCX0sCiAgICoJCQkJc21hbGw6IHZpZXdFbGVtZW50ID0+IHsKICAgKgkJCQkJY29uc3QgZm9udFNpemUgPSB2aWV3RWxlbWVudC5nZXRTdHlsZSggJ2ZvbnQtc2l6ZScgKTsKICAgKgogICAqCQkJCQlpZiAoICFmb250U2l6ZSApIHsKICAgKgkJCQkJCXJldHVybiBudWxsOwogICAqCQkJCQl9CiAgICoKICAgKgkJCQkJY29uc3QgbWF0Y2ggPSBmb250U2l6ZS5tYXRjaCggLyhcZCspXHMqcHgvICk7CiAgICoKICAgKgkJCQkJaWYgKCAhbWF0Y2ggKSB7CiAgICoJCQkJCQlyZXR1cm4gbnVsbDsKICAgKgkJCQkJfQogICAqCiAgICoJCQkJCWNvbnN0IHNpemUgPSBOdW1iZXIoIG1hdGNoWyAxIF0gKTsKICAgKgogICAqCQkJCQlpZiAoIHZpZXdFbGVtZW50LmlzKCAnc3BhbicgKSAmJiBzaXplIDwgMTAgKSB7CiAgICoJCQkJCQkvLyBSZXR1cm5lZCB2YWx1ZSBjYW4gYmUgYW4gb2JqZWN0IHdpdGggdGhlIG1hdGNoZWQgcHJvcGVydGllcy4KICAgKgkJCQkJCS8vIFRoZXNlIHByb3BlcnRpZXMgd2lsbCBiZSAiY29uc3VtZWQiIGR1cmluZyB0aGUgY29udmVyc2lvbi4KICAgKgkJCQkJCS8vIFNlZSBgZW5naW5lLnZpZXcuTWF0Y2hlcn5NYXRjaGVyUGF0dGVybmAgYW5kIGBlbmdpbmUudmlldy5NYXRjaGVyI21hdGNoYCBmb3IgbW9yZSBkZXRhaWxzLgogICAqCiAgICoJCQkJCQlyZXR1cm4geyBuYW1lOiB0cnVlLCBzdHlsZXM6IFsgJ2ZvbnQtc2l6ZScgXSB9OwogICAqCQkJCQl9CiAgICoKICAgKgkJCQkJcmV0dXJuIG51bGw7CiAgICoJCQkJfQogICAqCQkJfQogICAqCQl9ICk7CiAgICoKICAgKiBUaGUgYGRlZmluaXRpb24ubW9kZWxgIHBhcmFtZXRlciBzcGVjaWZpZXMgd2hpY2ggbW9kZWwgYXR0cmlidXRlIHNob3VsZCBiZSBjb252ZXJ0ZWQgZnJvbSBvciB0by4gSXQgY2FuIGJlIGEgYHsga2V5LCB2YWx1ZSB9YCBvYmplY3QKICAgKiBkZXNjcmliaW5nIHRoZSBhdHRyaWJ1dGUga2V5IGFuZCB2YWx1ZSB0byBjb252ZXJ0IG9yIGEgYFN0cmluZ2Agc3BlY2lmeWluZyBqdXN0IHRoZSBhdHRyaWJ1dGUga2V5ICh0aGVuIGB2YWx1ZWAgaXMgc2V0IHRvIGB0cnVlYCkuCiAgICogU2VlIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vY29udmVyc2lvbn5Db252ZXJ0ZXJEZWZpbml0aW9ufSB0byBsZWFybiBhYm91dCBvdGhlciBwYXJhbWV0ZXJzLgogICAqCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vY29udmVyc2lvbn5Db252ZXJ0ZXJEZWZpbml0aW9ufSBkZWZpbml0aW9uIFRoZSBjb252ZXJ0ZXIgZGVmaW5pdGlvbi4KICAgKi8KCgogIGF0dHJpYnV0ZVRvRWxlbWVudChkZWZpbml0aW9uKSB7CiAgICAvLyBTZXQgdXAgZG93bmNhc3QgY29udmVydGVyLgogICAgdGhpcy5mb3IoJ2Rvd25jYXN0JykuYXR0cmlidXRlVG9FbGVtZW50KGRlZmluaXRpb24pOyAvLyBTZXQgdXAgdXBjYXN0IGNvbnZlcnRlci4KCiAgICBmb3IgKGNvbnN0IHsKICAgICAgbW9kZWwsCiAgICAgIHZpZXcKICAgIH0gb2YgX2dldEFsbFVwY2FzdERlZmluaXRpb25zKGRlZmluaXRpb24pKSB7CiAgICAgIHRoaXMuZm9yKCd1cGNhc3QnKS5lbGVtZW50VG9BdHRyaWJ1dGUoewogICAgICAgIHZpZXcsCiAgICAgICAgbW9kZWwsCiAgICAgICAgY29udmVydGVyUHJpb3JpdHk6IGRlZmluaXRpb24uY29udmVydGVyUHJpb3JpdHkKICAgICAgfSk7CiAgICB9CiAgfQogIC8qKgogICAqIFNldHMgdXAgY29udmVydGVycyBiZXR3ZWVuIHRoZSBtb2RlbCBhbmQgdGhlIHZpZXcgdGhhdCBjb252ZXJ0IGEgbW9kZWwgYXR0cmlidXRlIHRvIGEgdmlldyBhdHRyaWJ1dGUgKGFuZCB2aWNlIHZlcnNhKS4KICAgKiBGb3IgZXhhbXBsZSwgYDxpbWFnZSBzcmM9J2Zvby5qcGcnPjwvaW1hZ2U+YCBpcyBjb252ZXJ0ZWQgdG8gYDxpbWcgc3JjPSdmb28uanBnJz48L2ltZz5gICh0aGUgc2FtZSBhdHRyaWJ1dGUga2V5IGFuZCB2YWx1ZSkuCiAgICogVGhpcyB0eXBlIG9mIGNvbnZlcnRlcnMgaXMgaW50ZW5kZWQgdG8gYmUgdXNlZCB3aXRoIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudCBtb2RlbCBlbGVtZW50fSBub2Rlcy4KICAgKiBUbyBjb252ZXJ0IHRleHQgYXR0cmlidXRlcyB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL2NvbnZlcnNpb25+Q29udmVyc2lvbiNhdHRyaWJ1dGVUb0VsZW1lbnQgYGF0dHJpYnV0ZVRvRWxlbWVudCBjb252ZXJ0ZXJgfQogICAqIHNob3VsZCBiZSBzZXQgdXAuCiAgICoKICAgKgkJLy8gQSBzaW1wbGUgY29udmVyc2lvbiBmcm9tIHRoZSBgc291cmNlYCBtb2RlbCBhdHRyaWJ1dGUgdG8gdGhlIGBzcmNgIHZpZXcgYXR0cmlidXRlIChhbmQgdmljZSB2ZXJzYSkuCiAgICoJCWVkaXRvci5jb252ZXJzaW9uLmF0dHJpYnV0ZVRvQXR0cmlidXRlKCB7IG1vZGVsOiAnc291cmNlJywgdmlldzogJ3NyYycgfSApOwogICAqCiAgICoJCS8vIEF0dHJpYnV0ZSB2YWx1ZXMgYXJlIHN0cmljdGx5IHNwZWNpZmllZC4KICAgKgkJZWRpdG9yLmNvbnZlcnNpb24uYXR0cmlidXRlVG9BdHRyaWJ1dGUoIHsKICAgKgkJCW1vZGVsOiB7CiAgICoJCQkJbmFtZTogJ2ltYWdlJywKICAgKgkJCQlrZXk6ICdhc2lkZScsCiAgICoJCQkJdmFsdWVzOiBbICdhc2lkZScgXQogICAqCQkJfSwKICAgKgkJCXZpZXc6IHsKICAgKgkJCQlhc2lkZTogewogICAqCQkJCQluYW1lOiAnaW1nJywKICAgKgkJCQkJa2V5OiAnY2xhc3MnLAogICAqCQkJCQl2YWx1ZTogWyAnYXNpZGUnLCAnaGFsZi1zaXplJyBdCiAgICoJCQkJfQogICAqCQkJfQogICAqCQl9ICk7CiAgICoKICAgKgkJLy8gU2V0IHRoZSBzdHlsZSBhdHRyaWJ1dGUuCiAgICoJCWVkaXRvci5jb252ZXJzaW9uLmF0dHJpYnV0ZVRvQXR0cmlidXRlKCB7CiAgICoJCQltb2RlbDogewogICAqCQkJCW5hbWU6ICdpbWFnZScsCiAgICoJCQkJa2V5OiAnYXNpZGUnLAogICAqCQkJCXZhbHVlczogWyAnYXNpZGUnIF0KICAgKgkJCX0sCiAgICoJCQl2aWV3OiB7CiAgICoJCQkJYXNpZGU6IHsKICAgKgkJCQkJbmFtZTogJ2ltZycsCiAgICoJCQkJCWtleTogJ3N0eWxlJywKICAgKgkJCQkJdmFsdWU6IHsKICAgKgkJCQkJCWZsb2F0OiAncmlnaHQnLAogICAqCQkJCQkJd2lkdGg6ICc1MCUnLAogICAqCQkJCQkJbWFyZ2luOiAnNXB4JwogICAqCQkJCQl9CiAgICoJCQkJfQogICAqCQkJfQogICAqCQl9ICk7CiAgICoKICAgKgkJLy8gQ29udmVyc2lvbiBmcm9tIGFuZCB0byBhIG1vZGVsIGF0dHJpYnV0ZSBrZXkgd2hvc2UgdmFsdWUgaXMgYW4gZW51bSAoYGFsaWduPXJpZ2h0fGNlbnRlcmApLgogICAqCQkvLyBVc2UgYHVwY2FzdEFsc29gIHRvIGRlZmluZSBvdGhlciB2aWV3IGVsZW1lbnRzIHRoYXQgc2hvdWxkIGFsc28gYmUgY29udmVydGVkIHRvIHRoZSBgYWxpZ249cmlnaHRgIGF0dHJpYnV0ZS4KICAgKgkJZWRpdG9yLmNvbnZlcnNpb24uYXR0cmlidXRlVG9BdHRyaWJ1dGUoIHsKICAgKgkJCW1vZGVsOiB7CiAgICoJCQkJa2V5OiAnYWxpZ24nLAogICAqCQkJCXZhbHVlczogWyAncmlnaHQnLCAnY2VudGVyJyBdCiAgICoJCQl9LAogICAqCQkJdmlldzogewogICAqCQkJCXJpZ2h0OiB7CiAgICoJCQkJCWtleTogJ2NsYXNzJywKICAgKgkJCQkJdmFsdWU6ICdhbGlnbi1yaWdodCcKICAgKgkJCQl9LAogICAqCQkJCWNlbnRlcjogewogICAqCQkJCQlrZXk6ICdjbGFzcycsCiAgICoJCQkJCXZhbHVlOiAnYWxpZ24tY2VudGVyJwogICAqCQkJCX0KICAgKgkJCX0sCiAgICoJCQl1cGNhc3RBbHNvOiB7CiAgICoJCQkJcmlnaHQ6IHsKICAgKgkJCQkJc3R5bGVzOiB7CiAgICoJCQkJCQkndGV4dC1hbGlnbic6ICdyaWdodCcKICAgKgkJCQkJfQogICAqCQkJCX0sCiAgICoJCQkJY2VudGVyOiB7CiAgICoJCQkJCXN0eWxlczogewogICAqCQkJCQkJJ3RleHQtYWxpZ24nOiAnY2VudGVyJwogICAqCQkJCQl9CiAgICoJCQkJfQogICAqCQkJfQogICAqCQl9ICk7CiAgICoKICAgKiBUaGUgYGRlZmluaXRpb24ubW9kZWxgIHBhcmFtZXRlciBzcGVjaWZpZXMgd2hpY2ggbW9kZWwgYXR0cmlidXRlIHNob3VsZCBiZSBjb252ZXJ0ZWQgZnJvbSBhbmQgdG8uCiAgICogSXQgY2FuIGJlIGEgYHsga2V5LCBbIHZhbHVlcyBdLCBbIG5hbWUgXSB9YCBvYmplY3Qgb3IgYSBgU3RyaW5nYCwgd2hpY2ggd2lsbCBiZSB0cmVhdGVkIGxpa2UgYHsga2V5OiBkZWZpbml0aW9uLm1vZGVsIH1gLgogICAqIFRoZSBga2V5YCBwcm9wZXJ0eSBpcyB0aGUgbW9kZWwgYXR0cmlidXRlIGtleSB0byBjb252ZXJ0IGZyb20gYW5kIHRvLgogICAqIFRoZSBgdmFsdWVzYCBhcmUgdGhlIHBvc3NpYmxlIG1vZGVsIGF0dHJpYnV0ZSB2YWx1ZXMuIElmIGB2YWx1ZXNgIGlzIG5vdCBzZXQsIHRoZSBtb2RlbCBhdHRyaWJ1dGUgdmFsdWUgd2lsbCBiZSB0aGUgc2FtZSBhcyB0aGUKICAgKiB2aWV3IGF0dHJpYnV0ZSB2YWx1ZS4KICAgKiBJZiBgbmFtZWAgaXMgc2V0LCB0aGUgY29udmVyc2lvbiB3aWxsIGJlIHNldCB1cCBvbmx5IGZvciBtb2RlbCBlbGVtZW50cyB3aXRoIHRoZSBnaXZlbiBuYW1lLgogICAqCiAgICogVGhlIGBkZWZpbml0aW9uLnZpZXdgIHBhcmFtZXRlciBzcGVjaWZpZXMgd2hpY2ggdmlldyBhdHRyaWJ1dGUgc2hvdWxkIGJlIGNvbnZlcnRlZCBmcm9tIGFuZCB0by4KICAgKiBJdCBjYW4gYmUgYSBgeyBrZXksIHZhbHVlLCBbIG5hbWUgXSB9YCBvYmplY3Qgb3IgYSBgU3RyaW5nYCwgd2hpY2ggd2lsbCBiZSB0cmVhdGVkIGxpa2UgYHsga2V5OiBkZWZpbml0aW9uLnZpZXcgfWAuCiAgICogVGhlIGBrZXlgIHByb3BlcnR5IGlzIHRoZSB2aWV3IGF0dHJpYnV0ZSBrZXkgdG8gY29udmVydCBmcm9tIGFuZCB0by4KICAgKiBUaGUgYHZhbHVlYCBpcyB0aGUgdmlldyBhdHRyaWJ1dGUgdmFsdWUgdG8gY29udmVydCBmcm9tIGFuZCB0by4gSWYgYGRlZmluaXRpb24udmFsdWVgIGlzIG5vdCBzZXQsIHRoZSB2aWV3IGF0dHJpYnV0ZSB2YWx1ZSB3aWxsIGJlCiAgICogdGhlIHNhbWUgYXMgdGhlIG1vZGVsIGF0dHJpYnV0ZSB2YWx1ZS4KICAgKiBJZiBga2V5YCBpcyBgJ2NsYXNzJ2AsIGB2YWx1ZWAgY2FuIGJlIGEgYFN0cmluZ2Agb3IgYW4gYXJyYXkgb2YgYFN0cmluZ2BzLgogICAqIElmIGBrZXlgIGlzIGAnc3R5bGUnYCwgYHZhbHVlYCBpcyBhbiBvYmplY3Qgd2l0aCBrZXktdmFsdWUgcGFpcnMuCiAgICogSW4gb3RoZXIgY2FzZXMsIGB2YWx1ZWAgaXMgYSBgU3RyaW5nYC4KICAgKiBJZiBgbmFtZWAgaXMgc2V0LCB0aGUgY29udmVyc2lvbiB3aWxsIGJlIHNldCB1cCBvbmx5IGZvciBtb2RlbCBlbGVtZW50cyB3aXRoIHRoZSBnaXZlbiBuYW1lLgogICAqIElmIGBkZWZpbml0aW9uLm1vZGVsLnZhbHVlc2AgaXMgc2V0LCBgZGVmaW5pdGlvbi52aWV3YCBpcyBhbiBvYmplY3QgdGhhdCBhc3NpZ25zIHZhbHVlcyBmcm9tIGBkZWZpbml0aW9uLm1vZGVsLnZhbHVlc2AKICAgKiB0byBgeyBrZXksIHZhbHVlLCBbIG5hbWUgXSB9YCBvYmplY3RzLgogICAqCiAgICogYGRlZmluaXRpb24udXBjYXN0QWxzb2Agc3BlY2lmaWVzIHdoaWNoIG90aGVyIG1hdGNoaW5nIHZpZXcgZWxlbWVudHMgc2hvdWxkIGFsc28gYmUgdXBjYXN0IHRvIHRoZSBnaXZlbiBtb2RlbCBjb25maWd1cmF0aW9uLgogICAqIElmIGBkZWZpbml0aW9uLm1vZGVsLnZhbHVlc2AgaXMgc2V0LCBgZGVmaW5pdGlvbi51cGNhc3RBbHNvYCBzaG91bGQgYmUgYW4gb2JqZWN0IGFzc2lnbmluZyB2YWx1ZXMgZnJvbSBgZGVmaW5pdGlvbi5tb2RlbC52YWx1ZXNgCiAgICogdG8ge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9tYXRjaGVyfk1hdGNoZXJQYXR0ZXJufXMgb3IgYXJyYXlzIG9mIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvbWF0Y2hlcn5NYXRjaGVyUGF0dGVybn1zLgogICAqCiAgICogKipOb3RlOioqIGBkZWZpbml0aW9uLm1vZGVsYCBhbmQgYGRlZmluaXRpb24udmlld2AgZm9ybSBzaG91bGQgYmUgbWlycm9yZWQsIHNvIHRoZSBzYW1lIHR5cGVzIG9mIHBhcmFtZXRlcnMgc2hvdWxkCiAgICogYmUgZ2l2ZW4gaW4gYm90aCBwYXJhbWV0ZXJzLgogICAqCiAgICogQHBhcmFtIHtPYmplY3R9IGRlZmluaXRpb24gVGhlIGNvbnZlcnRlciBkZWZpbml0aW9uLgogICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gZGVmaW5pdGlvbi5tb2RlbCBUaGUgbW9kZWwgYXR0cmlidXRlIHRvIGNvbnZlcnQgZnJvbSBhbmQgdG8uCiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBkZWZpbml0aW9uLnZpZXcgVGhlIHZpZXcgYXR0cmlidXRlIHRvIGNvbnZlcnQgZnJvbSBhbmQgdG8uCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvbWF0Y2hlcn5NYXRjaGVyUGF0dGVybnxBcnJheS48bW9kdWxlOmVuZ2luZS92aWV3L21hdGNoZXJ+TWF0Y2hlclBhdHRlcm4+fSBbZGVmaW5pdGlvbi51cGNhc3RBbHNvXQogICAqIEFueSB2aWV3IGVsZW1lbnQgbWF0Y2hpbmcgYGRlZmluaXRpb24udXBjYXN0QWxzb2Agd2lsbCBhbHNvIGJlIGNvbnZlcnRlZCB0byB0aGUgZ2l2ZW4gbW9kZWwgYXR0cmlidXRlLiBgZGVmaW5pdGlvbi51cGNhc3RBbHNvYAogICAqIGlzIHVzZWQgb25seSBpZiBgY29uZmlnLm1vZGVsLnZhbHVlc2AgaXMgc3BlY2lmaWVkLgogICAqLwoKCiAgYXR0cmlidXRlVG9BdHRyaWJ1dGUoZGVmaW5pdGlvbikgewogICAgLy8gU2V0IHVwIGRvd25jYXN0IGNvbnZlcnRlci4KICAgIHRoaXMuZm9yKCdkb3duY2FzdCcpLmF0dHJpYnV0ZVRvQXR0cmlidXRlKGRlZmluaXRpb24pOyAvLyBTZXQgdXAgdXBjYXN0IGNvbnZlcnRlci4KCiAgICBmb3IgKGNvbnN0IHsKICAgICAgbW9kZWwsCiAgICAgIHZpZXcKICAgIH0gb2YgX2dldEFsbFVwY2FzdERlZmluaXRpb25zKGRlZmluaXRpb24pKSB7CiAgICAgIHRoaXMuZm9yKCd1cGNhc3QnKS5hdHRyaWJ1dGVUb0F0dHJpYnV0ZSh7CiAgICAgICAgdmlldywKICAgICAgICBtb2RlbAogICAgICB9KTsKICAgIH0KICB9CiAgLyoqCiAgICogQ3JlYXRlcyBhbmQgY2FjaGVzIGNvbnZlcnNpb24gaGVscGVycyBmb3IgZ2l2ZW4gZGlzcGF0Y2hlcnMgZ3JvdXAuCiAgICoKICAgKiBAcHJpdmF0ZQogICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zCiAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMubmFtZSBHcm91cCBuYW1lLgogICAqIEBwYXJhbSB7QXJyYXkuPG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi9kb3duY2FzdGRpc3BhdGNoZXJ+RG93bmNhc3REaXNwYXRjaGVyfAogICAqIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi91cGNhc3RkaXNwYXRjaGVyflVwY2FzdERpc3BhdGNoZXI+fSBvcHRpb25zLmRpc3BhdGNoZXJzCiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLmlzRG93bmNhc3QKICAgKi8KCgogIF9jcmVhdGVDb252ZXJzaW9uSGVscGVycyh7CiAgICBuYW1lLAogICAgZGlzcGF0Y2hlcnMsCiAgICBpc0Rvd25jYXN0CiAgfSkgewogICAgaWYgKHRoaXMuX2hlbHBlcnMuaGFzKG5hbWUpKSB7CiAgICAgIC8qKgogICAgICAgKiBUcnlpbmcgdG8gcmVnaXN0ZXIgYSBncm91cCBuYW1lIHRoYXQgaGFzIGFscmVhZHkgYmVlbiByZWdpc3RlcmVkLgogICAgICAgKgogICAgICAgKiBAZXJyb3IgY29udmVyc2lvbi1ncm91cC1leGlzdHMKICAgICAgICovCiAgICAgIHRocm93IG5ldyBDS0VkaXRvckVycm9yKCdjb252ZXJzaW9uLWdyb3VwLWV4aXN0czogVHJ5aW5nIHRvIHJlZ2lzdGVyIGEgZ3JvdXAgbmFtZSB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gcmVnaXN0ZXJlZC4nLCB0aGlzKTsKICAgIH0KCiAgICBjb25zdCBoZWxwZXJzID0gaXNEb3duY2FzdCA/IG5ldyBEb3duY2FzdEhlbHBlcnMoZGlzcGF0Y2hlcnMpIDogbmV3IFVwY2FzdEhlbHBlcnMoZGlzcGF0Y2hlcnMpOwoKICAgIHRoaXMuX2hlbHBlcnMuc2V0KG5hbWUsIGhlbHBlcnMpOwogIH0KCn0KLyoqCiAqIERlZmluZXMgaG93IHRoZSBtb2RlbCBzaG91bGQgYmUgY29udmVydGVkIGZyb20gYW5kIHRvIHRoZSB2aWV3LgogKgogKiBAdHlwZWRlZiB7T2JqZWN0fSBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vY29udmVyc2lvbn5Db252ZXJ0ZXJEZWZpbml0aW9uCiAqCiAqIEBwcm9wZXJ0eSB7Kn0gW21vZGVsXSBUaGUgbW9kZWwgY29udmVyc2lvbiBkZWZpbml0aW9uLiBEZXNjcmliZXMgdGhlIG1vZGVsIGVsZW1lbnQgb3IgbW9kZWwgYXR0cmlidXRlIHRvIGNvbnZlcnQuIFRoaXMgcGFyYW1ldGVyIGRpZmZlcnMKICogZm9yIGRpZmZlcmVudCBmdW5jdGlvbnMgdGhhdCBhY2NlcHQgYENvbnZlcnRlckRlZmluaXRpb25gLiBTZWUgdGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBmdW5jdGlvbiB0byBsZWFybiBob3cgdG8gc2V0IGl0LgogKiBAcHJvcGVydHkge21vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50ZGVmaW5pdGlvbn5FbGVtZW50RGVmaW5pdGlvbnxPYmplY3R9IHZpZXcgVGhlIGRlZmluaXRpb24gb2YgdGhlIHZpZXcgZWxlbWVudCB0byBjb252ZXJ0IGZyb20gYW5kCiAqIHRvLiBJZiBgbW9kZWxgIGRlc2NyaWJlcyBtdWx0aXBsZSB2YWx1ZXMsIGB2aWV3YCBpcyBhbiBvYmplY3QgdGhhdCBhc3NpZ25zIHRoZXNlIHZhbHVlcyAoYHZpZXdgIG9iamVjdCBrZXlzKSB0byB2aWV3IGVsZW1lbnQgZGVmaW5pdGlvbnMKICogKGB2aWV3YCBvYmplY3QgdmFsdWVzKS4KICogQHByb3BlcnR5IHttb2R1bGU6ZW5naW5lL3ZpZXcvbWF0Y2hlcn5NYXRjaGVyUGF0dGVybnxBcnJheS48bW9kdWxlOmVuZ2luZS92aWV3L21hdGNoZXJ+TWF0Y2hlclBhdHRlcm4+fSBbdXBjYXN0QWxzb10KICogQW55IHZpZXcgZWxlbWVudCBtYXRjaGluZyBgdXBjYXN0QWxzb2Agd2lsbCBhbHNvIGJlIGNvbnZlcnRlZCB0byB0aGUgbW9kZWwuIElmIGBtb2RlbGAgZGVzY3JpYmVzIG11bHRpcGxlIHZhbHVlcywgYHVwY2FzdEFsc29gCiAqIGlzIGFuIG9iamVjdCB0aGF0IGFzc2lnbnMgdGhlc2UgdmFsdWVzIChgdXBjYXN0QWxzb2Agb2JqZWN0IGtleXMpIHRvIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvbWF0Y2hlcn5NYXRjaGVyUGF0dGVybn1zCiAqIChgdXBjYXN0QWxzb2Agb2JqZWN0IHZhbHVlcykuCiAqIEBwcm9wZXJ0eSB7bW9kdWxlOnV0aWxzL3ByaW9yaXRpZXN+UHJpb3JpdHlTdHJpbmd9IFtjb252ZXJ0ZXJQcmlvcml0eV0gVGhlIGNvbnZlcnRlciBwcmlvcml0eS4KICovCi8vIEhlbHBlciBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYSBqb2ludCBhcnJheSBvdXQgb2YgYW4gaXRlbSBwYXNzZWQgaW4gYGRlZmluaXRpb24udmlld2AgYW5kIGl0ZW1zIHBhc3NlZCBpbgovLyBgZGVmaW5pdGlvbi51cGNhc3RBbHNvYC4KLy8KLy8gQHBhcmFtIHttb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vY29udmVyc2lvbn5Db252ZXJ0ZXJEZWZpbml0aW9ufSBkZWZpbml0aW9uCi8vIEByZXR1cm5zIHtBcnJheX0gQXJyYXkgY29udGFpbmluZyB2aWV3IGRlZmluaXRpb25zLgoKZnVuY3Rpb24qIF9nZXRBbGxVcGNhc3REZWZpbml0aW9ucyhkZWZpbml0aW9uKSB7CiAgaWYgKGRlZmluaXRpb24ubW9kZWwudmFsdWVzKSB7CiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIGRlZmluaXRpb24ubW9kZWwudmFsdWVzKSB7CiAgICAgIGNvbnN0IG1vZGVsID0gewogICAgICAgIGtleTogZGVmaW5pdGlvbi5tb2RlbC5rZXksCiAgICAgICAgdmFsdWUKICAgICAgfTsKICAgICAgY29uc3QgdmlldyA9IGRlZmluaXRpb24udmlld1t2YWx1ZV07CiAgICAgIGNvbnN0IHVwY2FzdEFsc28gPSBkZWZpbml0aW9uLnVwY2FzdEFsc28gPyBkZWZpbml0aW9uLnVwY2FzdEFsc29bdmFsdWVdIDogdW5kZWZpbmVkOwogICAgICB5aWVsZCogX2dldFVwY2FzdERlZmluaXRpb24obW9kZWwsIHZpZXcsIHVwY2FzdEFsc28pOwogICAgfQogIH0gZWxzZSB7CiAgICB5aWVsZCogX2dldFVwY2FzdERlZmluaXRpb24oZGVmaW5pdGlvbi5tb2RlbCwgZGVmaW5pdGlvbi52aWV3LCBkZWZpbml0aW9uLnVwY2FzdEFsc28pOwogIH0KfQoKZnVuY3Rpb24qIF9nZXRVcGNhc3REZWZpbml0aW9uKG1vZGVsLCB2aWV3LCB1cGNhc3RBbHNvKSB7CiAgeWllbGQgewogICAgbW9kZWwsCiAgICB2aWV3CiAgfTsKCiAgaWYgKHVwY2FzdEFsc28pIHsKICAgIHVwY2FzdEFsc28gPSBBcnJheS5pc0FycmF5KHVwY2FzdEFsc28pID8gdXBjYXN0QWxzbyA6IFt1cGNhc3RBbHNvXTsKCiAgICBmb3IgKGNvbnN0IHVwY2FzdEFsc29JdGVtIG9mIHVwY2FzdEFsc28pIHsKICAgICAgeWllbGQgewogICAgICAgIG1vZGVsLAogICAgICAgIHZpZXc6IHVwY2FzdEFsc29JdGVtCiAgICAgIH07CiAgICB9CiAgfQp9"},{"version":3,"sources":["/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-engine/src/conversion/conversion.js"],"names":["CKEditorError","UpcastHelpers","DowncastHelpers","Conversion","constructor","downcastDispatchers","upcastDispatchers","_helpers","Map","_downcast","Array","isArray","_createConversionHelpers","name","dispatchers","isDowncast","_upcast","addAlias","alias","dispatcher","includes","isUpcast","for","groupName","has","get","elementToElement","definition","model","view","_getAllUpcastDefinitions","converterPriority","attributeToElement","elementToAttribute","attributeToAttribute","helpers","set","values","value","key","upcastAlso","undefined","_getUpcastDefinition","upcastAlsoItem"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/conversion/conversion\n */\n\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport UpcastHelpers from './upcasthelpers';\nimport DowncastHelpers from './downcasthelpers';\n\n/**\n * A utility class that helps add converters to upcast and downcast dispatchers.\n *\n * We recommend reading the {@glink framework/guides/architecture/editing-engine Editing engine architecture} guide first to\n * understand the core concepts of the conversion mechanisms.\n *\n * An instance of the conversion manager is available in the\n * {@link module:core/editor/editor~Editor#conversion `editor.conversion`} property\n * and by default has the following groups of dispatchers (i.e. directions of conversion):\n *\n * * `downcast` (editing and data downcasts)\n * * `editingDowncast`\n * * `dataDowncast`\n * * `upcast`\n *\n * # One-way converters\n *\n * To add a converter to a specific group, use the {@link module:engine/conversion/conversion~Conversion#for `for()`}\n * method:\n *\n *\t\t// Add a converter to editing downcast and data downcast.\n *\t\teditor.conversion.for( 'downcast' ).elementToElement( config ) );\n *\n *\t\t// Add a converter to the data pipepline only:\n *\t\teditor.conversion.for( 'dataDowncast' ).elementToElement( dataConversionConfig ) );\n *\n *\t\t// And a slightly different one for the editing pipeline:\n *\t\teditor.conversion.for( 'editingDowncast' ).elementToElement( editingConversionConfig ) );\n *\n * See {@link module:engine/conversion/conversion~Conversion#for `for()`} method documentation to learn more about\n * available conversion helpers and how to use your custom ones.\n *\n * # Two-way converters\n *\n * Besides using one-way converters via the `for()` method, you can also use other methods available in this\n * class to add two-way converters (upcast and downcast):\n *\n * * {@link module:engine/conversion/conversion~Conversion#elementToElement `elementToElement()`} &ndash;\n * Model element to view element and vice versa.\n * * {@link module:engine/conversion/conversion~Conversion#attributeToElement `attributeToElement()`} &ndash;\n * Model attribute to view element and vice versa.\n * * {@link module:engine/conversion/conversion~Conversion#attributeToAttribute `attributeToAttribute()`} &ndash;\n * Model attribute to view element and vice versa.\n */\nexport default class Conversion {\n\t/**\n\t * Creates a new conversion instance.\n\t *\n\t * @param {module:engine/conversion/downcastdispatcher~DowncastDispatcher|\n\t * Array.<module:engine/conversion/downcastdispatcher~DowncastDispatcher>} downcastDispatchers\n\t * @param {module:engine/conversion/upcastdispatcher~UpcastDispatcher|\n\t * Array.<module:engine/conversion/upcastdispatcher~UpcastDispatcher>} upcastDispatchers\n\t */\n\tconstructor( downcastDispatchers, upcastDispatchers ) {\n\t\t/**\n\t\t * Maps dispatchers group name to ConversionHelpers instances.\n\t\t *\n\t\t * @private\n\t\t * @member {Map.<String,module:engine/conversion/conversionhelpers~ConversionHelpers>}\n\t\t */\n\t\tthis._helpers = new Map();\n\n\t\t// Define default 'downcast' & 'upcast' dispatchers groups. Those groups are always available as two-way converters needs them.\n\t\tthis._downcast = Array.isArray( downcastDispatchers ) ? downcastDispatchers : [ downcastDispatchers ];\n\t\tthis._createConversionHelpers( { name: 'downcast', dispatchers: this._downcast, isDowncast: true } );\n\n\t\tthis._upcast = Array.isArray( upcastDispatchers ) ? upcastDispatchers : [ upcastDispatchers ];\n\t\tthis._createConversionHelpers( { name: 'upcast', dispatchers: this._upcast, isDowncast: false } );\n\t}\n\n\t/**\n\t * Define an alias for registered dispatcher.\n\t *\n\t *\t\tconst conversion = new Conversion(\n\t *\t\t\t[ dataDowncastDispatcher, editingDowncastDispatcher ],\n\t *\t\t\tupcastDispatcher\n\t *\t\t);\n\t *\n\t *\t\tconversion.addAlias( 'dataDowncast', dataDowncastDispatcher );\n\t *\n\t * @param {String} alias An alias of a dispatcher.\n\t * @param {module:engine/conversion/downcastdispatcher~DowncastDispatcher|\n\t * module:engine/conversion/upcastdispatcher~UpcastDispatcher} dispatcher Dispatcher which should have an alias.\n\t */\n\taddAlias( alias, dispatcher ) {\n\t\tconst isDowncast = this._downcast.includes( dispatcher );\n\t\tconst isUpcast = this._upcast.includes( dispatcher );\n\n\t\tif ( !isUpcast && !isDowncast ) {\n\t\t\t/**\n\t\t\t * Trying to register and alias for a dispatcher that nas not been registered.\n\t\t\t *\n\t\t\t * @error conversion-add-alias-dispatcher-not-registered\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'conversion-add-alias-dispatcher-not-registered: ' +\n\t\t\t\t'Trying to register and alias for a dispatcher that nas not been registered.',\n\t\t\t\tthis\n\t\t\t);\n\t\t}\n\n\t\tthis._createConversionHelpers( { name: alias, dispatchers: [ dispatcher ], isDowncast } );\n\t}\n\n\t/**\n\t * Provides a chainable API to assign converters to conversion dispatchers group.\n\t *\n\t * If the given group name has not been registered, the\n\t * {@link module:utils/ckeditorerror~CKEditorError `conversion-for-unknown-group` error} is thrown.\n\t *\n\t * You can use conversion helpers available directly in the `for()` chain or your custom ones via\n\t * the {@link module:engine/conversion/conversionhelpers~ConversionHelpers#add `add()`} method.\n\t *\n\t * # Using bulit-in conversion helpers\n\t *\n\t * The `for()` chain comes with a set of conversion helpers which you can use like this:\n\t *\n\t *\t\teditor.conversion.for( 'downcast' )\n\t *\t\t\t.elementToElement( config1 )        // Adds an element-to-element downcast converter.\n\t *\t\t\t.attributeToElement( config2 );     // Adds an attribute-to-element downcast converter.\n\t *\n\t *\t\teditor.conversion.for( 'upcast' )\n\t *\t\t\t.elementToAttribute( config3 );     // Adds an element-to-attribute upcast converter.\n\t *\n\t * Refer to the documentation of built-in conversion helpers to learn about their configuration options.\n\t *\n\t * * downcast (model-to-view) conversion helpers:\n\t *\n\t *\t* {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToElement `elementToElement()`},\n\t *\t* {@link module:engine/conversion/downcasthelpers~DowncastHelpers#attributeToElement `attributeToElement()`},\n\t *\t* {@link module:engine/conversion/downcasthelpers~DowncastHelpers#attributeToAttribute `attributeToAttribute()`}.\n\t *\t* {@link module:engine/conversion/downcasthelpers~DowncastHelpers#markerToElement `markerToElement()`}.\n\t *\t* {@link module:engine/conversion/downcasthelpers~DowncastHelpers#markerToHighlight `markerToHighlight()`}.\n\t *\n\t * * upcast (view-to-model) conversion helpers:\n\t *\n\t *\t* {@link module:engine/conversion/upcasthelpers~UpcastHelpers#elementToElement `elementToElement()`},\n\t *\t* {@link module:engine/conversion/upcasthelpers~UpcastHelpers#elementToAttribute `elementToAttribute()`},\n\t *\t* {@link module:engine/conversion/upcasthelpers~UpcastHelpers#attributeToAttribute `attributeToAttribute()`}.\n\t *\t* {@link module:engine/conversion/upcasthelpers~UpcastHelpers#elementToMarker `elementToMarker()`}.\n\t *\n\t * # Using custom conversion helpers\n\t *\n\t * If you need to implement a nontypical converter, you can do so by calling:\n\t *\n\t *\t\teditor.conversion.for( direction ).add( customHelper );\n\t *\n\t * The `.add()` method takes exactly one parameter, which is a function. This function should accept one parameter that\n\t * is a dispatcher instance. The function should add an actual converter to the passed dispatcher instance.\n\t *\n\t * Example:\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).add( dispatcher => {\n\t *\t\t\tdispatcher.on( 'element:a',  ( evt, data, conversionApi ) => {\n\t *\t\t\t\t// Do something with a view <a> element.\n\t *\t\t\t} );\n\t *\t\t} );\n\t *\n\t * Refer to the documentation of {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher}\n\t * and {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher} to learn how to write\n\t * custom converters.\n\t *\n\t * @param {String} groupName The name of dispatchers group to add the converters to.\n\t * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers|module:engine/conversion/upcasthelpers~UpcastHelpers}\n\t */\n\tfor( groupName ) {\n\t\tif ( !this._helpers.has( groupName ) ) {\n\t\t\t/**\n\t\t\t * Trying to add a converter to an unknown dispatchers group.\n\t\t\t *\n\t\t\t * @error conversion-for-unknown-group\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'conversion-for-unknown-group: Trying to add a converter to an unknown dispatchers group.', this );\n\t\t}\n\n\t\treturn this._helpers.get( groupName );\n\t}\n\n\t/**\n\t * Sets up converters between the model and the view that convert a model element to a view element (and vice versa).\n\t * For example, the model `<paragraph>Foo</paragraph>` is `<p>Foo</p>` in the view.\n\t *\n\t *\t\t// A simple conversion from the `paragraph` model element to the `<p>` view element (and vice versa).\n\t *\t\teditor.conversion.elementToElement( { model: 'paragraph', view: 'p' } );\n\t *\n\t *\t\t// Override other converters by specifying a converter definition with a higher priority.\n\t *\t\teditor.conversion.elementToElement( { model: 'paragraph', view: 'div', converterPriority: 'high' } );\n\t *\n\t *\t\t// View specified as an object instead of a string.\n\t *\t\teditor.conversion.elementToElement( {\n\t *\t\t\tmodel: 'fancyParagraph',\n\t *\t\t\tview: {\n\t *\t\t\t\tname: 'p',\n\t *\t\t\t\tclasses: 'fancy'\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t *\t\t// Use `upcastAlso` to define other view elements that should also be converted to a `paragraph` element.\n\t *\t\teditor.conversion.elementToElement( {\n\t *\t\t\tmodel: 'paragraph',\n\t *\t\t\tview: 'p',\n\t *\t\t\tupcastAlso: [\n\t *\t\t\t\t'div',\n\t *\t\t\t\t{\n\t *\t\t\t\t\t// Any element with the `display: block` style.\n\t *\t\t\t\t\tstyles: {\n\t *\t\t\t\t\t\tdisplay: 'block'\n\t *\t\t\t\t\t}\n\t *\t\t\t\t}\n\t *\t\t\t]\n\t *\t\t} );\n\t *\n\t *\t\t// `upcastAlso` set as callback enables a conversion of a wide range of different view elements.\n\t *\t\teditor.conversion.elementToElement( {\n\t *\t\t\tmodel: 'heading',\n\t *\t\t\tview: 'h2',\n\t *\t\t\t// Convert \"headling-like\" paragraphs to headings.\n\t *\t\t\tupcastAlso: viewElement => {\n\t *\t\t\t\tconst fontSize = viewElement.getStyle( 'font-size' );\n\t *\n\t *\t\t\t\tif ( !fontSize ) {\n\t *\t\t\t\t\treturn null;\n\t *\t\t\t\t}\n\t *\n\t *\t\t\t\tconst match = fontSize.match( /(\\d+)\\s*px/ );\n\t *\n\t *\t\t\t\tif ( !match ) {\n\t *\t\t\t\t\treturn null;\n\t *\t\t\t\t}\n\t *\n\t *\t\t\t\tconst size = Number( match[ 1 ] );\n\t *\n\t *\t\t\t\tif ( size > 26 ) {\n\t *\t\t\t\t\t// Returned value can be an object with the matched properties.\n\t *\t\t\t\t\t// These properties will be \"consumed\" during the conversion.\n\t *\t\t\t\t\t// See `engine.view.Matcher~MatcherPattern` and `engine.view.Matcher#match` for more details.\n\t *\n\t *\t\t\t\t\treturn { name: true, styles: [ 'font-size' ] };\n\t *\t\t\t\t}\n\t *\n\t *\t\t\t\treturn null;\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * `definition.model` is a `String` with a model element name to convert from or to.\n\t * See {@link module:engine/conversion/conversion~ConverterDefinition} to learn about other parameters.\n\t *\n\t * @param {module:engine/conversion/conversion~ConverterDefinition} definition The converter definition.\n\t */\n\telementToElement( definition ) {\n\t\t// Set up downcast converter.\n\t\tthis.for( 'downcast' ).elementToElement( definition );\n\n\t\t// Set up upcast converter.\n\t\tfor ( const { model, view } of _getAllUpcastDefinitions( definition ) ) {\n\t\t\tthis.for( 'upcast' )\n\t\t\t\t.elementToElement( {\n\t\t\t\t\tmodel,\n\t\t\t\t\tview,\n\t\t\t\t\tconverterPriority: definition.converterPriority\n\t\t\t\t} );\n\t\t}\n\t}\n\n\t/**\n\t * Sets up converters between the model and the view that convert a model attribute to a view element (and vice versa).\n\t * For example, a model text node with `\"Foo\"` as data and the `bold` attribute is `<strong>Foo</strong>` in the view.\n\t *\n\t *\t\t// A simple conversion from the `bold=true` attribute to the `<strong>` view element (and vice versa).\n\t *\t\teditor.conversion.attributeToElement( { model: 'bold', view: 'strong' } );\n\t *\n\t *\t\t// Override other converters by specifying a converter definition with a higher priority.\n\t *\t\teditor.conversion.attributeToElement( { model: 'bold', view: 'b', converterPriority: 'high' } );\n\t *\n\t *\t\t// View specified as an object instead of a string.\n\t *\t\teditor.conversion.attributeToElement( {\n\t *\t\t\tmodel: 'bold',\n\t *\t\t\tview: {\n\t *\t\t\t\tname: 'span',\n\t *\t\t\t\tclasses: 'bold'\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t *\t\t// Use `config.model.name` to define the conversion only from a given node type, `$text` in this case.\n\t *\t\t// The same attribute on different elements may then be handled by a different converter.\n\t *\t\teditor.conversion.attributeToElement( {\n\t *\t\t\tmodel: {\n\t *\t\t\t\tkey: 'textDecoration',\n\t *\t\t\t\tvalues: [ 'underline', 'lineThrough' ],\n\t *\t\t\t\tname: '$text'\n\t *\t\t\t},\n\t *\t\t\tview: {\n\t *\t\t\t\tunderline: {\n\t *\t\t\t\t\tname: 'span',\n\t *\t\t\t\t\tstyles: {\n\t *\t\t\t\t\t\t'text-decoration': 'underline'\n\t *\t\t\t\t\t}\n\t *\t\t\t\t},\n\t *\t\t\t\tlineThrough: {\n\t *\t\t\t\t\tname: 'span',\n\t *\t\t\t\t\tstyles: {\n\t *\t\t\t\t\t\t'text-decoration': 'line-through'\n\t *\t\t\t\t\t}\n\t *\t\t\t\t}\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t *\t\t// Use `upcastAlso` to define other view elements that should also be converted to the `bold` attribute.\n\t *\t\teditor.conversion.attributeToElement( {\n\t *\t\t\tmodel: 'bold',\n\t *\t\t\tview: 'strong',\n\t *\t\t\tupcastAlso: [\n\t *\t\t\t\t'b',\n\t *\t\t\t\t{\n\t *\t\t\t\t\tname: 'span',\n\t *\t\t\t\t\tclasses: 'bold'\n\t *\t\t\t\t},\n\t *\t\t\t\t{\n\t *\t\t\t\t\tname: 'span',\n\t *\t\t\t\t\tstyles: {\n\t *\t\t\t\t\t\t'font-weight': 'bold'\n\t *\t\t\t\t\t}\n\t *\t\t\t\t},\n\t *\t\t\t\tviewElement => {\n\t *\t\t\t\t\tconst fontWeight = viewElement.getStyle( 'font-weight' );\n\t *\n\t *\t\t\t\t\tif ( viewElement.is( 'span' ) && fontWeight && /\\d+/.test() && Number( fontWeight ) > 500 ) {\n\t *\t\t\t\t\t\t// Returned value can be an object with the matched properties.\n\t *\t\t\t\t\t\t// These properties will be \"consumed\" during the conversion.\n\t *\t\t\t\t\t\t// See `engine.view.Matcher~MatcherPattern` and `engine.view.Matcher#match` for more details.\n\t *\n\t *\t\t\t\t\t\treturn {\n\t *\t\t\t\t\t\t\tname: true,\n\t *\t\t\t\t\t\t\tstyles: [ 'font-weight' ]\n\t *\t\t\t\t\t\t};\n\t *\t\t\t\t\t}\n\t *\t\t\t\t}\n\t *\t\t\t]\n\t *\t\t} );\n\t *\n\t *\t\t// Conversion from and to a model attribute key whose value is an enum (`fontSize=big|small`).\n\t *\t\t// `upcastAlso` set as callback enables a conversion of a wide range of different view elements.\n\t *\t\teditor.conversion.attributeToElement( {\n\t *\t\t\tmodel: {\n\t *\t\t\t\tkey: 'fontSize',\n\t *\t\t\t\tvalues: [ 'big', 'small' ]\n\t *\t\t\t},\n\t *\t\t\tview: {\n\t *\t\t\t\tbig: {\n\t *\t\t\t\t\tname: 'span',\n\t *\t\t\t\t\tstyles: {\n\t *\t\t\t\t\t\t'font-size': '1.2em'\n\t *\t\t\t\t\t}\n\t *\t\t\t\t},\n\t *\t\t\t\tsmall: {\n\t *\t\t\t\t\tname: 'span',\n\t *\t\t\t\t\tstyles: {\n\t *\t\t\t\t\t\t'font-size': '0.8em'\n\t *\t\t\t\t\t}\n\t *\t\t\t\t}\n\t *\t\t\t},\n\t *\t\t\tupcastAlso: {\n\t *\t\t\t\tbig: viewElement => {\n\t *\t\t\t\t\tconst fontSize = viewElement.getStyle( 'font-size' );\n\t *\n\t *\t\t\t\t\tif ( !fontSize ) {\n\t *\t\t\t\t\t\treturn null;\n\t *\t\t\t\t\t}\n\t *\n\t *\t\t\t\t\tconst match = fontSize.match( /(\\d+)\\s*px/ );\n\t *\n\t *\t\t\t\t\tif ( !match ) {\n\t *\t\t\t\t\t\treturn null;\n\t *\t\t\t\t\t}\n\t *\n\t *\t\t\t\t\tconst size = Number( match[ 1 ] );\n\t *\n\t *\t\t\t\t\tif ( viewElement.is( 'span' ) && size > 10 ) {\n\t *\t\t\t\t\t\t// Returned value can be an object with the matched properties.\n\t *\t\t\t\t\t\t// These properties will be \"consumed\" during the conversion.\n\t *\t\t\t\t\t\t// See `engine.view.Matcher~MatcherPattern` and `engine.view.Matcher#match` for more details.\n\t *\n\t *\t\t\t\t\t\treturn { name: true, styles: [ 'font-size' ] };\n\t *\t\t\t\t\t}\n\t *\n\t *\t\t\t\t\treturn null;\n\t *\t\t\t\t},\n\t *\t\t\t\tsmall: viewElement => {\n\t *\t\t\t\t\tconst fontSize = viewElement.getStyle( 'font-size' );\n\t *\n\t *\t\t\t\t\tif ( !fontSize ) {\n\t *\t\t\t\t\t\treturn null;\n\t *\t\t\t\t\t}\n\t *\n\t *\t\t\t\t\tconst match = fontSize.match( /(\\d+)\\s*px/ );\n\t *\n\t *\t\t\t\t\tif ( !match ) {\n\t *\t\t\t\t\t\treturn null;\n\t *\t\t\t\t\t}\n\t *\n\t *\t\t\t\t\tconst size = Number( match[ 1 ] );\n\t *\n\t *\t\t\t\t\tif ( viewElement.is( 'span' ) && size < 10 ) {\n\t *\t\t\t\t\t\t// Returned value can be an object with the matched properties.\n\t *\t\t\t\t\t\t// These properties will be \"consumed\" during the conversion.\n\t *\t\t\t\t\t\t// See `engine.view.Matcher~MatcherPattern` and `engine.view.Matcher#match` for more details.\n\t *\n\t *\t\t\t\t\t\treturn { name: true, styles: [ 'font-size' ] };\n\t *\t\t\t\t\t}\n\t *\n\t *\t\t\t\t\treturn null;\n\t *\t\t\t\t}\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * The `definition.model` parameter specifies which model attribute should be converted from or to. It can be a `{ key, value }` object\n\t * describing the attribute key and value to convert or a `String` specifying just the attribute key (then `value` is set to `true`).\n\t * See {@link module:engine/conversion/conversion~ConverterDefinition} to learn about other parameters.\n\t *\n\t * @param {module:engine/conversion/conversion~ConverterDefinition} definition The converter definition.\n\t */\n\tattributeToElement( definition ) {\n\t\t// Set up downcast converter.\n\t\tthis.for( 'downcast' ).attributeToElement( definition );\n\n\t\t// Set up upcast converter.\n\t\tfor ( const { model, view } of _getAllUpcastDefinitions( definition ) ) {\n\t\t\tthis.for( 'upcast' )\n\t\t\t\t.elementToAttribute( {\n\t\t\t\t\tview,\n\t\t\t\t\tmodel,\n\t\t\t\t\tconverterPriority: definition.converterPriority\n\t\t\t\t} );\n\t\t}\n\t}\n\n\t/**\n\t * Sets up converters between the model and the view that convert a model attribute to a view attribute (and vice versa).\n\t * For example, `<image src='foo.jpg'></image>` is converted to `<img src='foo.jpg'></img>` (the same attribute key and value).\n\t * This type of converters is intended to be used with {@link module:engine/model/element~Element model element} nodes.\n\t * To convert text attributes {@link module:engine/conversion/conversion~Conversion#attributeToElement `attributeToElement converter`}\n\t * should be set up.\n\t *\n\t *\t\t// A simple conversion from the `source` model attribute to the `src` view attribute (and vice versa).\n\t *\t\teditor.conversion.attributeToAttribute( { model: 'source', view: 'src' } );\n\t *\n\t *\t\t// Attribute values are strictly specified.\n\t *\t\teditor.conversion.attributeToAttribute( {\n\t *\t\t\tmodel: {\n\t *\t\t\t\tname: 'image',\n\t *\t\t\t\tkey: 'aside',\n\t *\t\t\t\tvalues: [ 'aside' ]\n\t *\t\t\t},\n\t *\t\t\tview: {\n\t *\t\t\t\taside: {\n\t *\t\t\t\t\tname: 'img',\n\t *\t\t\t\t\tkey: 'class',\n\t *\t\t\t\t\tvalue: [ 'aside', 'half-size' ]\n\t *\t\t\t\t}\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t *\t\t// Set the style attribute.\n\t *\t\teditor.conversion.attributeToAttribute( {\n\t *\t\t\tmodel: {\n\t *\t\t\t\tname: 'image',\n\t *\t\t\t\tkey: 'aside',\n\t *\t\t\t\tvalues: [ 'aside' ]\n\t *\t\t\t},\n\t *\t\t\tview: {\n\t *\t\t\t\taside: {\n\t *\t\t\t\t\tname: 'img',\n\t *\t\t\t\t\tkey: 'style',\n\t *\t\t\t\t\tvalue: {\n\t *\t\t\t\t\t\tfloat: 'right',\n\t *\t\t\t\t\t\twidth: '50%',\n\t *\t\t\t\t\t\tmargin: '5px'\n\t *\t\t\t\t\t}\n\t *\t\t\t\t}\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t *\t\t// Conversion from and to a model attribute key whose value is an enum (`align=right|center`).\n\t *\t\t// Use `upcastAlso` to define other view elements that should also be converted to the `align=right` attribute.\n\t *\t\teditor.conversion.attributeToAttribute( {\n\t *\t\t\tmodel: {\n\t *\t\t\t\tkey: 'align',\n\t *\t\t\t\tvalues: [ 'right', 'center' ]\n\t *\t\t\t},\n\t *\t\t\tview: {\n\t *\t\t\t\tright: {\n\t *\t\t\t\t\tkey: 'class',\n\t *\t\t\t\t\tvalue: 'align-right'\n\t *\t\t\t\t},\n\t *\t\t\t\tcenter: {\n\t *\t\t\t\t\tkey: 'class',\n\t *\t\t\t\t\tvalue: 'align-center'\n\t *\t\t\t\t}\n\t *\t\t\t},\n\t *\t\t\tupcastAlso: {\n\t *\t\t\t\tright: {\n\t *\t\t\t\t\tstyles: {\n\t *\t\t\t\t\t\t'text-align': 'right'\n\t *\t\t\t\t\t}\n\t *\t\t\t\t},\n\t *\t\t\t\tcenter: {\n\t *\t\t\t\t\tstyles: {\n\t *\t\t\t\t\t\t'text-align': 'center'\n\t *\t\t\t\t\t}\n\t *\t\t\t\t}\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * The `definition.model` parameter specifies which model attribute should be converted from and to.\n\t * It can be a `{ key, [ values ], [ name ] }` object or a `String`, which will be treated like `{ key: definition.model }`.\n\t * The `key` property is the model attribute key to convert from and to.\n\t * The `values` are the possible model attribute values. If `values` is not set, the model attribute value will be the same as the\n\t * view attribute value.\n\t * If `name` is set, the conversion will be set up only for model elements with the given name.\n\t *\n\t * The `definition.view` parameter specifies which view attribute should be converted from and to.\n\t * It can be a `{ key, value, [ name ] }` object or a `String`, which will be treated like `{ key: definition.view }`.\n\t * The `key` property is the view attribute key to convert from and to.\n\t * The `value` is the view attribute value to convert from and to. If `definition.value` is not set, the view attribute value will be\n\t * the same as the model attribute value.\n\t * If `key` is `'class'`, `value` can be a `String` or an array of `String`s.\n\t * If `key` is `'style'`, `value` is an object with key-value pairs.\n\t * In other cases, `value` is a `String`.\n\t * If `name` is set, the conversion will be set up only for model elements with the given name.\n\t * If `definition.model.values` is set, `definition.view` is an object that assigns values from `definition.model.values`\n\t * to `{ key, value, [ name ] }` objects.\n\t *\n\t * `definition.upcastAlso` specifies which other matching view elements should also be upcast to the given model configuration.\n\t * If `definition.model.values` is set, `definition.upcastAlso` should be an object assigning values from `definition.model.values`\n\t * to {@link module:engine/view/matcher~MatcherPattern}s or arrays of {@link module:engine/view/matcher~MatcherPattern}s.\n\t *\n\t * **Note:** `definition.model` and `definition.view` form should be mirrored, so the same types of parameters should\n\t * be given in both parameters.\n\t *\n\t * @param {Object} definition The converter definition.\n\t * @param {String|Object} definition.model The model attribute to convert from and to.\n\t * @param {String|Object} definition.view The view attribute to convert from and to.\n\t * @param {module:engine/view/matcher~MatcherPattern|Array.<module:engine/view/matcher~MatcherPattern>} [definition.upcastAlso]\n\t * Any view element matching `definition.upcastAlso` will also be converted to the given model attribute. `definition.upcastAlso`\n\t * is used only if `config.model.values` is specified.\n\t */\n\tattributeToAttribute( definition ) {\n\t\t// Set up downcast converter.\n\t\tthis.for( 'downcast' ).attributeToAttribute( definition );\n\n\t\t// Set up upcast converter.\n\t\tfor ( const { model, view } of _getAllUpcastDefinitions( definition ) ) {\n\t\t\tthis.for( 'upcast' )\n\t\t\t\t.attributeToAttribute( {\n\t\t\t\t\tview,\n\t\t\t\t\tmodel\n\t\t\t\t} );\n\t\t}\n\t}\n\n\t/**\n\t * Creates and caches conversion helpers for given dispatchers group.\n\t *\n\t * @private\n\t * @param {Object} options\n\t * @param {String} options.name Group name.\n\t * @param {Array.<module:engine/conversion/downcastdispatcher~DowncastDispatcher|\n\t * module:engine/conversion/upcastdispatcher~UpcastDispatcher>} options.dispatchers\n\t * @param {Boolean} options.isDowncast\n\t */\n\t_createConversionHelpers( { name, dispatchers, isDowncast } ) {\n\t\tif ( this._helpers.has( name ) ) {\n\t\t\t/**\n\t\t\t * Trying to register a group name that has already been registered.\n\t\t\t *\n\t\t\t * @error conversion-group-exists\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'conversion-group-exists: Trying to register a group name that has already been registered.', this );\n\t\t}\n\n\t\tconst helpers = isDowncast ? new DowncastHelpers( dispatchers ) : new UpcastHelpers( dispatchers );\n\n\t\tthis._helpers.set( name, helpers );\n\t}\n}\n\n/**\n * Defines how the model should be converted from and to the view.\n *\n * @typedef {Object} module:engine/conversion/conversion~ConverterDefinition\n *\n * @property {*} [model] The model conversion definition. Describes the model element or model attribute to convert. This parameter differs\n * for different functions that accept `ConverterDefinition`. See the description of the function to learn how to set it.\n * @property {module:engine/view/elementdefinition~ElementDefinition|Object} view The definition of the view element to convert from and\n * to. If `model` describes multiple values, `view` is an object that assigns these values (`view` object keys) to view element definitions\n * (`view` object values).\n * @property {module:engine/view/matcher~MatcherPattern|Array.<module:engine/view/matcher~MatcherPattern>} [upcastAlso]\n * Any view element matching `upcastAlso` will also be converted to the model. If `model` describes multiple values, `upcastAlso`\n * is an object that assigns these values (`upcastAlso` object keys) to {@link module:engine/view/matcher~MatcherPattern}s\n * (`upcastAlso` object values).\n * @property {module:utils/priorities~PriorityString} [converterPriority] The converter priority.\n */\n\n// Helper function that creates a joint array out of an item passed in `definition.view` and items passed in\n// `definition.upcastAlso`.\n//\n// @param {module:engine/conversion/conversion~ConverterDefinition} definition\n// @returns {Array} Array containing view definitions.\nfunction* _getAllUpcastDefinitions( definition ) {\n\tif ( definition.model.values ) {\n\t\tfor ( const value of definition.model.values ) {\n\t\t\tconst model = { key: definition.model.key, value };\n\t\t\tconst view = definition.view[ value ];\n\t\t\tconst upcastAlso = definition.upcastAlso ? definition.upcastAlso[ value ] : undefined;\n\n\t\t\tyield* _getUpcastDefinition( model, view, upcastAlso );\n\t\t}\n\t} else {\n\t\tyield* _getUpcastDefinition( definition.model, definition.view, definition.upcastAlso );\n\t}\n}\n\nfunction* _getUpcastDefinition( model, view, upcastAlso ) {\n\tyield { model, view };\n\n\tif ( upcastAlso ) {\n\t\tupcastAlso = Array.isArray( upcastAlso ) ? upcastAlso : [ upcastAlso ];\n\n\t\tfor ( const upcastAlsoItem of upcastAlso ) {\n\t\t\tyield { model, view: upcastAlsoItem };\n\t\t}\n\t}\n}\n"]}]}