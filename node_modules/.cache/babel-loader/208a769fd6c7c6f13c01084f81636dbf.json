{"remainingRequest":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/babel-loader/lib/index.js!/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-utils/src/emittermixin.js","dependencies":[{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-utils/src/emittermixin.js","mtime":499162500000},{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js","mtime":499162500000},{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/babel-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:LyoqCiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDE5LCBDS1NvdXJjZSAtIEZyZWRlcmljbyBLbmFiYmVuLiBBbGwgcmlnaHRzIHJlc2VydmVkLgogKiBGb3IgbGljZW5zaW5nLCBzZWUgTElDRU5TRS5tZCBvciBodHRwczovL2NrZWRpdG9yLmNvbS9sZWdhbC9ja2VkaXRvci1vc3MtbGljZW5zZQogKi8KCi8qKgogKiBAbW9kdWxlIHV0aWxzL2VtaXR0ZXJtaXhpbgogKi8KaW1wb3J0IEV2ZW50SW5mbyBmcm9tICcuL2V2ZW50aW5mbyc7CmltcG9ydCB1aWQgZnJvbSAnLi91aWQnOwppbXBvcnQgcHJpb3JpdGllcyBmcm9tICcuL3ByaW9yaXRpZXMnOyAvLyBUbyBjaGVjayBpZiBjb21wb25lbnQgaXMgbG9hZGVkIG1vcmUgdGhhbiBvbmNlLgoKaW1wb3J0ICcuL3ZlcnNpb24nOwppbXBvcnQgQ0tFZGl0b3JFcnJvciBmcm9tICcuL2NrZWRpdG9yZXJyb3InOwoKY29uc3QgX2xpc3RlbmluZ1RvID0gU3ltYm9sKCdsaXN0ZW5pbmdUbycpOwoKY29uc3QgX2VtaXR0ZXJJZCA9IFN5bWJvbCgnZW1pdHRlcklkJyk7Ci8qKgogKiBNaXhpbiB0aGF0IGluamVjdHMgdGhlIHtAbGluayB+RW1pdHRlciBldmVudHMgQVBJfSBpbnRvIGl0cyBob3N0LgogKgogKiBAbWl4aW4gRW1pdHRlck1peGluCiAqIEBpbXBsZW1lbnRzIG1vZHVsZTp1dGlscy9lbWl0dGVybWl4aW5+RW1pdHRlcgogKi8KCgpjb25zdCBFbWl0dGVyTWl4aW4gPSB7CiAgLyoqCiAgICogQGluaGVyaXREb2MKICAgKi8KICBvbihldmVudCwgY2FsbGJhY2ssIG9wdGlvbnMgPSB7fSkgewogICAgdGhpcy5saXN0ZW5Ubyh0aGlzLCBldmVudCwgY2FsbGJhY2ssIG9wdGlvbnMpOwogIH0sCgogIC8qKgogICAqIEBpbmhlcml0RG9jCiAgICovCiAgb25jZShldmVudCwgY2FsbGJhY2ssIG9wdGlvbnMpIHsKICAgIGxldCB3YXNGaXJlZCA9IGZhbHNlOwoKICAgIGNvbnN0IG9uY2VDYWxsYmFjayA9IGZ1bmN0aW9uIChldmVudCwgLi4uYXJncykgewogICAgICAvLyBFbnN1cmUgdGhlIGNhbGxiYWNrIGlzIGNhbGxlZCBvbmx5IG9uY2UgZXZlbiBpZiB0aGUgY2FsbGJhY2sgaXRzZWxmIGxlYWRzIHRvIHJlLWZpcmluZyB0aGUgZXZlbnQKICAgICAgLy8gKHdoaWNoIHdvdWxkIGNhbGwgdGhlIGNhbGxiYWNrIGFnYWluKS4KICAgICAgaWYgKCF3YXNGaXJlZCkgewogICAgICAgIHdhc0ZpcmVkID0gdHJ1ZTsgLy8gR28gb2ZmKCkgYXQgdGhlIGZpcnN0IGNhbGwuCgogICAgICAgIGV2ZW50Lm9mZigpOyAvLyBHbyB3aXRoIHRoZSBvcmlnaW5hbCBjYWxsYmFjay4KCiAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCBldmVudCwgLi4uYXJncyk7CiAgICAgIH0KICAgIH07IC8vIE1ha2UgYSBzaW1pbGFyIG9uKCkgY2FsbCwgc2ltcGx5IHJlcGxhY2luZyB0aGUgY2FsbGJhY2suCgoKICAgIHRoaXMubGlzdGVuVG8odGhpcywgZXZlbnQsIG9uY2VDYWxsYmFjaywgb3B0aW9ucyk7CiAgfSwKCiAgLyoqCiAgICogQGluaGVyaXREb2MKICAgKi8KICBvZmYoZXZlbnQsIGNhbGxiYWNrKSB7CiAgICB0aGlzLnN0b3BMaXN0ZW5pbmcodGhpcywgZXZlbnQsIGNhbGxiYWNrKTsKICB9LAoKICAvKioKICAgKiBAaW5oZXJpdERvYwogICAqLwogIGxpc3RlblRvKGVtaXR0ZXIsIGV2ZW50LCBjYWxsYmFjaywgb3B0aW9ucyA9IHt9KSB7CiAgICBsZXQgZW1pdHRlckluZm8sIGV2ZW50Q2FsbGJhY2tzOyAvLyBfbGlzdGVuaW5nVG8gY29udGFpbnMgYSBsaXN0IG9mIGVtaXR0ZXJzIHRoYXQgdGhpcyBvYmplY3QgaXMgbGlzdGVuaW5nIHRvLgogICAgLy8gVGhpcyBsaXN0IGhhcyB0aGUgZm9sbG93aW5nIGZvcm1hdDoKICAgIC8vCiAgICAvLyBfbGlzdGVuaW5nVG86IHsKICAgIC8vICAgICBlbWl0dGVySWQ6IHsKICAgIC8vICAgICAgICAgZW1pdHRlcjogZW1pdHRlciwKICAgIC8vICAgICAgICAgY2FsbGJhY2tzOiB7CiAgICAvLyAgICAgICAgICAgICBldmVudDE6IFsgY2FsbGJhY2sxLCBjYWxsYmFjazIsIC4uLiBdCiAgICAvLyAgICAgICAgICAgICAuLi4uCiAgICAvLyAgICAgICAgIH0KICAgIC8vICAgICB9LAogICAgLy8gICAgIC4uLgogICAgLy8gfQoKICAgIGlmICghdGhpc1tfbGlzdGVuaW5nVG9dKSB7CiAgICAgIHRoaXNbX2xpc3RlbmluZ1RvXSA9IHt9OwogICAgfQoKICAgIGNvbnN0IGVtaXR0ZXJzID0gdGhpc1tfbGlzdGVuaW5nVG9dOwoKICAgIGlmICghX2dldEVtaXR0ZXJJZChlbWl0dGVyKSkgewogICAgICBfc2V0RW1pdHRlcklkKGVtaXR0ZXIpOwogICAgfQoKICAgIGNvbnN0IGVtaXR0ZXJJZCA9IF9nZXRFbWl0dGVySWQoZW1pdHRlcik7CgogICAgaWYgKCEoZW1pdHRlckluZm8gPSBlbWl0dGVyc1tlbWl0dGVySWRdKSkgewogICAgICBlbWl0dGVySW5mbyA9IGVtaXR0ZXJzW2VtaXR0ZXJJZF0gPSB7CiAgICAgICAgZW1pdHRlciwKICAgICAgICBjYWxsYmFja3M6IHt9CiAgICAgIH07CiAgICB9CgogICAgaWYgKCEoZXZlbnRDYWxsYmFja3MgPSBlbWl0dGVySW5mby5jYWxsYmFja3NbZXZlbnRdKSkgewogICAgICBldmVudENhbGxiYWNrcyA9IGVtaXR0ZXJJbmZvLmNhbGxiYWNrc1tldmVudF0gPSBbXTsKICAgIH0KCiAgICBldmVudENhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTsgLy8gRmluYWxseSByZWdpc3RlciB0aGUgY2FsbGJhY2sgdG8gdGhlIGV2ZW50LgoKICAgIGNyZWF0ZUV2ZW50TmFtZXNwYWNlKGVtaXR0ZXIsIGV2ZW50KTsKICAgIGNvbnN0IGxpc3RzID0gZ2V0Q2FsbGJhY2tzTGlzdHNGb3JOYW1lc3BhY2UoZW1pdHRlciwgZXZlbnQpOwogICAgY29uc3QgcHJpb3JpdHkgPSBwcmlvcml0aWVzLmdldChvcHRpb25zLnByaW9yaXR5KTsKICAgIGNvbnN0IGNhbGxiYWNrRGVmaW5pdGlvbiA9IHsKICAgICAgY2FsbGJhY2ssCiAgICAgIHByaW9yaXR5CiAgICB9OyAvLyBBZGQgdGhlIGNhbGxiYWNrIHRvIGFsbCBjYWxsYmFja3MgbGlzdC4KCiAgICBmb3IgKGNvbnN0IGNhbGxiYWNrcyBvZiBsaXN0cykgewogICAgICAvLyBBZGQgdGhlIGNhbGxiYWNrIHRvIHRoZSBsaXN0IGluIHRoZSByaWdodCBwcmlvcml0eSBwb3NpdGlvbi4KICAgICAgbGV0IGFkZGVkID0gZmFsc2U7CgogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykgewogICAgICAgIGlmIChjYWxsYmFja3NbaV0ucHJpb3JpdHkgPCBwcmlvcml0eSkgewogICAgICAgICAgY2FsbGJhY2tzLnNwbGljZShpLCAwLCBjYWxsYmFja0RlZmluaXRpb24pOwogICAgICAgICAgYWRkZWQgPSB0cnVlOwogICAgICAgICAgYnJlYWs7CiAgICAgICAgfQogICAgICB9IC8vIEFkZCBhdCB0aGUgZW5kLCBpZiByaWdodCBwbGFjZSB3YXMgbm90IGZvdW5kLgoKCiAgICAgIGlmICghYWRkZWQpIHsKICAgICAgICBjYWxsYmFja3MucHVzaChjYWxsYmFja0RlZmluaXRpb24pOwogICAgICB9CiAgICB9CiAgfSwKCiAgLyoqCiAgICogQGluaGVyaXREb2MKICAgKi8KICBzdG9wTGlzdGVuaW5nKGVtaXR0ZXIsIGV2ZW50LCBjYWxsYmFjaykgewogICAgY29uc3QgZW1pdHRlcnMgPSB0aGlzW19saXN0ZW5pbmdUb107CgogICAgbGV0IGVtaXR0ZXJJZCA9IGVtaXR0ZXIgJiYgX2dldEVtaXR0ZXJJZChlbWl0dGVyKTsKCiAgICBjb25zdCBlbWl0dGVySW5mbyA9IGVtaXR0ZXJzICYmIGVtaXR0ZXJJZCAmJiBlbWl0dGVyc1tlbWl0dGVySWRdOwogICAgY29uc3QgZXZlbnRDYWxsYmFja3MgPSBlbWl0dGVySW5mbyAmJiBldmVudCAmJiBlbWl0dGVySW5mby5jYWxsYmFja3NbZXZlbnRdOyAvLyBTdG9wIGlmIG5vdGhpbmcgaGFzIGJlZW4gbGlzdGVuZWQuCgogICAgaWYgKCFlbWl0dGVycyB8fCBlbWl0dGVyICYmICFlbWl0dGVySW5mbyB8fCBldmVudCAmJiAhZXZlbnRDYWxsYmFja3MpIHsKICAgICAgcmV0dXJuOwogICAgfSAvLyBBbGwgcGFyYW1zIHByb3ZpZGVkLiBvZmYoKSB0aGF0IHNpbmdsZSBjYWxsYmFjay4KCgogICAgaWYgKGNhbGxiYWNrKSB7CiAgICAgIHJlbW92ZUNhbGxiYWNrKGVtaXR0ZXIsIGV2ZW50LCBjYWxsYmFjayk7CiAgICB9IC8vIE9ubHkgYGVtaXR0ZXJgIGFuZCBgZXZlbnRgIHByb3ZpZGVkLiBvZmYoKSBhbGwgY2FsbGJhY2tzIGZvciB0aGF0IGV2ZW50LgogICAgZWxzZSBpZiAoZXZlbnRDYWxsYmFja3MpIHsKICAgICAgICB3aGlsZSAoY2FsbGJhY2sgPSBldmVudENhbGxiYWNrcy5wb3AoKSkgewogICAgICAgICAgcmVtb3ZlQ2FsbGJhY2soZW1pdHRlciwgZXZlbnQsIGNhbGxiYWNrKTsKICAgICAgICB9CgogICAgICAgIGRlbGV0ZSBlbWl0dGVySW5mby5jYWxsYmFja3NbZXZlbnRdOwogICAgICB9IC8vIE9ubHkgYGVtaXR0ZXJgIHByb3ZpZGVkLiBvZmYoKSBhbGwgZXZlbnRzIGZvciB0aGF0IGVtaXR0ZXIuCiAgICAgIGVsc2UgaWYgKGVtaXR0ZXJJbmZvKSB7CiAgICAgICAgICBmb3IgKGV2ZW50IGluIGVtaXR0ZXJJbmZvLmNhbGxiYWNrcykgewogICAgICAgICAgICB0aGlzLnN0b3BMaXN0ZW5pbmcoZW1pdHRlciwgZXZlbnQpOwogICAgICAgICAgfQoKICAgICAgICAgIGRlbGV0ZSBlbWl0dGVyc1tlbWl0dGVySWRdOwogICAgICAgIH0gLy8gTm8gcGFyYW1zIHByb3ZpZGVkLiBvZmYoKSBhbGwgZW1pdHRlcnMuCiAgICAgICAgZWxzZSB7CiAgICAgICAgICAgIGZvciAoZW1pdHRlcklkIGluIGVtaXR0ZXJzKSB7CiAgICAgICAgICAgICAgdGhpcy5zdG9wTGlzdGVuaW5nKGVtaXR0ZXJzW2VtaXR0ZXJJZF0uZW1pdHRlcik7CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGRlbGV0ZSB0aGlzW19saXN0ZW5pbmdUb107CiAgICAgICAgICB9CiAgfSwKCiAgLyoqCiAgICogQGluaGVyaXREb2MKICAgKi8KICBmaXJlKGV2ZW50T3JJbmZvLCAuLi5hcmdzKSB7CiAgICB0cnkgewogICAgICBjb25zdCBldmVudEluZm8gPSBldmVudE9ySW5mbyBpbnN0YW5jZW9mIEV2ZW50SW5mbyA/IGV2ZW50T3JJbmZvIDogbmV3IEV2ZW50SW5mbyh0aGlzLCBldmVudE9ySW5mbyk7CiAgICAgIGNvbnN0IGV2ZW50ID0gZXZlbnRJbmZvLm5hbWU7CiAgICAgIGxldCBjYWxsYmFja3MgPSBnZXRDYWxsYmFja3NGb3JFdmVudCh0aGlzLCBldmVudCk7IC8vIFJlY29yZCB0aGF0IHRoZSBldmVudCBwYXNzZWQgdGhpcyBlbWl0dGVyIG9uIGl0cyBwYXRoLgoKICAgICAgZXZlbnRJbmZvLnBhdGgucHVzaCh0aGlzKTsgLy8gSGFuZGxlIGV2ZW50IGxpc3RlbmVyIGNhbGxiYWNrcyBmaXJzdC4KCiAgICAgIGlmIChjYWxsYmFja3MpIHsKICAgICAgICAvLyBBcmd1bWVudHMgcGFzc2VkIHRvIGVhY2ggY2FsbGJhY2suCiAgICAgICAgY29uc3QgY2FsbGJhY2tBcmdzID0gW2V2ZW50SW5mbywgLi4uYXJnc107IC8vIENvcHlpbmcgY2FsbGJhY2tzIGFycmF5IGlzIHRoZSBlYXNpZXN0IGFuZCBtb3N0IHNlY3VyZSB3YXkgb2YgcHJldmVudGluZyBpbmZpbml0ZSBsb29wcywgd2hlbiBldmVudCBjYWxsYmFja3MKICAgICAgICAvLyBhcmUgYWRkZWQgd2hpbGUgcHJvY2Vzc2luZyBvdGhlciBjYWxsYmFja3MuIFByZXZpb3VzIHNvbHV0aW9uIGludm9sdmVkIGFkZGluZyBjb3VudGVycyAodW5pcXVlIGlkcykgYnV0CiAgICAgICAgLy8gZmFpbGVkIGlmIGNhbGxiYWNrcyB3ZXJlIGFkZGVkIHRvIHRoZSBxdWV1ZSBiZWZvcmUgY3VycmVudGx5IHByb2Nlc3NlZCBjYWxsYmFjay4KICAgICAgICAvLyBJZiB0aGlzIHByb3ZlcyB0byBiZSB0b28gaW5lZmZpY2llbnQsIGFub3RoZXIgbWV0aG9kIGlzIHRvIGNoYW5nZSBgLm9uKClgIHNvIGNhbGxiYWNrcyBhcmUgc3RvcmVkIGlmIHNhbWUKICAgICAgICAvLyBldmVudCBpcyBjdXJyZW50bHkgcHJvY2Vzc2VkLiBUaGVuLCBgLmZpcmUoKWAgYXQgdGhlIGVuZCwgd291bGQgaGF2ZSB0byBhZGQgYWxsIHN0b3JlZCBldmVudHMuCgogICAgICAgIGNhbGxiYWNrcyA9IEFycmF5LmZyb20oY2FsbGJhY2tzKTsKCiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHsKICAgICAgICAgIGNhbGxiYWNrc1tpXS5jYWxsYmFjay5hcHBseSh0aGlzLCBjYWxsYmFja0FyZ3MpOyAvLyBSZW1vdmUgdGhlIGNhbGxiYWNrIGZyb20gZnV0dXJlIHJlcXVlc3RzIGlmIG9mZigpIGhhcyBiZWVuIGNhbGxlZC4KCiAgICAgICAgICBpZiAoZXZlbnRJbmZvLm9mZi5jYWxsZWQpIHsKICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBjYWxsZWQgbWFyayBmb3IgdGhlIG5leHQgY2FsbHMuCiAgICAgICAgICAgIGRlbGV0ZSBldmVudEluZm8ub2ZmLmNhbGxlZDsKICAgICAgICAgICAgcmVtb3ZlQ2FsbGJhY2sodGhpcywgZXZlbnQsIGNhbGxiYWNrc1tpXS5jYWxsYmFjayk7CiAgICAgICAgICB9IC8vIERvIG5vdCBleGVjdXRlIG5leHQgY2FsbGJhY2tzIGlmIHN0b3AoKSB3YXMgY2FsbGVkLgoKCiAgICAgICAgICBpZiAoZXZlbnRJbmZvLnN0b3AuY2FsbGVkKSB7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSAvLyBEZWxlZ2F0ZSBldmVudCB0byBvdGhlciBlbWl0dGVycyBpZiBuZWVkZWQuCgoKICAgICAgaWYgKHRoaXMuX2RlbGVnYXRpb25zKSB7CiAgICAgICAgY29uc3QgZGVzdGluYXRpb25zID0gdGhpcy5fZGVsZWdhdGlvbnMuZ2V0KGV2ZW50KTsKCiAgICAgICAgY29uc3QgcGFzc0FsbERlc3RpbmF0aW9ucyA9IHRoaXMuX2RlbGVnYXRpb25zLmdldCgnKicpOwoKICAgICAgICBpZiAoZGVzdGluYXRpb25zKSB7CiAgICAgICAgICBmaXJlRGVsZWdhdGVkRXZlbnRzKGRlc3RpbmF0aW9ucywgZXZlbnRJbmZvLCBhcmdzKTsKICAgICAgICB9CgogICAgICAgIGlmIChwYXNzQWxsRGVzdGluYXRpb25zKSB7CiAgICAgICAgICBmaXJlRGVsZWdhdGVkRXZlbnRzKHBhc3NBbGxEZXN0aW5hdGlvbnMsIGV2ZW50SW5mbywgYXJncyk7CiAgICAgICAgfQogICAgICB9CgogICAgICByZXR1cm4gZXZlbnRJbmZvLnJldHVybjsKICAgIH0gY2F0Y2ggKGVycikgewogICAgICAvLyBAaWYgQ0tfREVCVUcgLy8gdGhyb3cgZXJyOwoKICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8KICAgICAgQ0tFZGl0b3JFcnJvci5yZXRocm93VW5leHBlY3RlZEVycm9yKGVyciwgdGhpcyk7CiAgICB9CiAgfSwKCiAgLyoqCiAgICogQGluaGVyaXREb2MKICAgKi8KICBkZWxlZ2F0ZSguLi5ldmVudHMpIHsKICAgIHJldHVybiB7CiAgICAgIHRvOiAoZW1pdHRlciwgbmFtZU9yRnVuY3Rpb24pID0+IHsKICAgICAgICBpZiAoIXRoaXMuX2RlbGVnYXRpb25zKSB7CiAgICAgICAgICB0aGlzLl9kZWxlZ2F0aW9ucyA9IG5ldyBNYXAoKTsKICAgICAgICB9IC8vIE9yaWdpbmFsbHkgdGhlcmUgd2FzIGEgZm9yLi5vZiBsb29wIHdoaWNoIHVuZm9ydHVuYXRlbHkgY2F1c2VkIGFuIGVycm9yIGluIEJhYmVsIHRoYXQgZGlkbid0IGFsbG93CiAgICAgICAgLy8gYnVpbGQgYW4gYXBwbGljYXRpb24uIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2NrZWRpdG9yL2NrZWRpdG9yNS1yZWFjdC9pc3N1ZXMvNDAuCgoKICAgICAgICBldmVudHMuZm9yRWFjaChldmVudE5hbWUgPT4gewogICAgICAgICAgY29uc3QgZGVzdGluYXRpb25zID0gdGhpcy5fZGVsZWdhdGlvbnMuZ2V0KGV2ZW50TmFtZSk7CgogICAgICAgICAgaWYgKCFkZXN0aW5hdGlvbnMpIHsKICAgICAgICAgICAgdGhpcy5fZGVsZWdhdGlvbnMuc2V0KGV2ZW50TmFtZSwgbmV3IE1hcChbW2VtaXR0ZXIsIG5hbWVPckZ1bmN0aW9uXV0pKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGRlc3RpbmF0aW9ucy5zZXQoZW1pdHRlciwgbmFtZU9yRnVuY3Rpb24pOwogICAgICAgICAgfQogICAgICAgIH0pOwogICAgICB9CiAgICB9OwogIH0sCgogIC8qKgogICAqIEBpbmhlcml0RG9jCiAgICovCiAgc3RvcERlbGVnYXRpbmcoZXZlbnQsIGVtaXR0ZXIpIHsKICAgIGlmICghdGhpcy5fZGVsZWdhdGlvbnMpIHsKICAgICAgcmV0dXJuOwogICAgfQoKICAgIGlmICghZXZlbnQpIHsKICAgICAgdGhpcy5fZGVsZWdhdGlvbnMuY2xlYXIoKTsKICAgIH0gZWxzZSBpZiAoIWVtaXR0ZXIpIHsKICAgICAgdGhpcy5fZGVsZWdhdGlvbnMuZGVsZXRlKGV2ZW50KTsKICAgIH0gZWxzZSB7CiAgICAgIGNvbnN0IGRlc3RpbmF0aW9ucyA9IHRoaXMuX2RlbGVnYXRpb25zLmdldChldmVudCk7CgogICAgICBpZiAoZGVzdGluYXRpb25zKSB7CiAgICAgICAgZGVzdGluYXRpb25zLmRlbGV0ZShlbWl0dGVyKTsKICAgICAgfQogICAgfQogIH0KCn07CmV4cG9ydCBkZWZhdWx0IEVtaXR0ZXJNaXhpbjsKLyoqCiAqIEVtaXR0ZXIvbGlzdGVuZXIgaW50ZXJmYWNlLgogKgogKiBDYW4gYmUgZWFzaWx5IGltcGxlbWVudGVkIGJ5IGEgY2xhc3MgYnkgbWl4aW5nIHRoZSB7QGxpbmsgbW9kdWxlOnV0aWxzL2VtaXR0ZXJtaXhpbn5FbWl0dGVyTWl4aW59IG1peGluLgogKgogKiBAaW50ZXJmYWNlIEVtaXR0ZXIKICovCgovKioKICogUmVnaXN0ZXJzIGEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgd2hlbiBhbiBldmVudCBpcyBmaXJlZC4KICoKICogU2hvcnRoYW5kIGZvciB7QGxpbmsgI2xpc3RlblRvIGB0aGlzLmxpc3RlblRvKCB0aGlzLCBldmVudCwgY2FsbGJhY2ssIG9wdGlvbnMgKWB9IChpdCBtYWtlcyB0aGUgZW1pdHRlcgogKiBsaXN0ZW4gb24gaXRzZWxmKS4KICoKICogQG1ldGhvZCAjb24KICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IFRoZSBuYW1lIG9mIHRoZSBldmVudC4KICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiBldmVudC4KICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBBZGRpdGlvbmFsIG9wdGlvbnMuCiAqIEBwYXJhbSB7bW9kdWxlOnV0aWxzL3ByaW9yaXRpZXN+UHJpb3JpdHlTdHJpbmd8TnVtYmVyfSBbb3B0aW9ucy5wcmlvcml0eT0nbm9ybWFsJ10gVGhlIHByaW9yaXR5IG9mIHRoaXMgZXZlbnQgY2FsbGJhY2suIFRoZSBoaWdoZXIKICogdGhlIHByaW9yaXR5IHZhbHVlIHRoZSBzb29uZXIgdGhlIGNhbGxiYWNrIHdpbGwgYmUgZmlyZWQuIEV2ZW50cyBoYXZpbmcgdGhlIHNhbWUgcHJpb3JpdHkgYXJlIGNhbGxlZCBpbiB0aGUKICogb3JkZXIgdGhleSB3ZXJlIGFkZGVkLgogKi8KCi8qKgogKiBSZWdpc3RlcnMgYSBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCBvbiB0aGUgbmV4dCB0aW1lIHRoZSBldmVudCBpcyBmaXJlZCBvbmx5LiBUaGlzIGlzIHNpbWlsYXIgdG8KICogY2FsbGluZyB7QGxpbmsgI29ufSBmb2xsb3dlZCBieSB7QGxpbmsgI29mZn0gaW4gdGhlIGNhbGxiYWNrLgogKgogKiBAbWV0aG9kICNvbmNlCiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBUaGUgbmFtZSBvZiB0aGUgZXZlbnQuCiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb24gZXZlbnQuCiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gQWRkaXRpb25hbCBvcHRpb25zLgogKiBAcGFyYW0ge21vZHVsZTp1dGlscy9wcmlvcml0aWVzflByaW9yaXR5U3RyaW5nfE51bWJlcn0gW29wdGlvbnMucHJpb3JpdHk9J25vcm1hbCddIFRoZSBwcmlvcml0eSBvZiB0aGlzIGV2ZW50IGNhbGxiYWNrLiBUaGUgaGlnaGVyCiAqIHRoZSBwcmlvcml0eSB2YWx1ZSB0aGUgc29vbmVyIHRoZSBjYWxsYmFjayB3aWxsIGJlIGZpcmVkLiBFdmVudHMgaGF2aW5nIHRoZSBzYW1lIHByaW9yaXR5IGFyZSBjYWxsZWQgaW4gdGhlCiAqIG9yZGVyIHRoZXkgd2VyZSBhZGRlZC4KICovCgovKioKICogU3RvcHMgZXhlY3V0aW5nIHRoZSBjYWxsYmFjayBvbiB0aGUgZ2l2ZW4gZXZlbnQuCiAqIFNob3J0aGFuZCBmb3Ige0BsaW5rICNzdG9wTGlzdGVuaW5nIGB0aGlzLnN0b3BMaXN0ZW5pbmcoIHRoaXMsIGV2ZW50LCBjYWxsYmFjayApYH0uCiAqCiAqIEBtZXRob2QgI29mZgogKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgVGhlIG5hbWUgb2YgdGhlIGV2ZW50LgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gc3RvcCBiZWluZyBjYWxsZWQuCiAqLwoKLyoqCiAqIFJlZ2lzdGVycyBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIHdoZW4gYW4gZXZlbnQgaXMgZmlyZWQgaW4gYSBzcGVjaWZpYyAoZW1pdHRlcikgb2JqZWN0LgogKgogKiBFdmVudHMgY2FuIGJlIGdyb3VwZWQgaW4gbmFtZXNwYWNlcyB1c2luZyBgOmAuCiAqIFdoZW4gbmFtZXNwYWNlZCBldmVudCBpcyBmaXJlZCwgaXQgYWRkaXRpb25hbGx5IGZpcmVzIGFsbCBjYWxsYmFja3MgZm9yIHRoYXQgbmFtZXNwYWNlLgogKgogKgkJLy8gbXlFbWl0dGVyLm9uKCAuLi4gKSBpcyBhIHNob3J0aGFuZCBmb3IgbXlFbWl0dGVyLmxpc3RlblRvKCBteUVtaXR0ZXIsIC4uLiApLgogKgkJbXlFbWl0dGVyLm9uKCAnbXlHcm91cCcsIGdlbmVyaWNDYWxsYmFjayApOwogKgkJbXlFbWl0dGVyLm9uKCAnbXlHcm91cDpteUV2ZW50Jywgc3BlY2lmaWNDYWxsYmFjayApOwogKgogKgkJLy8gZ2VuZXJpY0NhbGxiYWNrIGlzIGZpcmVkLgogKgkJbXlFbWl0dGVyLmZpcmUoICdteUdyb3VwJyApOwogKgkJLy8gYm90aCBnZW5lcmljQ2FsbGJhY2sgYW5kIHNwZWNpZmljQ2FsbGJhY2sgYXJlIGZpcmVkLgogKgkJbXlFbWl0dGVyLmZpcmUoICdteUdyb3VwOm15RXZlbnQnICk7CiAqCQkvLyBnZW5lcmljQ2FsbGJhY2sgaXMgZmlyZWQgZXZlbiB0aG91Z2ggdGhlcmUgYXJlIG5vIGNhbGxiYWNrcyBmb3IgImZvbyIuCiAqCQlteUVtaXR0ZXIuZmlyZSggJ215R3JvdXA6Zm9vJyApOwogKgogKiBBbiBldmVudCBjYWxsYmFjayBjYW4ge0BsaW5rIG1vZHVsZTp1dGlscy9ldmVudGluZm9+RXZlbnRJbmZvI3N0b3Agc3RvcCB0aGUgZXZlbnR9IGFuZAogKiBzZXQgdGhlIHtAbGluayBtb2R1bGU6dXRpbHMvZXZlbnRpbmZvfkV2ZW50SW5mbyNyZXR1cm4gcmV0dXJuIHZhbHVlfSBvZiB0aGUge0BsaW5rICNmaXJlfSBtZXRob2QuCiAqCiAqIEBtZXRob2QgI2xpc3RlblRvCiAqIEBwYXJhbSB7bW9kdWxlOnV0aWxzL2VtaXR0ZXJtaXhpbn5FbWl0dGVyfSBlbWl0dGVyIFRoZSBvYmplY3QgdGhhdCBmaXJlcyB0aGUgZXZlbnQuCiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBUaGUgbmFtZSBvZiB0aGUgZXZlbnQuCiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb24gZXZlbnQuCiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gQWRkaXRpb25hbCBvcHRpb25zLgogKiBAcGFyYW0ge21vZHVsZTp1dGlscy9wcmlvcml0aWVzflByaW9yaXR5U3RyaW5nfE51bWJlcn0gW29wdGlvbnMucHJpb3JpdHk9J25vcm1hbCddIFRoZSBwcmlvcml0eSBvZiB0aGlzIGV2ZW50IGNhbGxiYWNrLiBUaGUgaGlnaGVyCiAqIHRoZSBwcmlvcml0eSB2YWx1ZSB0aGUgc29vbmVyIHRoZSBjYWxsYmFjayB3aWxsIGJlIGZpcmVkLiBFdmVudHMgaGF2aW5nIHRoZSBzYW1lIHByaW9yaXR5IGFyZSBjYWxsZWQgaW4gdGhlCiAqIG9yZGVyIHRoZXkgd2VyZSBhZGRlZC4KICovCgovKioKICogU3RvcHMgbGlzdGVuaW5nIGZvciBldmVudHMuIEl0IGNhbiBiZSB1c2VkIGF0IGRpZmZlcmVudCBsZXZlbHM6CiAqCiAqICogVG8gc3RvcCBsaXN0ZW5pbmcgdG8gYSBzcGVjaWZpYyBjYWxsYmFjay4KICogKiBUbyBzdG9wIGxpc3RlbmluZyB0byBhIHNwZWNpZmljIGV2ZW50LgogKiAqIFRvIHN0b3AgbGlzdGVuaW5nIHRvIGFsbCBldmVudHMgZmlyZWQgYnkgYSBzcGVjaWZpYyBvYmplY3QuCiAqICogVG8gc3RvcCBsaXN0ZW5pbmcgdG8gYWxsIGV2ZW50cyBmaXJlZCBieSBhbGwgb2JqZWN0cy4KICoKICogQG1ldGhvZCAjc3RvcExpc3RlbmluZwogKiBAcGFyYW0ge21vZHVsZTp1dGlscy9lbWl0dGVybWl4aW5+RW1pdHRlcn0gW2VtaXR0ZXJdIFRoZSBvYmplY3QgdG8gc3RvcCBsaXN0ZW5pbmcgdG8uIElmIG9taXR0ZWQsIHN0b3BzIGl0IGZvciBhbGwgb2JqZWN0cy4KICogQHBhcmFtIHtTdHJpbmd9IFtldmVudF0gKFJlcXVpcmVzIHRoZSBgZW1pdHRlcmApIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBzdG9wIGxpc3RlbmluZyB0by4gSWYgb21pdHRlZCwgc3RvcHMgaXQKICogZm9yIGFsbCBldmVudHMgZnJvbSBgZW1pdHRlcmAuCiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gKFJlcXVpcmVzIHRoZSBgZXZlbnRgKSBUaGUgZnVuY3Rpb24gdG8gYmUgcmVtb3ZlZCBmcm9tIHRoZSBjYWxsIGxpc3QgZm9yIHRoZSBnaXZlbgogKiBgZXZlbnRgLgogKi8KCi8qKgogKiBGaXJlcyBhbiBldmVudCwgZXhlY3V0aW5nIGFsbCBjYWxsYmFja3MgcmVnaXN0ZXJlZCBmb3IgaXQuCiAqCiAqIFRoZSBmaXJzdCBwYXJhbWV0ZXIgcGFzc2VkIHRvIGNhbGxiYWNrcyBpcyBhbiB7QGxpbmsgbW9kdWxlOnV0aWxzL2V2ZW50aW5mb35FdmVudEluZm99IG9iamVjdCwKICogZm9sbG93ZWQgYnkgdGhlIG9wdGlvbmFsIGBhcmdzYCBwcm92aWRlZCBpbiB0aGUgYGZpcmUoKWAgbWV0aG9kIGNhbGwuCiAqCiAqIEBtZXRob2QgI2ZpcmUKICogQHBhcmFtIHtTdHJpbmd8bW9kdWxlOnV0aWxzL2V2ZW50aW5mb35FdmVudEluZm99IGV2ZW50T3JJbmZvIFRoZSBuYW1lIG9mIHRoZSBldmVudCBvciBgRXZlbnRJbmZvYCBvYmplY3QgaWYgZXZlbnQgaXMgZGVsZWdhdGVkLgogKiBAcGFyYW0gey4uLip9IFthcmdzXSBBZGRpdGlvbmFsIGFyZ3VtZW50cyB0byBiZSBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrcy4KICogQHJldHVybnMgeyp9IEJ5IGRlZmF1bHQgdGhlIG1ldGhvZCByZXR1cm5zIGB1bmRlZmluZWRgLiBIb3dldmVyLCB0aGUgcmV0dXJuIHZhbHVlIGNhbiBiZSBjaGFuZ2VkIGJ5IGxpc3RlbmVycwogKiB0aHJvdWdoIG1vZGlmaWNhdGlvbiBvZiB0aGUge0BsaW5rIG1vZHVsZTp1dGlscy9ldmVudGluZm9+RXZlbnRJbmZvI3JldHVybiBgZXZ0LnJldHVybmB9J3MgcHJvcGVydHkgKHRoZSBldmVudCBpbmZvCiAqIGlzIHRoZSBmaXJzdCBwYXJhbSBvZiBldmVyeSBjYWxsYmFjaykuCiAqLwoKLyoqCiAqIERlbGVnYXRlcyBzZWxlY3RlZCBldmVudHMgdG8gYW5vdGhlciB7QGxpbmsgbW9kdWxlOnV0aWxzL2VtaXR0ZXJtaXhpbn5FbWl0dGVyfS4gRm9yIGluc3RhbmNlOgogKgogKgkJZW1pdHRlckEuZGVsZWdhdGUoICdldmVudFgnICkudG8oIGVtaXR0ZXJCICk7CiAqCQllbWl0dGVyQS5kZWxlZ2F0ZSggJ2V2ZW50WCcsICdldmVudFknICkudG8oIGVtaXR0ZXJDICk7CiAqCiAqIHRoZW4gYGV2ZW50WGAgaXMgZGVsZWdhdGVkIChmaXJlZCBieSkgYGVtaXR0ZXJCYCBhbmQgYGVtaXR0ZXJDYCBhbG9uZyB3aXRoIGBkYXRhYDoKICoKICoJCWVtaXR0ZXJBLmZpcmUoICdldmVudFgnLCBkYXRhICk7CiAqCiAqIGFuZCBgZXZlbnRZYCBpcyBkZWxlZ2F0ZWQgKGZpcmVkIGJ5KSBgZW1pdHRlckNgIGFsb25nIHdpdGggYGRhdGFgOgogKgogKgkJZW1pdHRlckEuZmlyZSggJ2V2ZW50WScsIGRhdGEgKTsKICoKICogQG1ldGhvZCAjZGVsZWdhdGUKICogQHBhcmFtIHsuLi5TdHJpbmd9IGV2ZW50cyBFdmVudCBuYW1lcyB0aGF0IHdpbGwgYmUgZGVsZWdhdGVkIHRvIGFub3RoZXIgZW1pdHRlci4KICogQHJldHVybnMge21vZHVsZTp1dGlscy9lbWl0dGVybWl4aW5+RW1pdHRlck1peGluRGVsZWdhdGVDaGFpbn0KICovCgovKioKICogU3RvcHMgZGVsZWdhdGluZyBldmVudHMuIEl0IGNhbiBiZSB1c2VkIGF0IGRpZmZlcmVudCBsZXZlbHM6CiAqCiAqICogVG8gc3RvcCBkZWxlZ2F0aW5nIGFsbCBldmVudHMuCiAqICogVG8gc3RvcCBkZWxlZ2F0aW5nIGEgc3BlY2lmaWMgZXZlbnQgdG8gYWxsIGVtaXR0ZXJzLgogKiAqIFRvIHN0b3AgZGVsZWdhdGluZyBhIHNwZWNpZmljIGV2ZW50IHRvIGEgc3BlY2lmaWMgZW1pdHRlci4KICoKICogQG1ldGhvZCAjc3RvcERlbGVnYXRpbmcKICogQHBhcmFtIHtTdHJpbmd9IFtldmVudF0gVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIHN0b3AgZGVsZWdhdGluZy4gSWYgb21pdHRlZCwgc3RvcHMgaXQgYWxsIGRlbGVnYXRpb25zLgogKiBAcGFyYW0ge21vZHVsZTp1dGlscy9lbWl0dGVybWl4aW5+RW1pdHRlcn0gW2VtaXR0ZXJdIChyZXF1aXJlcyBgZXZlbnRgKSBUaGUgb2JqZWN0IHRvIHN0b3AgZGVsZWdhdGluZyBhIHBhcnRpY3VsYXIgZXZlbnQgdG8uCiAqIElmIG9taXR0ZWQsIHN0b3BzIGRlbGVnYXRpb24gb2YgYGV2ZW50YCB0byBhbGwgZW1pdHRlcnMuCiAqLwoKLyoqCiAqIENoZWNrcyBpZiBgbGlzdGVuaW5nRW1pdHRlcmAgbGlzdGVucyB0byBhbiBlbWl0dGVyIHdpdGggZ2l2ZW4gYGxpc3RlbmVkVG9FbWl0dGVySWRgIGFuZCBpZiBzbywgcmV0dXJucyB0aGF0IGVtaXR0ZXIuCiAqIElmIG5vdCwgcmV0dXJucyBgbnVsbGAuCiAqCiAqIEBwcm90ZWN0ZWQKICogQHBhcmFtIHttb2R1bGU6dXRpbHMvZW1pdHRlcm1peGlufkVtaXR0ZXJ9IGxpc3RlbmluZ0VtaXR0ZXIgQW4gZW1pdHRlciB0aGF0IGxpc3RlbnMuCiAqIEBwYXJhbSB7U3RyaW5nfSBsaXN0ZW5lZFRvRW1pdHRlcklkIFVuaXF1ZSBlbWl0dGVyIGlkIG9mIGVtaXR0ZXIgbGlzdGVuZWQgdG8uCiAqIEByZXR1cm5zIHttb2R1bGU6dXRpbHMvZW1pdHRlcm1peGlufkVtaXR0ZXJ8bnVsbH0KICovCgpleHBvcnQgZnVuY3Rpb24gX2dldEVtaXR0ZXJMaXN0ZW5lZFRvKGxpc3RlbmluZ0VtaXR0ZXIsIGxpc3RlbmVkVG9FbWl0dGVySWQpIHsKICBpZiAobGlzdGVuaW5nRW1pdHRlcltfbGlzdGVuaW5nVG9dICYmIGxpc3RlbmluZ0VtaXR0ZXJbX2xpc3RlbmluZ1RvXVtsaXN0ZW5lZFRvRW1pdHRlcklkXSkgewogICAgcmV0dXJuIGxpc3RlbmluZ0VtaXR0ZXJbX2xpc3RlbmluZ1RvXVtsaXN0ZW5lZFRvRW1pdHRlcklkXS5lbWl0dGVyOwogIH0KCiAgcmV0dXJuIG51bGw7Cn0KLyoqCiAqIFNldHMgZW1pdHRlcidzIHVuaXF1ZSBpZC4KICoKICogKipOb3RlOioqIGBfZW1pdHRlcklkYCBjYW4gYmUgc2V0IG9ubHkgb25jZS4KICoKICogQHByb3RlY3RlZAogKiBAcGFyYW0ge21vZHVsZTp1dGlscy9lbWl0dGVybWl4aW5+RW1pdHRlcn0gZW1pdHRlciBBbiBlbWl0dGVyIGZvciB3aGljaCBpZCB3aWxsIGJlIHNldC4KICogQHBhcmFtIHtTdHJpbmd9IFtpZF0gVW5pcXVlIGlkIHRvIHNldC4gSWYgbm90IHBhc3NlZCwgcmFuZG9tIHVuaXF1ZSBpZCB3aWxsIGJlIHNldC4KICovCgpleHBvcnQgZnVuY3Rpb24gX3NldEVtaXR0ZXJJZChlbWl0dGVyLCBpZCkgewogIGlmICghZW1pdHRlcltfZW1pdHRlcklkXSkgewogICAgZW1pdHRlcltfZW1pdHRlcklkXSA9IGlkIHx8IHVpZCgpOwogIH0KfQovKioKICogUmV0dXJucyBlbWl0dGVyJ3MgdW5pcXVlIGlkLgogKgogKiBAcHJvdGVjdGVkCiAqIEBwYXJhbSB7bW9kdWxlOnV0aWxzL2VtaXR0ZXJtaXhpbn5FbWl0dGVyfSBlbWl0dGVyIEFuIGVtaXR0ZXIgd2hpY2ggaWQgd2lsbCBiZSByZXR1cm5lZC4KICovCgpleHBvcnQgZnVuY3Rpb24gX2dldEVtaXR0ZXJJZChlbWl0dGVyKSB7CiAgcmV0dXJuIGVtaXR0ZXJbX2VtaXR0ZXJJZF07Cn0gLy8gR2V0cyB0aGUgaW50ZXJuYWwgYF9ldmVudHNgIHByb3BlcnR5IG9mIHRoZSBnaXZlbiBvYmplY3QuCi8vIGBfZXZlbnRzYCBwcm9wZXJ0eSBzdG9yZSBhbGwgbGlzdHMgd2l0aCBjYWxsYmFja3MgZm9yIHJlZ2lzdGVyZWQgZXZlbnQgbmFtZXMuCi8vIElmIHRoZXJlIHdlcmUgbm8gZXZlbnRzIHJlZ2lzdGVyZWQgb24gdGhlIG9iamVjdCwgZW1wdHkgYF9ldmVudHNgIG9iamVjdCBpcyBjcmVhdGVkLgoKZnVuY3Rpb24gZ2V0RXZlbnRzKHNvdXJjZSkgewogIGlmICghc291cmNlLl9ldmVudHMpIHsKICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb3VyY2UsICdfZXZlbnRzJywgewogICAgICB2YWx1ZToge30KICAgIH0pOwogIH0KCiAgcmV0dXJuIHNvdXJjZS5fZXZlbnRzOwp9IC8vIENyZWF0ZXMgZXZlbnQgbm9kZSBmb3IgZ2VuZXJpYy1zcGVjaWZpYyBldmVudHMgcmVsYXRpb24gYXJjaGl0ZWN0dXJlLgoKCmZ1bmN0aW9uIG1ha2VFdmVudE5vZGUoKSB7CiAgcmV0dXJuIHsKICAgIGNhbGxiYWNrczogW10sCiAgICBjaGlsZEV2ZW50czogW10KICB9Owp9IC8vIENyZWF0ZXMgYW4gYXJjaGl0ZWN0dXJlIGZvciBnZW5lcmljLXNwZWNpZmljIGV2ZW50cyByZWxhdGlvbi4KLy8gSWYgbmVlZGVkLCBjcmVhdGVzIGFsbCBldmVudHMgZm9yIGdpdmVuIGV2ZW50TmFtZSwgaS5lLiBpZiB0aGUgZmlyc3QgcmVnaXN0ZXJlZCBldmVudAovLyBpcyBmb286YmFyOmFiYywgaXQgd2lsbCBjcmVhdGUgZm9vOmJhcjphYmMsIGZvbzpiYXIgYW5kIGZvbyBldmVudCBhbmQgdGllIHRoZW0gdG9nZXRoZXIuCi8vIEl0IGFsc28gY29waWVzIGNhbGxiYWNrcyBmcm9tIG1vcmUgZ2VuZXJpYyBldmVudHMgdG8gbW9yZSBzcGVjaWZpYyBldmVudHMgd2hlbgovLyBzcGVjaWZpYyBldmVudHMgYXJlIGNyZWF0ZWQuCgoKZnVuY3Rpb24gY3JlYXRlRXZlbnROYW1lc3BhY2Uoc291cmNlLCBldmVudE5hbWUpIHsKICBjb25zdCBldmVudHMgPSBnZXRFdmVudHMoc291cmNlKTsgLy8gRmlyc3QsIGNoZWNrIGlmIHRoZSBldmVudCB3ZSB3YW50IHRvIGFkZCB0byB0aGUgc3RydWN0dXJlIGFscmVhZHkgZXhpc3RzLgoKICBpZiAoZXZlbnRzW2V2ZW50TmFtZV0pIHsKICAgIC8vIElmIGl0IGV4aXN0cywgd2UgZG9uJ3QgaGF2ZSB0byBkbyBhbnl0aGluZy4KICAgIHJldHVybjsKICB9IC8vIEluIG90aGVyIGNhc2UsIHdlIGhhdmUgdG8gY3JlYXRlIHRoZSBzdHJ1Y3R1cmUgZm9yIHRoZSBldmVudC4KICAvLyBOb3RlLCB0aGF0IHdlIG1pZ2h0IG5lZWQgdG8gY3JlYXRlIGludGVybWVkaWF0ZSBldmVudHMgdG9vLgogIC8vIEkuZS4gaWYgZm9vOmJhcjphYmMgaXMgYmVpbmcgcmVnaXN0ZXJlZCBhbmQgd2Ugb25seSBoYXZlIGZvbyBpbiB0aGUgc3RydWN0dXJlLAogIC8vIHdlIG5lZWQgdG8gYWxzbyByZWdpc3RlciBmb286YmFyLgogIC8vIEN1cnJlbnRseSBwcm9jZXNzZWQgZXZlbnQgbmFtZS4KCgogIGxldCBuYW1lID0gZXZlbnROYW1lOyAvLyBOYW1lIG9mIHRoZSBldmVudCB0aGF0IGlzIGEgY2hpbGQgZXZlbnQgZm9yIGN1cnJlbnRseSBwcm9jZXNzZWQgZXZlbnQuCgogIGxldCBjaGlsZEV2ZW50TmFtZSA9IG51bGw7IC8vIEFycmF5IGNvbnRhaW5pbmcgYWxsIG5ld2x5IGNyZWF0ZWQgc3BlY2lmaWMgZXZlbnRzLgoKICBjb25zdCBuZXdFdmVudE5vZGVzID0gW107IC8vIFdoaWxlIGxvb3AgY2FuJ3QgY2hlY2sgZm9yICc6JyBpbmRleCBiZWNhdXNlIHdlIGhhdmUgdG8gaGFuZGxlIGdlbmVyaWMgZXZlbnRzIHRvby4KICAvLyBJbiBlYWNoIGxvb3AsIHdlIHRydW5jYXRlIGV2ZW50IG5hbWUsIGdvaW5nIGZyb20gdGhlIG1vc3Qgc3BlY2lmaWMgbmFtZSB0byB0aGUgZ2VuZXJpYyBvbmUuCiAgLy8gSS5lLiBmb286YmFyOmFiYyAtPiBmb286YmFyIC0+IGZvby4KCiAgd2hpbGUgKG5hbWUgIT09ICcnKSB7CiAgICBpZiAoZXZlbnRzW25hbWVdKSB7CiAgICAgIC8vIElmIHRoZSBjdXJyZW50bHkgcHJvY2Vzc2VkIGV2ZW50IG5hbWUgaXMgYWxyZWFkeSByZWdpc3RlcmVkLCB3ZSBjYW4gYmUgc3VyZQogICAgICAvLyB0aGF0IGl0IGFscmVhZHkgaGFzIGFsbCB0aGUgc3RydWN0dXJlIGNyZWF0ZWQsIHNvIHdlIGNhbiBicmVhayB0aGUgbG9vcCBoZXJlCiAgICAgIC8vIGFzIG5vIG1vcmUgZXZlbnRzIG5lZWQgdG8gYmUgcmVnaXN0ZXJlZC4KICAgICAgYnJlYWs7CiAgICB9IC8vIElmIHRoaXMgZXZlbnQgaXMgbm90IHlldCByZWdpc3RlcmVkLCBjcmVhdGUgYSBuZXcgb2JqZWN0IGZvciBpdC4KCgogICAgZXZlbnRzW25hbWVdID0gbWFrZUV2ZW50Tm9kZSgpOyAvLyBBZGQgaXQgdG8gdGhlIGFycmF5IHdpdGggbmV3bHkgY3JlYXRlZCBldmVudHMuCgogICAgbmV3RXZlbnROb2Rlcy5wdXNoKGV2ZW50c1tuYW1lXSk7IC8vIEFkZCBwcmV2aW91c2x5IHByb2Nlc3NlZCBldmVudCBuYW1lIGFzIGEgY2hpbGQgb2YgdGhpcyBldmVudC4KCiAgICBpZiAoY2hpbGRFdmVudE5hbWUpIHsKICAgICAgZXZlbnRzW25hbWVdLmNoaWxkRXZlbnRzLnB1c2goY2hpbGRFdmVudE5hbWUpOwogICAgfQoKICAgIGNoaWxkRXZlbnROYW1lID0gbmFtZTsgLy8gSWYgYC5sYXN0SW5kZXhPZigpYCByZXR1cm5zIC0xLCBgLnN1YnN0cigpYCB3aWxsIHJldHVybiAnJyB3aGljaCB3aWxsIGJyZWFrIHRoZSBsb29wLgoKICAgIG5hbWUgPSBuYW1lLnN1YnN0cigwLCBuYW1lLmxhc3RJbmRleE9mKCc6JykpOwogIH0KCiAgaWYgKG5hbWUgIT09ICcnKSB7CiAgICAvLyBJZiBuYW1lIGlzIG5vdCBlbXB0eSwgd2UgZm91bmQgYW4gYWxyZWFkeSByZWdpc3RlcmVkIGV2ZW50IHRoYXQgd2FzIGEgcGFyZW50IG9mIHRoZQogICAgLy8gZXZlbnQgd2Ugd2FudGVkIHRvIHJlZ2lzdGVyLgogICAgLy8gQ29weSB0aGF0IGV2ZW50J3MgY2FsbGJhY2tzIHRvIG5ld2x5IHJlZ2lzdGVyZWQgZXZlbnRzLgogICAgZm9yIChjb25zdCBub2RlIG9mIG5ld0V2ZW50Tm9kZXMpIHsKICAgICAgbm9kZS5jYWxsYmFja3MgPSBldmVudHNbbmFtZV0uY2FsbGJhY2tzLnNsaWNlKCk7CiAgICB9IC8vIEFkZCBsYXN0IG5ld2x5IGNyZWF0ZWQgZXZlbnQgdG8gdGhlIGFscmVhZHkgcmVnaXN0ZXJlZCBldmVudC4KCgogICAgZXZlbnRzW25hbWVdLmNoaWxkRXZlbnRzLnB1c2goY2hpbGRFdmVudE5hbWUpOwogIH0KfSAvLyBHZXRzIGFuIGFycmF5IGNvbnRhaW5pbmcgY2FsbGJhY2tzIGxpc3QgZm9yIGEgZ2l2ZW4gZXZlbnQgYW5kIGl0J3MgbW9yZSBzcGVjaWZpYyBldmVudHMuCi8vIEkuZS4gaWYgZ2l2ZW4gZXZlbnQgaXMgZm9vOmJhciBhbmQgdGhlcmUgaXMgYWxzbyBmb286YmFyOmFiYyBldmVudCByZWdpc3RlcmVkLCB0aGlzIHdpbGwKLy8gcmV0dXJuIGNhbGxiYWNrIGxpc3Qgb2YgZm9vOmJhciBhbmQgZm9vOmJhcjphYmMgKGJ1dCBub3QgZm9vKS4KCgpmdW5jdGlvbiBnZXRDYWxsYmFja3NMaXN0c0Zvck5hbWVzcGFjZShzb3VyY2UsIGV2ZW50TmFtZSkgewogIGNvbnN0IGV2ZW50Tm9kZSA9IGdldEV2ZW50cyhzb3VyY2UpW2V2ZW50TmFtZV07CgogIGlmICghZXZlbnROb2RlKSB7CiAgICByZXR1cm4gW107CiAgfQoKICBsZXQgY2FsbGJhY2tzTGlzdHMgPSBbZXZlbnROb2RlLmNhbGxiYWNrc107CgogIGZvciAobGV0IGkgPSAwOyBpIDwgZXZlbnROb2RlLmNoaWxkRXZlbnRzLmxlbmd0aDsgaSsrKSB7CiAgICBjb25zdCBjaGlsZENhbGxiYWNrc0xpc3RzID0gZ2V0Q2FsbGJhY2tzTGlzdHNGb3JOYW1lc3BhY2Uoc291cmNlLCBldmVudE5vZGUuY2hpbGRFdmVudHNbaV0pOwogICAgY2FsbGJhY2tzTGlzdHMgPSBjYWxsYmFja3NMaXN0cy5jb25jYXQoY2hpbGRDYWxsYmFja3NMaXN0cyk7CiAgfQoKICByZXR1cm4gY2FsbGJhY2tzTGlzdHM7Cn0gLy8gR2V0IHRoZSBsaXN0IG9mIGNhbGxiYWNrcyBmb3IgYSBnaXZlbiBldmVudCwgYnV0IG9ubHkgaWYgdGhlcmUgYW55IGNhbGxiYWNrcyBoYXZlIGJlZW4gcmVnaXN0ZXJlZC4KLy8gSWYgdGhlcmUgYXJlIG5vIGNhbGxiYWNrcyByZWdpc3RlcmVkIGZvciBnaXZlbiBldmVudCwgaXQgY2hlY2tzIGlmIHRoaXMgaXMgYSBzcGVjaWZpYyBldmVudCBhbmQgbG9va3MKLy8gZm9yIGNhbGxiYWNrcyBmb3IgaXQncyBtb3JlIGdlbmVyaWMgdmVyc2lvbi4KCgpmdW5jdGlvbiBnZXRDYWxsYmFja3NGb3JFdmVudChzb3VyY2UsIGV2ZW50TmFtZSkgewogIGxldCBldmVudDsKCiAgaWYgKCFzb3VyY2UuX2V2ZW50cyB8fCAhKGV2ZW50ID0gc291cmNlLl9ldmVudHNbZXZlbnROYW1lXSkgfHwgIWV2ZW50LmNhbGxiYWNrcy5sZW5ndGgpIHsKICAgIC8vIFRoZXJlIGFyZSBubyBjYWxsYmFja3MgcmVnaXN0ZXJlZCBmb3Igc3BlY2lmaWVkIGV2ZW50TmFtZS4KICAgIC8vIEJ1dCB0aGlzIGNvdWxkIGJlIGEgc3BlY2lmaWMtdHlwZSBldmVudCB0aGF0IGlzIGluIGEgbmFtZXNwYWNlLgogICAgaWYgKGV2ZW50TmFtZS5pbmRleE9mKCc6JykgPiAtMSkgewogICAgICAvLyBJZiB0aGUgZXZlbnROYW1lIGlzIHNwZWNpZmljLCB0cnkgdG8gZmluZCBjYWxsYmFjayBsaXN0cyBmb3IgbW9yZSBnZW5lcmljIGV2ZW50LgogICAgICByZXR1cm4gZ2V0Q2FsbGJhY2tzRm9yRXZlbnQoc291cmNlLCBldmVudE5hbWUuc3Vic3RyKDAsIGV2ZW50TmFtZS5sYXN0SW5kZXhPZignOicpKSk7CiAgICB9IGVsc2UgewogICAgICAvLyBJZiB0aGlzIGlzIGEgdG9wLWxldmVsIGdlbmVyaWMgZXZlbnQsIHJldHVybiBudWxsOwogICAgICByZXR1cm4gbnVsbDsKICAgIH0KICB9CgogIHJldHVybiBldmVudC5jYWxsYmFja3M7Cn0gLy8gRmlyZXMgZGVsZWdhdGVkIGV2ZW50cyBmb3IgZ2l2ZW4gbWFwIG9mIGRlc3RpbmF0aW9ucy4KLy8KLy8gQHByaXZhdGUKLy8gKiBAcGFyYW0ge01hcC48dXRpbHMuRW1pdHRlcj59IGRlc3RpbmF0aW9ucyBBIG1hcCBjb250YWluaW5nCi8vIGBbIHtAbGluayBtb2R1bGU6dXRpbHMvZW1pdHRlcm1peGlufkVtaXR0ZXJ9LCAiZXZlbnQgbmFtZSIgXWAgcGFpciBkZXN0aW5hdGlvbnMuCi8vICogQHBhcmFtIHt1dGlscy5FdmVudEluZm99IGV2ZW50SW5mbyBUaGUgb3JpZ2luYWwgZXZlbnQgaW5mbyBvYmplY3QuCi8vICogQHBhcmFtIHtBcnJheS48Kj59IGZpcmVBcmdzIEFyZ3VtZW50cyB0aGUgb3JpZ2luYWwgZXZlbnQgd2FzIGZpcmVkIHdpdGguCgoKZnVuY3Rpb24gZmlyZURlbGVnYXRlZEV2ZW50cyhkZXN0aW5hdGlvbnMsIGV2ZW50SW5mbywgZmlyZUFyZ3MpIHsKICBmb3IgKGxldCBbZW1pdHRlciwgbmFtZV0gb2YgZGVzdGluYXRpb25zKSB7CiAgICBpZiAoIW5hbWUpIHsKICAgICAgbmFtZSA9IGV2ZW50SW5mby5uYW1lOwogICAgfSBlbHNlIGlmICh0eXBlb2YgbmFtZSA9PSAnZnVuY3Rpb24nKSB7CiAgICAgIG5hbWUgPSBuYW1lKGV2ZW50SW5mby5uYW1lKTsKICAgIH0KCiAgICBjb25zdCBkZWxlZ2F0ZWRJbmZvID0gbmV3IEV2ZW50SW5mbyhldmVudEluZm8uc291cmNlLCBuYW1lKTsKICAgIGRlbGVnYXRlZEluZm8ucGF0aCA9IFsuLi5ldmVudEluZm8ucGF0aF07CiAgICBlbWl0dGVyLmZpcmUoZGVsZWdhdGVkSW5mbywgLi4uZmlyZUFyZ3MpOwogIH0KfSAvLyBSZW1vdmVzIGNhbGxiYWNrIGZyb20gZW1pdHRlciBmb3IgZ2l2ZW4gZXZlbnQuCi8vCi8vIEBwYXJhbSB7bW9kdWxlOnV0aWxzL2VtaXR0ZXJtaXhpbn5FbWl0dGVyfSBlbWl0dGVyCi8vIEBwYXJhbSB7U3RyaW5nfSBldmVudAovLyBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjawoKCmZ1bmN0aW9uIHJlbW92ZUNhbGxiYWNrKGVtaXR0ZXIsIGV2ZW50LCBjYWxsYmFjaykgewogIGNvbnN0IGxpc3RzID0gZ2V0Q2FsbGJhY2tzTGlzdHNGb3JOYW1lc3BhY2UoZW1pdHRlciwgZXZlbnQpOwoKICBmb3IgKGNvbnN0IGNhbGxiYWNrcyBvZiBsaXN0cykgewogICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHsKICAgICAgaWYgKGNhbGxiYWNrc1tpXS5jYWxsYmFjayA9PSBjYWxsYmFjaykgewogICAgICAgIC8vIFJlbW92ZSB0aGUgY2FsbGJhY2sgZnJvbSB0aGUgbGlzdCAoZml4aW5nIHRoZSBuZXh0IGluZGV4KS4KICAgICAgICBjYWxsYmFja3Muc3BsaWNlKGksIDEpOwogICAgICAgIGktLTsKICAgICAgfQogICAgfQogIH0KfQovKioKICogVGhlIHJldHVybiB2YWx1ZSBvZiB7QGxpbmsgfkVtaXR0ZXJNaXhpbiNkZWxlZ2F0ZX0uCiAqCiAqIEBpbnRlcmZhY2UgbW9kdWxlOnV0aWxzL2VtaXR0ZXJtaXhpbn5FbWl0dGVyTWl4aW5EZWxlZ2F0ZUNoYWluCiAqLwoKLyoqCiAqIFNlbGVjdHMgZGVzdGluYXRpb24gZm9yIHtAbGluayBtb2R1bGU6dXRpbHMvZW1pdHRlcm1peGlufkVtaXR0ZXJNaXhpbiNkZWxlZ2F0ZX0gZXZlbnRzLgogKgogKiBAbWV0aG9kICN0bwogKiBAcGFyYW0ge21vZHVsZTp1dGlscy9lbWl0dGVybWl4aW5+RW1pdHRlcn0gZW1pdHRlciBBbiBgRW1pdHRlck1peGluYCBpbnN0YW5jZSB3aGljaCBpcyB0aGUgZGVzdGluYXRpb24gZm9yIGRlbGVnYXRlZCBldmVudHMuCiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBbbmFtZU9yRnVuY3Rpb25dIEEgY3VzdG9tIGV2ZW50IG5hbWUgb3IgZnVuY3Rpb24gd2hpY2ggY29udmVydHMgdGhlIG9yaWdpbmFsIG5hbWUgc3RyaW5nLgogKi8="},{"version":3,"sources":["/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-utils/src/emittermixin.js"],"names":["EventInfo","uid","priorities","CKEditorError","_listeningTo","Symbol","_emitterId","EmitterMixin","on","event","callback","options","listenTo","once","wasFired","onceCallback","args","off","call","stopListening","emitter","emitterInfo","eventCallbacks","emitters","_getEmitterId","_setEmitterId","emitterId","callbacks","push","createEventNamespace","lists","getCallbacksListsForNamespace","priority","get","callbackDefinition","added","i","length","splice","removeCallback","pop","fire","eventOrInfo","eventInfo","name","getCallbacksForEvent","path","callbackArgs","Array","from","apply","called","stop","_delegations","destinations","passAllDestinations","fireDelegatedEvents","return","err","rethrowUnexpectedError","delegate","events","to","nameOrFunction","Map","forEach","eventName","set","stopDelegating","clear","delete","_getEmitterListenedTo","listeningEmitter","listenedToEmitterId","id","getEvents","source","_events","Object","defineProperty","value","makeEventNode","childEvents","childEventName","newEventNodes","substr","lastIndexOf","node","slice","eventNode","callbacksLists","childCallbacksLists","concat","indexOf","fireArgs","delegatedInfo"],"mappings":"AAAA;;;;;AAKA;;;AAIA,OAAOA,SAAP,MAAsB,aAAtB;AACA,OAAOC,GAAP,MAAgB,OAAhB;AACA,OAAOC,UAAP,MAAuB,cAAvB,C,CAEA;;AACA,OAAO,WAAP;AACA,OAAOC,aAAP,MAA0B,iBAA1B;;AAEA,MAAMC,YAAY,GAAGC,MAAM,CAAE,aAAF,CAA3B;;AACA,MAAMC,UAAU,GAAGD,MAAM,CAAE,WAAF,CAAzB;AAEA;;;;;;;;AAMA,MAAME,YAAY,GAAG;AACpB;;;AAGAC,EAAAA,EAAE,CAAEC,KAAF,EAASC,QAAT,EAAmBC,OAAO,GAAG,EAA7B,EAAkC;AACnC,SAAKC,QAAL,CAAe,IAAf,EAAqBH,KAArB,EAA4BC,QAA5B,EAAsCC,OAAtC;AACA,GANmB;;AAQpB;;;AAGAE,EAAAA,IAAI,CAAEJ,KAAF,EAASC,QAAT,EAAmBC,OAAnB,EAA6B;AAChC,QAAIG,QAAQ,GAAG,KAAf;;AAEA,UAAMC,YAAY,GAAG,UAAUN,KAAV,EAAiB,GAAGO,IAApB,EAA2B;AAC/C;AACA;AACA,UAAK,CAACF,QAAN,EAAiB;AAChBA,QAAAA,QAAQ,GAAG,IAAX,CADgB,CAGhB;;AACAL,QAAAA,KAAK,CAACQ,GAAN,GAJgB,CAMhB;;AACAP,QAAAA,QAAQ,CAACQ,IAAT,CAAe,IAAf,EAAqBT,KAArB,EAA4B,GAAGO,IAA/B;AACA;AACD,KAZD,CAHgC,CAiBhC;;;AACA,SAAKJ,QAAL,CAAe,IAAf,EAAqBH,KAArB,EAA4BM,YAA5B,EAA0CJ,OAA1C;AACA,GA9BmB;;AAgCpB;;;AAGAM,EAAAA,GAAG,CAAER,KAAF,EAASC,QAAT,EAAoB;AACtB,SAAKS,aAAL,CAAoB,IAApB,EAA0BV,KAA1B,EAAiCC,QAAjC;AACA,GArCmB;;AAuCpB;;;AAGAE,EAAAA,QAAQ,CAAEQ,OAAF,EAAWX,KAAX,EAAkBC,QAAlB,EAA4BC,OAAO,GAAG,EAAtC,EAA2C;AAClD,QAAIU,WAAJ,EAAiBC,cAAjB,CADkD,CAGlD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAK,CAAC,KAAMlB,YAAN,CAAN,EAA6B;AAC5B,WAAMA,YAAN,IAAuB,EAAvB;AACA;;AAED,UAAMmB,QAAQ,GAAG,KAAMnB,YAAN,CAAjB;;AAEA,QAAK,CAACoB,aAAa,CAAEJ,OAAF,CAAnB,EAAiC;AAChCK,MAAAA,aAAa,CAAEL,OAAF,CAAb;AACA;;AAED,UAAMM,SAAS,GAAGF,aAAa,CAAEJ,OAAF,CAA/B;;AAEA,QAAK,EAAGC,WAAW,GAAGE,QAAQ,CAAEG,SAAF,CAAzB,CAAL,EAAgD;AAC/CL,MAAAA,WAAW,GAAGE,QAAQ,CAAEG,SAAF,CAAR,GAAwB;AACrCN,QAAAA,OADqC;AAErCO,QAAAA,SAAS,EAAE;AAF0B,OAAtC;AAIA;;AAED,QAAK,EAAGL,cAAc,GAAGD,WAAW,CAACM,SAAZ,CAAuBlB,KAAvB,CAApB,CAAL,EAA4D;AAC3Da,MAAAA,cAAc,GAAGD,WAAW,CAACM,SAAZ,CAAuBlB,KAAvB,IAAiC,EAAlD;AACA;;AAEDa,IAAAA,cAAc,CAACM,IAAf,CAAqBlB,QAArB,EAxCkD,CA0ClD;;AACAmB,IAAAA,oBAAoB,CAAET,OAAF,EAAWX,KAAX,CAApB;AACA,UAAMqB,KAAK,GAAGC,6BAA6B,CAAEX,OAAF,EAAWX,KAAX,CAA3C;AACA,UAAMuB,QAAQ,GAAG9B,UAAU,CAAC+B,GAAX,CAAgBtB,OAAO,CAACqB,QAAxB,CAAjB;AAEA,UAAME,kBAAkB,GAAG;AAC1BxB,MAAAA,QAD0B;AAE1BsB,MAAAA;AAF0B,KAA3B,CA/CkD,CAoDlD;;AACA,SAAM,MAAML,SAAZ,IAAyBG,KAAzB,EAAiC;AAChC;AACA,UAAIK,KAAK,GAAG,KAAZ;;AAEA,WAAM,IAAIC,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAGT,SAAS,CAACU,MAA/B,EAAuCD,CAAC,EAAxC,EAA6C;AAC5C,YAAKT,SAAS,CAAES,CAAF,CAAT,CAAeJ,QAAf,GAA0BA,QAA/B,EAA0C;AACzCL,UAAAA,SAAS,CAACW,MAAV,CAAkBF,CAAlB,EAAqB,CAArB,EAAwBF,kBAAxB;AACAC,UAAAA,KAAK,GAAG,IAAR;AAEA;AACA;AACD,OAX+B,CAahC;;;AACA,UAAK,CAACA,KAAN,EAAc;AACbR,QAAAA,SAAS,CAACC,IAAV,CAAgBM,kBAAhB;AACA;AACD;AACD,GAjHmB;;AAmHpB;;;AAGAf,EAAAA,aAAa,CAAEC,OAAF,EAAWX,KAAX,EAAkBC,QAAlB,EAA6B;AACzC,UAAMa,QAAQ,GAAG,KAAMnB,YAAN,CAAjB;;AACA,QAAIsB,SAAS,GAAGN,OAAO,IAAII,aAAa,CAAEJ,OAAF,CAAxC;;AACA,UAAMC,WAAW,GAAGE,QAAQ,IAAIG,SAAZ,IAAyBH,QAAQ,CAAEG,SAAF,CAArD;AACA,UAAMJ,cAAc,GAAGD,WAAW,IAAIZ,KAAf,IAAwBY,WAAW,CAACM,SAAZ,CAAuBlB,KAAvB,CAA/C,CAJyC,CAMzC;;AACA,QAAK,CAACc,QAAD,IAAeH,OAAO,IAAI,CAACC,WAA3B,IAA8CZ,KAAK,IAAI,CAACa,cAA7D,EAAgF;AAC/E;AACA,KATwC,CAWzC;;;AACA,QAAKZ,QAAL,EAAgB;AACf6B,MAAAA,cAAc,CAAEnB,OAAF,EAAWX,KAAX,EAAkBC,QAAlB,CAAd;AACA,KAFD,CAGA;AAHA,SAIK,IAAKY,cAAL,EAAsB;AAC1B,eAAUZ,QAAQ,GAAGY,cAAc,CAACkB,GAAf,EAArB,EAA8C;AAC7CD,UAAAA,cAAc,CAAEnB,OAAF,EAAWX,KAAX,EAAkBC,QAAlB,CAAd;AACA;;AAED,eAAOW,WAAW,CAACM,SAAZ,CAAuBlB,KAAvB,CAAP;AACA,OANI,CAOL;AAPK,WAQA,IAAKY,WAAL,EAAmB;AACvB,eAAMZ,KAAN,IAAeY,WAAW,CAACM,SAA3B,EAAuC;AACtC,iBAAKR,aAAL,CAAoBC,OAApB,EAA6BX,KAA7B;AACA;;AACD,iBAAOc,QAAQ,CAAEG,SAAF,CAAf;AACA,SALI,CAML;AANK,aAOA;AACJ,iBAAMA,SAAN,IAAmBH,QAAnB,EAA8B;AAC7B,mBAAKJ,aAAL,CAAoBI,QAAQ,CAAEG,SAAF,CAAR,CAAsBN,OAA1C;AACA;;AACD,mBAAO,KAAMhB,YAAN,CAAP;AACA;AACD,GA3JmB;;AA6JpB;;;AAGAqC,EAAAA,IAAI,CAAEC,WAAF,EAAe,GAAG1B,IAAlB,EAAyB;AAC5B,QAAI;AACH,YAAM2B,SAAS,GAAGD,WAAW,YAAY1C,SAAvB,GAAmC0C,WAAnC,GAAiD,IAAI1C,SAAJ,CAAe,IAAf,EAAqB0C,WAArB,CAAnE;AACA,YAAMjC,KAAK,GAAGkC,SAAS,CAACC,IAAxB;AACA,UAAIjB,SAAS,GAAGkB,oBAAoB,CAAE,IAAF,EAAQpC,KAAR,CAApC,CAHG,CAKH;;AACAkC,MAAAA,SAAS,CAACG,IAAV,CAAelB,IAAf,CAAqB,IAArB,EANG,CAQH;;AACA,UAAKD,SAAL,EAAiB;AAChB;AACA,cAAMoB,YAAY,GAAG,CAAEJ,SAAF,EAAa,GAAG3B,IAAhB,CAArB,CAFgB,CAIhB;AACA;AACA;AACA;AACA;;AACAW,QAAAA,SAAS,GAAGqB,KAAK,CAACC,IAAN,CAAYtB,SAAZ,CAAZ;;AAEA,aAAM,IAAIS,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAGT,SAAS,CAACU,MAA/B,EAAuCD,CAAC,EAAxC,EAA6C;AAC5CT,UAAAA,SAAS,CAAES,CAAF,CAAT,CAAe1B,QAAf,CAAwBwC,KAAxB,CAA+B,IAA/B,EAAqCH,YAArC,EAD4C,CAG5C;;AACA,cAAKJ,SAAS,CAAC1B,GAAV,CAAckC,MAAnB,EAA4B;AAC3B;AACA,mBAAOR,SAAS,CAAC1B,GAAV,CAAckC,MAArB;AAEAZ,YAAAA,cAAc,CAAE,IAAF,EAAQ9B,KAAR,EAAekB,SAAS,CAAES,CAAF,CAAT,CAAe1B,QAA9B,CAAd;AACA,WAT2C,CAW5C;;;AACA,cAAKiC,SAAS,CAACS,IAAV,CAAeD,MAApB,EAA6B;AAC5B;AACA;AACD;AACD,OApCE,CAsCH;;;AACA,UAAK,KAAKE,YAAV,EAAyB;AACxB,cAAMC,YAAY,GAAG,KAAKD,YAAL,CAAkBpB,GAAlB,CAAuBxB,KAAvB,CAArB;;AACA,cAAM8C,mBAAmB,GAAG,KAAKF,YAAL,CAAkBpB,GAAlB,CAAuB,GAAvB,CAA5B;;AAEA,YAAKqB,YAAL,EAAoB;AACnBE,UAAAA,mBAAmB,CAAEF,YAAF,EAAgBX,SAAhB,EAA2B3B,IAA3B,CAAnB;AACA;;AAED,YAAKuC,mBAAL,EAA2B;AAC1BC,UAAAA,mBAAmB,CAAED,mBAAF,EAAuBZ,SAAvB,EAAkC3B,IAAlC,CAAnB;AACA;AACD;;AAED,aAAO2B,SAAS,CAACc,MAAjB;AACA,KArDD,CAqDE,OAAQC,GAAR,EAAc;AACf;;AACA;AACAvD,MAAAA,aAAa,CAACwD,sBAAd,CAAsCD,GAAtC,EAA2C,IAA3C;AACA;AACD,GA3NmB;;AA6NpB;;;AAGAE,EAAAA,QAAQ,CAAE,GAAGC,MAAL,EAAc;AACrB,WAAO;AACNC,MAAAA,EAAE,EAAE,CAAE1C,OAAF,EAAW2C,cAAX,KAA+B;AAClC,YAAK,CAAC,KAAKV,YAAX,EAA0B;AACzB,eAAKA,YAAL,GAAoB,IAAIW,GAAJ,EAApB;AACA,SAHiC,CAKlC;AACA;;;AACAH,QAAAA,MAAM,CAACI,OAAP,CAAgBC,SAAS,IAAI;AAC5B,gBAAMZ,YAAY,GAAG,KAAKD,YAAL,CAAkBpB,GAAlB,CAAuBiC,SAAvB,CAArB;;AAEA,cAAK,CAACZ,YAAN,EAAqB;AACpB,iBAAKD,YAAL,CAAkBc,GAAlB,CAAuBD,SAAvB,EAAkC,IAAIF,GAAJ,CAAS,CAAE,CAAE5C,OAAF,EAAW2C,cAAX,CAAF,CAAT,CAAlC;AACA,WAFD,MAEO;AACNT,YAAAA,YAAY,CAACa,GAAb,CAAkB/C,OAAlB,EAA2B2C,cAA3B;AACA;AACD,SARD;AASA;AAjBK,KAAP;AAmBA,GApPmB;;AAsPpB;;;AAGAK,EAAAA,cAAc,CAAE3D,KAAF,EAASW,OAAT,EAAmB;AAChC,QAAK,CAAC,KAAKiC,YAAX,EAA0B;AACzB;AACA;;AAED,QAAK,CAAC5C,KAAN,EAAc;AACb,WAAK4C,YAAL,CAAkBgB,KAAlB;AACA,KAFD,MAEO,IAAK,CAACjD,OAAN,EAAgB;AACtB,WAAKiC,YAAL,CAAkBiB,MAAlB,CAA0B7D,KAA1B;AACA,KAFM,MAEA;AACN,YAAM6C,YAAY,GAAG,KAAKD,YAAL,CAAkBpB,GAAlB,CAAuBxB,KAAvB,CAArB;;AAEA,UAAK6C,YAAL,EAAoB;AACnBA,QAAAA,YAAY,CAACgB,MAAb,CAAqBlD,OAArB;AACA;AACD;AACD;;AAzQmB,CAArB;AA4QA,eAAeb,YAAf;AAEA;;;;;;;;AAQA;;;;;;;;;;;;;;;AAeA;;;;;;;;;;;;;AAaA;;;;;;;;;AASA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8BA;;;;;;;;;;;;;;;;AAgBA;;;;;;;;;;;;;;AAcA;;;;;;;;;;;;;;;;;;;AAmBA;;;;;;;;;;;;;AAaA;;;;;;;;;;AASA,OAAO,SAASgE,qBAAT,CAAgCC,gBAAhC,EAAkDC,mBAAlD,EAAwE;AAC9E,MAAKD,gBAAgB,CAAEpE,YAAF,CAAhB,IAAoCoE,gBAAgB,CAAEpE,YAAF,CAAhB,CAAkCqE,mBAAlC,CAAzC,EAAmG;AAClG,WAAOD,gBAAgB,CAAEpE,YAAF,CAAhB,CAAkCqE,mBAAlC,EAAwDrD,OAA/D;AACA;;AAED,SAAO,IAAP;AACA;AAED;;;;;;;;;;AASA,OAAO,SAASK,aAAT,CAAwBL,OAAxB,EAAiCsD,EAAjC,EAAsC;AAC5C,MAAK,CAACtD,OAAO,CAAEd,UAAF,CAAb,EAA8B;AAC7Bc,IAAAA,OAAO,CAAEd,UAAF,CAAP,GAAwBoE,EAAE,IAAIzE,GAAG,EAAjC;AACA;AACD;AAED;;;;;;;AAMA,OAAO,SAASuB,aAAT,CAAwBJ,OAAxB,EAAkC;AACxC,SAAOA,OAAO,CAAEd,UAAF,CAAd;AACA,C,CAED;AACA;AACA;;AACA,SAASqE,SAAT,CAAoBC,MAApB,EAA6B;AAC5B,MAAK,CAACA,MAAM,CAACC,OAAb,EAAuB;AACtBC,IAAAA,MAAM,CAACC,cAAP,CAAuBH,MAAvB,EAA+B,SAA/B,EAA0C;AACzCI,MAAAA,KAAK,EAAE;AADkC,KAA1C;AAGA;;AAED,SAAOJ,MAAM,CAACC,OAAd;AACA,C,CAED;;;AACA,SAASI,aAAT,GAAyB;AACxB,SAAO;AACNtD,IAAAA,SAAS,EAAE,EADL;AAENuD,IAAAA,WAAW,EAAE;AAFP,GAAP;AAIA,C,CAED;AACA;AACA;AACA;AACA;;;AACA,SAASrD,oBAAT,CAA+B+C,MAA/B,EAAuCV,SAAvC,EAAmD;AAClD,QAAML,MAAM,GAAGc,SAAS,CAAEC,MAAF,CAAxB,CADkD,CAGlD;;AACA,MAAKf,MAAM,CAAEK,SAAF,CAAX,EAA2B;AAC1B;AACA;AACA,GAPiD,CASlD;AACA;AACA;AACA;AAEA;;;AACA,MAAItB,IAAI,GAAGsB,SAAX,CAfkD,CAgBlD;;AACA,MAAIiB,cAAc,GAAG,IAArB,CAjBkD,CAmBlD;;AACA,QAAMC,aAAa,GAAG,EAAtB,CApBkD,CAsBlD;AACA;AACA;;AACA,SAAQxC,IAAI,KAAK,EAAjB,EAAsB;AACrB,QAAKiB,MAAM,CAAEjB,IAAF,CAAX,EAAsB;AACrB;AACA;AACA;AACA;AACA,KANoB,CAQrB;;;AACAiB,IAAAA,MAAM,CAAEjB,IAAF,CAAN,GAAiBqC,aAAa,EAA9B,CATqB,CAUrB;;AACAG,IAAAA,aAAa,CAACxD,IAAd,CAAoBiC,MAAM,CAAEjB,IAAF,CAA1B,EAXqB,CAarB;;AACA,QAAKuC,cAAL,EAAsB;AACrBtB,MAAAA,MAAM,CAAEjB,IAAF,CAAN,CAAesC,WAAf,CAA2BtD,IAA3B,CAAiCuD,cAAjC;AACA;;AAEDA,IAAAA,cAAc,GAAGvC,IAAjB,CAlBqB,CAmBrB;;AACAA,IAAAA,IAAI,GAAGA,IAAI,CAACyC,MAAL,CAAa,CAAb,EAAgBzC,IAAI,CAAC0C,WAAL,CAAkB,GAAlB,CAAhB,CAAP;AACA;;AAED,MAAK1C,IAAI,KAAK,EAAd,EAAmB;AAClB;AACA;AAEA;AACA,SAAM,MAAM2C,IAAZ,IAAoBH,aAApB,EAAoC;AACnCG,MAAAA,IAAI,CAAC5D,SAAL,GAAiBkC,MAAM,CAAEjB,IAAF,CAAN,CAAejB,SAAf,CAAyB6D,KAAzB,EAAjB;AACA,KAPiB,CASlB;;;AACA3B,IAAAA,MAAM,CAAEjB,IAAF,CAAN,CAAesC,WAAf,CAA2BtD,IAA3B,CAAiCuD,cAAjC;AACA;AACD,C,CAED;AACA;AACA;;;AACA,SAASpD,6BAAT,CAAwC6C,MAAxC,EAAgDV,SAAhD,EAA4D;AAC3D,QAAMuB,SAAS,GAAGd,SAAS,CAAEC,MAAF,CAAT,CAAqBV,SAArB,CAAlB;;AAEA,MAAK,CAACuB,SAAN,EAAkB;AACjB,WAAO,EAAP;AACA;;AAED,MAAIC,cAAc,GAAG,CAAED,SAAS,CAAC9D,SAAZ,CAArB;;AAEA,OAAM,IAAIS,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAGqD,SAAS,CAACP,WAAV,CAAsB7C,MAA3C,EAAmDD,CAAC,EAApD,EAAyD;AACxD,UAAMuD,mBAAmB,GAAG5D,6BAA6B,CAAE6C,MAAF,EAAUa,SAAS,CAACP,WAAV,CAAuB9C,CAAvB,CAAV,CAAzD;AAEAsD,IAAAA,cAAc,GAAGA,cAAc,CAACE,MAAf,CAAuBD,mBAAvB,CAAjB;AACA;;AAED,SAAOD,cAAP;AACA,C,CAED;AACA;AACA;;;AACA,SAAS7C,oBAAT,CAA+B+B,MAA/B,EAAuCV,SAAvC,EAAmD;AAClD,MAAIzD,KAAJ;;AAEA,MAAK,CAACmE,MAAM,CAACC,OAAR,IAAmB,EAAGpE,KAAK,GAAGmE,MAAM,CAACC,OAAP,CAAgBX,SAAhB,CAAX,CAAnB,IAA+D,CAACzD,KAAK,CAACkB,SAAN,CAAgBU,MAArF,EAA8F;AAC7F;AACA;AACA,QAAK6B,SAAS,CAAC2B,OAAV,CAAmB,GAAnB,IAA2B,CAAC,CAAjC,EAAqC;AACpC;AACA,aAAOhD,oBAAoB,CAAE+B,MAAF,EAAUV,SAAS,CAACmB,MAAV,CAAkB,CAAlB,EAAqBnB,SAAS,CAACoB,WAAV,CAAuB,GAAvB,CAArB,CAAV,CAA3B;AACA,KAHD,MAGO;AACN;AACA,aAAO,IAAP;AACA;AACD;;AAED,SAAO7E,KAAK,CAACkB,SAAb;AACA,C,CAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAS6B,mBAAT,CAA8BF,YAA9B,EAA4CX,SAA5C,EAAuDmD,QAAvD,EAAkE;AACjE,OAAM,IAAI,CAAE1E,OAAF,EAAWwB,IAAX,CAAV,IAA+BU,YAA/B,EAA8C;AAC7C,QAAK,CAACV,IAAN,EAAa;AACZA,MAAAA,IAAI,GAAGD,SAAS,CAACC,IAAjB;AACA,KAFD,MAEO,IAAK,OAAOA,IAAP,IAAe,UAApB,EAAiC;AACvCA,MAAAA,IAAI,GAAGA,IAAI,CAAED,SAAS,CAACC,IAAZ,CAAX;AACA;;AAED,UAAMmD,aAAa,GAAG,IAAI/F,SAAJ,CAAe2C,SAAS,CAACiC,MAAzB,EAAiChC,IAAjC,CAAtB;AAEAmD,IAAAA,aAAa,CAACjD,IAAd,GAAqB,CAAE,GAAGH,SAAS,CAACG,IAAf,CAArB;AAEA1B,IAAAA,OAAO,CAACqB,IAAR,CAAcsD,aAAd,EAA6B,GAAGD,QAAhC;AACA;AACD,C,CAED;AACA;AACA;AACA;AACA;;;AACA,SAASvD,cAAT,CAAyBnB,OAAzB,EAAkCX,KAAlC,EAAyCC,QAAzC,EAAoD;AACnD,QAAMoB,KAAK,GAAGC,6BAA6B,CAAEX,OAAF,EAAWX,KAAX,CAA3C;;AAEA,OAAM,MAAMkB,SAAZ,IAAyBG,KAAzB,EAAiC;AAChC,SAAM,IAAIM,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAGT,SAAS,CAACU,MAA/B,EAAuCD,CAAC,EAAxC,EAA6C;AAC5C,UAAKT,SAAS,CAAES,CAAF,CAAT,CAAe1B,QAAf,IAA2BA,QAAhC,EAA2C;AAC1C;AACAiB,QAAAA,SAAS,CAACW,MAAV,CAAkBF,CAAlB,EAAqB,CAArB;AACAA,QAAAA,CAAC;AACD;AACD;AACD;AACD;AAED;;;;;;AAMA","sourcesContent":["/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/emittermixin\n */\n\nimport EventInfo from './eventinfo';\nimport uid from './uid';\nimport priorities from './priorities';\n\n// To check if component is loaded more than once.\nimport './version';\nimport CKEditorError from './ckeditorerror';\n\nconst _listeningTo = Symbol( 'listeningTo' );\nconst _emitterId = Symbol( 'emitterId' );\n\n/**\n * Mixin that injects the {@link ~Emitter events API} into its host.\n *\n * @mixin EmitterMixin\n * @implements module:utils/emittermixin~Emitter\n */\nconst EmitterMixin = {\n\t/**\n\t * @inheritDoc\n\t */\n\ton( event, callback, options = {} ) {\n\t\tthis.listenTo( this, event, callback, options );\n\t},\n\n\t/**\n\t * @inheritDoc\n\t */\n\tonce( event, callback, options ) {\n\t\tlet wasFired = false;\n\n\t\tconst onceCallback = function( event, ...args ) {\n\t\t\t// Ensure the callback is called only once even if the callback itself leads to re-firing the event\n\t\t\t// (which would call the callback again).\n\t\t\tif ( !wasFired ) {\n\t\t\t\twasFired = true;\n\n\t\t\t\t// Go off() at the first call.\n\t\t\t\tevent.off();\n\n\t\t\t\t// Go with the original callback.\n\t\t\t\tcallback.call( this, event, ...args );\n\t\t\t}\n\t\t};\n\n\t\t// Make a similar on() call, simply replacing the callback.\n\t\tthis.listenTo( this, event, onceCallback, options );\n\t},\n\n\t/**\n\t * @inheritDoc\n\t */\n\toff( event, callback ) {\n\t\tthis.stopListening( this, event, callback );\n\t},\n\n\t/**\n\t * @inheritDoc\n\t */\n\tlistenTo( emitter, event, callback, options = {} ) {\n\t\tlet emitterInfo, eventCallbacks;\n\n\t\t// _listeningTo contains a list of emitters that this object is listening to.\n\t\t// This list has the following format:\n\t\t//\n\t\t// _listeningTo: {\n\t\t//     emitterId: {\n\t\t//         emitter: emitter,\n\t\t//         callbacks: {\n\t\t//             event1: [ callback1, callback2, ... ]\n\t\t//             ....\n\t\t//         }\n\t\t//     },\n\t\t//     ...\n\t\t// }\n\n\t\tif ( !this[ _listeningTo ] ) {\n\t\t\tthis[ _listeningTo ] = {};\n\t\t}\n\n\t\tconst emitters = this[ _listeningTo ];\n\n\t\tif ( !_getEmitterId( emitter ) ) {\n\t\t\t_setEmitterId( emitter );\n\t\t}\n\n\t\tconst emitterId = _getEmitterId( emitter );\n\n\t\tif ( !( emitterInfo = emitters[ emitterId ] ) ) {\n\t\t\temitterInfo = emitters[ emitterId ] = {\n\t\t\t\temitter,\n\t\t\t\tcallbacks: {}\n\t\t\t};\n\t\t}\n\n\t\tif ( !( eventCallbacks = emitterInfo.callbacks[ event ] ) ) {\n\t\t\teventCallbacks = emitterInfo.callbacks[ event ] = [];\n\t\t}\n\n\t\teventCallbacks.push( callback );\n\n\t\t// Finally register the callback to the event.\n\t\tcreateEventNamespace( emitter, event );\n\t\tconst lists = getCallbacksListsForNamespace( emitter, event );\n\t\tconst priority = priorities.get( options.priority );\n\n\t\tconst callbackDefinition = {\n\t\t\tcallback,\n\t\t\tpriority\n\t\t};\n\n\t\t// Add the callback to all callbacks list.\n\t\tfor ( const callbacks of lists ) {\n\t\t\t// Add the callback to the list in the right priority position.\n\t\t\tlet added = false;\n\n\t\t\tfor ( let i = 0; i < callbacks.length; i++ ) {\n\t\t\t\tif ( callbacks[ i ].priority < priority ) {\n\t\t\t\t\tcallbacks.splice( i, 0, callbackDefinition );\n\t\t\t\t\tadded = true;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add at the end, if right place was not found.\n\t\t\tif ( !added ) {\n\t\t\t\tcallbacks.push( callbackDefinition );\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * @inheritDoc\n\t */\n\tstopListening( emitter, event, callback ) {\n\t\tconst emitters = this[ _listeningTo ];\n\t\tlet emitterId = emitter && _getEmitterId( emitter );\n\t\tconst emitterInfo = emitters && emitterId && emitters[ emitterId ];\n\t\tconst eventCallbacks = emitterInfo && event && emitterInfo.callbacks[ event ];\n\n\t\t// Stop if nothing has been listened.\n\t\tif ( !emitters || ( emitter && !emitterInfo ) || ( event && !eventCallbacks ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// All params provided. off() that single callback.\n\t\tif ( callback ) {\n\t\t\tremoveCallback( emitter, event, callback );\n\t\t}\n\t\t// Only `emitter` and `event` provided. off() all callbacks for that event.\n\t\telse if ( eventCallbacks ) {\n\t\t\twhile ( ( callback = eventCallbacks.pop() ) ) {\n\t\t\t\tremoveCallback( emitter, event, callback );\n\t\t\t}\n\n\t\t\tdelete emitterInfo.callbacks[ event ];\n\t\t}\n\t\t// Only `emitter` provided. off() all events for that emitter.\n\t\telse if ( emitterInfo ) {\n\t\t\tfor ( event in emitterInfo.callbacks ) {\n\t\t\t\tthis.stopListening( emitter, event );\n\t\t\t}\n\t\t\tdelete emitters[ emitterId ];\n\t\t}\n\t\t// No params provided. off() all emitters.\n\t\telse {\n\t\t\tfor ( emitterId in emitters ) {\n\t\t\t\tthis.stopListening( emitters[ emitterId ].emitter );\n\t\t\t}\n\t\t\tdelete this[ _listeningTo ];\n\t\t}\n\t},\n\n\t/**\n\t * @inheritDoc\n\t */\n\tfire( eventOrInfo, ...args ) {\n\t\ttry {\n\t\t\tconst eventInfo = eventOrInfo instanceof EventInfo ? eventOrInfo : new EventInfo( this, eventOrInfo );\n\t\t\tconst event = eventInfo.name;\n\t\t\tlet callbacks = getCallbacksForEvent( this, event );\n\n\t\t\t// Record that the event passed this emitter on its path.\n\t\t\teventInfo.path.push( this );\n\n\t\t\t// Handle event listener callbacks first.\n\t\t\tif ( callbacks ) {\n\t\t\t\t// Arguments passed to each callback.\n\t\t\t\tconst callbackArgs = [ eventInfo, ...args ];\n\n\t\t\t\t// Copying callbacks array is the easiest and most secure way of preventing infinite loops, when event callbacks\n\t\t\t\t// are added while processing other callbacks. Previous solution involved adding counters (unique ids) but\n\t\t\t\t// failed if callbacks were added to the queue before currently processed callback.\n\t\t\t\t// If this proves to be too inefficient, another method is to change `.on()` so callbacks are stored if same\n\t\t\t\t// event is currently processed. Then, `.fire()` at the end, would have to add all stored events.\n\t\t\t\tcallbacks = Array.from( callbacks );\n\n\t\t\t\tfor ( let i = 0; i < callbacks.length; i++ ) {\n\t\t\t\t\tcallbacks[ i ].callback.apply( this, callbackArgs );\n\n\t\t\t\t\t// Remove the callback from future requests if off() has been called.\n\t\t\t\t\tif ( eventInfo.off.called ) {\n\t\t\t\t\t\t// Remove the called mark for the next calls.\n\t\t\t\t\t\tdelete eventInfo.off.called;\n\n\t\t\t\t\t\tremoveCallback( this, event, callbacks[ i ].callback );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Do not execute next callbacks if stop() was called.\n\t\t\t\t\tif ( eventInfo.stop.called ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Delegate event to other emitters if needed.\n\t\t\tif ( this._delegations ) {\n\t\t\t\tconst destinations = this._delegations.get( event );\n\t\t\t\tconst passAllDestinations = this._delegations.get( '*' );\n\n\t\t\t\tif ( destinations ) {\n\t\t\t\t\tfireDelegatedEvents( destinations, eventInfo, args );\n\t\t\t\t}\n\n\t\t\t\tif ( passAllDestinations ) {\n\t\t\t\t\tfireDelegatedEvents( passAllDestinations, eventInfo, args );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn eventInfo.return;\n\t\t} catch ( err ) {\n\t\t\t// @if CK_DEBUG // throw err;\n\t\t\t/* istanbul ignore next */\n\t\t\tCKEditorError.rethrowUnexpectedError( err, this );\n\t\t}\n\t},\n\n\t/**\n\t * @inheritDoc\n\t */\n\tdelegate( ...events ) {\n\t\treturn {\n\t\t\tto: ( emitter, nameOrFunction ) => {\n\t\t\t\tif ( !this._delegations ) {\n\t\t\t\t\tthis._delegations = new Map();\n\t\t\t\t}\n\n\t\t\t\t// Originally there was a for..of loop which unfortunately caused an error in Babel that didn't allow\n\t\t\t\t// build an application. See: https://github.com/ckeditor/ckeditor5-react/issues/40.\n\t\t\t\tevents.forEach( eventName => {\n\t\t\t\t\tconst destinations = this._delegations.get( eventName );\n\n\t\t\t\t\tif ( !destinations ) {\n\t\t\t\t\t\tthis._delegations.set( eventName, new Map( [ [ emitter, nameOrFunction ] ] ) );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdestinations.set( emitter, nameOrFunction );\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t}\n\t\t};\n\t},\n\n\t/**\n\t * @inheritDoc\n\t */\n\tstopDelegating( event, emitter ) {\n\t\tif ( !this._delegations ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( !event ) {\n\t\t\tthis._delegations.clear();\n\t\t} else if ( !emitter ) {\n\t\t\tthis._delegations.delete( event );\n\t\t} else {\n\t\t\tconst destinations = this._delegations.get( event );\n\n\t\t\tif ( destinations ) {\n\t\t\t\tdestinations.delete( emitter );\n\t\t\t}\n\t\t}\n\t}\n};\n\nexport default EmitterMixin;\n\n/**\n * Emitter/listener interface.\n *\n * Can be easily implemented by a class by mixing the {@link module:utils/emittermixin~EmitterMixin} mixin.\n *\n * @interface Emitter\n */\n\n/**\n * Registers a callback function to be executed when an event is fired.\n *\n * Shorthand for {@link #listenTo `this.listenTo( this, event, callback, options )`} (it makes the emitter\n * listen on itself).\n *\n * @method #on\n * @param {String} event The name of the event.\n * @param {Function} callback The function to be called on event.\n * @param {Object} [options={}] Additional options.\n * @param {module:utils/priorities~PriorityString|Number} [options.priority='normal'] The priority of this event callback. The higher\n * the priority value the sooner the callback will be fired. Events having the same priority are called in the\n * order they were added.\n */\n\n/**\n * Registers a callback function to be executed on the next time the event is fired only. This is similar to\n * calling {@link #on} followed by {@link #off} in the callback.\n *\n * @method #once\n * @param {String} event The name of the event.\n * @param {Function} callback The function to be called on event.\n * @param {Object} [options={}] Additional options.\n * @param {module:utils/priorities~PriorityString|Number} [options.priority='normal'] The priority of this event callback. The higher\n * the priority value the sooner the callback will be fired. Events having the same priority are called in the\n * order they were added.\n */\n\n/**\n * Stops executing the callback on the given event.\n * Shorthand for {@link #stopListening `this.stopListening( this, event, callback )`}.\n *\n * @method #off\n * @param {String} event The name of the event.\n * @param {Function} callback The function to stop being called.\n */\n\n/**\n * Registers a callback function to be executed when an event is fired in a specific (emitter) object.\n *\n * Events can be grouped in namespaces using `:`.\n * When namespaced event is fired, it additionally fires all callbacks for that namespace.\n *\n *\t\t// myEmitter.on( ... ) is a shorthand for myEmitter.listenTo( myEmitter, ... ).\n *\t\tmyEmitter.on( 'myGroup', genericCallback );\n *\t\tmyEmitter.on( 'myGroup:myEvent', specificCallback );\n *\n *\t\t// genericCallback is fired.\n *\t\tmyEmitter.fire( 'myGroup' );\n *\t\t// both genericCallback and specificCallback are fired.\n *\t\tmyEmitter.fire( 'myGroup:myEvent' );\n *\t\t// genericCallback is fired even though there are no callbacks for \"foo\".\n *\t\tmyEmitter.fire( 'myGroup:foo' );\n *\n * An event callback can {@link module:utils/eventinfo~EventInfo#stop stop the event} and\n * set the {@link module:utils/eventinfo~EventInfo#return return value} of the {@link #fire} method.\n *\n * @method #listenTo\n * @param {module:utils/emittermixin~Emitter} emitter The object that fires the event.\n * @param {String} event The name of the event.\n * @param {Function} callback The function to be called on event.\n * @param {Object} [options={}] Additional options.\n * @param {module:utils/priorities~PriorityString|Number} [options.priority='normal'] The priority of this event callback. The higher\n * the priority value the sooner the callback will be fired. Events having the same priority are called in the\n * order they were added.\n */\n\n/**\n * Stops listening for events. It can be used at different levels:\n *\n * * To stop listening to a specific callback.\n * * To stop listening to a specific event.\n * * To stop listening to all events fired by a specific object.\n * * To stop listening to all events fired by all objects.\n *\n * @method #stopListening\n * @param {module:utils/emittermixin~Emitter} [emitter] The object to stop listening to. If omitted, stops it for all objects.\n * @param {String} [event] (Requires the `emitter`) The name of the event to stop listening to. If omitted, stops it\n * for all events from `emitter`.\n * @param {Function} [callback] (Requires the `event`) The function to be removed from the call list for the given\n * `event`.\n */\n\n/**\n * Fires an event, executing all callbacks registered for it.\n *\n * The first parameter passed to callbacks is an {@link module:utils/eventinfo~EventInfo} object,\n * followed by the optional `args` provided in the `fire()` method call.\n *\n * @method #fire\n * @param {String|module:utils/eventinfo~EventInfo} eventOrInfo The name of the event or `EventInfo` object if event is delegated.\n * @param {...*} [args] Additional arguments to be passed to the callbacks.\n * @returns {*} By default the method returns `undefined`. However, the return value can be changed by listeners\n * through modification of the {@link module:utils/eventinfo~EventInfo#return `evt.return`}'s property (the event info\n * is the first param of every callback).\n */\n\n/**\n * Delegates selected events to another {@link module:utils/emittermixin~Emitter}. For instance:\n *\n *\t\temitterA.delegate( 'eventX' ).to( emitterB );\n *\t\temitterA.delegate( 'eventX', 'eventY' ).to( emitterC );\n *\n * then `eventX` is delegated (fired by) `emitterB` and `emitterC` along with `data`:\n *\n *\t\temitterA.fire( 'eventX', data );\n *\n * and `eventY` is delegated (fired by) `emitterC` along with `data`:\n *\n *\t\temitterA.fire( 'eventY', data );\n *\n * @method #delegate\n * @param {...String} events Event names that will be delegated to another emitter.\n * @returns {module:utils/emittermixin~EmitterMixinDelegateChain}\n */\n\n/**\n * Stops delegating events. It can be used at different levels:\n *\n * * To stop delegating all events.\n * * To stop delegating a specific event to all emitters.\n * * To stop delegating a specific event to a specific emitter.\n *\n * @method #stopDelegating\n * @param {String} [event] The name of the event to stop delegating. If omitted, stops it all delegations.\n * @param {module:utils/emittermixin~Emitter} [emitter] (requires `event`) The object to stop delegating a particular event to.\n * If omitted, stops delegation of `event` to all emitters.\n */\n\n/**\n * Checks if `listeningEmitter` listens to an emitter with given `listenedToEmitterId` and if so, returns that emitter.\n * If not, returns `null`.\n *\n * @protected\n * @param {module:utils/emittermixin~Emitter} listeningEmitter An emitter that listens.\n * @param {String} listenedToEmitterId Unique emitter id of emitter listened to.\n * @returns {module:utils/emittermixin~Emitter|null}\n */\nexport function _getEmitterListenedTo( listeningEmitter, listenedToEmitterId ) {\n\tif ( listeningEmitter[ _listeningTo ] && listeningEmitter[ _listeningTo ][ listenedToEmitterId ] ) {\n\t\treturn listeningEmitter[ _listeningTo ][ listenedToEmitterId ].emitter;\n\t}\n\n\treturn null;\n}\n\n/**\n * Sets emitter's unique id.\n *\n * **Note:** `_emitterId` can be set only once.\n *\n * @protected\n * @param {module:utils/emittermixin~Emitter} emitter An emitter for which id will be set.\n * @param {String} [id] Unique id to set. If not passed, random unique id will be set.\n */\nexport function _setEmitterId( emitter, id ) {\n\tif ( !emitter[ _emitterId ] ) {\n\t\temitter[ _emitterId ] = id || uid();\n\t}\n}\n\n/**\n * Returns emitter's unique id.\n *\n * @protected\n * @param {module:utils/emittermixin~Emitter} emitter An emitter which id will be returned.\n */\nexport function _getEmitterId( emitter ) {\n\treturn emitter[ _emitterId ];\n}\n\n// Gets the internal `_events` property of the given object.\n// `_events` property store all lists with callbacks for registered event names.\n// If there were no events registered on the object, empty `_events` object is created.\nfunction getEvents( source ) {\n\tif ( !source._events ) {\n\t\tObject.defineProperty( source, '_events', {\n\t\t\tvalue: {}\n\t\t} );\n\t}\n\n\treturn source._events;\n}\n\n// Creates event node for generic-specific events relation architecture.\nfunction makeEventNode() {\n\treturn {\n\t\tcallbacks: [],\n\t\tchildEvents: []\n\t};\n}\n\n// Creates an architecture for generic-specific events relation.\n// If needed, creates all events for given eventName, i.e. if the first registered event\n// is foo:bar:abc, it will create foo:bar:abc, foo:bar and foo event and tie them together.\n// It also copies callbacks from more generic events to more specific events when\n// specific events are created.\nfunction createEventNamespace( source, eventName ) {\n\tconst events = getEvents( source );\n\n\t// First, check if the event we want to add to the structure already exists.\n\tif ( events[ eventName ] ) {\n\t\t// If it exists, we don't have to do anything.\n\t\treturn;\n\t}\n\n\t// In other case, we have to create the structure for the event.\n\t// Note, that we might need to create intermediate events too.\n\t// I.e. if foo:bar:abc is being registered and we only have foo in the structure,\n\t// we need to also register foo:bar.\n\n\t// Currently processed event name.\n\tlet name = eventName;\n\t// Name of the event that is a child event for currently processed event.\n\tlet childEventName = null;\n\n\t// Array containing all newly created specific events.\n\tconst newEventNodes = [];\n\n\t// While loop can't check for ':' index because we have to handle generic events too.\n\t// In each loop, we truncate event name, going from the most specific name to the generic one.\n\t// I.e. foo:bar:abc -> foo:bar -> foo.\n\twhile ( name !== '' ) {\n\t\tif ( events[ name ] ) {\n\t\t\t// If the currently processed event name is already registered, we can be sure\n\t\t\t// that it already has all the structure created, so we can break the loop here\n\t\t\t// as no more events need to be registered.\n\t\t\tbreak;\n\t\t}\n\n\t\t// If this event is not yet registered, create a new object for it.\n\t\tevents[ name ] = makeEventNode();\n\t\t// Add it to the array with newly created events.\n\t\tnewEventNodes.push( events[ name ] );\n\n\t\t// Add previously processed event name as a child of this event.\n\t\tif ( childEventName ) {\n\t\t\tevents[ name ].childEvents.push( childEventName );\n\t\t}\n\n\t\tchildEventName = name;\n\t\t// If `.lastIndexOf()` returns -1, `.substr()` will return '' which will break the loop.\n\t\tname = name.substr( 0, name.lastIndexOf( ':' ) );\n\t}\n\n\tif ( name !== '' ) {\n\t\t// If name is not empty, we found an already registered event that was a parent of the\n\t\t// event we wanted to register.\n\n\t\t// Copy that event's callbacks to newly registered events.\n\t\tfor ( const node of newEventNodes ) {\n\t\t\tnode.callbacks = events[ name ].callbacks.slice();\n\t\t}\n\n\t\t// Add last newly created event to the already registered event.\n\t\tevents[ name ].childEvents.push( childEventName );\n\t}\n}\n\n// Gets an array containing callbacks list for a given event and it's more specific events.\n// I.e. if given event is foo:bar and there is also foo:bar:abc event registered, this will\n// return callback list of foo:bar and foo:bar:abc (but not foo).\nfunction getCallbacksListsForNamespace( source, eventName ) {\n\tconst eventNode = getEvents( source )[ eventName ];\n\n\tif ( !eventNode ) {\n\t\treturn [];\n\t}\n\n\tlet callbacksLists = [ eventNode.callbacks ];\n\n\tfor ( let i = 0; i < eventNode.childEvents.length; i++ ) {\n\t\tconst childCallbacksLists = getCallbacksListsForNamespace( source, eventNode.childEvents[ i ] );\n\n\t\tcallbacksLists = callbacksLists.concat( childCallbacksLists );\n\t}\n\n\treturn callbacksLists;\n}\n\n// Get the list of callbacks for a given event, but only if there any callbacks have been registered.\n// If there are no callbacks registered for given event, it checks if this is a specific event and looks\n// for callbacks for it's more generic version.\nfunction getCallbacksForEvent( source, eventName ) {\n\tlet event;\n\n\tif ( !source._events || !( event = source._events[ eventName ] ) || !event.callbacks.length ) {\n\t\t// There are no callbacks registered for specified eventName.\n\t\t// But this could be a specific-type event that is in a namespace.\n\t\tif ( eventName.indexOf( ':' ) > -1 ) {\n\t\t\t// If the eventName is specific, try to find callback lists for more generic event.\n\t\t\treturn getCallbacksForEvent( source, eventName.substr( 0, eventName.lastIndexOf( ':' ) ) );\n\t\t} else {\n\t\t\t// If this is a top-level generic event, return null;\n\t\t\treturn null;\n\t\t}\n\t}\n\n\treturn event.callbacks;\n}\n\n// Fires delegated events for given map of destinations.\n//\n// @private\n// * @param {Map.<utils.Emitter>} destinations A map containing\n// `[ {@link module:utils/emittermixin~Emitter}, \"event name\" ]` pair destinations.\n// * @param {utils.EventInfo} eventInfo The original event info object.\n// * @param {Array.<*>} fireArgs Arguments the original event was fired with.\nfunction fireDelegatedEvents( destinations, eventInfo, fireArgs ) {\n\tfor ( let [ emitter, name ] of destinations ) {\n\t\tif ( !name ) {\n\t\t\tname = eventInfo.name;\n\t\t} else if ( typeof name == 'function' ) {\n\t\t\tname = name( eventInfo.name );\n\t\t}\n\n\t\tconst delegatedInfo = new EventInfo( eventInfo.source, name );\n\n\t\tdelegatedInfo.path = [ ...eventInfo.path ];\n\n\t\temitter.fire( delegatedInfo, ...fireArgs );\n\t}\n}\n\n// Removes callback from emitter for given event.\n//\n// @param {module:utils/emittermixin~Emitter} emitter\n// @param {String} event\n// @param {Function} callback\nfunction removeCallback( emitter, event, callback ) {\n\tconst lists = getCallbacksListsForNamespace( emitter, event );\n\n\tfor ( const callbacks of lists ) {\n\t\tfor ( let i = 0; i < callbacks.length; i++ ) {\n\t\t\tif ( callbacks[ i ].callback == callback ) {\n\t\t\t\t// Remove the callback from the list (fixing the next index).\n\t\t\t\tcallbacks.splice( i, 1 );\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * The return value of {@link ~EmitterMixin#delegate}.\n *\n * @interface module:utils/emittermixin~EmitterMixinDelegateChain\n */\n\n/**\n * Selects destination for {@link module:utils/emittermixin~EmitterMixin#delegate} events.\n *\n * @method #to\n * @param {module:utils/emittermixin~Emitter} emitter An `EmitterMixin` instance which is the destination for delegated events.\n * @param {String|Function} [nameOrFunction] A custom event name or function which converts the original name string.\n */\n"]}]}