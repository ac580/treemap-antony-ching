{"remainingRequest":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/babel-loader/lib/index.js!/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-engine/src/model/node.js","dependencies":[{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-engine/src/model/node.js","mtime":499162500000},{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js","mtime":499162500000},{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/babel-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:LyoqCiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDE5LCBDS1NvdXJjZSAtIEZyZWRlcmljbyBLbmFiYmVuLiBBbGwgcmlnaHRzIHJlc2VydmVkLgogKiBGb3IgbGljZW5zaW5nLCBzZWUgTElDRU5TRS5tZCBvciBodHRwczovL2NrZWRpdG9yLmNvbS9sZWdhbC9ja2VkaXRvci1vc3MtbGljZW5zZQogKi8KCi8qKgogKiBAbW9kdWxlIGVuZ2luZS9tb2RlbC9ub2RlCiAqLwppbXBvcnQgdG9NYXAgZnJvbSAnQGNrZWRpdG9yL2NrZWRpdG9yNS11dGlscy9zcmMvdG9tYXAnOwppbXBvcnQgQ0tFZGl0b3JFcnJvciBmcm9tICdAY2tlZGl0b3IvY2tlZGl0b3I1LXV0aWxzL3NyYy9ja2VkaXRvcmVycm9yJzsKaW1wb3J0IGNvbXBhcmVBcnJheXMgZnJvbSAnQGNrZWRpdG9yL2NrZWRpdG9yNS11dGlscy9zcmMvY29tcGFyZWFycmF5cyc7IC8vIFRvIGNoZWNrIGlmIGNvbXBvbmVudCBpcyBsb2FkZWQgbW9yZSB0aGFuIG9uY2UuCgppbXBvcnQgJ0Bja2VkaXRvci9ja2VkaXRvcjUtdXRpbHMvc3JjL3ZlcnNpb24nOwovKioKICogTW9kZWwgbm9kZS4gTW9zdCBiYXNpYyBzdHJ1Y3R1cmUgb2YgbW9kZWwgdHJlZS4KICoKICogVGhpcyBpcyBhbiBhYnN0cmFjdCBjbGFzcyB0aGF0IGlzIGEgYmFzZSBmb3Igb3RoZXIgY2xhc3NlcyByZXByZXNlbnRpbmcgZGlmZmVyZW50IG5vZGVzIGluIG1vZGVsLgogKgogKiAqKk5vdGU6KiogSWYgYSBub2RlIGlzIGRldGFjaGVkIGZyb20gdGhlIG1vZGVsIHRyZWUsIHlvdSBjYW4gbWFuaXB1bGF0ZSBpdCB1c2luZyBpdCdzIEFQSS4KICogSG93ZXZlciwgaXQgaXMgKip2ZXJ5IGltcG9ydGFudCoqIHRoYXQgbm9kZXMgYWxyZWFkeSBhdHRhY2hlZCB0byBtb2RlbCB0cmVlIHNob3VsZCBiZSBvbmx5IGNoYW5nZWQgdGhyb3VnaAogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC93cml0ZXJ+V3JpdGVyIFdyaXRlciBBUEl9LgogKgogKiBDaGFuZ2VzIGRvbmUgYnkgYE5vZGVgIG1ldGhvZHMsIGxpa2Uge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50I19pbnNlcnRDaGlsZCBfaW5zZXJ0Q2hpbGR9IG9yCiAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL25vZGV+Tm9kZSNfc2V0QXR0cmlidXRlIF9zZXRBdHRyaWJ1dGV9CiAqIGRvIG5vdCBnZW5lcmF0ZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9vcGVyYXRpb24vb3BlcmF0aW9ufk9wZXJhdGlvbiBvcGVyYXRpb25zfQogKiB3aGljaCBhcmUgZXNzZW50aWFsIGZvciBjb3JyZWN0IGVkaXRvciB3b3JrIGlmIHlvdSBtb2RpZnkgbm9kZXMgaW4ge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnR+RG9jdW1lbnQgZG9jdW1lbnR9IHJvb3QuCiAqCiAqIFRoZSBmbG93IG9mIHdvcmtpbmcgb24gYE5vZGVgIChhbmQgY2xhc3NlcyB0aGF0IGluaGVyaXRzIGZyb20gaXQpIGlzIGFzIHN1Y2g6CiAqIDEuIFlvdSBjYW4gY3JlYXRlIGEgYE5vZGVgIGluc3RhbmNlLCBtb2RpZnkgaXQgdXNpbmcgaXQncyBBUEkuCiAqIDIuIEFkZCBgTm9kZWAgdG8gdGhlIG1vZGVsIHVzaW5nIGBCYXRjaGAgQVBJLgogKiAzLiBDaGFuZ2UgYE5vZGVgIHRoYXQgd2FzIGFscmVhZHkgYWRkZWQgdG8gdGhlIG1vZGVsIHVzaW5nIGBCYXRjaGAgQVBJLgogKgogKiBTaW1pbGFybHksIHlvdSBjYW5ub3QgdXNlIGBCYXRjaGAgQVBJIG9uIGEgbm9kZSB0aGF0IGhhcyBub3QgYmVlbiBhZGRlZCB0byB0aGUgbW9kZWwgdHJlZSwgd2l0aCB0aGUgZXhjZXB0aW9uCiAqIG9mIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3dyaXRlcn5Xcml0ZXIjaW5zZXJ0IGluc2VydGluZ30gdGhhdCBub2RlIHRvIHRoZSBtb2RlbCB0cmVlLgogKgogKiBCZSBhd2FyZSB0aGF0IHVzaW5nIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3dyaXRlcn5Xcml0ZXIjcmVtb3ZlIHJlbW92ZSBmcm9tIEJhdGNoIEFQSX0gZG9lcyBub3QgYWxsb3cgdG8gdXNlIGBOb2RlYCBBUEkgYmVjYXVzZQogKiB0aGUgaW5mb3JtYXRpb24gYWJvdXQgYE5vZGVgIGlzIHN0aWxsIGtlcHQgaW4gbW9kZWwgZG9jdW1lbnQuCiAqCiAqIEluIGNhc2Ugb2Yge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50IGVsZW1lbnQgbm9kZX0sIGFkZGluZyBhbmQgcmVtb3ZpbmcgY2hpbGRyZW4gYWxzbyBjb3VudHMgYXMgY2hhbmdpbmcgYSBub2RlIGFuZAogKiBmb2xsb3dzIHNhbWUgcnVsZXMuCiAqLwoKZXhwb3J0IGRlZmF1bHQgY2xhc3MgTm9kZSB7CiAgLyoqCiAgICogQ3JlYXRlcyBhIG1vZGVsIG5vZGUuCiAgICoKICAgKiBUaGlzIGlzIGFuIGFic3RyYWN0IGNsYXNzLCBzbyB0aGlzIGNvbnN0cnVjdG9yIHNob3VsZCBub3QgYmUgdXNlZCBkaXJlY3RseS4KICAgKgogICAqIEBhYnN0cmFjdAogICAqIEBwYXJhbSB7T2JqZWN0fSBbYXR0cnNdIE5vZGUncyBhdHRyaWJ1dGVzLiBTZWUge0BsaW5rIG1vZHVsZTp1dGlscy90b21hcH50b01hcH0gZm9yIGEgbGlzdCBvZiBhY2NlcHRlZCB2YWx1ZXMuCiAgICovCiAgY29uc3RydWN0b3IoYXR0cnMpIHsKICAgIC8qKgogICAgICogUGFyZW50IG9mIHRoaXMgbm9kZS4gSXQgY291bGQgYmUge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50fQogICAgICogb3Ige0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50fS4KICAgICAqIEVxdWFscyB0byBgbnVsbGAgaWYgdGhlIG5vZGUgaGFzIG5vIHBhcmVudC4KICAgICAqCiAgICAgKiBAcmVhZG9ubHkKICAgICAqIEBtZW1iZXIge21vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50fG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50fG51bGx9CiAgICAgKi8KICAgIHRoaXMucGFyZW50ID0gbnVsbDsKICAgIC8qKgogICAgICogQXR0cmlidXRlcyBzZXQgb24gdGhpcyBub2RlLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAbWVtYmVyIHtNYXB9IG1vZHVsZTplbmdpbmUvbW9kZWwvbm9kZX5Ob2RlI19hdHRycwogICAgICovCgogICAgdGhpcy5fYXR0cnMgPSB0b01hcChhdHRycyk7CiAgfQogIC8qKgogICAqIEluZGV4IG9mIHRoaXMgbm9kZSBpbiBpdCdzIHBhcmVudCBvciBgbnVsbGAgaWYgdGhlIG5vZGUgaGFzIG5vIHBhcmVudC4KICAgKgogICAqIEFjY2Vzc2luZyB0aGlzIHByb3BlcnR5IHRocm93cyBhbiBlcnJvciBpZiB0aGlzIG5vZGUncyBwYXJlbnQgZWxlbWVudCBkb2VzIG5vdCBjb250YWluIGl0LgogICAqIFRoaXMgbWVhbnMgdGhhdCBtb2RlbCB0cmVlIGdvdCBicm9rZW4uCiAgICoKICAgKiBAcmVhZG9ubHkKICAgKiBAdHlwZSB7TnVtYmVyfG51bGx9CiAgICovCgoKICBnZXQgaW5kZXgoKSB7CiAgICBsZXQgcG9zOwoKICAgIGlmICghdGhpcy5wYXJlbnQpIHsKICAgICAgcmV0dXJuIG51bGw7CiAgICB9CgogICAgaWYgKChwb3MgPSB0aGlzLnBhcmVudC5nZXRDaGlsZEluZGV4KHRoaXMpKSA9PT0gbnVsbCkgewogICAgICB0aHJvdyBuZXcgQ0tFZGl0b3JFcnJvcignbW9kZWwtbm9kZS1ub3QtZm91bmQtaW4tcGFyZW50OiBUaGUgbm9kZVwncyBwYXJlbnQgZG9lcyBub3QgY29udGFpbiB0aGlzIG5vZGUuJywgdGhpcyk7CiAgICB9CgogICAgcmV0dXJuIHBvczsKICB9CiAgLyoqCiAgICogT2Zmc2V0IGF0IHdoaWNoIHRoaXMgbm9kZSBzdGFydHMgaW4gaXQncyBwYXJlbnQuIEl0IGlzIGVxdWFsIHRvIHRoZSBzdW0gb2Yge0BsaW5rICNvZmZzZXRTaXplIG9mZnNldFNpemV9CiAgICogb2YgYWxsIGl0J3MgcHJldmlvdXMgc2libGluZ3MuIEVxdWFscyB0byBgbnVsbGAgaWYgbm9kZSBoYXMgbm8gcGFyZW50LgogICAqCiAgICogQWNjZXNzaW5nIHRoaXMgcHJvcGVydHkgdGhyb3dzIGFuIGVycm9yIGlmIHRoaXMgbm9kZSdzIHBhcmVudCBlbGVtZW50IGRvZXMgbm90IGNvbnRhaW4gaXQuCiAgICogVGhpcyBtZWFucyB0aGF0IG1vZGVsIHRyZWUgZ290IGJyb2tlbi4KICAgKgogICAqIEByZWFkb25seQogICAqIEB0eXBlIHtOdW1iZXJ8bnVsbH0KICAgKi8KCgogIGdldCBzdGFydE9mZnNldCgpIHsKICAgIGxldCBwb3M7CgogICAgaWYgKCF0aGlzLnBhcmVudCkgewogICAgICByZXR1cm4gbnVsbDsKICAgIH0KCiAgICBpZiAoKHBvcyA9IHRoaXMucGFyZW50LmdldENoaWxkU3RhcnRPZmZzZXQodGhpcykpID09PSBudWxsKSB7CiAgICAgIHRocm93IG5ldyBDS0VkaXRvckVycm9yKCdtb2RlbC1ub2RlLW5vdC1mb3VuZC1pbi1wYXJlbnQ6IFRoZSBub2RlXCdzIHBhcmVudCBkb2VzIG5vdCBjb250YWluIHRoaXMgbm9kZS4nLCB0aGlzKTsKICAgIH0KCiAgICByZXR1cm4gcG9zOwogIH0KICAvKioKICAgKiBPZmZzZXQgc2l6ZSBvZiB0aGlzIG5vZGUuIFJlcHJlc2VudHMgaG93IG11Y2ggIm9mZnNldCBzcGFjZSIgaXMgb2NjdXBpZWQgYnkgdGhlIG5vZGUgaW4gaXQncyBwYXJlbnQuCiAgICogSXQgaXMgaW1wb3J0YW50IGZvciB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbiBwb3NpdGlvbn0uIFdoZW4gbm9kZSBoYXMgYG9mZnNldFNpemVgIGdyZWF0ZXIgdGhhbiBgMWAsIHBvc2l0aW9uCiAgICogY2FuIGJlIHBsYWNlZCBiZXR3ZWVuIHRoYXQgbm9kZSBzdGFydCBhbmQgZW5kLiBgb2Zmc2V0U2l6ZWAgZ3JlYXRlciB0aGFuIGAxYCBpcyBmb3Igbm9kZXMgdGhhdCByZXByZXNlbnRzIG1vcmUKICAgKiB0aGFuIG9uZSBlbnRpdHksIGkuZS4ge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvdGV4dH5UZXh0IHRleHQgbm9kZX0uCiAgICoKICAgKiBAcmVhZG9ubHkKICAgKiBAdHlwZSB7TnVtYmVyfQogICAqLwoKCiAgZ2V0IG9mZnNldFNpemUoKSB7CiAgICByZXR1cm4gMTsKICB9CiAgLyoqCiAgICogT2Zmc2V0IGF0IHdoaWNoIHRoaXMgbm9kZSBlbmRzIGluIGl0J3MgcGFyZW50LiBJdCBpcyBlcXVhbCB0byB0aGUgc3VtIG9mIHRoaXMgbm9kZSdzCiAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbm9kZX5Ob2RlI3N0YXJ0T2Zmc2V0IHN0YXJ0IG9mZnNldH0gYW5kIHtAbGluayAjb2Zmc2V0U2l6ZSBvZmZzZXQgc2l6ZX0uCiAgICogRXF1YWxzIHRvIGBudWxsYCBpZiB0aGUgbm9kZSBoYXMgbm8gcGFyZW50LgogICAqCiAgICogQHJlYWRvbmx5CiAgICogQHR5cGUge051bWJlcnxudWxsfQogICAqLwoKCiAgZ2V0IGVuZE9mZnNldCgpIHsKICAgIGlmICghdGhpcy5wYXJlbnQpIHsKICAgICAgcmV0dXJuIG51bGw7CiAgICB9CgogICAgcmV0dXJuIHRoaXMuc3RhcnRPZmZzZXQgKyB0aGlzLm9mZnNldFNpemU7CiAgfQogIC8qKgogICAqIE5vZGUncyBuZXh0IHNpYmxpbmcgb3IgYG51bGxgIGlmIHRoZSBub2RlIGlzIGEgbGFzdCBjaGlsZCBvZiBpdCdzIHBhcmVudCBvciBpZiB0aGUgbm9kZSBoYXMgbm8gcGFyZW50LgogICAqCiAgICogQHJlYWRvbmx5CiAgICogQHR5cGUge21vZHVsZTplbmdpbmUvbW9kZWwvbm9kZX5Ob2RlfG51bGx9CiAgICovCgoKICBnZXQgbmV4dFNpYmxpbmcoKSB7CiAgICBjb25zdCBpbmRleCA9IHRoaXMuaW5kZXg7CiAgICByZXR1cm4gaW5kZXggIT09IG51bGwgJiYgdGhpcy5wYXJlbnQuZ2V0Q2hpbGQoaW5kZXggKyAxKSB8fCBudWxsOwogIH0KICAvKioKICAgKiBOb2RlJ3MgcHJldmlvdXMgc2libGluZyBvciBgbnVsbGAgaWYgdGhlIG5vZGUgaXMgYSBmaXJzdCBjaGlsZCBvZiBpdCdzIHBhcmVudCBvciBpZiB0aGUgbm9kZSBoYXMgbm8gcGFyZW50LgogICAqCiAgICogQHJlYWRvbmx5CiAgICogQHR5cGUge21vZHVsZTplbmdpbmUvbW9kZWwvbm9kZX5Ob2RlfG51bGx9CiAgICovCgoKICBnZXQgcHJldmlvdXNTaWJsaW5nKCkgewogICAgY29uc3QgaW5kZXggPSB0aGlzLmluZGV4OwogICAgcmV0dXJuIGluZGV4ICE9PSBudWxsICYmIHRoaXMucGFyZW50LmdldENoaWxkKGluZGV4IC0gMSkgfHwgbnVsbDsKICB9CiAgLyoqCiAgICogVGhlIHRvcC1tb3N0IGFuY2VzdG9yIG9mIHRoZSBub2RlLiBJZiBub2RlIGhhcyBubyBwYXJlbnQgaXQgaXMgdGhlIHJvb3QgaXRzZWxmLiBJZiB0aGUgbm9kZSBpcyBhIHBhcnQKICAgKiBvZiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnR9LCBpdCdzIGByb290YCBpcyBlcXVhbCB0byB0aGF0IGBEb2N1bWVudEZyYWdtZW50YC4KICAgKgogICAqIEByZWFkb25seQogICAqIEB0eXBlIHttb2R1bGU6ZW5naW5lL21vZGVsL25vZGV+Tm9kZXxtb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudH0KICAgKi8KCgogIGdldCByb290KCkgewogICAgbGV0IHJvb3QgPSB0aGlzOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNvbnNpc3RlbnQtdGhpcwoKICAgIHdoaWxlIChyb290LnBhcmVudCkgewogICAgICByb290ID0gcm9vdC5wYXJlbnQ7CiAgICB9CgogICAgcmV0dXJuIHJvb3Q7CiAgfQogIC8qKgogICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50fkRvY3VtZW50IERvY3VtZW50fSB0aGF0IG93bnMgdGhpcyBub2RlIG9yIGBudWxsYCBpZiB0aGUgbm9kZSBoYXMgbm8gcGFyZW50IG9yIGlzIGluc2lkZQogICAqIGEge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50IERvY3VtZW50RnJhZ21lbnR9LgogICAqCiAgICogQHJlYWRvbmx5CiAgICogQHR5cGUge21vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnR+RG9jdW1lbnR8bnVsbH0KICAgKi8KCgogIGdldCBkb2N1bWVudCgpIHsKICAgIC8vIFRoaXMgaXMgYSB0b3AgZWxlbWVudCBvZiBhIHN1Yi10cmVlLgogICAgaWYgKHRoaXMucm9vdCA9PSB0aGlzKSB7CiAgICAgIHJldHVybiBudWxsOwogICAgfSAvLyBSb290IG1heSBiZSBgRG9jdW1lbnRGcmFnbWVudGAgd2hpY2ggZG9lcyBub3QgaGF2ZSBkb2N1bWVudCBwcm9wZXJ0eS4KCgogICAgcmV0dXJuIHRoaXMucm9vdC5kb2N1bWVudCB8fCBudWxsOwogIH0KICAvKioKICAgKiBHZXRzIHBhdGggdG8gdGhlIG5vZGUuIFRoZSBwYXRoIGlzIGFuIGFycmF5IGNvbnRhaW5pbmcgc3RhcnRpbmcgb2Zmc2V0cyBvZiBjb25zZWN1dGl2ZSBhbmNlc3RvcnMgb2YgdGhpcyBub2RlLAogICAqIGJlZ2lubmluZyBmcm9tIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL25vZGV+Tm9kZSNyb290IHJvb3R9LCBkb3duIHRvIHRoaXMgbm9kZSdzIHN0YXJ0aW5nIG9mZnNldC4gVGhlIHBhdGggY2FuIGJlIHVzZWQgdG8KICAgKiBjcmVhdGUge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb24gUG9zaXRpb259IGluc3RhbmNlLgogICAqCiAgICoJCWNvbnN0IGFiYyA9IG5ldyBUZXh0KCAnYWJjJyApOwogICAqCQljb25zdCBmb28gPSBuZXcgVGV4dCggJ2ZvbycgKTsKICAgKgkJY29uc3QgaDEgPSBuZXcgRWxlbWVudCggJ2gxJywgbnVsbCwgbmV3IFRleHQoICdoZWFkZXInICkgKTsKICAgKgkJY29uc3QgcCA9IG5ldyBFbGVtZW50KCAncCcsIG51bGwsIFsgYWJjLCBmb28gXSApOwogICAqCQljb25zdCBkaXYgPSBuZXcgRWxlbWVudCggJ2RpdicsIG51bGwsIFsgaDEsIHAgXSApOwogICAqCQlmb28uZ2V0UGF0aCgpOyAvLyBSZXR1cm5zIFsgMSwgMyBdLiBgZm9vYCBpcyBpbiBgcGAgd2hpY2ggaXMgaW4gYGRpdmAuIGBwYCBzdGFydHMgYXQgb2Zmc2V0IDEsIHdoaWxlIGBmb29gIGF0IDMuCiAgICoJCWgxLmdldFBhdGgoKTsgLy8gUmV0dXJucyBbIDAgXS4KICAgKgkJZGl2LmdldFBhdGgoKTsgLy8gUmV0dXJucyBbXS4KICAgKgogICAqIEByZXR1cm5zIHtBcnJheS48TnVtYmVyPn0gVGhlIHBhdGguCiAgICovCgoKICBnZXRQYXRoKCkgewogICAgY29uc3QgcGF0aCA9IFtdOwogICAgbGV0IG5vZGUgPSB0aGlzOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNvbnNpc3RlbnQtdGhpcwoKICAgIHdoaWxlIChub2RlLnBhcmVudCkgewogICAgICBwYXRoLnVuc2hpZnQobm9kZS5zdGFydE9mZnNldCk7CiAgICAgIG5vZGUgPSBub2RlLnBhcmVudDsKICAgIH0KCiAgICByZXR1cm4gcGF0aDsKICB9CiAgLyoqCiAgICogUmV0dXJucyBhbmNlc3RvcnMgYXJyYXkgb2YgdGhpcyBub2RlLgogICAqCiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBvYmplY3QuCiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5pbmNsdWRlU2VsZj1mYWxzZV0gV2hlbiBzZXQgdG8gYHRydWVgIHRoaXMgbm9kZSB3aWxsIGJlIGFsc28gaW5jbHVkZWQgaW4gcGFyZW50J3MgYXJyYXkuCiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5wYXJlbnRGaXJzdD1mYWxzZV0gV2hlbiBzZXQgdG8gYHRydWVgLCBhcnJheSB3aWxsIGJlIHNvcnRlZCBmcm9tIG5vZGUncyBwYXJlbnQgdG8gcm9vdCBlbGVtZW50LAogICAqIG90aGVyd2lzZSByb290IGVsZW1lbnQgd2lsbCBiZSB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgYXJyYXkuCiAgICogQHJldHVybnMge0FycmF5fSBBcnJheSB3aXRoIGFuY2VzdG9ycy4KICAgKi8KCgogIGdldEFuY2VzdG9ycyhvcHRpb25zID0gewogICAgaW5jbHVkZVNlbGY6IGZhbHNlLAogICAgcGFyZW50Rmlyc3Q6IGZhbHNlCiAgfSkgewogICAgY29uc3QgYW5jZXN0b3JzID0gW107CiAgICBsZXQgcGFyZW50ID0gb3B0aW9ucy5pbmNsdWRlU2VsZiA/IHRoaXMgOiB0aGlzLnBhcmVudDsKCiAgICB3aGlsZSAocGFyZW50KSB7CiAgICAgIGFuY2VzdG9yc1tvcHRpb25zLnBhcmVudEZpcnN0ID8gJ3B1c2gnIDogJ3Vuc2hpZnQnXShwYXJlbnQpOwogICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50OwogICAgfQoKICAgIHJldHVybiBhbmNlc3RvcnM7CiAgfQogIC8qKgogICAqIFJldHVybnMgYSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR9IG9yIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudH0KICAgKiB3aGljaCBpcyBhIGNvbW1vbiBhbmNlc3RvciBvZiBib3RoIG5vZGVzLgogICAqCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL25vZGV+Tm9kZX0gbm9kZSBUaGUgc2Vjb25kIG5vZGUuCiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBvYmplY3QuCiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5pbmNsdWRlU2VsZj1mYWxzZV0gV2hlbiBzZXQgdG8gYHRydWVgIGJvdGggbm9kZXMgd2lsbCBiZSBjb25zaWRlcmVkICJhbmNlc3RvcnMiIHRvby4KICAgKiBXaGljaCBtZWFucyB0aGF0IGlmIGUuZy4gbm9kZSBBIGlzIGluc2lkZSBCLCB0aGVuIHRoZWlyIGNvbW1vbiBhbmNlc3RvciB3aWxsIGJlIEIuCiAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50fG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50fG51bGx9CiAgICovCgoKICBnZXRDb21tb25BbmNlc3Rvcihub2RlLCBvcHRpb25zID0ge30pIHsKICAgIGNvbnN0IGFuY2VzdG9yc0EgPSB0aGlzLmdldEFuY2VzdG9ycyhvcHRpb25zKTsKICAgIGNvbnN0IGFuY2VzdG9yc0IgPSBub2RlLmdldEFuY2VzdG9ycyhvcHRpb25zKTsKICAgIGxldCBpID0gMDsKCiAgICB3aGlsZSAoYW5jZXN0b3JzQVtpXSA9PSBhbmNlc3RvcnNCW2ldICYmIGFuY2VzdG9yc0FbaV0pIHsKICAgICAgaSsrOwogICAgfQoKICAgIHJldHVybiBpID09PSAwID8gbnVsbCA6IGFuY2VzdG9yc0FbaSAtIDFdOwogIH0KICAvKioKICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBub2RlIGlzIGJlZm9yZSBnaXZlbiBub2RlLiBgZmFsc2VgIGlzIHJldHVybmVkIGlmIG5vZGVzIGFyZSBpbiBkaWZmZXJlbnQgdHJlZXMgKGZvciBleGFtcGxlLAogICAqIGluIGRpZmZlcmVudCB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnR9cykuCiAgICoKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvbm9kZX5Ob2RlfSBub2RlIE5vZGUgdG8gY29tcGFyZSB3aXRoLgogICAqIEByZXR1cm5zIHtCb29sZWFufQogICAqLwoKCiAgaXNCZWZvcmUobm9kZSkgewogICAgLy8gR2l2ZW4gbm9kZSBpcyBub3QgYmVmb3JlIHRoaXMgbm9kZSBpZiB0aGV5IGFyZSBzYW1lLgogICAgaWYgKHRoaXMgPT0gbm9kZSkgewogICAgICByZXR1cm4gZmFsc2U7CiAgICB9IC8vIFJldHVybiBgZmFsc2VgIGlmIGl0IGlzIGltcG9zc2libGUgdG8gY29tcGFyZSBub2Rlcy4KCgogICAgaWYgKHRoaXMucm9vdCAhPT0gbm9kZS5yb290KSB7CiAgICAgIHJldHVybiBmYWxzZTsKICAgIH0KCiAgICBjb25zdCB0aGlzUGF0aCA9IHRoaXMuZ2V0UGF0aCgpOwogICAgY29uc3Qgbm9kZVBhdGggPSBub2RlLmdldFBhdGgoKTsKICAgIGNvbnN0IHJlc3VsdCA9IGNvbXBhcmVBcnJheXModGhpc1BhdGgsIG5vZGVQYXRoKTsKCiAgICBzd2l0Y2ggKHJlc3VsdCkgewogICAgICBjYXNlICdwcmVmaXgnOgogICAgICAgIHJldHVybiB0cnVlOwoKICAgICAgY2FzZSAnZXh0ZW5zaW9uJzoKICAgICAgICByZXR1cm4gZmFsc2U7CgogICAgICBkZWZhdWx0OgogICAgICAgIHJldHVybiB0aGlzUGF0aFtyZXN1bHRdIDwgbm9kZVBhdGhbcmVzdWx0XTsKICAgIH0KICB9CiAgLyoqCiAgICogUmV0dXJucyB3aGV0aGVyIHRoaXMgbm9kZSBpcyBhZnRlciBnaXZlbiBub2RlLiBgZmFsc2VgIGlzIHJldHVybmVkIGlmIG5vZGVzIGFyZSBpbiBkaWZmZXJlbnQgdHJlZXMgKGZvciBleGFtcGxlLAogICAqIGluIGRpZmZlcmVudCB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnR9cykuCiAgICoKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvbm9kZX5Ob2RlfSBub2RlIE5vZGUgdG8gY29tcGFyZSB3aXRoLgogICAqIEByZXR1cm5zIHtCb29sZWFufQogICAqLwoKCiAgaXNBZnRlcihub2RlKSB7CiAgICAvLyBHaXZlbiBub2RlIGlzIG5vdCBiZWZvcmUgdGhpcyBub2RlIGlmIHRoZXkgYXJlIHNhbWUuCiAgICBpZiAodGhpcyA9PSBub2RlKSB7CiAgICAgIHJldHVybiBmYWxzZTsKICAgIH0gLy8gUmV0dXJuIGBmYWxzZWAgaWYgaXQgaXMgaW1wb3NzaWJsZSB0byBjb21wYXJlIG5vZGVzLgoKCiAgICBpZiAodGhpcy5yb290ICE9PSBub2RlLnJvb3QpIHsKICAgICAgcmV0dXJuIGZhbHNlOwogICAgfSAvLyBJbiBvdGhlciBjYXNlcywganVzdCBjaGVjayBpZiB0aGUgYG5vZGVgIGlzIGJlZm9yZSwgYW5kIHJldHVybiB0aGUgb3Bwb3NpdGUuCgoKICAgIHJldHVybiAhdGhpcy5pc0JlZm9yZShub2RlKTsKICB9CiAgLyoqCiAgICogQ2hlY2tzIGlmIHRoZSBub2RlIGhhcyBhbiBhdHRyaWJ1dGUgd2l0aCBnaXZlbiBrZXkuCiAgICoKICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IEtleSBvZiBhdHRyaWJ1dGUgdG8gY2hlY2suCiAgICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiBhdHRyaWJ1dGUgd2l0aCBnaXZlbiBrZXkgaXMgc2V0IG9uIG5vZGUsIGBmYWxzZWAgb3RoZXJ3aXNlLgogICAqLwoKCiAgaGFzQXR0cmlidXRlKGtleSkgewogICAgcmV0dXJuIHRoaXMuX2F0dHJzLmhhcyhrZXkpOwogIH0KICAvKioKICAgKiBHZXRzIGFuIGF0dHJpYnV0ZSB2YWx1ZSBmb3IgZ2l2ZW4ga2V5IG9yIGB1bmRlZmluZWRgIGlmIHRoYXQgYXR0cmlidXRlIGlzIG5vdCBzZXQgb24gbm9kZS4KICAgKgogICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgS2V5IG9mIGF0dHJpYnV0ZSB0byBsb29rIGZvci4KICAgKiBAcmV0dXJucyB7Kn0gQXR0cmlidXRlIHZhbHVlIG9yIGB1bmRlZmluZWRgLgogICAqLwoKCiAgZ2V0QXR0cmlidXRlKGtleSkgewogICAgcmV0dXJuIHRoaXMuX2F0dHJzLmdldChrZXkpOwogIH0KICAvKioKICAgKiBSZXR1cm5zIGl0ZXJhdG9yIHRoYXQgaXRlcmF0ZXMgb3ZlciB0aGlzIG5vZGUncyBhdHRyaWJ1dGVzLgogICAqCiAgICogQXR0cmlidXRlcyBhcmUgcmV0dXJuZWQgYXMgYXJyYXlzIGNvbnRhaW5pbmcgdHdvIGl0ZW1zLiBGaXJzdCBvbmUgaXMgYXR0cmlidXRlIGtleSBhbmQgc2Vjb25kIGlzIGF0dHJpYnV0ZSB2YWx1ZS4KICAgKiBUaGlzIGZvcm1hdCBpcyBhY2NlcHRlZCBieSBuYXRpdmUgYE1hcGAgb2JqZWN0IGFuZCBhbHNvIGNhbiBiZSBwYXNzZWQgaW4gYE5vZGVgIGNvbnN0cnVjdG9yLgogICAqCiAgICogQHJldHVybnMge0l0ZXJhYmxlLjwqPn0KICAgKi8KCgogIGdldEF0dHJpYnV0ZXMoKSB7CiAgICByZXR1cm4gdGhpcy5fYXR0cnMuZW50cmllcygpOwogIH0KICAvKioKICAgKiBSZXR1cm5zIGl0ZXJhdG9yIHRoYXQgaXRlcmF0ZXMgb3ZlciB0aGlzIG5vZGUncyBhdHRyaWJ1dGUga2V5cy4KICAgKgogICAqIEByZXR1cm5zIHtJdGVyYWJsZS48U3RyaW5nPn0KICAgKi8KCgogIGdldEF0dHJpYnV0ZUtleXMoKSB7CiAgICByZXR1cm4gdGhpcy5fYXR0cnMua2V5cygpOwogIH0KICAvKioKICAgKiBDb252ZXJ0cyBgTm9kZWAgdG8gcGxhaW4gb2JqZWN0IGFuZCByZXR1cm5zIGl0LgogICAqCiAgICogQHJldHVybnMge09iamVjdH0gYE5vZGVgIGNvbnZlcnRlZCB0byBwbGFpbiBvYmplY3QuCiAgICovCgoKICB0b0pTT04oKSB7CiAgICBjb25zdCBqc29uID0ge307IC8vIFNlcmlhbGl6ZXMgYXR0cmlidXRlcyB0byB0aGUgb2JqZWN0LgogICAgLy8gYXR0cmlidXRlcyA9IHsgYTogJ2ZvbycsIGI6IDEsIGM6IHRydWUgfS4KCiAgICBpZiAodGhpcy5fYXR0cnMuc2l6ZSkgewogICAgICBqc29uLmF0dHJpYnV0ZXMgPSBBcnJheS5mcm9tKHRoaXMuX2F0dHJzKS5yZWR1Y2UoKHJlc3VsdCwgYXR0cikgPT4gewogICAgICAgIHJlc3VsdFthdHRyWzBdXSA9IGF0dHJbMV07CiAgICAgICAgcmV0dXJuIHJlc3VsdDsKICAgICAgfSwge30pOwogICAgfQoKICAgIHJldHVybiBqc29uOwogIH0KICAvKioKICAgKiBDaGVja3Mgd2hldGhlciB0aGlzIG9iamVjdCBpcyBvZiB0aGUgZ2l2ZW4gdHlwZS4KICAgKgogICAqIFRoaXMgbWV0aG9kIGlzIHVzZWZ1bCB3aGVuIHByb2Nlc3NpbmcgbW9kZWwgb2JqZWN0cyB0aGF0IGFyZSBvZiB1bmtub3duIHR5cGUuIEZvciBleGFtcGxlLCBhIGZ1bmN0aW9uCiAgICogbWF5IHJldHVybiBhIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudH0gb3IgYSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9ub2Rlfk5vZGV9CiAgICogdGhhdCBjYW4gYmUgZWl0aGVyIGEgdGV4dCBub2RlIG9yIGFuIGVsZW1lbnQuIFRoaXMgbWV0aG9kIGNhbiBiZSB1c2VkIHRvIGNoZWNrIHdoYXQga2luZCBvZiBvYmplY3QgaXMgcmV0dXJuZWQuCiAgICoKICAgKgkJc29tZU9iamVjdC5pcyggJ2VsZW1lbnQnICk7IC8vIC0+IHRydWUgaWYgdGhpcyBpcyBhbiBlbGVtZW50CiAgICoJCXNvbWVPYmplY3QuaXMoICdub2RlJyApOyAvLyAtPiB0cnVlIGlmIHRoaXMgaXMgYSBub2RlIChhIHRleHQgbm9kZSBvciBhbiBlbGVtZW50KQogICAqCQlzb21lT2JqZWN0LmlzKCAnZG9jdW1lbnRGcmFnbWVudCcgKTsgLy8gLT4gdHJ1ZSBpZiB0aGlzIGlzIGEgZG9jdW1lbnQgZnJhZ21lbnQKICAgKgogICAqIFNpbmNlIHRoaXMgbWV0aG9kIGlzIGFsc28gYXZhaWxhYmxlIG9uIGEgcmFuZ2Ugb2YgdmlldyBvYmplY3RzLCB5b3UgY2FuIHByZWZpeCB0aGUgdHlwZSBvZiB0aGUgb2JqZWN0IHdpdGgKICAgKiBgbW9kZWw6YCBvciBgdmlldzpgIHRvIGNoZWNrLCBmb3IgZXhhbXBsZSwgaWYgdGhpcyBpcyB0aGUgbW9kZWwncyBvciB2aWV3J3MgZWxlbWVudDoKICAgKgogICAqCQltb2RlbEVsZW1lbnQuaXMoICdtb2RlbDplbGVtZW50JyApOyAvLyAtPiB0cnVlCiAgICoJCW1vZGVsRWxlbWVudC5pcyggJ3ZpZXc6ZWxlbWVudCcgKTsgLy8gLT4gZmFsc2UKICAgKgogICAqIEJ5IHVzaW5nIHRoaXMgbWV0aG9kIGl0IGlzIGFsc28gcG9zc2libGUgdG8gY2hlY2sgYSBuYW1lIG9mIGFuIGVsZW1lbnQ6CiAgICoKICAgKgkJaW1hZ2VFbGVtZW50LmlzKCAnaW1hZ2UnICk7IC8vIC0+IHRydWUKICAgKgkJaW1hZ2VFbGVtZW50LmlzKCAnZWxlbWVudCcsICdpbWFnZScgKTsgLy8gLT4gc2FtZSBhcyBhYm92ZQogICAqCQlpbWFnZUVsZW1lbnQuaXMoICdtb2RlbDplbGVtZW50JywgJ2ltYWdlJyApOyAvLyAtPiBzYW1lIGFzIGFib3ZlLCBidXQgbW9yZSBwcmVjaXNlCiAgICoKICAgKiBUaGUgbGlzdCBvZiBtb2RlbCBvYmplY3RzIHdoaWNoIGltcGxlbWVudCB0aGUgYGlzKClgIG1ldGhvZDoKICAgKgogICAqICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbm9kZX5Ob2RlI2lzIGBOb2RlI2lzKClgfQogICAqICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvdGV4dH5UZXh0I2lzIGBUZXh0I2lzKClgfQogICAqICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50I2lzIGBFbGVtZW50I2lzKClgfQogICAqICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvcm9vdGVsZW1lbnR+Um9vdEVsZW1lbnQjaXMgYFJvb3RFbGVtZW50I2lzKClgfQogICAqICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb24jaXMgYFBvc2l0aW9uI2lzKClgfQogICAqICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbGl2ZXBvc2l0aW9ufkxpdmVQb3NpdGlvbiNpcyBgTGl2ZVBvc2l0aW9uI2lzKClgfQogICAqICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2UjaXMgYFJhbmdlI2lzKClgfQogICAqICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbGl2ZXJhbmdlfkxpdmVSYW5nZSNpcyBgTGl2ZVJhbmdlI2lzKClgfQogICAqICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50I2lzIGBEb2N1bWVudEZyYWdtZW50I2lzKClgfQogICAqICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvc2VsZWN0aW9uflNlbGVjdGlvbiNpcyBgU2VsZWN0aW9uI2lzKClgfQogICAqICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnRzZWxlY3Rpb25+RG9jdW1lbnRTZWxlY3Rpb24jaXMgYERvY3VtZW50U2VsZWN0aW9uI2lzKClgfQogICAqICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbWFya2VyY29sbGVjdGlvbn5NYXJrZXIjaXMgYE1hcmtlciNpcygpYH0KICAgKiAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3RleHRwcm94eX5UZXh0UHJveHkjaXMgYFRleHRQcm94eSNpcygpYH0KICAgKgogICAqIEBtZXRob2QgI2lzCiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUKICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0KICAgKi8KCgogIGlzKHR5cGUpIHsKICAgIHJldHVybiB0eXBlID09ICdub2RlJyB8fCB0eXBlID09ICdtb2RlbDpub2RlJzsKICB9CiAgLyoqCiAgICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyBub2RlLCB0aGF0IGlzIGEgbm9kZSB3aXRoIGV4YWN0bHkgc2FtZSBhdHRyaWJ1dGVzLCBhbmQgcmV0dXJucyBpdC4KICAgKgogICAqIEBwcm90ZWN0ZWQKICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9ub2Rlfk5vZGV9IE5vZGUgd2l0aCBzYW1lIGF0dHJpYnV0ZXMgYXMgdGhpcyBub2RlLgogICAqLwoKCiAgX2Nsb25lKCkgewogICAgcmV0dXJuIG5ldyBOb2RlKHRoaXMuX2F0dHJzKTsKICB9CiAgLyoqCiAgICogUmVtb3ZlcyB0aGlzIG5vZGUgZnJvbSBpdCdzIHBhcmVudC4KICAgKgogICAqIEBzZWUgbW9kdWxlOmVuZ2luZS9tb2RlbC93cml0ZXJ+V3JpdGVyI3JlbW92ZQogICAqIEBwcm90ZWN0ZWQKICAgKi8KCgogIF9yZW1vdmUoKSB7CiAgICB0aGlzLnBhcmVudC5fcmVtb3ZlQ2hpbGRyZW4odGhpcy5pbmRleCk7CiAgfQogIC8qKgogICAqIFNldHMgYXR0cmlidXRlIG9uIHRoZSBub2RlLiBJZiBhdHRyaWJ1dGUgd2l0aCB0aGUgc2FtZSBrZXkgYWxyZWFkeSBpcyBzZXQsIGl0J3MgdmFsdWUgaXMgb3ZlcndyaXR0ZW4uCiAgICoKICAgKiBAc2VlIG1vZHVsZTplbmdpbmUvbW9kZWwvd3JpdGVyfldyaXRlciNzZXRBdHRyaWJ1dGUKICAgKiBAcHJvdGVjdGVkCiAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBLZXkgb2YgYXR0cmlidXRlIHRvIHNldC4KICAgKiBAcGFyYW0geyp9IHZhbHVlIEF0dHJpYnV0ZSB2YWx1ZS4KICAgKi8KCgogIF9zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSkgewogICAgdGhpcy5fYXR0cnMuc2V0KGtleSwgdmFsdWUpOwogIH0KICAvKioKICAgKiBSZW1vdmVzIGFsbCBhdHRyaWJ1dGVzIGZyb20gdGhlIG5vZGUgYW5kIHNldHMgZ2l2ZW4gYXR0cmlidXRlcy4KICAgKgogICAqIEBzZWUgbW9kdWxlOmVuZ2luZS9tb2RlbC93cml0ZXJ+V3JpdGVyI3NldEF0dHJpYnV0ZXMKICAgKiBAcHJvdGVjdGVkCiAgICogQHBhcmFtIHtPYmplY3R9IFthdHRyc10gQXR0cmlidXRlcyB0byBzZXQuIFNlZSB7QGxpbmsgbW9kdWxlOnV0aWxzL3RvbWFwfnRvTWFwfSBmb3IgYSBsaXN0IG9mIGFjY2VwdGVkIHZhbHVlcy4KICAgKi8KCgogIF9zZXRBdHRyaWJ1dGVzVG8oYXR0cnMpIHsKICAgIHRoaXMuX2F0dHJzID0gdG9NYXAoYXR0cnMpOwogIH0KICAvKioKICAgKiBSZW1vdmVzIGFuIGF0dHJpYnV0ZSB3aXRoIGdpdmVuIGtleSBmcm9tIHRoZSBub2RlLgogICAqCiAgICogQHNlZSBtb2R1bGU6ZW5naW5lL21vZGVsL3dyaXRlcn5Xcml0ZXIjcmVtb3ZlQXR0cmlidXRlCiAgICogQHByb3RlY3RlZAogICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgS2V5IG9mIGF0dHJpYnV0ZSB0byByZW1vdmUuCiAgICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgYXR0cmlidXRlIHdhcyBzZXQgb24gdGhlIGVsZW1lbnQsIGBmYWxzZWAgb3RoZXJ3aXNlLgogICAqLwoKCiAgX3JlbW92ZUF0dHJpYnV0ZShrZXkpIHsKICAgIHJldHVybiB0aGlzLl9hdHRycy5kZWxldGUoa2V5KTsKICB9CiAgLyoqCiAgICogUmVtb3ZlcyBhbGwgYXR0cmlidXRlcyBmcm9tIHRoZSBub2RlLgogICAqCiAgICogQHNlZSBtb2R1bGU6ZW5naW5lL21vZGVsL3dyaXRlcn5Xcml0ZXIjY2xlYXJBdHRyaWJ1dGVzCiAgICogQHByb3RlY3RlZAogICAqLwoKCiAgX2NsZWFyQXR0cmlidXRlcygpIHsKICAgIHRoaXMuX2F0dHJzLmNsZWFyKCk7CiAgfQoKfQovKioKICogVGhlIG5vZGUncyBwYXJlbnQgZG9lcyBub3QgY29udGFpbiB0aGlzIG5vZGUuCiAqCiAqIFRoaXMgZXJyb3IgbWF5IGJlIHRocm93biBmcm9tIGNvcnJ1cHRlZCB0cmVlcy4KICoKICogQGVycm9yIG1vZGVsLW5vZGUtbm90LWZvdW5kLWluLXBhcmVudAogKi8="},{"version":3,"sources":["/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-engine/src/model/node.js"],"names":["toMap","CKEditorError","compareArrays","Node","constructor","attrs","parent","_attrs","index","pos","getChildIndex","startOffset","getChildStartOffset","offsetSize","endOffset","nextSibling","getChild","previousSibling","root","document","getPath","path","node","unshift","getAncestors","options","includeSelf","parentFirst","ancestors","getCommonAncestor","ancestorsA","ancestorsB","i","isBefore","thisPath","nodePath","result","isAfter","hasAttribute","key","has","getAttribute","get","getAttributes","entries","getAttributeKeys","keys","toJSON","json","size","attributes","Array","from","reduce","attr","is","type","_clone","_remove","_removeChildren","_setAttribute","value","set","_setAttributesTo","_removeAttribute","delete","_clearAttributes","clear"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/node\n */\n\nimport toMap from '@ckeditor/ckeditor5-utils/src/tomap';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport compareArrays from '@ckeditor/ckeditor5-utils/src/comparearrays';\n\n// To check if component is loaded more than once.\nimport '@ckeditor/ckeditor5-utils/src/version';\n\n/**\n * Model node. Most basic structure of model tree.\n *\n * This is an abstract class that is a base for other classes representing different nodes in model.\n *\n * **Note:** If a node is detached from the model tree, you can manipulate it using it's API.\n * However, it is **very important** that nodes already attached to model tree should be only changed through\n * {@link module:engine/model/writer~Writer Writer API}.\n *\n * Changes done by `Node` methods, like {@link module:engine/model/element~Element#_insertChild _insertChild} or\n * {@link module:engine/model/node~Node#_setAttribute _setAttribute}\n * do not generate {@link module:engine/model/operation/operation~Operation operations}\n * which are essential for correct editor work if you modify nodes in {@link module:engine/model/document~Document document} root.\n *\n * The flow of working on `Node` (and classes that inherits from it) is as such:\n * 1. You can create a `Node` instance, modify it using it's API.\n * 2. Add `Node` to the model using `Batch` API.\n * 3. Change `Node` that was already added to the model using `Batch` API.\n *\n * Similarly, you cannot use `Batch` API on a node that has not been added to the model tree, with the exception\n * of {@link module:engine/model/writer~Writer#insert inserting} that node to the model tree.\n *\n * Be aware that using {@link module:engine/model/writer~Writer#remove remove from Batch API} does not allow to use `Node` API because\n * the information about `Node` is still kept in model document.\n *\n * In case of {@link module:engine/model/element~Element element node}, adding and removing children also counts as changing a node and\n * follows same rules.\n */\nexport default class Node {\n\t/**\n\t * Creates a model node.\n\t *\n\t * This is an abstract class, so this constructor should not be used directly.\n\t *\n\t * @abstract\n\t * @param {Object} [attrs] Node's attributes. See {@link module:utils/tomap~toMap} for a list of accepted values.\n\t */\n\tconstructor( attrs ) {\n\t\t/**\n\t\t * Parent of this node. It could be {@link module:engine/model/element~Element}\n\t\t * or {@link module:engine/model/documentfragment~DocumentFragment}.\n\t\t * Equals to `null` if the node has no parent.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment|null}\n\t\t */\n\t\tthis.parent = null;\n\n\t\t/**\n\t\t * Attributes set on this node.\n\t\t *\n\t\t * @private\n\t\t * @member {Map} module:engine/model/node~Node#_attrs\n\t\t */\n\t\tthis._attrs = toMap( attrs );\n\t}\n\n\t/**\n\t * Index of this node in it's parent or `null` if the node has no parent.\n\t *\n\t * Accessing this property throws an error if this node's parent element does not contain it.\n\t * This means that model tree got broken.\n\t *\n\t * @readonly\n\t * @type {Number|null}\n\t */\n\tget index() {\n\t\tlet pos;\n\n\t\tif ( !this.parent ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif ( ( pos = this.parent.getChildIndex( this ) ) === null ) {\n\t\t\tthrow new CKEditorError( 'model-node-not-found-in-parent: The node\\'s parent does not contain this node.', this );\n\t\t}\n\n\t\treturn pos;\n\t}\n\n\t/**\n\t * Offset at which this node starts in it's parent. It is equal to the sum of {@link #offsetSize offsetSize}\n\t * of all it's previous siblings. Equals to `null` if node has no parent.\n\t *\n\t * Accessing this property throws an error if this node's parent element does not contain it.\n\t * This means that model tree got broken.\n\t *\n\t * @readonly\n\t * @type {Number|null}\n\t */\n\tget startOffset() {\n\t\tlet pos;\n\n\t\tif ( !this.parent ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif ( ( pos = this.parent.getChildStartOffset( this ) ) === null ) {\n\t\t\tthrow new CKEditorError( 'model-node-not-found-in-parent: The node\\'s parent does not contain this node.', this );\n\t\t}\n\n\t\treturn pos;\n\t}\n\n\t/**\n\t * Offset size of this node. Represents how much \"offset space\" is occupied by the node in it's parent.\n\t * It is important for {@link module:engine/model/position~Position position}. When node has `offsetSize` greater than `1`, position\n\t * can be placed between that node start and end. `offsetSize` greater than `1` is for nodes that represents more\n\t * than one entity, i.e. {@link module:engine/model/text~Text text node}.\n\t *\n\t * @readonly\n\t * @type {Number}\n\t */\n\tget offsetSize() {\n\t\treturn 1;\n\t}\n\n\t/**\n\t * Offset at which this node ends in it's parent. It is equal to the sum of this node's\n\t * {@link module:engine/model/node~Node#startOffset start offset} and {@link #offsetSize offset size}.\n\t * Equals to `null` if the node has no parent.\n\t *\n\t * @readonly\n\t * @type {Number|null}\n\t */\n\tget endOffset() {\n\t\tif ( !this.parent ) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn this.startOffset + this.offsetSize;\n\t}\n\n\t/**\n\t * Node's next sibling or `null` if the node is a last child of it's parent or if the node has no parent.\n\t *\n\t * @readonly\n\t * @type {module:engine/model/node~Node|null}\n\t */\n\tget nextSibling() {\n\t\tconst index = this.index;\n\n\t\treturn ( index !== null && this.parent.getChild( index + 1 ) ) || null;\n\t}\n\n\t/**\n\t * Node's previous sibling or `null` if the node is a first child of it's parent or if the node has no parent.\n\t *\n\t * @readonly\n\t * @type {module:engine/model/node~Node|null}\n\t */\n\tget previousSibling() {\n\t\tconst index = this.index;\n\n\t\treturn ( index !== null && this.parent.getChild( index - 1 ) ) || null;\n\t}\n\n\t/**\n\t * The top-most ancestor of the node. If node has no parent it is the root itself. If the node is a part\n\t * of {@link module:engine/model/documentfragment~DocumentFragment}, it's `root` is equal to that `DocumentFragment`.\n\t *\n\t * @readonly\n\t * @type {module:engine/model/node~Node|module:engine/model/documentfragment~DocumentFragment}\n\t */\n\tget root() {\n\t\tlet root = this; // eslint-disable-line consistent-this\n\n\t\twhile ( root.parent ) {\n\t\t\troot = root.parent;\n\t\t}\n\n\t\treturn root;\n\t}\n\n\t/**\n\t * {@link module:engine/model/document~Document Document} that owns this node or `null` if the node has no parent or is inside\n\t * a {@link module:engine/model/documentfragment~DocumentFragment DocumentFragment}.\n\t *\n\t * @readonly\n\t * @type {module:engine/model/document~Document|null}\n\t */\n\tget document() {\n\t\t// This is a top element of a sub-tree.\n\t\tif ( this.root == this ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Root may be `DocumentFragment` which does not have document property.\n\t\treturn this.root.document || null;\n\t}\n\n\t/**\n\t * Gets path to the node. The path is an array containing starting offsets of consecutive ancestors of this node,\n\t * beginning from {@link module:engine/model/node~Node#root root}, down to this node's starting offset. The path can be used to\n\t * create {@link module:engine/model/position~Position Position} instance.\n\t *\n\t *\t\tconst abc = new Text( 'abc' );\n\t *\t\tconst foo = new Text( 'foo' );\n\t *\t\tconst h1 = new Element( 'h1', null, new Text( 'header' ) );\n\t *\t\tconst p = new Element( 'p', null, [ abc, foo ] );\n\t *\t\tconst div = new Element( 'div', null, [ h1, p ] );\n\t *\t\tfoo.getPath(); // Returns [ 1, 3 ]. `foo` is in `p` which is in `div`. `p` starts at offset 1, while `foo` at 3.\n\t *\t\th1.getPath(); // Returns [ 0 ].\n\t *\t\tdiv.getPath(); // Returns [].\n\t *\n\t * @returns {Array.<Number>} The path.\n\t */\n\tgetPath() {\n\t\tconst path = [];\n\t\tlet node = this; // eslint-disable-line consistent-this\n\n\t\twhile ( node.parent ) {\n\t\t\tpath.unshift( node.startOffset );\n\t\t\tnode = node.parent;\n\t\t}\n\n\t\treturn path;\n\t}\n\n\t/**\n\t * Returns ancestors array of this node.\n\t *\n\t * @param {Object} options Options object.\n\t * @param {Boolean} [options.includeSelf=false] When set to `true` this node will be also included in parent's array.\n\t * @param {Boolean} [options.parentFirst=false] When set to `true`, array will be sorted from node's parent to root element,\n\t * otherwise root element will be the first item in the array.\n\t * @returns {Array} Array with ancestors.\n\t */\n\tgetAncestors( options = { includeSelf: false, parentFirst: false } ) {\n\t\tconst ancestors = [];\n\t\tlet parent = options.includeSelf ? this : this.parent;\n\n\t\twhile ( parent ) {\n\t\t\tancestors[ options.parentFirst ? 'push' : 'unshift' ]( parent );\n\t\t\tparent = parent.parent;\n\t\t}\n\n\t\treturn ancestors;\n\t}\n\n\t/**\n\t * Returns a {@link module:engine/model/element~Element} or {@link module:engine/model/documentfragment~DocumentFragment}\n\t * which is a common ancestor of both nodes.\n\t *\n\t * @param {module:engine/model/node~Node} node The second node.\n\t * @param {Object} options Options object.\n\t * @param {Boolean} [options.includeSelf=false] When set to `true` both nodes will be considered \"ancestors\" too.\n\t * Which means that if e.g. node A is inside B, then their common ancestor will be B.\n\t * @returns {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment|null}\n\t */\n\tgetCommonAncestor( node, options = {} ) {\n\t\tconst ancestorsA = this.getAncestors( options );\n\t\tconst ancestorsB = node.getAncestors( options );\n\n\t\tlet i = 0;\n\n\t\twhile ( ancestorsA[ i ] == ancestorsB[ i ] && ancestorsA[ i ] ) {\n\t\t\ti++;\n\t\t}\n\n\t\treturn i === 0 ? null : ancestorsA[ i - 1 ];\n\t}\n\n\t/**\n\t * Returns whether this node is before given node. `false` is returned if nodes are in different trees (for example,\n\t * in different {@link module:engine/model/documentfragment~DocumentFragment}s).\n\t *\n\t * @param {module:engine/model/node~Node} node Node to compare with.\n\t * @returns {Boolean}\n\t */\n\tisBefore( node ) {\n\t\t// Given node is not before this node if they are same.\n\t\tif ( this == node ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Return `false` if it is impossible to compare nodes.\n\t\tif ( this.root !== node.root ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst thisPath = this.getPath();\n\t\tconst nodePath = node.getPath();\n\n\t\tconst result = compareArrays( thisPath, nodePath );\n\n\t\tswitch ( result ) {\n\t\t\tcase 'prefix':\n\t\t\t\treturn true;\n\n\t\t\tcase 'extension':\n\t\t\t\treturn false;\n\n\t\t\tdefault:\n\t\t\t\treturn thisPath[ result ] < nodePath[ result ];\n\t\t}\n\t}\n\n\t/**\n\t * Returns whether this node is after given node. `false` is returned if nodes are in different trees (for example,\n\t * in different {@link module:engine/model/documentfragment~DocumentFragment}s).\n\t *\n\t * @param {module:engine/model/node~Node} node Node to compare with.\n\t * @returns {Boolean}\n\t */\n\tisAfter( node ) {\n\t\t// Given node is not before this node if they are same.\n\t\tif ( this == node ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Return `false` if it is impossible to compare nodes.\n\t\tif ( this.root !== node.root ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// In other cases, just check if the `node` is before, and return the opposite.\n\t\treturn !this.isBefore( node );\n\t}\n\n\t/**\n\t * Checks if the node has an attribute with given key.\n\t *\n\t * @param {String} key Key of attribute to check.\n\t * @returns {Boolean} `true` if attribute with given key is set on node, `false` otherwise.\n\t */\n\thasAttribute( key ) {\n\t\treturn this._attrs.has( key );\n\t}\n\n\t/**\n\t * Gets an attribute value for given key or `undefined` if that attribute is not set on node.\n\t *\n\t * @param {String} key Key of attribute to look for.\n\t * @returns {*} Attribute value or `undefined`.\n\t */\n\tgetAttribute( key ) {\n\t\treturn this._attrs.get( key );\n\t}\n\n\t/**\n\t * Returns iterator that iterates over this node's attributes.\n\t *\n\t * Attributes are returned as arrays containing two items. First one is attribute key and second is attribute value.\n\t * This format is accepted by native `Map` object and also can be passed in `Node` constructor.\n\t *\n\t * @returns {Iterable.<*>}\n\t */\n\tgetAttributes() {\n\t\treturn this._attrs.entries();\n\t}\n\n\t/**\n\t * Returns iterator that iterates over this node's attribute keys.\n\t *\n\t * @returns {Iterable.<String>}\n\t */\n\tgetAttributeKeys() {\n\t\treturn this._attrs.keys();\n\t}\n\n\t/**\n\t * Converts `Node` to plain object and returns it.\n\t *\n\t * @returns {Object} `Node` converted to plain object.\n\t */\n\ttoJSON() {\n\t\tconst json = {};\n\n\t\t// Serializes attributes to the object.\n\t\t// attributes = { a: 'foo', b: 1, c: true }.\n\t\tif ( this._attrs.size ) {\n\t\t\tjson.attributes = Array.from( this._attrs ).reduce( ( result, attr ) => {\n\t\t\t\tresult[ attr[ 0 ] ] = attr[ 1 ];\n\n\t\t\t\treturn result;\n\t\t\t}, {} );\n\t\t}\n\n\t\treturn json;\n\t}\n\n\t/**\n\t * Checks whether this object is of the given type.\n\t *\n\t * This method is useful when processing model objects that are of unknown type. For example, a function\n\t * may return a {@link module:engine/model/documentfragment~DocumentFragment} or a {@link module:engine/model/node~Node}\n\t * that can be either a text node or an element. This method can be used to check what kind of object is returned.\n\t *\n\t *\t\tsomeObject.is( 'element' ); // -> true if this is an element\n\t *\t\tsomeObject.is( 'node' ); // -> true if this is a node (a text node or an element)\n\t *\t\tsomeObject.is( 'documentFragment' ); // -> true if this is a document fragment\n\t *\n\t * Since this method is also available on a range of view objects, you can prefix the type of the object with\n\t * `model:` or `view:` to check, for example, if this is the model's or view's element:\n\t *\n\t *\t\tmodelElement.is( 'model:element' ); // -> true\n\t *\t\tmodelElement.is( 'view:element' ); // -> false\n\t *\n\t * By using this method it is also possible to check a name of an element:\n\t *\n\t *\t\timageElement.is( 'image' ); // -> true\n\t *\t\timageElement.is( 'element', 'image' ); // -> same as above\n\t *\t\timageElement.is( 'model:element', 'image' ); // -> same as above, but more precise\n\t *\n\t * The list of model objects which implement the `is()` method:\n\t *\n\t * * {@link module:engine/model/node~Node#is `Node#is()`}\n\t * * {@link module:engine/model/text~Text#is `Text#is()`}\n\t * * {@link module:engine/model/element~Element#is `Element#is()`}\n\t * * {@link module:engine/model/rootelement~RootElement#is `RootElement#is()`}\n\t * * {@link module:engine/model/position~Position#is `Position#is()`}\n\t * * {@link module:engine/model/liveposition~LivePosition#is `LivePosition#is()`}\n\t * * {@link module:engine/model/range~Range#is `Range#is()`}\n\t * * {@link module:engine/model/liverange~LiveRange#is `LiveRange#is()`}\n\t * * {@link module:engine/model/documentfragment~DocumentFragment#is `DocumentFragment#is()`}\n\t * * {@link module:engine/model/selection~Selection#is `Selection#is()`}\n\t * * {@link module:engine/model/documentselection~DocumentSelection#is `DocumentSelection#is()`}\n\t * * {@link module:engine/model/markercollection~Marker#is `Marker#is()`}\n\t * * {@link module:engine/model/textproxy~TextProxy#is `TextProxy#is()`}\n\t *\n\t * @method #is\n\t * @param {String} type\n\t * @returns {Boolean}\n\t */\n\tis( type ) {\n\t\treturn type == 'node' || type == 'model:node';\n\t}\n\n\t/**\n\t * Creates a copy of this node, that is a node with exactly same attributes, and returns it.\n\t *\n\t * @protected\n\t * @returns {module:engine/model/node~Node} Node with same attributes as this node.\n\t */\n\t_clone() {\n\t\treturn new Node( this._attrs );\n\t}\n\n\t/**\n\t * Removes this node from it's parent.\n\t *\n\t * @see module:engine/model/writer~Writer#remove\n\t * @protected\n\t */\n\t_remove() {\n\t\tthis.parent._removeChildren( this.index );\n\t}\n\n\t/**\n\t * Sets attribute on the node. If attribute with the same key already is set, it's value is overwritten.\n\t *\n\t * @see module:engine/model/writer~Writer#setAttribute\n\t * @protected\n\t * @param {String} key Key of attribute to set.\n\t * @param {*} value Attribute value.\n\t */\n\t_setAttribute( key, value ) {\n\t\tthis._attrs.set( key, value );\n\t}\n\n\t/**\n\t * Removes all attributes from the node and sets given attributes.\n\t *\n\t * @see module:engine/model/writer~Writer#setAttributes\n\t * @protected\n\t * @param {Object} [attrs] Attributes to set. See {@link module:utils/tomap~toMap} for a list of accepted values.\n\t */\n\t_setAttributesTo( attrs ) {\n\t\tthis._attrs = toMap( attrs );\n\t}\n\n\t/**\n\t * Removes an attribute with given key from the node.\n\t *\n\t * @see module:engine/model/writer~Writer#removeAttribute\n\t * @protected\n\t * @param {String} key Key of attribute to remove.\n\t * @returns {Boolean} `true` if the attribute was set on the element, `false` otherwise.\n\t */\n\t_removeAttribute( key ) {\n\t\treturn this._attrs.delete( key );\n\t}\n\n\t/**\n\t * Removes all attributes from the node.\n\t *\n\t * @see module:engine/model/writer~Writer#clearAttributes\n\t * @protected\n\t */\n\t_clearAttributes() {\n\t\tthis._attrs.clear();\n\t}\n}\n\n/**\n * The node's parent does not contain this node.\n *\n * This error may be thrown from corrupted trees.\n *\n * @error model-node-not-found-in-parent\n */\n"]}]}