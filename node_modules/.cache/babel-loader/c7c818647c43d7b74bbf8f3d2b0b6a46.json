{"remainingRequest":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/babel-loader/lib/index.js!/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-table/src/tablewalker.js","dependencies":[{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-table/src/tablewalker.js","mtime":499162500000},{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js","mtime":499162500000},{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/babel-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:LyoqCiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDE5LCBDS1NvdXJjZSAtIEZyZWRlcmljbyBLbmFiYmVuLiBBbGwgcmlnaHRzIHJlc2VydmVkLgogKiBGb3IgbGljZW5zaW5nLCBzZWUgTElDRU5TRS5tZCBvciBodHRwczovL2NrZWRpdG9yLmNvbS9sZWdhbC9ja2VkaXRvci1vc3MtbGljZW5zZQogKi8KCi8qKgogKiBAbW9kdWxlIHRhYmxlL3RhYmxld2Fsa2VyCiAqLwoKLyoqCiAqIFRhYmxlIGl0ZXJhdG9yIGNsYXNzLiBJdCBhbGxvd3MgdG8gaXRlcmF0ZSBvdmVyIHRhYmxlIGNlbGxzLiBGb3IgZWFjaCBjZWxsIHRoZSBpdGVyYXRvciB5aWVsZHMKICoge0BsaW5rIG1vZHVsZTp0YWJsZS90YWJsZXdhbGtlcn5UYWJsZVdhbGtlclZhbHVlfSB3aXRoIHByb3BlciB0YWJsZSBjZWxsIGF0dHJpYnV0ZXMuCiAqLwpleHBvcnQgZGVmYXVsdCBjbGFzcyBUYWJsZVdhbGtlciB7CiAgLyoqCiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGUgdGFibGUgd2Fsa2VyLgogICAqCiAgICogVGhlIHRhYmxlIHdhbGtlciBpdGVyYXRlcyBpbnRlcm5hbGx5IGJ5IHRyYXZlcnNpbmcgdGhlIHRhYmxlIGZyb20gcm93IGluZGV4ID0gMCBhbmQgY29sdW1uIGluZGV4ID0gMC4KICAgKiBJdCB3YWxrcyByb3cgYnkgcm93IGFuZCBjb2x1bW4gYnkgY29sdW1uIGluIG9yZGVyIHRvIG91dHB1dCB2YWx1ZXMgZGVmaW5lZCBpbiB0aGUgY29uc3RydWN0b3IuCiAgICogQnkgZGVmYXVsdCBpdCB3aWxsIG91dHB1dCBvbmx5IHRob3NlIGxvY2F0aW9ucyB0aGF0IGFyZSBvY2N1cGllZCBieSBhIGNlbGwuIFRvIGluY2x1ZGUgYWxzbyBzcGFubmVkIHJvd3MgYW5kIGNvbHVtbnMsCiAgICogcGFzcyB0aGUgYGluY2x1ZGVTcGFubmVkYCBvcHRpb24gdG8gdGhlIGNvbnN0cnVjdG9yLgogICAqCiAgICogVGhlIG1vc3QgaW1wb3J0YW50IHZhbHVlcyBvZiB0aGUgaXRlcmF0b3IgYXJlIGNvbHVtbiBhbmQgcm93IGluZGV4ZXMgb2YgYSBjZWxsLgogICAqCiAgICogU2VlIHtAbGluayBtb2R1bGU6dGFibGUvdGFibGV3YWxrZXJ+VGFibGVXYWxrZXJWYWx1ZX0gd2hhdCB2YWx1ZXMgYXJlIHJldHVybmVkIGJ5IHRoZSB0YWJsZSB3YWxrZXIuCiAgICoKICAgKiBUbyBpdGVyYXRlIG92ZXIgYSBnaXZlbiByb3c6CiAgICoKICAgKgkJY29uc3QgdGFibGVXYWxrZXIgPSBuZXcgVGFibGVXYWxrZXIoIHRhYmxlLCB7IHN0YXJ0Um93OiAxLCBlbmRSb3c6IDIgfSApOwogICAqCiAgICoJCWZvciAoIGNvbnN0IGNlbGxJbmZvIG9mIHRhYmxlV2Fsa2VyICkgewogICAqCQkJY29uc29sZS5sb2coICdBIGNlbGwgYXQgcm93ICcgKyBjZWxsSW5mby5yb3cgKyAnIGFuZCBjb2x1bW4gJyArIGNlbGxJbmZvLmNvbHVtbiApOwogICAqCQl9CiAgICoKICAgKiBGb3IgaW5zdGFuY2UgdGhlIGNvZGUgYWJvdmUgZm9yIHRoZSBmb2xsb3dpbmcgdGFibGU6CiAgICoKICAgKgkJKy0tLS0rLS0tLSstLS0tKy0tLS0rLS0tLSstLS0tKwogICAqCQl8IDAwICAgICAgfCAwMiB8IDAzIHwgMDQgfCAwNSB8CiAgICoJCXwgICAgICAgICArLS0tLSstLS0tKy0tLS0rLS0tLSsKICAgKgkJfCAgICAgICAgIHwgMTIgICAgICB8IDE0IHwgMTUgfAogICAqCQl8ICAgICAgICAgKy0tLS0rLS0tLSstLS0tKyAgICArCiAgICoJCXwgICAgICAgICB8IDIyICAgICAgICAgICB8ICAgIHwKICAgKgkJfC0tLS0rLS0tLSstLS0tKy0tLS0rLS0tLSsgICAgKwogICAqCQl8IDMwIHwgMzEgfCAzMiB8IDMzIHwgMzQgfCAgICB8CiAgICoJCSstLS0tKy0tLS0rLS0tLSstLS0tKy0tLS0rLS0tLSsKICAgKgogICAqIHdpbGwgbG9nIGluIHRoZSBjb25zb2xlOgogICAqCiAgICoJCSdBIGNlbGwgYXQgcm93IDEgYW5kIGNvbHVtbiAyJwogICAqCQknQSBjZWxsIGF0IHJvdyAxIGFuZCBjb2x1bW4gNCcKICAgKgkJJ0EgY2VsbCBhdCByb3cgMSBhbmQgY29sdW1uIDUnCiAgICoJCSdBIGNlbGwgYXQgcm93IDIgYW5kIGNvbHVtbiAyJwogICAqCiAgICogVG8gYWxzbyBpdGVyYXRlIG92ZXIgc3Bhbm5lZCBjZWxsczoKICAgKgogICAqCQljb25zdCB0YWJsZVdhbGtlciA9IG5ldyBUYWJsZVdhbGtlciggdGFibGUsIHsgc3RhcnRSb3c6IDEsIGVuZFJvdzogMSwgaW5jbHVkZVNwYW5uZWQ6IHRydWUgfSApOwogICAqCiAgICoJCWZvciAoIGNvbnN0IHZhbHVlIG9mIHRhYmxlV2Fsa2VyICkgewogICAqCQkJY29uc29sZS5sb2coICdDZWxsIGF0ICcgKyB2YWx1ZS5yb3cgKyAnIHggJyArIHZhbHVlLmNvbHVtbiArICcgOiAnICsgKCB2YWx1ZS5pc1NwYW5uZWQgPyAnaXMgc3Bhbm5lZCcgOiAnaGFzIGRhdGEnICkgKTsKICAgKgkJfQogICAqCiAgICogd2lsbCBsb2cgaW4gdGhlIGNvbnNvbGUgZm9yIHRoZSB0YWJsZSBmcm9tIHByZXZpb3VzIGV4YW1wbGU6CiAgICoKICAgKgkJJ0NlbGwgYXQgMSB4IDAgOiBpcyBzcGFubmVkJwogICAqCQknQ2VsbCBhdCAxIHggMSA6IGlzIHNwYW5uZWQnCiAgICoJCSdDZWxsIGF0IDEgeCAyIDogaGFzIGRhdGEnCiAgICoJCSdDZWxsIGF0IDEgeCAzIDogaXMgc3Bhbm5lZCcKICAgKgkJJ0NlbGwgYXQgMSB4IDQgOiBoYXMgZGF0YScKICAgKgkJJ0NlbGwgYXQgMSB4IDUgOiBoYXMgZGF0YScKICAgKgogICAqIEBjb25zdHJ1Y3RvcgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR9IHRhYmxlIEEgdGFibGUgb3ZlciB3aGljaCB0aGUgd2Fsa2VyIGl0ZXJhdGVzLgogICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gQW4gb2JqZWN0IHdpdGggY29uZmlndXJhdGlvbi4KICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY29sdW1uXSBBIGNvbHVtbiBpbmRleCBmb3Igd2hpY2ggdGhpcyBpdGVyYXRvciB3aWxsIG91dHB1dCBjZWxscy4KICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc3RhcnRSb3c9MF0gQSByb3cgaW5kZXggZm9yIHdoaWNoIHRoaXMgaXRlcmF0b3Igc2hvdWxkIHN0YXJ0LgogICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5lbmRSb3ddIEEgcm93IGluZGV4IGZvciB3aGljaCB0aGlzIGl0ZXJhdG9yIHNob3VsZCBlbmQuCiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5pbmNsdWRlU3Bhbm5lZD1mYWxzZV0gQWxzbyByZXR1cm4gdmFsdWVzIGZvciBzcGFubmVkIGNlbGxzLgogICAqLwogIGNvbnN0cnVjdG9yKHRhYmxlLCBvcHRpb25zID0ge30pIHsKICAgIC8qKgogICAgICogVGhlIHdhbGtlcidzIHRhYmxlIGVsZW1lbnQuCiAgICAgKgogICAgICogQHJlYWRvbmx5CiAgICAgKiBAbWVtYmVyIHttb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudH0KICAgICAqLwogICAgdGhpcy50YWJsZSA9IHRhYmxlOwogICAgLyoqCiAgICAgKiBBIHJvdyBpbmRleCBvbiB3aGljaCB0aGlzIGl0ZXJhdG9yIHdpbGwgc3RhcnQuCiAgICAgKgogICAgICogQHJlYWRvbmx5CiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9CiAgICAgKi8KCiAgICB0aGlzLnN0YXJ0Um93ID0gb3B0aW9ucy5zdGFydFJvdyB8fCAwOwogICAgLyoqCiAgICAgKiBBIHJvdyBpbmRleCBvbiB3aGljaCB0aGlzIGl0ZXJhdG9yIHdpbGwgZW5kLgogICAgICoKICAgICAqIEByZWFkb25seQogICAgICogQG1lbWJlciB7TnVtYmVyfQogICAgICovCgogICAgdGhpcy5lbmRSb3cgPSB0eXBlb2Ygb3B0aW9ucy5lbmRSb3cgPT0gJ251bWJlcicgPyBvcHRpb25zLmVuZFJvdyA6IHVuZGVmaW5lZDsKICAgIC8qKgogICAgICogRW5hYmxlcyBvdXRwdXQgb2Ygc3Bhbm5lZCBjZWxscyB0aGF0IGFyZSBub3JtYWxseSBub3QgeWllbGRlZC4KICAgICAqCiAgICAgKiBAcmVhZG9ubHkKICAgICAqIEBtZW1iZXIge0Jvb2xlYW59CiAgICAgKi8KCiAgICB0aGlzLmluY2x1ZGVTcGFubmVkID0gISFvcHRpb25zLmluY2x1ZGVTcGFubmVkOwogICAgLyoqCiAgICAgKiBJZiBzZXQsIHRoZSB0YWJsZSB3YWxrZXIgd2lsbCBvbmx5IG91dHB1dCBjZWxscyBvZiBhIGdpdmVuIGNvbHVtbiBvciBjZWxscyB0aGF0IG92ZXJsYXAgaXQuCiAgICAgKgogICAgICogQHJlYWRvbmx5CiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9CiAgICAgKi8KCiAgICB0aGlzLmNvbHVtbiA9IHR5cGVvZiBvcHRpb25zLmNvbHVtbiA9PSAnbnVtYmVyJyA/IG9wdGlvbnMuY29sdW1uIDogdW5kZWZpbmVkOwogICAgLyoqCiAgICAgKiBSb3cgaW5kZXhlcyB0byBza2lwIGZyb20gdGhlIGl0ZXJhdGlvbi4KICAgICAqCiAgICAgKiBAcmVhZG9ubHkKICAgICAqIEBtZW1iZXIge1NldDxOdW1iZXI+fQogICAgICogQHByaXZhdGUKICAgICAqLwoKICAgIHRoaXMuX3NraXBSb3dzID0gbmV3IFNldCgpOwogICAgLyoqCiAgICAgKiBUaGUgY3VycmVudCByb3cgaW5kZXguCiAgICAgKgogICAgICogQHJlYWRvbmx5CiAgICAgKiBAbWVtYmVyIHtOdW1iZXJ9CiAgICAgKiBAcHJpdmF0ZQogICAgICovCgogICAgdGhpcy5fcm93ID0gMDsKICAgIC8qKgogICAgICogVGhlIGN1cnJlbnQgY29sdW1uIGluZGV4LgogICAgICoKICAgICAqIEByZWFkb25seQogICAgICogQG1lbWJlciB7TnVtYmVyfQogICAgICogQHByaXZhdGUKICAgICAqLwoKICAgIHRoaXMuX2NvbHVtbiA9IDA7CiAgICAvKioKICAgICAqIFRoZSBjZWxsIGluZGV4IGluIGEgcGFyZW50IHJvdy4gRm9yIHNwYW5uZWQgY2VsbHMgd2hlbiB7QGxpbmsgI2luY2x1ZGVTcGFubmVkfSBpcyBzZXQgdG8gYHRydWVgLAogICAgICogdGhpcyByZXByZXNlbnRzIHRoZSBpbmRleCBvZiB0aGUgbmV4dCB0YWJsZSBjZWxsLgogICAgICoKICAgICAqIEByZWFkb25seQogICAgICogQG1lbWJlciB7TnVtYmVyfQogICAgICogQHByaXZhdGUKICAgICAqLwoKICAgIHRoaXMuX2NlbGxJbmRleCA9IDA7CiAgICAvKioKICAgICAqIEhvbGRzIGEgbWFwIG9mIHNwYW5uZWQgY2VsbHMgaW4gYSB0YWJsZS4KICAgICAqCiAgICAgKiBAcmVhZG9ubHkKICAgICAqIEBtZW1iZXIge01hcDxOdW1iZXIsIE1hcC48TnVtYmVyLCBtb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudD4+fQogICAgICogQHByaXZhdGUKICAgICAqLwoKICAgIHRoaXMuX3NwYW5uZWRDZWxscyA9IG5ldyBNYXAoKTsKICAgIHRoaXMuX25leHRDZWxsQXRDb2x1bW4gPSAtMTsKICB9CiAgLyoqCiAgICogSXRlcmFibGUgaW50ZXJmYWNlLgogICAqCiAgICogQHJldHVybnMge0l0ZXJhYmxlLjxtb2R1bGU6dGFibGUvdGFibGV3YWxrZXJ+VGFibGVXYWxrZXJWYWx1ZT59CiAgICovCgoKICBbU3ltYm9sLml0ZXJhdG9yXSgpIHsKICAgIHJldHVybiB0aGlzOwogIH0KICAvKioKICAgKiBHZXRzIHRoZSBuZXh0IHRhYmxlIHdhbGtlcidzIHZhbHVlLgogICAqCiAgICogQHJldHVybnMge21vZHVsZTp0YWJsZS90YWJsZXdhbGtlcn5UYWJsZVdhbGtlclZhbHVlfSBUaGUgbmV4dCB0YWJsZSB3YWxrZXIncyB2YWx1ZS4KICAgKi8KCgogIG5leHQoKSB7CiAgICBjb25zdCByb3cgPSB0aGlzLnRhYmxlLmdldENoaWxkKHRoaXMuX3Jvdyk7IC8vIEl0ZXJhdG9yIGlzIGRvbmUgd2hlbiB0aGVyZSdzIG5vIHJvdyAodGFibGUgZW5kZWQpIG9yIHRoZSByb3cgaXMgYWZ0ZXIgYGVuZFJvd2AgbGltaXQuCgogICAgaWYgKCFyb3cgfHwgdGhpcy5faXNPdmVyRW5kUm93KCkpIHsKICAgICAgcmV0dXJuIHsKICAgICAgICBkb25lOiB0cnVlCiAgICAgIH07CiAgICB9CgogICAgbGV0IGNlbGwsIHNraXBDdXJyZW50VmFsdWUsIG91dFZhbHVlOwoKICAgIGlmICh0aGlzLl9pc1NwYW5uZWQodGhpcy5fcm93LCB0aGlzLl9jb2x1bW4pKSB7CiAgICAgIGNlbGwgPSB0aGlzLl9nZXRTcGFubmVkKHRoaXMuX3JvdywgdGhpcy5fY29sdW1uKTsKICAgICAgc2tpcEN1cnJlbnRWYWx1ZSA9ICF0aGlzLmluY2x1ZGVTcGFubmVkIHx8IHRoaXMuX3Nob3VsZFNraXBSb3coKSB8fCB0aGlzLl9zaG91bGRTa2lwQ29sdW1uKCk7CiAgICAgIG91dFZhbHVlID0gdGhpcy5fZm9ybWF0T3V0VmFsdWUoY2VsbCwgdGhpcy5fY29sdW1uLCB0cnVlKTsKICAgIH0gZWxzZSB7CiAgICAgIGNlbGwgPSByb3cuZ2V0Q2hpbGQodGhpcy5fY2VsbEluZGV4KTsKCiAgICAgIGlmICghY2VsbCkgewogICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBtb3JlIGNlbGxzIGxlZnQgaW4gcm93IGFkdmFuY2UgdG8gdGhlIG5leHQgcm93LgogICAgICAgIHRoaXMuX3JvdysrOwogICAgICAgIHRoaXMuX2NvbHVtbiA9IDA7CiAgICAgICAgdGhpcy5fY2VsbEluZGV4ID0gMDsKICAgICAgICB0aGlzLl9uZXh0Q2VsbEF0Q29sdW1uID0gLTE7CiAgICAgICAgcmV0dXJuIHRoaXMubmV4dCgpOwogICAgICB9CgogICAgICBjb25zdCBjb2xzcGFuID0gcGFyc2VJbnQoY2VsbC5nZXRBdHRyaWJ1dGUoJ2NvbHNwYW4nKSB8fCAxKTsKICAgICAgY29uc3Qgcm93c3BhbiA9IHBhcnNlSW50KGNlbGwuZ2V0QXR0cmlidXRlKCdyb3dzcGFuJykgfHwgMSk7IC8vIFJlY29yZCB0aGlzIGNlbGwgc3BhbnMgaWYgaXQncyBub3QgMXgxIGNlbGwuCgogICAgICBpZiAoY29sc3BhbiA+IDEgfHwgcm93c3BhbiA+IDEpIHsKICAgICAgICB0aGlzLl9yZWNvcmRTcGFucyh0aGlzLl9yb3csIHRoaXMuX2NvbHVtbiwgcm93c3BhbiwgY29sc3BhbiwgY2VsbCk7CiAgICAgIH0KCiAgICAgIHRoaXMuX25leHRDZWxsQXRDb2x1bW4gPSB0aGlzLl9jb2x1bW4gKyBjb2xzcGFuOwogICAgICBza2lwQ3VycmVudFZhbHVlID0gdGhpcy5fc2hvdWxkU2tpcFJvdygpIHx8IHRoaXMuX3Nob3VsZFNraXBDb2x1bW4oKTsKICAgICAgb3V0VmFsdWUgPSB0aGlzLl9mb3JtYXRPdXRWYWx1ZShjZWxsLCB0aGlzLl9jb2x1bW4sIGZhbHNlLCByb3dzcGFuLCBjb2xzcGFuKTsKICAgIH0gLy8gQWR2YW5jZSB0byB0aGUgbmV4dCBjb2x1bW4gYmVmb3JlIHJldHVybmluZyB2YWx1ZS4KCgogICAgdGhpcy5fY29sdW1uKys7CgogICAgaWYgKHRoaXMuX2NvbHVtbiA9PSB0aGlzLl9uZXh0Q2VsbEF0Q29sdW1uKSB7CiAgICAgIHRoaXMuX2NlbGxJbmRleCsrOwogICAgfSAvLyBUaGUgY3VycmVudCB2YWx1ZSB3aWxsIGJlIHJldHVybmVkIG9ubHkgaWYgY3VycmVudCByb3cgYW5kIGNvbHVtbiBhcmUgbm90IHNraXBwZWQuCgoKICAgIHJldHVybiBza2lwQ3VycmVudFZhbHVlID8gdGhpcy5uZXh0KCkgOiBvdXRWYWx1ZTsKICB9CiAgLyoqCiAgICogTWFya3MgYSByb3cgdG8gc2tpcCBpbiB0aGUgbmV4dCBpdGVyYXRpb24uIEl0IHdpbGwgYWxzbyBza2lwIGNlbGxzIGZyb20gdGhlIGN1cnJlbnQgcm93IGlmIHRoZXJlIGFyZSBhbnkgY2VsbHMgZnJvbSB0aGUgY3VycmVudCByb3cKICAgKiB0byBvdXRwdXQuCiAgICoKICAgKiBAcGFyYW0ge051bWJlcn0gcm93IFJvdyBpbmRleCB0byBza2lwLgogICAqLwoKCiAgc2tpcFJvdyhyb3cpIHsKICAgIHRoaXMuX3NraXBSb3dzLmFkZChyb3cpOwogIH0KICAvKioKICAgKiBDaGVja3MgaWYgdGhlIGN1cnJlbnQgcm93IGlzIG92ZXIge0BsaW5rICNlbmRSb3d9LgogICAqCiAgICogQHByaXZhdGUKICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0KICAgKi8KCgogIF9pc092ZXJFbmRSb3coKSB7CiAgICAvLyBJZiB7QGxpbmsgI2VuZFJvdykgaXMgZGVmaW5lZCBza2lwIGFsbCByb3dzIGFib3ZlIGl0LgogICAgcmV0dXJuIHRoaXMuZW5kUm93ICE9PSB1bmRlZmluZWQgJiYgdGhpcy5fcm93ID4gdGhpcy5lbmRSb3c7CiAgfQogIC8qKgogICAqIEEgY29tbW9uIG1ldGhvZCBmb3IgZm9ybWF0dGluZyB0aGUgaXRlcmF0b3IncyBvdXRwdXQgdmFsdWUuCiAgICoKICAgKiBAcHJpdmF0ZQogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR9IGNlbGwgVGhlIHRhYmxlIGNlbGwgdG8gb3V0cHV0LgogICAqIEBwYXJhbSB7TnVtYmVyfSBjb2x1bW4gQ29sdW1uIGluZGV4ICh1c2UgdGhlIGNhY2hlZCB2YWx1ZSkuCiAgICogQHBhcmFtIHtCb29sZWFufSBpc1NwYW5uZWQgV2hldGhlciB0aGUgdmFsdWUgaXMgcmV0dXJuZWQgZm9yIGEgc3Bhbm5lZCBjZWxsIGxvY2F0aW9uIG9yIGFjdHVhbCBjZWxsLgogICAqIEBwYXJhbSB7TnVtYmVyfSByb3dzcGFuIFJvd3NwYW4gb2YgdGhlIGN1cnJlbnQgY2VsbC4KICAgKiBAcGFyYW0ge051bWJlcn0gY29sc3BhbiBDb2xzcGFuIG9mIHRoZSBjdXJyZW50IGNlbGwuCiAgICogQHJldHVybnMge3tkb25lOiBib29sZWFuLCB2YWx1ZToge2NlbGw6ICosIHJvdzogTnVtYmVyLCBjb2x1bW46ICosIHJvd3NwYW46ICosIGNvbHNwYW46ICosIGNlbGxJbmRleDogTnVtYmVyfX19CiAgICovCgoKICBfZm9ybWF0T3V0VmFsdWUoY2VsbCwgY29sdW1uLCBpc1NwYW5uZWQsIHJvd3NwYW4gPSAxLCBjb2xzcGFuID0gMSkgewogICAgcmV0dXJuIHsKICAgICAgZG9uZTogZmFsc2UsCiAgICAgIHZhbHVlOiB7CiAgICAgICAgY2VsbCwKICAgICAgICByb3c6IHRoaXMuX3JvdywKICAgICAgICBjb2x1bW4sCiAgICAgICAgaXNTcGFubmVkLAogICAgICAgIHJvd3NwYW4sCiAgICAgICAgY29sc3BhbiwKICAgICAgICBjZWxsSW5kZXg6IHRoaXMuX2NlbGxJbmRleAogICAgICB9CiAgICB9OwogIH0KICAvKioKICAgKiBDaGVja3MgaWYgdGhlIGN1cnJlbnQgcm93IHNob3VsZCBiZSBza2lwcGVkLgogICAqCiAgICogQHByaXZhdGUKICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0KICAgKi8KCgogIF9zaG91bGRTa2lwUm93KCkgewogICAgY29uc3Qgcm93SXNCZWxvd1N0YXJ0Um93ID0gdGhpcy5fcm93IDwgdGhpcy5zdGFydFJvdzsKCiAgICBjb25zdCByb3dJc01hcmtlZEFzU2tpcHBlZCA9IHRoaXMuX3NraXBSb3dzLmhhcyh0aGlzLl9yb3cpOwoKICAgIHJldHVybiByb3dJc0JlbG93U3RhcnRSb3cgfHwgcm93SXNNYXJrZWRBc1NraXBwZWQ7CiAgfQogIC8qKgogICAqIENoZWNrcyBpZiB0aGUgY3VycmVudCBjb2x1bW4gc2hvdWxkIGJlIHNraXBwZWQuCiAgICoKICAgKiBAcHJpdmF0ZQogICAqIEByZXR1cm5zIHtCb29sZWFufQogICAqLwoKCiAgX3Nob3VsZFNraXBDb2x1bW4oKSB7CiAgICBpZiAodGhpcy5jb2x1bW4gPT09IHVuZGVmaW5lZCkgewogICAgICAvLyBUaGUge0BsaW5rICNjb2x1bW59IGlzIG5vdCBkZWZpbmVkIHNvIG91dHB1dCBhbGwgY29sdW1ucy4KICAgICAgcmV0dXJuIGZhbHNlOwogICAgfQoKICAgIHJldHVybiB0aGlzLmNvbHVtbiAhPSB0aGlzLl9jb2x1bW47CiAgfQogIC8qKgogICAqIENoZWNrcyBpZiB0aGUgY3VycmVudCBjZWxsIGxvY2F0aW9uIChyb3cgeCBjb2x1bW4pIGlzIHNwYW5uZWQgYnkgYW5vdGhlciBjZWxsLgogICAqCiAgICogQHByaXZhdGUKICAgKiBAcGFyYW0ge051bWJlcn0gcm93IFJvdyBpbmRleCBvZiBhIGNlbGwgbG9jYXRpb24gdG8gY2hlY2suCiAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbHVtbiBDb2x1bW4gaW5kZXggb2YgYSBjZWxsIGxvY2F0aW9uIHRvIGNoZWNrLgogICAqIEByZXR1cm5zIHtCb29sZWFufQogICAqLwoKCiAgX2lzU3Bhbm5lZChyb3csIGNvbHVtbikgewogICAgaWYgKCF0aGlzLl9zcGFubmVkQ2VsbHMuaGFzKHJvdykpIHsKICAgICAgLy8gTm8gc3BhbnMgZm9yIGdpdmVuIHJvdy4KICAgICAgcmV0dXJuIGZhbHNlOwogICAgfQoKICAgIGNvbnN0IHJvd1NwYW5zID0gdGhpcy5fc3Bhbm5lZENlbGxzLmdldChyb3cpOyAvLyBJZiBzcGFucyBmb3IgZ2l2ZW4gcm93cyBoYXMgZW50cnkgZm9yIGNvbHVtbiBpdCBtZWFucyB0aGF0IHRoaXMgbG9jYXRpb24gaWYgc3Bhbm5lZCBieSBvdGhlciBjZWxsLgoKCiAgICByZXR1cm4gcm93U3BhbnMuaGFzKGNvbHVtbik7CiAgfQogIC8qKgogICAqIFJldHVybnMgdGhlIGNlbGwgZWxlbWVudCB0aGF0IGlzIHNwYW5uZWQgb3ZlciBgcm93YCB4IGBjb2x1bW5gIGxvY2F0aW9uLgogICAqCiAgICogQHByaXZhdGUKICAgKiBAcGFyYW0ge051bWJlcn0gcm93IFJvdyBpbmRleCBvZiB0aGUgY2VsbCBsb2NhdGlvbi4KICAgKiBAcGFyYW0ge051bWJlcn0gY29sdW1uIENvbHVtbiBpbmRleCBvZiB0aGUgY2VsbCBsb2NhdGlvbi4KICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR9CiAgICovCgoKICBfZ2V0U3Bhbm5lZChyb3csIGNvbHVtbikgewogICAgcmV0dXJuIHRoaXMuX3NwYW5uZWRDZWxscy5nZXQocm93KS5nZXQoY29sdW1uKTsKICB9CiAgLyoqCiAgICogVXBkYXRlcyBzcGFubmVkIGNlbGxzIG1hcCByZWxhdGl2ZSB0byB0aGUgY3VycmVudCBjZWxsIGxvY2F0aW9uIGFuZCBpdHMgc3BhbiBkaW1lbnNpb25zLgogICAqCiAgICogQHByaXZhdGUKICAgKiBAcGFyYW0ge051bWJlcn0gcm93IFJvdyBpbmRleCBvZiBhIGNlbGwuCiAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbHVtbiBDb2x1bW4gaW5kZXggb2YgYSBjZWxsLgogICAqIEBwYXJhbSB7TnVtYmVyfSByb3dzcGFuIENlbGwgaGVpZ2h0LgogICAqIEBwYXJhbSB7TnVtYmVyfSBjb2xzcGFuIENlbGwgd2lkdGguCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudH0gY2VsbCBDZWxsIHRoYXQgaXMgc3Bhbm5lZC4KICAgKi8KCgogIF9yZWNvcmRTcGFucyhyb3csIGNvbHVtbiwgcm93c3BhbiwgY29sc3BhbiwgY2VsbCkgewogICAgLy8gVGhpcyB3aWxsIHVwZGF0ZSBhbGwgY2VsbCBsb2NhdGlvbnMgYWZ0ZXIgY3VycmVudCBjb2x1bW4gLSBpZSBhIGNlbGwgaGFzIGNvbHNwYW4gc2V0LgogICAgZm9yIChsZXQgY29sdW1uVG9VcGRhdGUgPSBjb2x1bW4gKyAxOyBjb2x1bW5Ub1VwZGF0ZSA8PSBjb2x1bW4gKyBjb2xzcGFuIC0gMTsgY29sdW1uVG9VcGRhdGUrKykgewogICAgICB0aGlzLl9tYXJrU3Bhbm5lZENlbGwocm93LCBjb2x1bW5Ub1VwZGF0ZSwgY2VsbCk7CiAgICB9IC8vIFRoaXMgd2lsbCB1cGRhdGUgYWxsIHJvd3MgYmVsb3cgY3VycmVudCB1cCB0byByb3cncyBoZWlnaHQuCgoKICAgIGZvciAobGV0IHJvd1RvVXBkYXRlID0gcm93ICsgMTsgcm93VG9VcGRhdGUgPCByb3cgKyByb3dzcGFuOyByb3dUb1VwZGF0ZSsrKSB7CiAgICAgIGZvciAobGV0IGNvbHVtblRvVXBkYXRlID0gY29sdW1uOyBjb2x1bW5Ub1VwZGF0ZSA8PSBjb2x1bW4gKyBjb2xzcGFuIC0gMTsgY29sdW1uVG9VcGRhdGUrKykgewogICAgICAgIHRoaXMuX21hcmtTcGFubmVkQ2VsbChyb3dUb1VwZGF0ZSwgY29sdW1uVG9VcGRhdGUsIGNlbGwpOwogICAgICB9CiAgICB9CiAgfQogIC8qKgogICAqIE1hcmtzIHRoZSBjZWxsIGxvY2F0aW9uIGFzIHNwYW5uZWQgYnkgYW5vdGhlciBjZWxsLgogICAqCiAgICogQHByaXZhdGUKICAgKiBAcGFyYW0ge051bWJlcn0gcm93IFJvdyBpbmRleCBvZiB0aGUgY2VsbCBsb2NhdGlvbi4KICAgKiBAcGFyYW0ge051bWJlcn0gY29sdW1uIENvbHVtbiBpbmRleCBvZiB0aGUgY2VsbCBsb2NhdGlvbi4KICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50fSBjZWxsIENlbGwgdGhhdCBpcyBzcGFubmVkLgogICAqLwoKCiAgX21hcmtTcGFubmVkQ2VsbChyb3csIGNvbHVtbiwgY2VsbCkgewogICAgaWYgKCF0aGlzLl9zcGFubmVkQ2VsbHMuaGFzKHJvdykpIHsKICAgICAgdGhpcy5fc3Bhbm5lZENlbGxzLnNldChyb3csIG5ldyBNYXAoKSk7CiAgICB9CgogICAgY29uc3Qgcm93U3BhbnMgPSB0aGlzLl9zcGFubmVkQ2VsbHMuZ2V0KHJvdyk7CgogICAgcm93U3BhbnMuc2V0KGNvbHVtbiwgY2VsbCk7CiAgfQoKfQovKioKICogQW4gb2JqZWN0IHJldHVybmVkIGJ5IHtAbGluayBtb2R1bGU6dGFibGUvdGFibGV3YWxrZXJ+VGFibGVXYWxrZXJ9IHdoZW4gdHJhdmVyc2luZyB0YWJsZSBjZWxscy4KICoKICogQHR5cGVkZWYge09iamVjdH0gbW9kdWxlOnRhYmxlL3RhYmxld2Fsa2VyflRhYmxlV2Fsa2VyVmFsdWUKICogQHByb3BlcnR5IHttb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudH0gY2VsbCBUaGUgY3VycmVudCB0YWJsZSBjZWxsLgogKiBAcHJvcGVydHkge051bWJlcn0gcm93IFRoZSByb3cgaW5kZXggb2YgYSBjZWxsLgogKiBAcHJvcGVydHkge051bWJlcn0gY29sdW1uIFRoZSBjb2x1bW4gaW5kZXggb2YgYSBjZWxsLiBDb2x1bW4gaW5kZXggaXMgYWRqdXN0ZWQgdG8gd2lkdGhzIGFuZCBoZWlnaHRzIG9mIHByZXZpb3VzIGNlbGxzLgogKiBAcGFyYW0ge0Jvb2xlYW59IGlzU3Bhbm5lZCBXaGV0aGVyIHRoZSB2YWx1ZSBpcyByZXR1cm5lZCBmb3IgYSBzcGFubmVkIGNlbGwgbG9jYXRpb24gb3IgYWN0dWFsIGNlbGwuCiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBjb2xzcGFuIFRoZSBgY29sc3BhbmAgYXR0cmlidXRlIG9mIGEgY2VsbC4gSXQgdGhlIG1vZGVsIGF0dHJpYnV0ZSBpcyBub3QgcHJlc2VudCwgaXQgaXMgc2V0IHRvIGAxYC4gRm9yIHNwYW5uZWQKICogdGFibGUgbG9jYXRpb25zLCBpdCBpcyBzZXQgdG8gYDFgLgogKiBAcHJvcGVydHkge051bWJlcn0gcm93c3BhbiBUaGUgYHJvd3NwYW5gIGF0dHJpYnV0ZSBvZiBhIGNlbGwuIEl0IHRoZSBtb2RlbCBhdHRyaWJ1dGUgaXMgbm90IHByZXNlbnQsIGl0IGlzIHNldCB0byBgMWAuIEZvciBzcGFubmVkCiAqIHRhYmxlIGxvY2F0aW9ucywgaXQgaXMgc2V0IHRvIGAxYC4KICogQHByb3BlcnR5IHtOdW1iZXJ9IGNlbGxJbmRleCBUaGUgaW5kZXggb2YgdGhlIGN1cnJlbnQgY2VsbCBpbiBhIHBhcmVudCByb3cuCiAqLw=="},{"version":3,"sources":["/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-table/src/tablewalker.js"],"names":["TableWalker","constructor","table","options","startRow","endRow","undefined","includeSpanned","column","_skipRows","Set","_row","_column","_cellIndex","_spannedCells","Map","_nextCellAtColumn","Symbol","iterator","next","row","getChild","_isOverEndRow","done","cell","skipCurrentValue","outValue","_isSpanned","_getSpanned","_shouldSkipRow","_shouldSkipColumn","_formatOutValue","colspan","parseInt","getAttribute","rowspan","_recordSpans","skipRow","add","isSpanned","value","cellIndex","rowIsBelowStartRow","rowIsMarkedAsSkipped","has","rowSpans","get","columnToUpdate","_markSpannedCell","rowToUpdate","set"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module table/tablewalker\n */\n\n/**\n * Table iterator class. It allows to iterate over table cells. For each cell the iterator yields\n * {@link module:table/tablewalker~TableWalkerValue} with proper table cell attributes.\n */\nexport default class TableWalker {\n\t/**\n\t * Creates an instance of the table walker.\n\t *\n\t * The table walker iterates internally by traversing the table from row index = 0 and column index = 0.\n\t * It walks row by row and column by column in order to output values defined in the constructor.\n\t * By default it will output only those locations that are occupied by a cell. To include also spanned rows and columns,\n\t * pass the `includeSpanned` option to the constructor.\n\t *\n\t * The most important values of the iterator are column and row indexes of a cell.\n\t *\n\t * See {@link module:table/tablewalker~TableWalkerValue} what values are returned by the table walker.\n\t *\n\t * To iterate over a given row:\n\t *\n\t *\t\tconst tableWalker = new TableWalker( table, { startRow: 1, endRow: 2 } );\n\t *\n\t *\t\tfor ( const cellInfo of tableWalker ) {\n\t *\t\t\tconsole.log( 'A cell at row ' + cellInfo.row + ' and column ' + cellInfo.column );\n\t *\t\t}\n\t *\n\t * For instance the code above for the following table:\n\t *\n\t *\t\t+----+----+----+----+----+----+\n\t *\t\t| 00      | 02 | 03 | 04 | 05 |\n\t *\t\t|         +----+----+----+----+\n\t *\t\t|         | 12      | 14 | 15 |\n\t *\t\t|         +----+----+----+    +\n\t *\t\t|         | 22           |    |\n\t *\t\t|----+----+----+----+----+    +\n\t *\t\t| 30 | 31 | 32 | 33 | 34 |    |\n\t *\t\t+----+----+----+----+----+----+\n\t *\n\t * will log in the console:\n\t *\n\t *\t\t'A cell at row 1 and column 2'\n\t *\t\t'A cell at row 1 and column 4'\n\t *\t\t'A cell at row 1 and column 5'\n\t *\t\t'A cell at row 2 and column 2'\n\t *\n\t * To also iterate over spanned cells:\n\t *\n\t *\t\tconst tableWalker = new TableWalker( table, { startRow: 1, endRow: 1, includeSpanned: true } );\n\t *\n\t *\t\tfor ( const value of tableWalker ) {\n\t *\t\t\tconsole.log( 'Cell at ' + value.row + ' x ' + value.column + ' : ' + ( value.isSpanned ? 'is spanned' : 'has data' ) );\n\t *\t\t}\n\t *\n\t * will log in the console for the table from previous example:\n\t *\n\t *\t\t'Cell at 1 x 0 : is spanned'\n\t *\t\t'Cell at 1 x 1 : is spanned'\n\t *\t\t'Cell at 1 x 2 : has data'\n\t *\t\t'Cell at 1 x 3 : is spanned'\n\t *\t\t'Cell at 1 x 4 : has data'\n\t *\t\t'Cell at 1 x 5 : has data'\n\t *\n\t * @constructor\n\t * @param {module:engine/model/element~Element} table A table over which the walker iterates.\n\t * @param {Object} [options={}] An object with configuration.\n\t * @param {Number} [options.column] A column index for which this iterator will output cells.\n\t * @param {Number} [options.startRow=0] A row index for which this iterator should start.\n\t * @param {Number} [options.endRow] A row index for which this iterator should end.\n\t * @param {Boolean} [options.includeSpanned=false] Also return values for spanned cells.\n\t */\n\tconstructor( table, options = {} ) {\n\t\t/**\n\t\t * The walker's table element.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/element~Element}\n\t\t */\n\t\tthis.table = table;\n\n\t\t/**\n\t\t * A row index on which this iterator will start.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Number}\n\t\t */\n\t\tthis.startRow = options.startRow || 0;\n\n\t\t/**\n\t\t * A row index on which this iterator will end.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Number}\n\t\t */\n\t\tthis.endRow = typeof options.endRow == 'number' ? options.endRow : undefined;\n\n\t\t/**\n\t\t * Enables output of spanned cells that are normally not yielded.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Boolean}\n\t\t */\n\t\tthis.includeSpanned = !!options.includeSpanned;\n\n\t\t/**\n\t\t * If set, the table walker will only output cells of a given column or cells that overlap it.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Number}\n\t\t */\n\t\tthis.column = typeof options.column == 'number' ? options.column : undefined;\n\n\t\t/**\n\t\t * Row indexes to skip from the iteration.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Set<Number>}\n\t\t * @private\n\t\t */\n\t\tthis._skipRows = new Set();\n\n\t\t/**\n\t\t * The current row index.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Number}\n\t\t * @private\n\t\t */\n\t\tthis._row = 0;\n\n\t\t/**\n\t\t * The current column index.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Number}\n\t\t * @private\n\t\t */\n\t\tthis._column = 0;\n\n\t\t/**\n\t\t * The cell index in a parent row. For spanned cells when {@link #includeSpanned} is set to `true`,\n\t\t * this represents the index of the next table cell.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Number}\n\t\t * @private\n\t\t */\n\t\tthis._cellIndex = 0;\n\n\t\t/**\n\t\t * Holds a map of spanned cells in a table.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Map<Number, Map.<Number, module:engine/model/element~Element>>}\n\t\t * @private\n\t\t */\n\t\tthis._spannedCells = new Map();\n\n\t\tthis._nextCellAtColumn = -1;\n\t}\n\n\t/**\n\t * Iterable interface.\n\t *\n\t * @returns {Iterable.<module:table/tablewalker~TableWalkerValue>}\n\t */\n\t[ Symbol.iterator ]() {\n\t\treturn this;\n\t}\n\n\t/**\n\t * Gets the next table walker's value.\n\t *\n\t * @returns {module:table/tablewalker~TableWalkerValue} The next table walker's value.\n\t */\n\tnext() {\n\t\tconst row = this.table.getChild( this._row );\n\n\t\t// Iterator is done when there's no row (table ended) or the row is after `endRow` limit.\n\t\tif ( !row || this._isOverEndRow() ) {\n\t\t\treturn { done: true };\n\t\t}\n\n\t\tlet cell, skipCurrentValue, outValue;\n\n\t\tif ( this._isSpanned( this._row, this._column ) ) {\n\t\t\tcell = this._getSpanned( this._row, this._column );\n\n\t\t\tskipCurrentValue = !this.includeSpanned || this._shouldSkipRow() || this._shouldSkipColumn();\n\t\t\toutValue = this._formatOutValue( cell, this._column, true );\n\t\t} else {\n\t\t\tcell = row.getChild( this._cellIndex );\n\n\t\t\tif ( !cell ) {\n\t\t\t\t// If there are no more cells left in row advance to the next row.\n\t\t\t\tthis._row++;\n\t\t\t\tthis._column = 0;\n\t\t\t\tthis._cellIndex = 0;\n\t\t\t\tthis._nextCellAtColumn = -1;\n\n\t\t\t\treturn this.next();\n\t\t\t}\n\n\t\t\tconst colspan = parseInt( cell.getAttribute( 'colspan' ) || 1 );\n\t\t\tconst rowspan = parseInt( cell.getAttribute( 'rowspan' ) || 1 );\n\n\t\t\t// Record this cell spans if it's not 1x1 cell.\n\t\t\tif ( colspan > 1 || rowspan > 1 ) {\n\t\t\t\tthis._recordSpans( this._row, this._column, rowspan, colspan, cell );\n\t\t\t}\n\n\t\t\tthis._nextCellAtColumn = this._column + colspan;\n\n\t\t\tskipCurrentValue = this._shouldSkipRow() || this._shouldSkipColumn();\n\t\t\toutValue = this._formatOutValue( cell, this._column, false, rowspan, colspan );\n\t\t}\n\n\t\t// Advance to the next column before returning value.\n\t\tthis._column++;\n\n\t\tif ( this._column == this._nextCellAtColumn ) {\n\t\t\tthis._cellIndex++;\n\t\t}\n\n\t\t// The current value will be returned only if current row and column are not skipped.\n\t\treturn skipCurrentValue ? this.next() : outValue;\n\t}\n\n\t/**\n\t * Marks a row to skip in the next iteration. It will also skip cells from the current row if there are any cells from the current row\n\t * to output.\n\t *\n\t * @param {Number} row Row index to skip.\n\t */\n\tskipRow( row ) {\n\t\tthis._skipRows.add( row );\n\t}\n\n\t/**\n\t * Checks if the current row is over {@link #endRow}.\n\t *\n\t * @private\n\t * @returns {Boolean}\n\t */\n\t_isOverEndRow() {\n\t\t// If {@link #endRow) is defined skip all rows above it.\n\t\treturn this.endRow !== undefined && this._row > this.endRow;\n\t}\n\n\t/**\n\t * A common method for formatting the iterator's output value.\n\t *\n\t * @private\n\t * @param {module:engine/model/element~Element} cell The table cell to output.\n\t * @param {Number} column Column index (use the cached value).\n\t * @param {Boolean} isSpanned Whether the value is returned for a spanned cell location or actual cell.\n\t * @param {Number} rowspan Rowspan of the current cell.\n\t * @param {Number} colspan Colspan of the current cell.\n\t * @returns {{done: boolean, value: {cell: *, row: Number, column: *, rowspan: *, colspan: *, cellIndex: Number}}}\n\t */\n\t_formatOutValue( cell, column, isSpanned, rowspan = 1, colspan = 1 ) {\n\t\treturn {\n\t\t\tdone: false,\n\t\t\tvalue: {\n\t\t\t\tcell,\n\t\t\t\trow: this._row,\n\t\t\t\tcolumn,\n\t\t\t\tisSpanned,\n\t\t\t\trowspan,\n\t\t\t\tcolspan,\n\t\t\t\tcellIndex: this._cellIndex\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Checks if the current row should be skipped.\n\t *\n\t * @private\n\t * @returns {Boolean}\n\t */\n\t_shouldSkipRow() {\n\t\tconst rowIsBelowStartRow = this._row < this.startRow;\n\t\tconst rowIsMarkedAsSkipped = this._skipRows.has( this._row );\n\n\t\treturn rowIsBelowStartRow || rowIsMarkedAsSkipped;\n\t}\n\n\t/**\n\t * Checks if the current column should be skipped.\n\t *\n\t * @private\n\t * @returns {Boolean}\n\t */\n\t_shouldSkipColumn() {\n\t\tif ( this.column === undefined ) {\n\t\t\t// The {@link #column} is not defined so output all columns.\n\t\t\treturn false;\n\t\t}\n\n\t\treturn this.column != this._column;\n\t}\n\n\t/**\n\t * Checks if the current cell location (row x column) is spanned by another cell.\n\t *\n\t * @private\n\t * @param {Number} row Row index of a cell location to check.\n\t * @param {Number} column Column index of a cell location to check.\n\t * @returns {Boolean}\n\t */\n\t_isSpanned( row, column ) {\n\t\tif ( !this._spannedCells.has( row ) ) {\n\t\t\t// No spans for given row.\n\t\t\treturn false;\n\t\t}\n\n\t\tconst rowSpans = this._spannedCells.get( row );\n\n\t\t// If spans for given rows has entry for column it means that this location if spanned by other cell.\n\t\treturn rowSpans.has( column );\n\t}\n\n\t/**\n\t * Returns the cell element that is spanned over `row` x `column` location.\n\t *\n\t * @private\n\t * @param {Number} row Row index of the cell location.\n\t * @param {Number} column Column index of the cell location.\n\t * @returns {module:engine/model/element~Element}\n\t */\n\t_getSpanned( row, column ) {\n\t\treturn this._spannedCells.get( row ).get( column );\n\t}\n\n\t/**\n\t * Updates spanned cells map relative to the current cell location and its span dimensions.\n\t *\n\t * @private\n\t * @param {Number} row Row index of a cell.\n\t * @param {Number} column Column index of a cell.\n\t * @param {Number} rowspan Cell height.\n\t * @param {Number} colspan Cell width.\n\t * @param {module:engine/model/element~Element} cell Cell that is spanned.\n\t */\n\t_recordSpans( row, column, rowspan, colspan, cell ) {\n\t\t// This will update all cell locations after current column - ie a cell has colspan set.\n\t\tfor ( let columnToUpdate = column + 1; columnToUpdate <= column + colspan - 1; columnToUpdate++ ) {\n\t\t\tthis._markSpannedCell( row, columnToUpdate, cell );\n\t\t}\n\n\t\t// This will update all rows below current up to row's height.\n\t\tfor ( let rowToUpdate = row + 1; rowToUpdate < row + rowspan; rowToUpdate++ ) {\n\t\t\tfor ( let columnToUpdate = column; columnToUpdate <= column + colspan - 1; columnToUpdate++ ) {\n\t\t\t\tthis._markSpannedCell( rowToUpdate, columnToUpdate, cell );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Marks the cell location as spanned by another cell.\n\t *\n\t * @private\n\t * @param {Number} row Row index of the cell location.\n\t * @param {Number} column Column index of the cell location.\n\t * @param {module:engine/model/element~Element} cell Cell that is spanned.\n\t */\n\t_markSpannedCell( row, column, cell ) {\n\t\tif ( !this._spannedCells.has( row ) ) {\n\t\t\tthis._spannedCells.set( row, new Map() );\n\t\t}\n\n\t\tconst rowSpans = this._spannedCells.get( row );\n\n\t\trowSpans.set( column, cell );\n\t}\n}\n\n/**\n * An object returned by {@link module:table/tablewalker~TableWalker} when traversing table cells.\n *\n * @typedef {Object} module:table/tablewalker~TableWalkerValue\n * @property {module:engine/model/element~Element} cell The current table cell.\n * @property {Number} row The row index of a cell.\n * @property {Number} column The column index of a cell. Column index is adjusted to widths and heights of previous cells.\n * @param {Boolean} isSpanned Whether the value is returned for a spanned cell location or actual cell.\n * @property {Number} colspan The `colspan` attribute of a cell. It the model attribute is not present, it is set to `1`. For spanned\n * table locations, it is set to `1`.\n * @property {Number} rowspan The `rowspan` attribute of a cell. It the model attribute is not present, it is set to `1`. For spanned\n * table locations, it is set to `1`.\n * @property {Number} cellIndex The index of the current cell in a parent row.\n */\n"]}]}