{"remainingRequest":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/babel-loader/lib/index.js!/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-autoformat/src/blockautoformatediting.js","dependencies":[{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-autoformat/src/blockautoformatediting.js","mtime":499162500000},{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js","mtime":499162500000},{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/babel-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:LyoqCiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDE5LCBDS1NvdXJjZSAtIEZyZWRlcmljbyBLbmFiYmVuLiBBbGwgcmlnaHRzIHJlc2VydmVkLgogKiBGb3IgbGljZW5zaW5nLCBzZWUgTElDRU5TRS5tZCBvciBodHRwczovL2NrZWRpdG9yLmNvbS9sZWdhbC9ja2VkaXRvci1vc3MtbGljZW5zZQogKi8KCi8qKgogKiBAbW9kdWxlIGF1dG9mb3JtYXQvYmxvY2thdXRvZm9ybWF0ZWRpdGluZwogKi8KaW1wb3J0IExpdmVSYW5nZSBmcm9tICdAY2tlZGl0b3IvY2tlZGl0b3I1LWVuZ2luZS9zcmMvbW9kZWwvbGl2ZXJhbmdlJzsKLyoqCiAqIFRoZSBibG9jayBhdXRvZm9ybWF0dGluZyBlbmdpbmUuIEl0IGFsbG93cyB0byBmb3JtYXQgdmFyaW91cyBibG9jayBwYXR0ZXJucy4gRm9yIGV4YW1wbGUsCiAqIGl0IGNhbiBiZSBjb25maWd1cmVkIHRvIHR1cm4gYSBwYXJhZ3JhcGggc3RhcnRpbmcgd2l0aCBgKmAgYW5kIGZvbGxvd2VkIGJ5IGEgc3BhY2UgaW50byBhIGxpc3QgaXRlbS4KICoKICogVGhlIGF1dG9mb3JtYXR0aW5nIG9wZXJhdGlvbiBpcyBpbnRlZ3JhdGVkIHdpdGggdGhlIHVuZG8gbWFuYWdlciwKICogc28gdGhlIGF1dG9mb3JtYXR0aW5nIHN0ZXAgY2FuIGJlIHVuZG9uZSBpZiB0aGUgdXNlcidzIGludGVudGlvbiB3YXMgbm90IHRvIGZvcm1hdCB0aGUgdGV4dC4KICoKICogU2VlIHRoZSBjb25zdHJ1Y3RvcnMgZG9jdW1lbnRhdGlvbiB0byBsZWFybiBob3cgdG8gY3JlYXRlIGN1c3RvbSBpbmxpbmUgYXV0b2Zvcm1hdHRlcnMuIFlvdSBjYW4gYWxzbyB1c2UKICogdGhlIHtAbGluayBtb2R1bGU6YXV0b2Zvcm1hdC9hdXRvZm9ybWF0fkF1dG9mb3JtYXR9IGZlYXR1cmUgd2hpY2ggZW5hYmxlcyBhIHNldCBvZiBkZWZhdWx0IGF1dG9mb3JtYXR0ZXJzCiAqIChsaXN0cywgaGVhZGluZ3MsIGJvbGQgYW5kIGl0YWxpYykuCiAqLwoKZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmxvY2tBdXRvZm9ybWF0RWRpdGluZyB7CiAgLyoqCiAgICogQGluaGVyaXREb2MKICAgKi8KICBzdGF0aWMgZ2V0IHBsdWdpbk5hbWUoKSB7CiAgICByZXR1cm4gJ0Jsb2NrQXV0b2Zvcm1hdEVkaXRpbmcnOwogIH0KICAvKioKICAgKiBDcmVhdGVzIGEgbGlzdGVuZXIgdHJpZ2dlcmVkIG9uIGBjaGFuZ2VgIGV2ZW50IGluIHRoZSBkb2N1bWVudC4KICAgKiBDYWxscyB0aGUgY2FsbGJhY2sgd2hlbiBpbnNlcnRlZCB0ZXh0IG1hdGNoZXMgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBvciB0aGUgY29tbWFuZCBuYW1lCiAgICogaWYgcHJvdmlkZWQgaW5zdGVhZCBvZiB0aGUgY2FsbGJhY2suCiAgICoKICAgKiBFeGFtcGxlcyBvZiB1c2FnZToKICAgKgogICAqIFRvIGNvbnZlcnQgYSBwYXJhZ3JhcGggdG8gaGVhZGluZyAxIHdoZW4gYC0gYCBpcyB0eXBlZCwgdXNpbmcganVzdCB0aGUgY29tbWFuZCBuYW1lOgogICAqCiAgICoJCW5ldyBCbG9ja0F1dG9mb3JtYXRFZGl0aW5nKCBlZGl0b3IsIC9eXC0gJC8sICdoZWFkaW5nMScgKTsKICAgKgogICAqIFRvIGNvbnZlcnQgYSBwYXJhZ3JhcGggdG8gaGVhZGluZyAxIHdoZW4gYC0gYCBpcyB0eXBlZCwgdXNpbmcganVzdCB0aGUgY2FsbGJhY2s6CiAgICoKICAgKgkJbmV3IEJsb2NrQXV0b2Zvcm1hdEVkaXRpbmcoIGVkaXRvciwgL15cLSAkLywgKCBjb250ZXh0ICkgPT4gewogICAqCQkJY29uc3QgeyBtYXRjaCB9ID0gY29udGV4dDsKICAgKgkJCWNvbnN0IGhlYWRpbmdMZXZlbCA9IG1hdGNoWyAxIF0ubGVuZ3RoOwogICAqCiAgICoJCQllZGl0b3IuZXhlY3V0ZSggJ2hlYWRpbmcnLCB7CiAgICoJCQkJZm9ybWF0SWQ6IGBoZWFkaW5nJHsgaGVhZGluZ0xldmVsIH1gCiAgICoJCQl9ICk7CiAgICogCQl9ICk7CiAgICoKICAgKiBAcGFyYW0ge21vZHVsZTpjb3JlL2VkaXRvci9lZGl0b3J+RWRpdG9yfSBlZGl0b3IgVGhlIGVkaXRvciBpbnN0YW5jZS4KICAgKiBAcGFyYW0ge1JlZ0V4cH0gcGF0dGVybiBUaGUgcmVndWxhciBleHByZXNzaW9uIHRvIGV4ZWN1dGUgb24ganVzdCBpbnNlcnRlZCB0ZXh0LgogICAqIEBwYXJhbSB7RnVuY3Rpb258U3RyaW5nfSBjYWxsYmFja09yQ29tbWFuZCBUaGUgY2FsbGJhY2sgdG8gZXhlY3V0ZSBvciB0aGUgY29tbWFuZCB0byBydW4gd2hlbiB0aGUgdGV4dCBpcyBtYXRjaGVkLgogICAqIEluIGNhc2Ugb2YgcHJvdmlkaW5nIHRoZSBjYWxsYmFjaywgaXQgcmVjZWl2ZXMgdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXI6CiAgICogKiB7T2JqZWN0fSBtYXRjaCBSZWdFeHAuZXhlYygpIHJlc3VsdCBvZiBtYXRjaGluZyB0aGUgcGF0dGVybiB0byBpbnNlcnRlZCB0ZXh0LgogICAqLwoKCiAgY29uc3RydWN0b3IoZWRpdG9yLCBwYXR0ZXJuLCBjYWxsYmFja09yQ29tbWFuZCkgewogICAgbGV0IGNhbGxiYWNrOwogICAgbGV0IGNvbW1hbmQgPSBudWxsOwoKICAgIGlmICh0eXBlb2YgY2FsbGJhY2tPckNvbW1hbmQgPT0gJ2Z1bmN0aW9uJykgewogICAgICBjYWxsYmFjayA9IGNhbGxiYWNrT3JDb21tYW5kOwogICAgfSBlbHNlIHsKICAgICAgLy8gV2UgYXNzdW1lIHRoYXQgdGhlIGFjdHVhbCBjb21tYW5kIG5hbWUgd2FzIHByb3ZpZGVkLgogICAgICBjb21tYW5kID0gZWRpdG9yLmNvbW1hbmRzLmdldChjYWxsYmFja09yQ29tbWFuZCk7CgogICAgICBjYWxsYmFjayA9ICgpID0+IHsKICAgICAgICBlZGl0b3IuZXhlY3V0ZShjYWxsYmFja09yQ29tbWFuZCk7CiAgICAgIH07CiAgICB9CgogICAgZWRpdG9yLm1vZGVsLmRvY3VtZW50Lm9uKCdjaGFuZ2UnLCAoZXZ0LCBiYXRjaCkgPT4gewogICAgICBpZiAoY29tbWFuZCAmJiAhY29tbWFuZC5pc0VuYWJsZWQpIHsKICAgICAgICByZXR1cm47CiAgICAgIH0KCiAgICAgIGlmIChiYXRjaC50eXBlID09ICd0cmFuc3BhcmVudCcpIHsKICAgICAgICByZXR1cm47CiAgICAgIH0KCiAgICAgIGNvbnN0IGNoYW5nZXMgPSBBcnJheS5mcm9tKGVkaXRvci5tb2RlbC5kb2N1bWVudC5kaWZmZXIuZ2V0Q2hhbmdlcygpKTsKICAgICAgY29uc3QgZW50cnkgPSBjaGFuZ2VzWzBdOyAvLyBUeXBpbmcgaXMgcmVwcmVzZW50ZWQgYnkgb25seSBhIHNpbmdsZSBjaGFuZ2UuCgogICAgICBpZiAoY2hhbmdlcy5sZW5ndGggIT0gMSB8fCBlbnRyeS50eXBlICE9PSAnaW5zZXJ0JyB8fCBlbnRyeS5uYW1lICE9ICckdGV4dCcgfHwgZW50cnkubGVuZ3RoICE9IDEpIHsKICAgICAgICByZXR1cm47CiAgICAgIH0KCiAgICAgIGNvbnN0IGJsb2NrVG9Gb3JtYXQgPSBlbnRyeS5wb3NpdGlvbi5wYXJlbnQ7IC8vIEJsb2NrIGZvcm1hdHRpbmcgc2hvdWxkIHRyaWdnZXIgb25seSBpZiB0aGUgZW50aXJlIGNvbnRlbnQgb2YgYSBwYXJhZ3JhcGggaXMgYSBzaW5nbGUgdGV4dCBub2RlLi4uIChzZWUgY2tlZGl0b3I1IzU2NzEpLgoKICAgICAgaWYgKCFibG9ja1RvRm9ybWF0LmlzKCdwYXJhZ3JhcGgnKSB8fCBibG9ja1RvRm9ybWF0LmNoaWxkQ291bnQgIT09IDEpIHsKICAgICAgICByZXR1cm47CiAgICAgIH0KCiAgICAgIGNvbnN0IG1hdGNoID0gcGF0dGVybi5leGVjKGJsb2NrVG9Gb3JtYXQuZ2V0Q2hpbGQoMCkuZGF0YSk7IC8vIC4uLmFuZCB0aGlzIHRleHQgbm9kZSdzIGRhdGEgbWF0Y2ggdGhlIHBhdHRlcm4uCgogICAgICBpZiAoIW1hdGNoKSB7CiAgICAgICAgcmV0dXJuOwogICAgICB9IC8vIFVzZSBlbnF1ZXVlQ2hhbmdlIHRvIGNyZWF0ZSBuZXcgYmF0Y2ggdG8gc2VwYXJhdGUgdHlwaW5nIGJhdGNoIGZyb20gdGhlIGF1dG8tZm9ybWF0IGNoYW5nZXMuCgoKICAgICAgZWRpdG9yLm1vZGVsLmVucXVldWVDaGFuZ2Uod3JpdGVyID0+IHsKICAgICAgICAvLyBNYXRjaGVkIHJhbmdlLgogICAgICAgIGNvbnN0IHN0YXJ0ID0gd3JpdGVyLmNyZWF0ZVBvc2l0aW9uQXQoYmxvY2tUb0Zvcm1hdCwgMCk7CiAgICAgICAgY29uc3QgZW5kID0gd3JpdGVyLmNyZWF0ZVBvc2l0aW9uQXQoYmxvY2tUb0Zvcm1hdCwgbWF0Y2hbMF0ubGVuZ3RoKTsKICAgICAgICBjb25zdCByYW5nZSA9IG5ldyBMaXZlUmFuZ2Uoc3RhcnQsIGVuZCk7CiAgICAgICAgY29uc3Qgd2FzQ2hhbmdlZCA9IGNhbGxiYWNrKHsKICAgICAgICAgIG1hdGNoCiAgICAgICAgfSk7IC8vIFJlbW92ZSBtYXRjaGVkIHRleHQuCgogICAgICAgIGlmICh3YXNDaGFuZ2VkICE9PSBmYWxzZSkgewogICAgICAgICAgd3JpdGVyLnJlbW92ZShyYW5nZSk7CiAgICAgICAgfQoKICAgICAgICByYW5nZS5kZXRhY2goKTsKICAgICAgfSk7CiAgICB9KTsKICB9Cgp9"},{"version":3,"sources":["/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-autoformat/src/blockautoformatediting.js"],"names":["LiveRange","BlockAutoformatEditing","pluginName","constructor","editor","pattern","callbackOrCommand","callback","command","commands","get","execute","model","document","on","evt","batch","isEnabled","type","changes","Array","from","differ","getChanges","entry","length","name","blockToFormat","position","parent","is","childCount","match","exec","getChild","data","enqueueChange","writer","start","createPositionAt","end","range","wasChanged","remove","detach"],"mappings":"AAAA;;;;;AAKA;;;AAIA,OAAOA,SAAP,MAAsB,gDAAtB;AAEA;;;;;;;;;;;;AAWA,eAAe,MAAMC,sBAAN,CAA6B;AAC3C;;;AAGA,aAAWC,UAAX,GAAwB;AACvB,WAAO,wBAAP;AACA;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BAC,EAAAA,WAAW,CAAEC,MAAF,EAAUC,OAAV,EAAmBC,iBAAnB,EAAuC;AACjD,QAAIC,QAAJ;AACA,QAAIC,OAAO,GAAG,IAAd;;AAEA,QAAK,OAAOF,iBAAP,IAA4B,UAAjC,EAA8C;AAC7CC,MAAAA,QAAQ,GAAGD,iBAAX;AACA,KAFD,MAEO;AACN;AACAE,MAAAA,OAAO,GAAGJ,MAAM,CAACK,QAAP,CAAgBC,GAAhB,CAAqBJ,iBAArB,CAAV;;AAEAC,MAAAA,QAAQ,GAAG,MAAM;AAChBH,QAAAA,MAAM,CAACO,OAAP,CAAgBL,iBAAhB;AACA,OAFD;AAGA;;AAEDF,IAAAA,MAAM,CAACQ,KAAP,CAAaC,QAAb,CAAsBC,EAAtB,CAA0B,QAA1B,EAAoC,CAAEC,GAAF,EAAOC,KAAP,KAAkB;AACrD,UAAKR,OAAO,IAAI,CAACA,OAAO,CAACS,SAAzB,EAAqC;AACpC;AACA;;AAED,UAAKD,KAAK,CAACE,IAAN,IAAc,aAAnB,EAAmC;AAClC;AACA;;AAED,YAAMC,OAAO,GAAGC,KAAK,CAACC,IAAN,CAAYjB,MAAM,CAACQ,KAAP,CAAaC,QAAb,CAAsBS,MAAtB,CAA6BC,UAA7B,EAAZ,CAAhB;AACA,YAAMC,KAAK,GAAGL,OAAO,CAAE,CAAF,CAArB,CAVqD,CAYrD;;AACA,UAAKA,OAAO,CAACM,MAAR,IAAkB,CAAlB,IAAuBD,KAAK,CAACN,IAAN,KAAe,QAAtC,IAAkDM,KAAK,CAACE,IAAN,IAAc,OAAhE,IAA2EF,KAAK,CAACC,MAAN,IAAgB,CAAhG,EAAoG;AACnG;AACA;;AAED,YAAME,aAAa,GAAGH,KAAK,CAACI,QAAN,CAAeC,MAArC,CAjBqD,CAmBrD;;AACA,UAAK,CAACF,aAAa,CAACG,EAAd,CAAkB,WAAlB,CAAD,IAAoCH,aAAa,CAACI,UAAd,KAA6B,CAAtE,EAA0E;AACzE;AACA;;AAED,YAAMC,KAAK,GAAG3B,OAAO,CAAC4B,IAAR,CAAcN,aAAa,CAACO,QAAd,CAAwB,CAAxB,EAA4BC,IAA1C,CAAd,CAxBqD,CA0BrD;;AACA,UAAK,CAACH,KAAN,EAAc;AACb;AACA,OA7BoD,CA+BrD;;;AACA5B,MAAAA,MAAM,CAACQ,KAAP,CAAawB,aAAb,CAA4BC,MAAM,IAAI;AACrC;AACA,cAAMC,KAAK,GAAGD,MAAM,CAACE,gBAAP,CAAyBZ,aAAzB,EAAwC,CAAxC,CAAd;AACA,cAAMa,GAAG,GAAGH,MAAM,CAACE,gBAAP,CAAyBZ,aAAzB,EAAwCK,KAAK,CAAE,CAAF,CAAL,CAAWP,MAAnD,CAAZ;AACA,cAAMgB,KAAK,GAAG,IAAIzC,SAAJ,CAAesC,KAAf,EAAsBE,GAAtB,CAAd;AAEA,cAAME,UAAU,GAAGnC,QAAQ,CAAE;AAAEyB,UAAAA;AAAF,SAAF,CAA3B,CANqC,CAQrC;;AACA,YAAKU,UAAU,KAAK,KAApB,EAA4B;AAC3BL,UAAAA,MAAM,CAACM,MAAP,CAAeF,KAAf;AACA;;AAEDA,QAAAA,KAAK,CAACG,MAAN;AACA,OAdD;AAeA,KA/CD;AAgDA;;AAnG0C","sourcesContent":["/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module autoformat/blockautoformatediting\n */\n\nimport LiveRange from '@ckeditor/ckeditor5-engine/src/model/liverange';\n\n/**\n * The block autoformatting engine. It allows to format various block patterns. For example,\n * it can be configured to turn a paragraph starting with `*` and followed by a space into a list item.\n *\n * The autoformatting operation is integrated with the undo manager,\n * so the autoformatting step can be undone if the user's intention was not to format the text.\n *\n * See the constructors documentation to learn how to create custom inline autoformatters. You can also use\n * the {@link module:autoformat/autoformat~Autoformat} feature which enables a set of default autoformatters\n * (lists, headings, bold and italic).\n */\nexport default class BlockAutoformatEditing {\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get pluginName() {\n\t\treturn 'BlockAutoformatEditing';\n\t}\n\n\t/**\n\t * Creates a listener triggered on `change` event in the document.\n\t * Calls the callback when inserted text matches the regular expression or the command name\n\t * if provided instead of the callback.\n\t *\n\t * Examples of usage:\n\t *\n\t * To convert a paragraph to heading 1 when `- ` is typed, using just the command name:\n\t *\n\t *\t\tnew BlockAutoformatEditing( editor, /^\\- $/, 'heading1' );\n\t *\n\t * To convert a paragraph to heading 1 when `- ` is typed, using just the callback:\n\t *\n\t *\t\tnew BlockAutoformatEditing( editor, /^\\- $/, ( context ) => {\n\t *\t\t\tconst { match } = context;\n\t *\t\t\tconst headingLevel = match[ 1 ].length;\n\t *\n\t *\t\t\teditor.execute( 'heading', {\n\t *\t\t\t\tformatId: `heading${ headingLevel }`\n\t *\t\t\t} );\n\t * \t\t} );\n\t *\n\t * @param {module:core/editor/editor~Editor} editor The editor instance.\n\t * @param {RegExp} pattern The regular expression to execute on just inserted text.\n\t * @param {Function|String} callbackOrCommand The callback to execute or the command to run when the text is matched.\n\t * In case of providing the callback, it receives the following parameter:\n\t * * {Object} match RegExp.exec() result of matching the pattern to inserted text.\n\t */\n\tconstructor( editor, pattern, callbackOrCommand ) {\n\t\tlet callback;\n\t\tlet command = null;\n\n\t\tif ( typeof callbackOrCommand == 'function' ) {\n\t\t\tcallback = callbackOrCommand;\n\t\t} else {\n\t\t\t// We assume that the actual command name was provided.\n\t\t\tcommand = editor.commands.get( callbackOrCommand );\n\n\t\t\tcallback = () => {\n\t\t\t\teditor.execute( callbackOrCommand );\n\t\t\t};\n\t\t}\n\n\t\teditor.model.document.on( 'change', ( evt, batch ) => {\n\t\t\tif ( command && !command.isEnabled ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( batch.type == 'transparent' ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst changes = Array.from( editor.model.document.differ.getChanges() );\n\t\t\tconst entry = changes[ 0 ];\n\n\t\t\t// Typing is represented by only a single change.\n\t\t\tif ( changes.length != 1 || entry.type !== 'insert' || entry.name != '$text' || entry.length != 1 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst blockToFormat = entry.position.parent;\n\n\t\t\t// Block formatting should trigger only if the entire content of a paragraph is a single text node... (see ckeditor5#5671).\n\t\t\tif ( !blockToFormat.is( 'paragraph' ) || blockToFormat.childCount !== 1 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst match = pattern.exec( blockToFormat.getChild( 0 ).data );\n\n\t\t\t// ...and this text node's data match the pattern.\n\t\t\tif ( !match ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Use enqueueChange to create new batch to separate typing batch from the auto-format changes.\n\t\t\teditor.model.enqueueChange( writer => {\n\t\t\t\t// Matched range.\n\t\t\t\tconst start = writer.createPositionAt( blockToFormat, 0 );\n\t\t\t\tconst end = writer.createPositionAt( blockToFormat, match[ 0 ].length );\n\t\t\t\tconst range = new LiveRange( start, end );\n\n\t\t\t\tconst wasChanged = callback( { match } );\n\n\t\t\t\t// Remove matched text.\n\t\t\t\tif ( wasChanged !== false ) {\n\t\t\t\t\twriter.remove( range );\n\t\t\t\t}\n\n\t\t\t\trange.detach();\n\t\t\t} );\n\t\t} );\n\t}\n}\n"]}]}