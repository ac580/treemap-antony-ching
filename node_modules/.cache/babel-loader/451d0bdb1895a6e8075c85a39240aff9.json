{"remainingRequest":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/babel-loader/lib/index.js!/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-engine/src/model/range.js","dependencies":[{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-engine/src/model/range.js","mtime":499162500000},{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js","mtime":499162500000},{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/babel-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:LyoqCiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDE5LCBDS1NvdXJjZSAtIEZyZWRlcmljbyBLbmFiYmVuLiBBbGwgcmlnaHRzIHJlc2VydmVkLgogKiBGb3IgbGljZW5zaW5nLCBzZWUgTElDRU5TRS5tZCBvciBodHRwczovL2NrZWRpdG9yLmNvbS9sZWdhbC9ja2VkaXRvci1vc3MtbGljZW5zZQogKi8KCi8qKgogKiBAbW9kdWxlIGVuZ2luZS9tb2RlbC9yYW5nZQogKi8KaW1wb3J0IFBvc2l0aW9uIGZyb20gJy4vcG9zaXRpb24nOwppbXBvcnQgVHJlZVdhbGtlciBmcm9tICcuL3RyZWV3YWxrZXInOwppbXBvcnQgQ0tFZGl0b3JFcnJvciBmcm9tICdAY2tlZGl0b3IvY2tlZGl0b3I1LXV0aWxzL3NyYy9ja2VkaXRvcmVycm9yJzsKaW1wb3J0IGNvbXBhcmVBcnJheXMgZnJvbSAnQGNrZWRpdG9yL2NrZWRpdG9yNS11dGlscy9zcmMvY29tcGFyZWFycmF5cyc7Ci8qKgogKiBSZXByZXNlbnRzIGEgcmFuZ2UgaW4gdGhlIG1vZGVsIHRyZWUuCiAqCiAqIEEgcmFuZ2UgaXMgZGVmaW5lZCBieSBpdHMge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2Ujc3RhcnR9IGFuZCB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZSNlbmR9CiAqIHBvc2l0aW9ucy4KICoKICogWW91IGNhbiBjcmVhdGUgcmFuZ2UgaW5zdGFuY2VzIHZpYSBpdHMgY29uc3RydWN0b3Igb3IgdGhlIGBjcmVhdGVSYW5nZSooKWAgZmFjdG9yeSBtZXRob2RzIG9mCiAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL21vZGVsfk1vZGVsfSBhbmQge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvd3JpdGVyfldyaXRlcn0uCiAqLwoKZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmFuZ2UgewogIC8qKgogICAqIENyZWF0ZXMgYSByYW5nZSBzcGFubmluZyBmcm9tIGBzdGFydGAgcG9zaXRpb24gdG8gYGVuZGAgcG9zaXRpb24uCiAgICoKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259IHN0YXJ0IFN0YXJ0IHBvc2l0aW9uLgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0gW2VuZF0gRW5kIHBvc2l0aW9uLiBJZiBub3Qgc2V0LCByYW5nZSB3aWxsIGJlIGNvbGxhcHNlZCBhdCBgc3RhcnRgIHBvc2l0aW9uLgogICAqLwogIGNvbnN0cnVjdG9yKHN0YXJ0LCBlbmQgPSBudWxsKSB7CiAgICAvKioKICAgICAqIFN0YXJ0IHBvc2l0aW9uLgogICAgICoKICAgICAqIEByZWFkb25seQogICAgICogQG1lbWJlciB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0KICAgICAqLwogICAgdGhpcy5zdGFydCA9IFBvc2l0aW9uLl9jcmVhdGVBdChzdGFydCk7CiAgICAvKioKICAgICAqIEVuZCBwb3NpdGlvbi4KICAgICAqCiAgICAgKiBAcmVhZG9ubHkKICAgICAqIEBtZW1iZXIge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259CiAgICAgKi8KCiAgICB0aGlzLmVuZCA9IGVuZCA/IFBvc2l0aW9uLl9jcmVhdGVBdChlbmQpIDogUG9zaXRpb24uX2NyZWF0ZUF0KHN0YXJ0KTsgLy8gSWYgdGhlIHJhbmdlIGlzIGNvbGxhcHNlZCwgdHJlYXQgaW4gYSBzaW1pbGFyIHdheSBhcyBhIHBvc2l0aW9uIGFuZCBzZXQgaXRzIGJvdW5kYXJpZXMgc3RpY2tpbmVzcyB0byAndG9Ob25lJy4KICAgIC8vIEluIG90aGVyIGNhc2UsIG1ha2UgdGhlIGJvdW5kYXJpZXMgc3RpY2sgdG8gdGhlICJpbnNpZGUiIG9mIHRoZSByYW5nZS4KCiAgICB0aGlzLnN0YXJ0LnN0aWNraW5lc3MgPSB0aGlzLmlzQ29sbGFwc2VkID8gJ3RvTm9uZScgOiAndG9OZXh0JzsKICAgIHRoaXMuZW5kLnN0aWNraW5lc3MgPSB0aGlzLmlzQ29sbGFwc2VkID8gJ3RvTm9uZScgOiAndG9QcmV2aW91cyc7CiAgfQogIC8qKgogICAqIEl0ZXJhYmxlIGludGVyZmFjZS4KICAgKgogICAqIEl0ZXJhdGVzIG92ZXIgYWxsIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbSBpdGVtc30gdGhhdCBhcmUgaW4gdGhpcyByYW5nZSBhbmQgcmV0dXJucwogICAqIHRoZW0gdG9nZXRoZXIgd2l0aCBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGxpa2UgbGVuZ3RoIG9yIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9uIHBvc2l0aW9uc30sCiAgICogZ3JvdXBlZCBhcyB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC90cmVld2Fsa2VyflRyZWVXYWxrZXJWYWx1ZX0uCiAgICogSXQgaXRlcmF0ZXMgb3ZlciBhbGwge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvdGV4dHByb3h5flRleHRQcm94eSB0ZXh0IGNvbnRlbnRzfSB0aGF0IGFyZSBpbnNpZGUgdGhlIHJhbmdlCiAgICogYW5kIGFsbCB0aGUge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50fXMgdGhhdCBhcmUgZW50ZXJlZCBpbnRvIHdoZW4gaXRlcmF0aW5nIG92ZXIgdGhpcyByYW5nZS4KICAgKgogICAqIFRoaXMgaXRlcmF0b3IgdXNlcyB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC90cmVld2Fsa2VyflRyZWVXYWxrZXJ9IHdpdGggYGJvdW5kYXJpZXNgIHNldCB0byB0aGlzIHJhbmdlCiAgICogYW5kIGBpZ25vcmVFbGVtZW50RW5kYCBvcHRpb24gc2V0IHRvIGB0cnVlYC4KICAgKgogICAqIEByZXR1cm5zIHtJdGVyYWJsZS48bW9kdWxlOmVuZ2luZS9tb2RlbC90cmVld2Fsa2VyflRyZWVXYWxrZXJWYWx1ZT59CiAgICovCgoKICAqW1N5bWJvbC5pdGVyYXRvcl0oKSB7CiAgICB5aWVsZCogbmV3IFRyZWVXYWxrZXIoewogICAgICBib3VuZGFyaWVzOiB0aGlzLAogICAgICBpZ25vcmVFbGVtZW50RW5kOiB0cnVlCiAgICB9KTsKICB9CiAgLyoqCiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSByYW5nZSBpcyBjb2xsYXBzZWQsIHRoYXQgaXMgaWYge0BsaW5rICNzdGFydH0gYW5kCiAgICoge0BsaW5rICNlbmR9IHBvc2l0aW9ucyBhcmUgZXF1YWwuCiAgICoKICAgKiBAdHlwZSB7Qm9vbGVhbn0KICAgKi8KCgogIGdldCBpc0NvbGxhcHNlZCgpIHsKICAgIHJldHVybiB0aGlzLnN0YXJ0LmlzRXF1YWwodGhpcy5lbmQpOwogIH0KICAvKioKICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyByYW5nZSBpcyBmbGF0LCB0aGF0IGlzIGlmIHtAbGluayAjc3RhcnR9IHBvc2l0aW9uIGFuZAogICAqIHtAbGluayAjZW5kfSBwb3NpdGlvbiBhcmUgaW4gdGhlIHNhbWUge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb24jcGFyZW50fS4KICAgKgogICAqIEB0eXBlIHtCb29sZWFufQogICAqLwoKCiAgZ2V0IGlzRmxhdCgpIHsKICAgIGNvbnN0IHN0YXJ0UGFyZW50UGF0aCA9IHRoaXMuc3RhcnQuZ2V0UGFyZW50UGF0aCgpOwogICAgY29uc3QgZW5kUGFyZW50UGF0aCA9IHRoaXMuZW5kLmdldFBhcmVudFBhdGgoKTsKICAgIHJldHVybiBjb21wYXJlQXJyYXlzKHN0YXJ0UGFyZW50UGF0aCwgZW5kUGFyZW50UGF0aCkgPT0gJ3NhbWUnOwogIH0KICAvKioKICAgKiBSYW5nZSByb290IGVsZW1lbnQuCiAgICoKICAgKiBAdHlwZSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR8bW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnR9CiAgICovCgoKICBnZXQgcm9vdCgpIHsKICAgIHJldHVybiB0aGlzLnN0YXJ0LnJvb3Q7CiAgfQogIC8qKgogICAqIENoZWNrcyB3aGV0aGVyIHRoaXMgcmFuZ2UgY29udGFpbnMgZ2l2ZW4ge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb24gcG9zaXRpb259LgogICAqCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufSBwb3NpdGlvbiBQb3NpdGlvbiB0byBjaGVjay4KICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIGdpdmVuIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9uIHBvc2l0aW9ufSBpcyBjb250YWluZWQKICAgKiBpbiB0aGlzIHJhbmdlLGBmYWxzZWAgb3RoZXJ3aXNlLgogICAqLwoKCiAgY29udGFpbnNQb3NpdGlvbihwb3NpdGlvbikgewogICAgcmV0dXJuIHBvc2l0aW9uLmlzQWZ0ZXIodGhpcy5zdGFydCkgJiYgcG9zaXRpb24uaXNCZWZvcmUodGhpcy5lbmQpOwogIH0KICAvKioKICAgKiBDaGVja3Mgd2hldGhlciB0aGlzIHJhbmdlIGNvbnRhaW5zIGdpdmVuIHtAbGluayB+UmFuZ2UgcmFuZ2V9LgogICAqCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlfSBvdGhlclJhbmdlIFJhbmdlIHRvIGNoZWNrLgogICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2xvb3NlPWZhbHNlXSBXaGV0aGVyIHRoZSBjaGVjayBpcyBsb29zZSBvciBzdHJpY3QuIElmIHRoZSBjaGVjayBpcyBzdHJpY3QgKGBmYWxzZWApLCBjb21wYXJlZCByYW5nZSBjYW5ub3QKICAgKiBzdGFydCBvciBlbmQgYXQgdGhlIHNhbWUgcG9zaXRpb24gYXMgdGhpcyByYW5nZSBib3VuZGFyaWVzLiBJZiB0aGUgY2hlY2sgaXMgbG9vc2UgKGB0cnVlYCksIGNvbXBhcmVkIHJhbmdlIGNhbiBzdGFydCwgZW5kIG9yCiAgICogZXZlbiBiZSBlcXVhbCB0byB0aGlzIHJhbmdlLiBOb3RlIHRoYXQgY29sbGFwc2VkIHJhbmdlcyBhcmUgYWx3YXlzIGNvbXBhcmVkIGluIHN0cmljdCBtb2RlLgogICAqIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgZ2l2ZW4ge0BsaW5rIH5SYW5nZSByYW5nZX0gYm91bmRhcmllcyBhcmUgY29udGFpbmVkIGJ5IHRoaXMgcmFuZ2UsIGBmYWxzZWAgb3RoZXJ3aXNlLgogICAqLwoKCiAgY29udGFpbnNSYW5nZShvdGhlclJhbmdlLCBsb29zZSA9IGZhbHNlKSB7CiAgICBpZiAob3RoZXJSYW5nZS5pc0NvbGxhcHNlZCkgewogICAgICBsb29zZSA9IGZhbHNlOwogICAgfQoKICAgIGNvbnN0IGNvbnRhaW5zU3RhcnQgPSB0aGlzLmNvbnRhaW5zUG9zaXRpb24ob3RoZXJSYW5nZS5zdGFydCkgfHwgbG9vc2UgJiYgdGhpcy5zdGFydC5pc0VxdWFsKG90aGVyUmFuZ2Uuc3RhcnQpOwogICAgY29uc3QgY29udGFpbnNFbmQgPSB0aGlzLmNvbnRhaW5zUG9zaXRpb24ob3RoZXJSYW5nZS5lbmQpIHx8IGxvb3NlICYmIHRoaXMuZW5kLmlzRXF1YWwob3RoZXJSYW5nZS5lbmQpOwogICAgcmV0dXJuIGNvbnRhaW5zU3RhcnQgJiYgY29udGFpbnNFbmQ7CiAgfQogIC8qKgogICAqIENoZWNrcyB3aGV0aGVyIGdpdmVuIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbX0gaXMgaW5zaWRlIHRoaXMgcmFuZ2UuCiAgICoKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtfSBpdGVtIE1vZGVsIGl0ZW0gdG8gY2hlY2suCiAgICovCgoKICBjb250YWluc0l0ZW0oaXRlbSkgewogICAgY29uc3QgcG9zID0gUG9zaXRpb24uX2NyZWF0ZUJlZm9yZShpdGVtKTsKCiAgICByZXR1cm4gdGhpcy5jb250YWluc1Bvc2l0aW9uKHBvcykgfHwgdGhpcy5zdGFydC5pc0VxdWFsKHBvcyk7CiAgfQogIC8qKgogICAqIENoZWNrcyB3aGV0aGVyIHRoaXMgb2JqZWN0IGlzIG9mIHRoZSBnaXZlbi4KICAgKgogICAqCQlyYW5nZS5pcyggJ3JhbmdlJyApOyAvLyAtPiB0cnVlCiAgICoJCXJhbmdlLmlzKCAnbW9kZWw6cmFuZ2UnICk7IC8vIC0+IHRydWUKICAgKgogICAqCQlyYW5nZS5pcyggJ3ZpZXc6cmFuZ2UnICk7IC8vIC0+IGZhbHNlCiAgICoJCXJhbmdlLmlzKCAnZG9jdW1lbnRTZWxlY3Rpb24nICk7IC8vIC0+IGZhbHNlCiAgICoKICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9ub2Rlfk5vZGUjaXMgQ2hlY2sgdGhlIGVudGlyZSBsaXN0IG9mIG1vZGVsIG9iamVjdHN9IHdoaWNoIGltcGxlbWVudCB0aGUgYGlzKClgIG1ldGhvZC4KICAgKgogICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlCiAgICogQHJldHVybnMge0Jvb2xlYW59CiAgICovCgoKICBpcyh0eXBlKSB7CiAgICByZXR1cm4gdHlwZSA9PSAncmFuZ2UnIHx8IHR5cGUgPT0gJ21vZGVsOnJhbmdlJzsKICB9CiAgLyoqCiAgICogVHdvIHJhbmdlcyBhcmUgZXF1YWwgaWYgdGhlaXIge0BsaW5rICNzdGFydH0gYW5kIHtAbGluayAjZW5kfSBwb3NpdGlvbnMgYXJlIGVxdWFsLgogICAqCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlfSBvdGhlclJhbmdlIFJhbmdlIHRvIGNvbXBhcmUgd2l0aC4KICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIHJhbmdlcyBhcmUgZXF1YWwsIGBmYWxzZWAgb3RoZXJ3aXNlLgogICAqLwoKCiAgaXNFcXVhbChvdGhlclJhbmdlKSB7CiAgICByZXR1cm4gdGhpcy5zdGFydC5pc0VxdWFsKG90aGVyUmFuZ2Uuc3RhcnQpICYmIHRoaXMuZW5kLmlzRXF1YWwob3RoZXJSYW5nZS5lbmQpOwogIH0KICAvKioKICAgKiBDaGVja3MgYW5kIHJldHVybnMgd2hldGhlciB0aGlzIHJhbmdlIGludGVyc2VjdHMgd2l0aCBnaXZlbiByYW5nZS4KICAgKgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZX0gb3RoZXJSYW5nZSBSYW5nZSB0byBjb21wYXJlIHdpdGguCiAgICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiByYW5nZXMgaW50ZXJzZWN0LCBgZmFsc2VgIG90aGVyd2lzZS4KICAgKi8KCgogIGlzSW50ZXJzZWN0aW5nKG90aGVyUmFuZ2UpIHsKICAgIHJldHVybiB0aGlzLnN0YXJ0LmlzQmVmb3JlKG90aGVyUmFuZ2UuZW5kKSAmJiB0aGlzLmVuZC5pc0FmdGVyKG90aGVyUmFuZ2Uuc3RhcnQpOwogIH0KICAvKioKICAgKiBDb21wdXRlcyB3aGljaCBwYXJ0KHMpIG9mIHRoaXMge0BsaW5rIH5SYW5nZSByYW5nZX0gaXMgbm90IGEgcGFydCBvZiBnaXZlbiB7QGxpbmsgflJhbmdlIHJhbmdlfS4KICAgKiBSZXR1cm5lZCBhcnJheSBjb250YWlucyB6ZXJvLCBvbmUgb3IgdHdvIHtAbGluayB+UmFuZ2UgcmFuZ2VzfS4KICAgKgogICAqIEV4YW1wbGVzOgogICAqCiAgICoJCWxldCByYW5nZSA9IG1vZGVsLmNyZWF0ZVJhbmdlKAogICAqCQkJbW9kZWwuY3JlYXRlUG9zaXRpb25Gcm9tUGF0aCggcm9vdCwgWyAyLCA3IF0gKSwKICAgKgkJCW1vZGVsLmNyZWF0ZVBvc2l0aW9uRnJvbVBhdGgoIHJvb3QsIFsgNCwgMCwgMSBdICkKICAgKgkJKTsKICAgKgkJbGV0IG90aGVyUmFuZ2UgPSBtb2RlbC5jcmVhdGVSYW5nZSggbW9kZWwuY3JlYXRlUG9zaXRpb25Gcm9tUGF0aCggcm9vdCwgWyAxIF0gKSwgbW9kZWwuY3JlYXRlUG9zaXRpb25Gcm9tUGF0aCggcm9vdCwgWyA1IF0gKSApOwogICAqCQlsZXQgdHJhbnNmb3JtZWQgPSByYW5nZS5nZXREaWZmZXJlbmNlKCBvdGhlclJhbmdlICk7CiAgICoJCS8vIHRyYW5zZm9ybWVkIGFycmF5IGhhcyBubyByYW5nZXMgYmVjYXVzZSBgb3RoZXJSYW5nZWAgY29udGFpbnMgYHJhbmdlYAogICAqCiAgICoJCW90aGVyUmFuZ2UgPSBtb2RlbC5jcmVhdGVSYW5nZSggbW9kZWwuY3JlYXRlUG9zaXRpb25Gcm9tUGF0aCggcm9vdCwgWyAxIF0gKSwgbW9kZWwuY3JlYXRlUG9zaXRpb25Gcm9tUGF0aCggcm9vdCwgWyAzIF0gKSApOwogICAqCQl0cmFuc2Zvcm1lZCA9IHJhbmdlLmdldERpZmZlcmVuY2UoIG90aGVyUmFuZ2UgKTsKICAgKgkJLy8gdHJhbnNmb3JtZWQgYXJyYXkgaGFzIG9uZSByYW5nZTogZnJvbSBbIDMgXSB0byBbIDQsIDAsIDEgXQogICAqCiAgICoJCW90aGVyUmFuZ2UgPSBtb2RlbC5jcmVhdGVSYW5nZSggbW9kZWwuY3JlYXRlUG9zaXRpb25Gcm9tUGF0aCggcm9vdCwgWyAzIF0gKSwgbW9kZWwuY3JlYXRlUG9zaXRpb25Gcm9tUGF0aCggcm9vdCwgWyA0IF0gKSApOwogICAqCQl0cmFuc2Zvcm1lZCA9IHJhbmdlLmdldERpZmZlcmVuY2UoIG90aGVyUmFuZ2UgKTsKICAgKgkJLy8gdHJhbnNmb3JtZWQgYXJyYXkgaGFzIHR3byByYW5nZXM6IGZyb20gWyAyLCA3IF0gdG8gWyAzIF0gYW5kIGZyb20gWyA0IF0gdG8gWyA0LCAwLCAxIF0KICAgKgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZX0gb3RoZXJSYW5nZSBSYW5nZSB0byBkaWZmZXJlbnRpYXRlIGFnYWluc3QuCiAgICogQHJldHVybnMge0FycmF5Ljxtb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlPn0gVGhlIGRpZmZlcmVuY2UgYmV0d2VlbiByYW5nZXMuCiAgICovCgoKICBnZXREaWZmZXJlbmNlKG90aGVyUmFuZ2UpIHsKICAgIGNvbnN0IHJhbmdlcyA9IFtdOwoKICAgIGlmICh0aGlzLmlzSW50ZXJzZWN0aW5nKG90aGVyUmFuZ2UpKSB7CiAgICAgIC8vIFJhbmdlcyBpbnRlcnNlY3QuCiAgICAgIGlmICh0aGlzLmNvbnRhaW5zUG9zaXRpb24ob3RoZXJSYW5nZS5zdGFydCkpIHsKICAgICAgICAvLyBHaXZlbiByYW5nZSBzdGFydCBpcyBpbnNpZGUgdGhpcyByYW5nZS4gVGhpcyBtZWFucyB0aGF0IHdlIGhhdmUgdG8KICAgICAgICAvLyBhZGQgc2hydW5rZW4gcmFuZ2UgLSBmcm9tIHRoZSBzdGFydCB0byB0aGUgbWlkZGxlIG9mIHRoaXMgcmFuZ2UuCiAgICAgICAgcmFuZ2VzLnB1c2gobmV3IFJhbmdlKHRoaXMuc3RhcnQsIG90aGVyUmFuZ2Uuc3RhcnQpKTsKICAgICAgfQoKICAgICAgaWYgKHRoaXMuY29udGFpbnNQb3NpdGlvbihvdGhlclJhbmdlLmVuZCkpIHsKICAgICAgICAvLyBHaXZlbiByYW5nZSBlbmQgaXMgaW5zaWRlIHRoaXMgcmFuZ2UuIFRoaXMgbWVhbnMgdGhhdCB3ZSBoYXZlIHRvCiAgICAgICAgLy8gYWRkIHNocnVua2VuIHJhbmdlIC0gZnJvbSB0aGUgbWlkZGxlIG9mIHRoaXMgcmFuZ2UgdG8gdGhlIGVuZC4KICAgICAgICByYW5nZXMucHVzaChuZXcgUmFuZ2Uob3RoZXJSYW5nZS5lbmQsIHRoaXMuZW5kKSk7CiAgICAgIH0KICAgIH0gZWxzZSB7CiAgICAgIC8vIFJhbmdlcyBkbyBub3QgaW50ZXJzZWN0LCByZXR1cm4gdGhlIG9yaWdpbmFsIHJhbmdlLgogICAgICByYW5nZXMucHVzaChuZXcgUmFuZ2UodGhpcy5zdGFydCwgdGhpcy5lbmQpKTsKICAgIH0KCiAgICByZXR1cm4gcmFuZ2VzOwogIH0KICAvKioKICAgKiBSZXR1cm5zIGFuIGludGVyc2VjdGlvbiBvZiB0aGlzIHtAbGluayB+UmFuZ2UgcmFuZ2V9IGFuZCBnaXZlbiB7QGxpbmsgflJhbmdlIHJhbmdlfS4KICAgKiBJbnRlcnNlY3Rpb24gaXMgYSBjb21tb24gcGFydCBvZiBib3RoIG9mIHRob3NlIHJhbmdlcy4gSWYgcmFuZ2VzIGhhcyBubyBjb21tb24gcGFydCwgcmV0dXJucyBgbnVsbGAuCiAgICoKICAgKiBFeGFtcGxlczoKICAgKgogICAqCQlsZXQgcmFuZ2UgPSBtb2RlbC5jcmVhdGVSYW5nZSgKICAgKgkJCW1vZGVsLmNyZWF0ZVBvc2l0aW9uRnJvbVBhdGgoIHJvb3QsIFsgMiwgNyBdICksCiAgICoJCQltb2RlbC5jcmVhdGVQb3NpdGlvbkZyb21QYXRoKCByb290LCBbIDQsIDAsIDEgXSApCiAgICoJCSk7CiAgICoJCWxldCBvdGhlclJhbmdlID0gbW9kZWwuY3JlYXRlUmFuZ2UoIG1vZGVsLmNyZWF0ZVBvc2l0aW9uRnJvbVBhdGgoIHJvb3QsIFsgMSBdICksIG1vZGVsLmNyZWF0ZVBvc2l0aW9uRnJvbVBhdGgoIHJvb3QsIFsgMiBdICkgKTsKICAgKgkJbGV0IHRyYW5zZm9ybWVkID0gcmFuZ2UuZ2V0SW50ZXJzZWN0aW9uKCBvdGhlclJhbmdlICk7IC8vIG51bGwgLSByYW5nZXMgaGF2ZSBubyBjb21tb24gcGFydAogICAqCiAgICoJCW90aGVyUmFuZ2UgPSBtb2RlbC5jcmVhdGVSYW5nZSggbW9kZWwuY3JlYXRlUG9zaXRpb25Gcm9tUGF0aCggcm9vdCwgWyAzIF0gKSwgbW9kZWwuY3JlYXRlUG9zaXRpb25Gcm9tUGF0aCggcm9vdCwgWyA1IF0gKSApOwogICAqCQl0cmFuc2Zvcm1lZCA9IHJhbmdlLmdldEludGVyc2VjdGlvbiggb3RoZXJSYW5nZSApOyAvLyByYW5nZSBmcm9tIFsgMyBdIHRvIFsgNCwgMCwgMSBdCiAgICoKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2V9IG90aGVyUmFuZ2UgUmFuZ2UgdG8gY2hlY2sgZm9yIGludGVyc2VjdGlvbi4KICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZXxudWxsfSBBIGNvbW1vbiBwYXJ0IG9mIGdpdmVuIHJhbmdlcyBvciBgbnVsbGAgaWYgcmFuZ2VzIGhhdmUgbm8gY29tbW9uIHBhcnQuCiAgICovCgoKICBnZXRJbnRlcnNlY3Rpb24ob3RoZXJSYW5nZSkgewogICAgaWYgKHRoaXMuaXNJbnRlcnNlY3Rpbmcob3RoZXJSYW5nZSkpIHsKICAgICAgLy8gUmFuZ2VzIGludGVyc2VjdCwgc28gYSBjb21tb24gcmFuZ2Ugd2lsbCBiZSByZXR1cm5lZC4KICAgICAgLy8gQXQgbW9zdCwgaXQgd2lsbCBiZSBzYW1lIGFzIHRoaXMgcmFuZ2UuCiAgICAgIGxldCBjb21tb25SYW5nZVN0YXJ0ID0gdGhpcy5zdGFydDsKICAgICAgbGV0IGNvbW1vblJhbmdlRW5kID0gdGhpcy5lbmQ7CgogICAgICBpZiAodGhpcy5jb250YWluc1Bvc2l0aW9uKG90aGVyUmFuZ2Uuc3RhcnQpKSB7CiAgICAgICAgLy8gR2l2ZW4gcmFuZ2Ugc3RhcnQgaXMgaW5zaWRlIHRoaXMgcmFuZ2UuIFRoaXMgbWVhbnMgdGhhTnQgd2UgaGF2ZSB0bwogICAgICAgIC8vIHNocmluayBjb21tb24gcmFuZ2UgdG8gdGhlIGdpdmVuIHJhbmdlIHN0YXJ0LgogICAgICAgIGNvbW1vblJhbmdlU3RhcnQgPSBvdGhlclJhbmdlLnN0YXJ0OwogICAgICB9CgogICAgICBpZiAodGhpcy5jb250YWluc1Bvc2l0aW9uKG90aGVyUmFuZ2UuZW5kKSkgewogICAgICAgIC8vIEdpdmVuIHJhbmdlIGVuZCBpcyBpbnNpZGUgdGhpcyByYW5nZS4gVGhpcyBtZWFucyB0aGF0IHdlIGhhdmUgdG8KICAgICAgICAvLyBzaHJpbmsgY29tbW9uIHJhbmdlIHRvIHRoZSBnaXZlbiByYW5nZSBlbmQuCiAgICAgICAgY29tbW9uUmFuZ2VFbmQgPSBvdGhlclJhbmdlLmVuZDsKICAgICAgfQoKICAgICAgcmV0dXJuIG5ldyBSYW5nZShjb21tb25SYW5nZVN0YXJ0LCBjb21tb25SYW5nZUVuZCk7CiAgICB9IC8vIFJhbmdlcyBkbyBub3QgaW50ZXJzZWN0LCBzbyB0aGV5IGRvIG5vdCBoYXZlIGNvbW1vbiBwYXJ0LgoKCiAgICByZXR1cm4gbnVsbDsKICB9CiAgLyoqCiAgICogQ29tcHV0ZXMgYW5kIHJldHVybnMgdGhlIHNtYWxsZXN0IHNldCBvZiB7QGxpbmsgI2lzRmxhdCBmbGF0fSByYW5nZXMsIHRoYXQgY292ZXJzIHRoaXMgcmFuZ2UgaW4gd2hvbGUuCiAgICoKICAgKiBTZWUgYW4gZXhhbXBsZSBvZiBhIG1vZGVsIHN0cnVjdHVyZSAoYFtgIGFuZCBgXWAgYXJlIHJhbmdlIGJvdW5kYXJpZXMpOgogICAqCiAgICoJCXJvb3QgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb290CiAgICoJCSB8LSBlbGVtZW50IERJViAgICAgICAgICAgICAgICAgICAgICAgICBESVYgICAgICAgICAgICAgUDIgICAgICAgICAgICAgIFAzICAgICAgICAgICAgIERJVgogICAqCQkgfCAgIHwtIGVsZW1lbnQgSCAgICAgICAgICAgICAgICAgICBIICAgICAgICBQMSAgICAgICAgZiBvIG8gICAgICAgICAgIGIgYSByICAgICAgIEggICAgICAgICBQNAogICAqCQkgfCAgIHwgICB8LSAiZmlyW3N0IiAgICAgICAgICAgICBmaXJbc3QgICAgIGxvcmVtICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlXWNvbmQgICAgIGlwc3VtCiAgICoJCSB8ICAgfC0gZWxlbWVudCBQMQogICAqCQkgfCAgIHwgICB8LSAibG9yZW0iICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8CiAgICoJCSB8LSBlbGVtZW50IFAyICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwKICAgKgkJIHwgICB8LSAiZm9vIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBWVgogICAqCQkgfC0gZWxlbWVudCBQMwogICAqCQkgfCAgIHwtICJiYXIiICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm9vdAogICAqCQkgfC0gZWxlbWVudCBESVYgICAgICAgICAgICAgICAgICAgICAgICAgRElWICAgICAgICAgICAgIFtQMiAgICAgICAgICAgICBQM10gICAgICAgICAgICAgRElWCiAgICoJCSB8ICAgfC0gZWxlbWVudCBIICAgICAgICAgICAgICAgICAgIEggICAgICAgW1AxXSAgICAgICBmIG8gbyAgICAgICAgICAgYiBhIHIgICAgICAgIEggICAgICAgICBQNAogICAqCQkgfCAgIHwgICB8LSAic2VdY29uZCIgICAgICAgICAgICBmaXJbc3RdICAgIGxvcmVtICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzZV1jb25kICAgICBpcHN1bQogICAqCQkgfCAgIHwtIGVsZW1lbnQgUDQKICAgKgkJIHwgICB8ICAgfC0gImlwc3VtIgogICAqCiAgICogQXMgaXQgY2FuIGJlIHNlZW4sIGxldHRlcnMgY29udGFpbmVkIGluIHRoZSByYW5nZSBhcmU6IGBzdGxvcmVtZm9vYmFyc2VgLCBzcHJlYWQgYWNyb3NzIGRpZmZlcmVudCBwYXJlbnRzLgogICAqIFdlIGFyZSBsb29raW5nIGZvciBtaW5pbWFsIHNldCBvZiBmbGF0IHJhbmdlcyB0aGF0IGNvbnRhaW5zIHRoZSBzYW1lIG5vZGVzLgogICAqCiAgICogTWluaW1hbCBmbGF0IHJhbmdlcyBmb3IgYWJvdmUgcmFuZ2UgYCggWyAwLCAwLCAzIF0sIFsgMywgMCwgMiBdIClgIHdpbGwgYmU6CiAgICoKICAgKgkJKCBbIDAsIDAsIDMgXSwgWyAwLCAwLCA1IF0gKSA9ICJzdCIKICAgKgkJKCBbIDAsIDEgXSwgWyAwLCAyIF0gKSA9IGVsZW1lbnQgUDEgKCJsb3JlbSIpCiAgICoJCSggWyAxIF0sIFsgMyBdICkgPSBlbGVtZW50IFAyLCBlbGVtZW50IFAzICgiZm9vYmFyIikKICAgKgkJKCBbIDMsIDAsIDAgXSwgWyAzLCAwLCAyIF0gKSA9ICJzZSIKICAgKgogICAqICoqTm90ZToqKiBpZiBhbiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnQgZWxlbWVudH0gaXMgbm90IHdob2xseSBjb250YWluZWQgaW4gdGhpcyByYW5nZSwgaXQgd29uJ3QgYmUgcmV0dXJuZWQKICAgKiBpbiBhbnkgb2YgdGhlIHJldHVybmVkIGZsYXQgcmFuZ2VzLiBTZWUgaW4gdGhlIGV4YW1wbGUgaG93IGBIYCBlbGVtZW50cyBhdCB0aGUgYmVnaW5uaW5nIGFuZCBhdCB0aGUgZW5kIG9mIHRoZSByYW5nZQogICAqIHdlcmUgb21pdHRlZC4gT25seSB0aGVpciBwYXJ0cyB0aGF0IHdlcmUgd2hvbGx5IGluIHRoZSByYW5nZSB3ZXJlIHJldHVybmVkLgogICAqCiAgICogKipOb3RlOioqIHRoaXMgbWV0aG9kIGlzIG5vdCByZXR1cm5pbmcgZmxhdCByYW5nZXMgdGhhdCBjb250YWluIG5vIG5vZGVzLgogICAqCiAgICogQHJldHVybnMge0FycmF5Ljxtb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlPn0gQXJyYXkgb2YgZmxhdCByYW5nZXMgY292ZXJpbmcgdGhpcyByYW5nZS4KICAgKi8KCgogIGdldE1pbmltYWxGbGF0UmFuZ2VzKCkgewogICAgY29uc3QgcmFuZ2VzID0gW107CiAgICBjb25zdCBkaWZmQXQgPSB0aGlzLnN0YXJ0LmdldENvbW1vblBhdGgodGhpcy5lbmQpLmxlbmd0aDsKCiAgICBjb25zdCBwb3MgPSBQb3NpdGlvbi5fY3JlYXRlQXQodGhpcy5zdGFydCk7CgogICAgbGV0IHBvc1BhcmVudCA9IHBvcy5wYXJlbnQ7IC8vIEdvIHVwLgoKICAgIHdoaWxlIChwb3MucGF0aC5sZW5ndGggPiBkaWZmQXQgKyAxKSB7CiAgICAgIGNvbnN0IGhvd01hbnkgPSBwb3NQYXJlbnQubWF4T2Zmc2V0IC0gcG9zLm9mZnNldDsKCiAgICAgIGlmIChob3dNYW55ICE9PSAwKSB7CiAgICAgICAgcmFuZ2VzLnB1c2gobmV3IFJhbmdlKHBvcywgcG9zLmdldFNoaWZ0ZWRCeShob3dNYW55KSkpOwogICAgICB9CgogICAgICBwb3MucGF0aCA9IHBvcy5wYXRoLnNsaWNlKDAsIC0xKTsKICAgICAgcG9zLm9mZnNldCsrOwogICAgICBwb3NQYXJlbnQgPSBwb3NQYXJlbnQucGFyZW50OwogICAgfSAvLyBHbyBkb3duLgoKCiAgICB3aGlsZSAocG9zLnBhdGgubGVuZ3RoIDw9IHRoaXMuZW5kLnBhdGgubGVuZ3RoKSB7CiAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuZW5kLnBhdGhbcG9zLnBhdGgubGVuZ3RoIC0gMV07CiAgICAgIGNvbnN0IGhvd01hbnkgPSBvZmZzZXQgLSBwb3Mub2Zmc2V0OwoKICAgICAgaWYgKGhvd01hbnkgIT09IDApIHsKICAgICAgICByYW5nZXMucHVzaChuZXcgUmFuZ2UocG9zLCBwb3MuZ2V0U2hpZnRlZEJ5KGhvd01hbnkpKSk7CiAgICAgIH0KCiAgICAgIHBvcy5vZmZzZXQgPSBvZmZzZXQ7CiAgICAgIHBvcy5wYXRoLnB1c2goMCk7CiAgICB9CgogICAgcmV0dXJuIHJhbmdlczsKICB9CiAgLyoqCiAgICogQ3JlYXRlcyBhIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3RyZWV3YWxrZXJ+VHJlZVdhbGtlciBUcmVlV2Fsa2VyfSBpbnN0YW5jZSB3aXRoIHRoaXMgcmFuZ2UgYXMgYSBib3VuZGFyeS4KICAgKgogICAqIEZvciBleGFtcGxlLCB0byBpdGVyYXRlIG92ZXIgYWxsIGl0ZW1zIGluIHRoZSBlbnRpcmUgZG9jdW1lbnQgcm9vdDoKICAgKgogICAqCQkvLyBDcmVhdGUgYSByYW5nZSBzcGFubmluZyBvdmVyIHRoZSBlbnRpcmUgcm9vdCBjb250ZW50OgogICAqCQljb25zdCByYW5nZSA9IGVkaXRvci5tb2RlbC5jcmVhdGVSYW5nZUluKCBlZGl0b3IubW9kZWwuZG9jdW1lbnQuZ2V0Um9vdCgpICk7CiAgICoKICAgKgkJLy8gSXRlcmF0ZSBvdmVyIGFsbCBpdGVtcyBpbiB0aGlzIHJhbmdlOgogICAqCQlmb3IgKCBjb25zdCB2YWx1ZSBvZiByYW5nZS5nZXRXYWxrZXIoKSApIHsKICAgKgkJCWNvbnNvbGUubG9nKCB2YWx1ZS5pdGVtICk7CiAgICoJCX0KICAgKgogICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9iamVjdCB3aXRoIGNvbmZpZ3VyYXRpb24gb3B0aW9ucy4gU2VlIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3RyZWV3YWxrZXJ+VHJlZVdhbGtlcn0uCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufSBbb3B0aW9ucy5zdGFydFBvc2l0aW9uXQogICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2luZ2xlQ2hhcmFjdGVycz1mYWxzZV0KICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNoYWxsb3c9ZmFsc2VdCiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5pZ25vcmVFbGVtZW50RW5kPWZhbHNlXQogICAqLwoKCiAgZ2V0V2Fsa2VyKG9wdGlvbnMgPSB7fSkgewogICAgb3B0aW9ucy5ib3VuZGFyaWVzID0gdGhpczsKICAgIHJldHVybiBuZXcgVHJlZVdhbGtlcihvcHRpb25zKTsKICB9CiAgLyoqCiAgICogUmV0dXJucyBhbiBpdGVyYXRvciB0aGF0IGl0ZXJhdGVzIG92ZXIgYWxsIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbSBpdGVtc30gdGhhdCBhcmUgaW4gdGhpcyByYW5nZSBhbmQgcmV0dXJucwogICAqIHRoZW0uCiAgICoKICAgKiBUaGlzIG1ldGhvZCB1c2VzIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3RyZWV3YWxrZXJ+VHJlZVdhbGtlcn0gd2l0aCBgYm91bmRhcmllc2Agc2V0IHRvIHRoaXMgcmFuZ2UgYW5kIGBpZ25vcmVFbGVtZW50RW5kYCBvcHRpb24KICAgKiBzZXQgdG8gYHRydWVgLiBIb3dldmVyIGl0IHJldHVybnMgb25seSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9pdGVtfkl0ZW0gbW9kZWwgaXRlbXN9LAogICAqIG5vdCB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC90cmVld2Fsa2VyflRyZWVXYWxrZXJWYWx1ZX0uCiAgICoKICAgKiBZb3UgbWF5IHNwZWNpZnkgYWRkaXRpb25hbCBvcHRpb25zIGZvciB0aGUgdHJlZSB3YWxrZXIuIFNlZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC90cmVld2Fsa2VyflRyZWVXYWxrZXJ9IGZvcgogICAqIGEgZnVsbCBsaXN0IG9mIGF2YWlsYWJsZSBvcHRpb25zLgogICAqCiAgICogQG1ldGhvZCBnZXRJdGVtcwogICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9iamVjdCB3aXRoIGNvbmZpZ3VyYXRpb24gb3B0aW9ucy4gU2VlIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3RyZWV3YWxrZXJ+VHJlZVdhbGtlcn0uCiAgICogQHJldHVybnMge0l0ZXJhYmxlLjxtb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbT59CiAgICovCgoKICAqZ2V0SXRlbXMob3B0aW9ucyA9IHt9KSB7CiAgICBvcHRpb25zLmJvdW5kYXJpZXMgPSB0aGlzOwogICAgb3B0aW9ucy5pZ25vcmVFbGVtZW50RW5kID0gdHJ1ZTsKICAgIGNvbnN0IHRyZWVXYWxrZXIgPSBuZXcgVHJlZVdhbGtlcihvcHRpb25zKTsKCiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHRyZWVXYWxrZXIpIHsKICAgICAgeWllbGQgdmFsdWUuaXRlbTsKICAgIH0KICB9CiAgLyoqCiAgICogUmV0dXJucyBhbiBpdGVyYXRvciB0aGF0IGl0ZXJhdGVzIG92ZXIgYWxsIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9uIHBvc2l0aW9uc30gdGhhdCBhcmUgYm91bmRhcmllcyBvcgogICAqIGNvbnRhaW5lZCBpbiB0aGlzIHJhbmdlLgogICAqCiAgICogVGhpcyBtZXRob2QgdXNlcyB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC90cmVld2Fsa2VyflRyZWVXYWxrZXJ9IHdpdGggYGJvdW5kYXJpZXNgIHNldCB0byB0aGlzIHJhbmdlLiBIb3dldmVyIGl0IHJldHVybnMgb25seQogICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9uIHBvc2l0aW9uc30sIG5vdCB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC90cmVld2Fsa2VyflRyZWVXYWxrZXJWYWx1ZX0uCiAgICoKICAgKiBZb3UgbWF5IHNwZWNpZnkgYWRkaXRpb25hbCBvcHRpb25zIGZvciB0aGUgdHJlZSB3YWxrZXIuIFNlZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC90cmVld2Fsa2VyflRyZWVXYWxrZXJ9IGZvcgogICAqIGEgZnVsbCBsaXN0IG9mIGF2YWlsYWJsZSBvcHRpb25zLgogICAqCiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT2JqZWN0IHdpdGggY29uZmlndXJhdGlvbiBvcHRpb25zLiBTZWUge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvdHJlZXdhbGtlcn5UcmVlV2Fsa2VyfS4KICAgKiBAcmV0dXJucyB7SXRlcmFibGUuPG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb24+fQogICAqLwoKCiAgKmdldFBvc2l0aW9ucyhvcHRpb25zID0ge30pIHsKICAgIG9wdGlvbnMuYm91bmRhcmllcyA9IHRoaXM7CiAgICBjb25zdCB0cmVlV2Fsa2VyID0gbmV3IFRyZWVXYWxrZXIob3B0aW9ucyk7CiAgICB5aWVsZCB0cmVlV2Fsa2VyLnBvc2l0aW9uOwoKICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdHJlZVdhbGtlcikgewogICAgICB5aWVsZCB2YWx1ZS5uZXh0UG9zaXRpb247CiAgICB9CiAgfQogIC8qKgogICAqIFJldHVybnMgYSByYW5nZSB0aGF0IGlzIGEgcmVzdWx0IG9mIHRyYW5zZm9ybWluZyB0aGlzIHJhbmdlIGJ5IGdpdmVuIGBvcGVyYXRpb25gLgogICAqCiAgICogKipOb3RlOioqIHRyYW5zZm9ybWF0aW9uIG1heSBicmVhayBvbmUgcmFuZ2UgaW50byBtdWx0aXBsZSByYW5nZXMgKGZvciBleGFtcGxlLCB3aGVuIGEgcGFydCBvZiB0aGUgcmFuZ2UgaXMKICAgKiBtb3ZlZCB0byBhIGRpZmZlcmVudCBwYXJ0IG9mIGRvY3VtZW50IHRyZWUpLiBGb3IgdGhpcyByZWFzb24sIGFuIGFycmF5IGlzIHJldHVybmVkIGJ5IHRoaXMgbWV0aG9kIGFuZCBpdAogICAqIG1heSBjb250YWluIG9uZSBvciBtb3JlIGBSYW5nZWAgaW5zdGFuY2VzLgogICAqCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL29wZXJhdGlvbi9vcGVyYXRpb25+T3BlcmF0aW9ufSBvcGVyYXRpb24gT3BlcmF0aW9uIHRvIHRyYW5zZm9ybSByYW5nZSBieS4KICAgKiBAcmV0dXJucyB7QXJyYXkuPG1vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2U+fSBSYW5nZSB3aGljaCBpcyB0aGUgcmVzdWx0IG9mIHRyYW5zZm9ybWF0aW9uLgogICAqLwoKCiAgZ2V0VHJhbnNmb3JtZWRCeU9wZXJhdGlvbihvcGVyYXRpb24pIHsKICAgIHN3aXRjaCAob3BlcmF0aW9uLnR5cGUpIHsKICAgICAgY2FzZSAnaW5zZXJ0JzoKICAgICAgICByZXR1cm4gdGhpcy5fZ2V0VHJhbnNmb3JtZWRCeUluc2VydE9wZXJhdGlvbihvcGVyYXRpb24pOwoKICAgICAgY2FzZSAnbW92ZSc6CiAgICAgIGNhc2UgJ3JlbW92ZSc6CiAgICAgIGNhc2UgJ3JlaW5zZXJ0JzoKICAgICAgICByZXR1cm4gdGhpcy5fZ2V0VHJhbnNmb3JtZWRCeU1vdmVPcGVyYXRpb24ob3BlcmF0aW9uKTsKCiAgICAgIGNhc2UgJ3NwbGl0JzoKICAgICAgICByZXR1cm4gW3RoaXMuX2dldFRyYW5zZm9ybWVkQnlTcGxpdE9wZXJhdGlvbihvcGVyYXRpb24pXTsKCiAgICAgIGNhc2UgJ21lcmdlJzoKICAgICAgICByZXR1cm4gW3RoaXMuX2dldFRyYW5zZm9ybWVkQnlNZXJnZU9wZXJhdGlvbihvcGVyYXRpb24pXTsKICAgIH0KCiAgICByZXR1cm4gW25ldyBSYW5nZSh0aGlzLnN0YXJ0LCB0aGlzLmVuZCldOwogIH0KICAvKioKICAgKiBSZXR1cm5zIGEgcmFuZ2UgdGhhdCBpcyBhIHJlc3VsdCBvZiB0cmFuc2Zvcm1pbmcgdGhpcyByYW5nZSBieSBtdWx0aXBsZSBgb3BlcmF0aW9uc2AuCiAgICoKICAgKiBAc2VlIH5SYW5nZSNnZXRUcmFuc2Zvcm1lZEJ5T3BlcmF0aW9uCiAgICogQHBhcmFtIHtJdGVyYWJsZS48bW9kdWxlOmVuZ2luZS9tb2RlbC9vcGVyYXRpb24vb3BlcmF0aW9ufk9wZXJhdGlvbj59IG9wZXJhdGlvbnMgT3BlcmF0aW9ucyB0byB0cmFuc2Zvcm0gdGhlIHJhbmdlIGJ5LgogICAqIEByZXR1cm5zIHtBcnJheS48bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZT59IFJhbmdlIHdoaWNoIGlzIHRoZSByZXN1bHQgb2YgdHJhbnNmb3JtYXRpb24uCiAgICovCgoKICBnZXRUcmFuc2Zvcm1lZEJ5T3BlcmF0aW9ucyhvcGVyYXRpb25zKSB7CiAgICBjb25zdCByYW5nZXMgPSBbbmV3IFJhbmdlKHRoaXMuc3RhcnQsIHRoaXMuZW5kKV07CgogICAgZm9yIChjb25zdCBvcGVyYXRpb24gb2Ygb3BlcmF0aW9ucykgewogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykgewogICAgICAgIGNvbnN0IHJlc3VsdCA9IHJhbmdlc1tpXS5nZXRUcmFuc2Zvcm1lZEJ5T3BlcmF0aW9uKG9wZXJhdGlvbik7CiAgICAgICAgcmFuZ2VzLnNwbGljZShpLCAxLCAuLi5yZXN1bHQpOwogICAgICAgIGkgKz0gcmVzdWx0Lmxlbmd0aCAtIDE7CiAgICAgIH0KICAgIH0gLy8gSXQgbWF5IGhhcHBlbiB0aGF0IGEgcmFuZ2UgaXMgc3BsaXQgaW50byB0d28sIGFuZCB0aGVuIHRoZSBwYXJ0IG9mIHNlY29uZCAicGllY2UiIGlzIG1vdmVkIGludG8gZmlyc3QKICAgIC8vICJwaWVjZSIuIEluIHRoaXMgY2FzZSB3ZSB3aWxsIGhhdmUgaW5jb3JyZWN0IHRoaXJkIHJhbmdlLCB3aGljaCBzaG91bGQgbm90IGJlIGluY2x1ZGVkIGluIHRoZSByZXN1bHQgLS0KICAgIC8vIGJlY2F1c2UgaXQgaXMgYWxyZWFkeSBpbmNsdWRlZCBpbiB0aGUgZmlyc3QgInBpZWNlIi4gSW4gdGhpcyBsb29wIHdlIGFyZSBsb29raW5nIGZvciBhbGwgc3VjaCByYW5nZXMgdGhhdAogICAgLy8gYXJlIGluc2lkZSBvdGhlciByYW5nZXMgYW5kIHdlIHNpbXBseSByZW1vdmUgdGhlbS4KCgogICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHsKICAgICAgY29uc3QgcmFuZ2UgPSByYW5nZXNbaV07CgogICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCByYW5nZXMubGVuZ3RoOyBqKyspIHsKICAgICAgICBjb25zdCBuZXh0ID0gcmFuZ2VzW2pdOwoKICAgICAgICBpZiAocmFuZ2UuY29udGFpbnNSYW5nZShuZXh0KSB8fCBuZXh0LmNvbnRhaW5zUmFuZ2UocmFuZ2UpIHx8IHJhbmdlLmlzRXF1YWwobmV4dCkpIHsKICAgICAgICAgIHJhbmdlcy5zcGxpY2UoaiwgMSk7CiAgICAgICAgfQogICAgICB9CiAgICB9CgogICAgcmV0dXJuIHJhbmdlczsKICB9CiAgLyoqCiAgICogUmV0dXJucyBhbiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR9IG9yIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudH0KICAgKiB3aGljaCBpcyBhIGNvbW1vbiBhbmNlc3RvciBvZiB0aGUgcmFuZ2UncyBib3RoIGVuZHMgKGluIHdoaWNoIHRoZSBlbnRpcmUgcmFuZ2UgaXMgY29udGFpbmVkKS4KICAgKgogICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudHxtb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudHxudWxsfQogICAqLwoKCiAgZ2V0Q29tbW9uQW5jZXN0b3IoKSB7CiAgICByZXR1cm4gdGhpcy5zdGFydC5nZXRDb21tb25BbmNlc3Rvcih0aGlzLmVuZCk7CiAgfQogIC8qKgogICAqIENvbnZlcnRzIGBSYW5nZWAgdG8gcGxhaW4gb2JqZWN0IGFuZCByZXR1cm5zIGl0LgogICAqCiAgICogQHJldHVybnMge09iamVjdH0gYE5vZGVgIGNvbnZlcnRlZCB0byBwbGFpbiBvYmplY3QuCiAgICovCgoKICB0b0pTT04oKSB7CiAgICByZXR1cm4gewogICAgICBzdGFydDogdGhpcy5zdGFydC50b0pTT04oKSwKICAgICAgZW5kOiB0aGlzLmVuZC50b0pTT04oKQogICAgfTsKICB9CiAgLyoqCiAgICogUmV0dXJucyBhIG5ldyByYW5nZSB0aGF0IGlzIGVxdWFsIHRvIGN1cnJlbnQgcmFuZ2UuCiAgICoKICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZX0KICAgKi8KCgogIGNsb25lKCkgewogICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMuc3RhcnQsIHRoaXMuZW5kKTsKICB9CiAgLyoqCiAgICogUmV0dXJucyBhIHJlc3VsdCBvZiB0cmFuc2Zvcm1pbmcgYSBjb3B5IG9mIHRoaXMgcmFuZ2UgYnkgaW5zZXJ0IG9wZXJhdGlvbi4KICAgKgogICAqIE9uZSBvciBtb3JlIHJhbmdlcyBtYXkgYmUgcmV0dXJuZWQgYXMgYSByZXN1bHQgb2YgdGhpcyB0cmFuc2Zvcm1hdGlvbi4KICAgKgogICAqIEBwcm90ZWN0ZWQKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvb3BlcmF0aW9uL2luc2VydG9wZXJhdGlvbn5JbnNlcnRPcGVyYXRpb259IG9wZXJhdGlvbgogICAqIEByZXR1cm5zIHtBcnJheS48bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZT59CiAgICovCgoKICBfZ2V0VHJhbnNmb3JtZWRCeUluc2VydE9wZXJhdGlvbihvcGVyYXRpb24sIHNwcmVhZCA9IGZhbHNlKSB7CiAgICByZXR1cm4gdGhpcy5fZ2V0VHJhbnNmb3JtZWRCeUluc2VydGlvbihvcGVyYXRpb24ucG9zaXRpb24sIG9wZXJhdGlvbi5ob3dNYW55LCBzcHJlYWQpOwogIH0KICAvKioKICAgKiBSZXR1cm5zIGEgcmVzdWx0IG9mIHRyYW5zZm9ybWluZyBhIGNvcHkgb2YgdGhpcyByYW5nZSBieSBtb3ZlIG9wZXJhdGlvbi4KICAgKgogICAqIE9uZSBvciBtb3JlIHJhbmdlcyBtYXkgYmUgcmV0dXJuZWQgYXMgYSByZXN1bHQgb2YgdGhpcyB0cmFuc2Zvcm1hdGlvbi4KICAgKgogICAqIEBwcm90ZWN0ZWQKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvb3BlcmF0aW9uL21vdmVvcGVyYXRpb25+TW92ZU9wZXJhdGlvbn0gb3BlcmF0aW9uCiAgICogQHJldHVybnMge0FycmF5Ljxtb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlPn0KICAgKi8KCgogIF9nZXRUcmFuc2Zvcm1lZEJ5TW92ZU9wZXJhdGlvbihvcGVyYXRpb24sIHNwcmVhZCA9IGZhbHNlKSB7CiAgICBjb25zdCBzb3VyY2VQb3NpdGlvbiA9IG9wZXJhdGlvbi5zb3VyY2VQb3NpdGlvbjsKICAgIGNvbnN0IGhvd01hbnkgPSBvcGVyYXRpb24uaG93TWFueTsKICAgIGNvbnN0IHRhcmdldFBvc2l0aW9uID0gb3BlcmF0aW9uLnRhcmdldFBvc2l0aW9uOwogICAgcmV0dXJuIHRoaXMuX2dldFRyYW5zZm9ybWVkQnlNb3ZlKHNvdXJjZVBvc2l0aW9uLCB0YXJnZXRQb3NpdGlvbiwgaG93TWFueSwgc3ByZWFkKTsKICB9CiAgLyoqCiAgICogUmV0dXJucyBhIHJlc3VsdCBvZiB0cmFuc2Zvcm1pbmcgYSBjb3B5IG9mIHRoaXMgcmFuZ2UgYnkgc3BsaXQgb3BlcmF0aW9uLgogICAqCiAgICogQWx3YXlzIG9uZSByYW5nZSBpcyByZXR1cm5lZC4gVGhlIHRyYW5zZm9ybWF0aW9uIGlzIGRvbmUgaW4gYSB3YXkgdG8gbm90IGJyZWFrIHRoZSByYW5nZS4KICAgKgogICAqIEBwcm90ZWN0ZWQKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvb3BlcmF0aW9uL3NwbGl0b3BlcmF0aW9uflNwbGl0T3BlcmF0aW9ufSBvcGVyYXRpb24KICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZX0KICAgKi8KCgogIF9nZXRUcmFuc2Zvcm1lZEJ5U3BsaXRPcGVyYXRpb24ob3BlcmF0aW9uKSB7CiAgICBjb25zdCBzdGFydCA9IHRoaXMuc3RhcnQuX2dldFRyYW5zZm9ybWVkQnlTcGxpdE9wZXJhdGlvbihvcGVyYXRpb24pOwoKICAgIGxldCBlbmQgPSB0aGlzLmVuZC5fZ2V0VHJhbnNmb3JtZWRCeVNwbGl0T3BlcmF0aW9uKG9wZXJhdGlvbik7CgogICAgaWYgKHRoaXMuZW5kLmlzRXF1YWwob3BlcmF0aW9uLmluc2VydGlvblBvc2l0aW9uKSkgewogICAgICBlbmQgPSB0aGlzLmVuZC5nZXRTaGlmdGVkQnkoMSk7CiAgICB9IC8vIEJlbG93IG1heSBoYXBwZW4gd2hlbiByYW5nZSBjb250YWlucyBncmF2ZXlhcmQgZWxlbWVudCB1c2VkIGJ5IHNwbGl0IG9wZXJhdGlvbi4KCgogICAgaWYgKHN0YXJ0LnJvb3QgIT0gZW5kLnJvb3QpIHsKICAgICAgLy8gRW5kIHBvc2l0aW9uIHdhcyBuZXh0IHRvIHRoZSBtb3ZlZCBncmF2ZXlhcmQgZWxlbWVudCBhbmQgd2FzIG1vdmVkIHdpdGggaXQuCiAgICAgIC8vIEZpeCBpdCBieSB1c2luZyBvbGQgYGVuZGAgd2hpY2ggaGFzIHByb3BlciBgcm9vdGAuCiAgICAgIGVuZCA9IHRoaXMuZW5kLmdldFNoaWZ0ZWRCeSgtMSk7CiAgICB9CgogICAgcmV0dXJuIG5ldyBSYW5nZShzdGFydCwgZW5kKTsKICB9CiAgLyoqCiAgICogUmV0dXJucyBhIHJlc3VsdCBvZiB0cmFuc2Zvcm1pbmcgYSBjb3B5IG9mIHRoaXMgcmFuZ2UgYnkgbWVyZ2Ugb3BlcmF0aW9uLgogICAqCiAgICogQWx3YXlzIG9uZSByYW5nZSBpcyByZXR1cm5lZC4gVGhlIHRyYW5zZm9ybWF0aW9uIGlzIGRvbmUgaW4gYSB3YXkgdG8gbm90IGJyZWFrIHRoZSByYW5nZS4KICAgKgogICAqIEBwcm90ZWN0ZWQKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvb3BlcmF0aW9uL21lcmdlb3BlcmF0aW9ufk1lcmdlT3BlcmF0aW9ufSBvcGVyYXRpb24KICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZX0KICAgKi8KCgogIF9nZXRUcmFuc2Zvcm1lZEJ5TWVyZ2VPcGVyYXRpb24ob3BlcmF0aW9uKSB7CiAgICAvLyBTcGVjaWFsIGNhc2Ugd2hlbiB0aGUgbWFya2VyIGlzIHNldCBvbiAidGhlIGNsb3NpbmcgdGFnIiBvZiBhbiBlbGVtZW50LiBNYXJrZXIgY2FuIGJlIHNldCBsaWtlIHRoYXQgZHVyaW5nCiAgICAvLyB0cmFuc2Zvcm1hdGlvbnMsIGVzcGVjaWFsbHkgd2hlbiBhIGNvbnRlbnQgb2YgYSBmZXcgYmxvY2sgZWxlbWVudHMgd2VyZSByZW1vdmVkLiBGb3IgZXhhbXBsZToKICAgIC8vCiAgICAvLyB7fSBpcyB0aGUgdHJhbnNmb3JtZWQgcmFuZ2UsIFtdIGlzIHRoZSByZW1vdmVkIHJhbmdlLgogICAgLy8gPHA+Rltve288L3A+PHA+Qn1hcjwvcD48cD5YeV16PC9wPgogICAgLy8KICAgIC8vIDxwPkZve288L3A+PHA+Qn1hcjwvcD48cD56PC9wPgogICAgLy8gPHA+Rns8L3A+PHA+Qn1hcjwvcD48cD56PC9wPgogICAgLy8gPHA+Rns8L3A+fTxwPno8L3A+CiAgICAvLyA8cD5Ge316PC9wPgogICAgLy8KICAgIGlmICh0aGlzLnN0YXJ0LmlzRXF1YWwob3BlcmF0aW9uLnRhcmdldFBvc2l0aW9uKSAmJiB0aGlzLmVuZC5pc0VxdWFsKG9wZXJhdGlvbi5kZWxldGlvblBvc2l0aW9uKSkgewogICAgICByZXR1cm4gbmV3IFJhbmdlKHRoaXMuc3RhcnQpOwogICAgfQoKICAgIGxldCBzdGFydCA9IHRoaXMuc3RhcnQuX2dldFRyYW5zZm9ybWVkQnlNZXJnZU9wZXJhdGlvbihvcGVyYXRpb24pOwoKICAgIGxldCBlbmQgPSB0aGlzLmVuZC5fZ2V0VHJhbnNmb3JtZWRCeU1lcmdlT3BlcmF0aW9uKG9wZXJhdGlvbik7CgogICAgaWYgKHN0YXJ0LnJvb3QgIT0gZW5kLnJvb3QpIHsKICAgICAgLy8gVGhpcyBoYXBwZW5zIHdoZW4gdGhlIGVuZCBwb3NpdGlvbiB3YXMgbmV4dCB0byB0aGUgbWVyZ2VkIChkZWxldGVkKSBlbGVtZW50LgogICAgICAvLyBUaGVuLCB0aGUgZW5kIHBvc2l0aW9uIHdhcyBtb3ZlZCB0byB0aGUgZ3JhdmV5YXJkIHJvb3QuIEluIHRoaXMgY2FzZSB3ZSBuZWVkIHRvIGZpeAogICAgICAvLyB0aGUgcmFuZ2UgY2F1c2UgaXRzIGJvdW5kYXJpZXMgd291bGQgYmUgaW4gZGlmZmVyZW50IHJvb3RzLgogICAgICBlbmQgPSB0aGlzLmVuZC5nZXRTaGlmdGVkQnkoLTEpOwogICAgfQoKICAgIGlmIChzdGFydC5pc0FmdGVyKGVuZCkpIHsKICAgICAgLy8gVGhpcyBoYXBwZW5zIGluIHRocmVlIGZvbGxvd2luZyBjYXNlczoKICAgICAgLy8KICAgICAgLy8gQ2FzZSAxOiBNZXJnZSBvcGVyYXRpb24gc291cmNlIHBvc2l0aW9uIGlzIGJlZm9yZSB0aGUgdGFyZ2V0IHBvc2l0aW9uIChkdWUgdG8gc29tZSB0cmFuc2Zvcm1hdGlvbnMsIE9ULCBldGMuKQogICAgICAvLyAgICAgICAgIFRoaXMgbWVhbnMgdGhhdCBzdGFydCBjYW4gYmUgbW92ZWQgYmVmb3JlIHRoZSBlbmQgb2YgdGhlIHJhbmdlLgogICAgICAvLwogICAgICAvLyBCZWZvcmU6IDxwPmF7YTwvcD48cD5ifWI8L3A+PHA+Y2M8L3A+CiAgICAgIC8vIE1lcmdlOiAgPHA+Yn1iPC9wPjxwPmNjYXthPC9wPgogICAgICAvLyBGaXg6ICAgIDxwPntifWI8L3A+PHA+Y2NhYTwvcD4KICAgICAgLy8KICAgICAgLy8gQ2FzZSAyOiBSYW5nZSBzdGFydCBpcyBiZWZvcmUgbWVyZ2VkIG5vZGUgYnV0IG5vdCBkaXJlY3RseS4KICAgICAgLy8gICAgICAgICBSZXN1bHQgc2hvdWxkIGluY2x1ZGUgYWxsIG5vZGVzIHRoYXQgd2VyZSBpbiB0aGUgb3JpZ2luYWwgcmFuZ2UuCiAgICAgIC8vCiAgICAgIC8vIEJlZm9yZTogPHA+YWE8L3A+ezxwPmNjPC9wPjxwPmJ9YjwvcD4KICAgICAgLy8gTWVyZ2U6ICA8cD5hYWJ9YjwvcD57PHA+Y2M8L3A+CiAgICAgIC8vIEZpeDogICAgPHA+YWF7YmI8L3A+PHA+Y2M8L3A+fQogICAgICAvLwogICAgICAvLyAgICAgICAgIFRoZSByYW5nZSBpcyBleHBhbmRlZCBieSBhbiBhZGRpdGlvbmFsIGBiYCBsZXR0ZXIgYnV0IGl0IGlzIGJldHRlciB0aGFuIGRyb3BwaW5nIHRoZSB3aG9sZSBgY2NgIHBhcmFncmFwaC4KICAgICAgLy8KICAgICAgLy8gQ2FzZSAzOiBSYW5nZSBzdGFydCBpcyBkaXJlY3RseSBiZWZvcmUgbWVyZ2VkIG5vZGUuCiAgICAgIC8vICAgICAgICAgUmVzdWx0aW5nIHJhbmdlIHNob3VsZCBpbmNsdWRlIG9ubHkgbm9kZXMgZnJvbSB0aGUgbWVyZ2VkIGVsZW1lbnQ6CiAgICAgIC8vCiAgICAgIC8vIEJlZm9yZTogPHA+YWE8L3A+ezxwPmJ9YjwvcD48cD5jYzwvcD4KICAgICAgLy8gTWVyZ2U6ICA8cD5hYWJ9YjwvcD57PHA+Y2M8L3A+CiAgICAgIC8vIEZpeDogICAgPHA+YWF7Yn1iPC9wPjxwPmNjPC9wPgogICAgICAvLwogICAgICBpZiAob3BlcmF0aW9uLnNvdXJjZVBvc2l0aW9uLmlzQmVmb3JlKG9wZXJhdGlvbi50YXJnZXRQb3NpdGlvbikpIHsKICAgICAgICAvLyBDYXNlIDEuCiAgICAgICAgc3RhcnQgPSBQb3NpdGlvbi5fY3JlYXRlQXQoZW5kKTsKICAgICAgICBzdGFydC5vZmZzZXQgPSAwOwogICAgICB9IGVsc2UgewogICAgICAgIGlmICghb3BlcmF0aW9uLmRlbGV0aW9uUG9zaXRpb24uaXNFcXVhbChzdGFydCkpIHsKICAgICAgICAgIC8vIENhc2UgMi4KICAgICAgICAgIGVuZCA9IG9wZXJhdGlvbi5kZWxldGlvblBvc2l0aW9uOwogICAgICAgIH0gLy8gSW4gYm90aCBjYXNlIDIgYW5kIDMgc3RhcnQgaXMgYXQgdGhlIGVuZCBvZiB0aGUgbWVyZ2UtdG8gZWxlbWVudC4KCgogICAgICAgIHN0YXJ0ID0gb3BlcmF0aW9uLnRhcmdldFBvc2l0aW9uOwogICAgICB9CgogICAgICByZXR1cm4gbmV3IFJhbmdlKHN0YXJ0LCBlbmQpOwogICAgfQoKICAgIHJldHVybiBuZXcgUmFuZ2Uoc3RhcnQsIGVuZCk7CiAgfQogIC8qKgogICAqIFJldHVybnMgYW4gYXJyYXkgY29udGFpbmluZyBvbmUgb3IgdHdvIHtAbGluayB+UmFuZ2UgcmFuZ2VzfSB0aGF0IGFyZSBhIHJlc3VsdCBvZiB0cmFuc2Zvcm1pbmcgdGhpcwogICAqIHtAbGluayB+UmFuZ2UgcmFuZ2V9IGJ5IGluc2VydGluZyBgaG93TWFueWAgbm9kZXMgYXQgYGluc2VydFBvc2l0aW9uYC4gVHdvIHtAbGluayB+UmFuZ2UgcmFuZ2VzfSBhcmUKICAgKiByZXR1cm5lZCBpZiB0aGUgaW5zZXJ0aW9uIHdhcyBpbnNpZGUgdGhpcyB7QGxpbmsgflJhbmdlIHJhbmdlfSBhbmQgYHNwcmVhZGAgaXMgc2V0IHRvIGB0cnVlYC4KICAgKgogICAqIEV4YW1wbGVzOgogICAqCiAgICoJCWxldCByYW5nZSA9IG1vZGVsLmNyZWF0ZVJhbmdlKAogICAqCQkJbW9kZWwuY3JlYXRlUG9zaXRpb25Gcm9tUGF0aCggcm9vdCwgWyAyLCA3IF0gKSwKICAgKgkJCW1vZGVsLmNyZWF0ZVBvc2l0aW9uRnJvbVBhdGgoIHJvb3QsIFsgNCwgMCwgMSBdICkKICAgKgkJKTsKICAgKgkJbGV0IHRyYW5zZm9ybWVkID0gcmFuZ2UuX2dldFRyYW5zZm9ybWVkQnlJbnNlcnRpb24oIG1vZGVsLmNyZWF0ZVBvc2l0aW9uRnJvbVBhdGgoIHJvb3QsIFsgMSBdICksIDIgKTsKICAgKgkJLy8gdHJhbnNmb3JtZWQgYXJyYXkgaGFzIG9uZSByYW5nZSBmcm9tIFsgNCwgNyBdIHRvIFsgNiwgMCwgMSBdCiAgICoKICAgKgkJdHJhbnNmb3JtZWQgPSByYW5nZS5fZ2V0VHJhbnNmb3JtZWRCeUluc2VydGlvbiggbW9kZWwuY3JlYXRlUG9zaXRpb25Gcm9tUGF0aCggcm9vdCwgWyA0LCAwLCAwIF0gKSwgNCApOwogICAqCQkvLyB0cmFuc2Zvcm1lZCBhcnJheSBoYXMgb25lIHJhbmdlIGZyb20gWyAyLCA3IF0gdG8gWyA0LCAwLCA1IF0KICAgKgogICAqCQl0cmFuc2Zvcm1lZCA9IHJhbmdlLl9nZXRUcmFuc2Zvcm1lZEJ5SW5zZXJ0aW9uKCBtb2RlbC5jcmVhdGVQb3NpdGlvbkZyb21QYXRoKCByb290LCBbIDMsIDIgXSApLCA0ICk7CiAgICoJCS8vIHRyYW5zZm9ybWVkIGFycmF5IGhhcyBvbmUgcmFuZ2UsIHdoaWNoIGlzIGVxdWFsIHRvIG9yaWdpbmFsIHJhbmdlCiAgICoKICAgKgkJdHJhbnNmb3JtZWQgPSByYW5nZS5fZ2V0VHJhbnNmb3JtZWRCeUluc2VydGlvbiggbW9kZWwuY3JlYXRlUG9zaXRpb25Gcm9tUGF0aCggcm9vdCwgWyAzLCAyIF0gKSwgNCwgdHJ1ZSApOwogICAqCQkvLyB0cmFuc2Zvcm1lZCBhcnJheSBoYXMgdHdvIHJhbmdlczogZnJvbSBbIDIsIDcgXSB0byBbIDMsIDIgXSBhbmQgZnJvbSBbIDMsIDYgXSB0byBbIDQsIDAsIDEgXQogICAqCiAgICogQHByb3RlY3RlZAogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0gaW5zZXJ0UG9zaXRpb24gUG9zaXRpb24gd2hlcmUgbm9kZXMgYXJlIGluc2VydGVkLgogICAqIEBwYXJhbSB7TnVtYmVyfSBob3dNYW55IEhvdyBtYW55IG5vZGVzIGFyZSBpbnNlcnRlZC4KICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzcHJlYWRdIEZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIHRoaXMge35SYW5nZSByYW5nZX0gc2hvdWxkIGJlIHNwcmVhZCBpZiBpbnNlcnRpb24KICAgKiB3YXMgaW5zaWRlIHRoZSByYW5nZS4gRGVmYXVsdHMgdG8gYGZhbHNlYC4KICAgKiBAcmV0dXJucyB7QXJyYXkuPG1vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2U+fSBSZXN1bHQgb2YgdGhlIHRyYW5zZm9ybWF0aW9uLgogICAqLwoKCiAgX2dldFRyYW5zZm9ybWVkQnlJbnNlcnRpb24oaW5zZXJ0UG9zaXRpb24sIGhvd01hbnksIHNwcmVhZCA9IGZhbHNlKSB7CiAgICBpZiAoc3ByZWFkICYmIHRoaXMuY29udGFpbnNQb3NpdGlvbihpbnNlcnRQb3NpdGlvbikpIHsKICAgICAgLy8gUmFuZ2UgaGFzIHRvIGJlIHNwcmVhZC4gVGhlIGZpcnN0IHBhcnQgaXMgZnJvbSBvcmlnaW5hbCBzdGFydCB0byB0aGUgc3ByZWFkIHBvaW50LgogICAgICAvLyBUaGUgb3RoZXIgcGFydCBpcyBmcm9tIHNwcmVhZCBwb2ludCB0byB0aGUgb3JpZ2luYWwgZW5kLCBidXQgdHJhbnNmb3JtZWQgYnkKICAgICAgLy8gaW5zZXJ0aW9uIHRvIHJlZmxlY3QgaW5zZXJ0aW9uIGNoYW5nZXMuCiAgICAgIHJldHVybiBbbmV3IFJhbmdlKHRoaXMuc3RhcnQsIGluc2VydFBvc2l0aW9uKSwgbmV3IFJhbmdlKGluc2VydFBvc2l0aW9uLmdldFNoaWZ0ZWRCeShob3dNYW55KSwgdGhpcy5lbmQuX2dldFRyYW5zZm9ybWVkQnlJbnNlcnRpb24oaW5zZXJ0UG9zaXRpb24sIGhvd01hbnkpKV07CiAgICB9IGVsc2UgewogICAgICBjb25zdCByYW5nZSA9IG5ldyBSYW5nZSh0aGlzLnN0YXJ0LCB0aGlzLmVuZCk7CiAgICAgIHJhbmdlLnN0YXJ0ID0gcmFuZ2Uuc3RhcnQuX2dldFRyYW5zZm9ybWVkQnlJbnNlcnRpb24oaW5zZXJ0UG9zaXRpb24sIGhvd01hbnkpOwogICAgICByYW5nZS5lbmQgPSByYW5nZS5lbmQuX2dldFRyYW5zZm9ybWVkQnlJbnNlcnRpb24oaW5zZXJ0UG9zaXRpb24sIGhvd01hbnkpOwogICAgICByZXR1cm4gW3JhbmdlXTsKICAgIH0KICB9CiAgLyoqCiAgICogUmV0dXJucyBhbiBhcnJheSBjb250YWluaW5nIHtAbGluayB+UmFuZ2UgcmFuZ2VzfSB0aGF0IGFyZSBhIHJlc3VsdCBvZiB0cmFuc2Zvcm1pbmcgdGhpcwogICAqIHtAbGluayB+UmFuZ2UgcmFuZ2V9IGJ5IG1vdmluZyBgaG93TWFueWAgbm9kZXMgZnJvbSBgc291cmNlUG9zaXRpb25gIHRvIGB0YXJnZXRQb3NpdGlvbmAuCiAgICoKICAgKiBAcHJvdGVjdGVkCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufSBzb3VyY2VQb3NpdGlvbiBQb3NpdGlvbiBmcm9tIHdoaWNoIG5vZGVzIGFyZSBtb3ZlZC4KICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259IHRhcmdldFBvc2l0aW9uIFBvc2l0aW9uIHRvIHdoZXJlIG5vZGVzIGFyZSBtb3ZlZC4KICAgKiBAcGFyYW0ge051bWJlcn0gaG93TWFueSBIb3cgbWFueSBub2RlcyBhcmUgbW92ZWQuCiAgICogQHBhcmFtIHtCb29sZWFufSBbc3ByZWFkPWZhbHNlXSBXaGV0aGVyIHRoZSByYW5nZSBzaG91bGQgYmUgc3ByZWFkIGlmIHRoZSBtb3ZlIHBvaW50cyBpbnNpZGUgdGhlIHJhbmdlLgogICAqIEByZXR1cm5zIHtBcnJheS48bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZT59IFJlc3VsdCBvZiB0aGUgdHJhbnNmb3JtYXRpb24uCiAgICovCgoKICBfZ2V0VHJhbnNmb3JtZWRCeU1vdmUoc291cmNlUG9zaXRpb24sIHRhcmdldFBvc2l0aW9uLCBob3dNYW55LCBzcHJlYWQgPSBmYWxzZSkgewogICAgLy8gU3BlY2lhbCBjYXNlIGZvciB0cmFuc2Zvcm1pbmcgYSBjb2xsYXBzZWQgcmFuZ2UuIEp1c3QgdHJhbnNmb3JtIGl0IGxpa2UgYSBwb3NpdGlvbi4KICAgIGlmICh0aGlzLmlzQ29sbGFwc2VkKSB7CiAgICAgIGNvbnN0IG5ld1BvcyA9IHRoaXMuc3RhcnQuX2dldFRyYW5zZm9ybWVkQnlNb3ZlKHNvdXJjZVBvc2l0aW9uLCB0YXJnZXRQb3NpdGlvbiwgaG93TWFueSk7CgogICAgICByZXR1cm4gW25ldyBSYW5nZShuZXdQb3MpXTsKICAgIH0gLy8gU3BlY2lhbCBjYXNlIGZvciB0cmFuc2Zvcm1hdGlvbiB3aGVuIGEgcGFydCBvZiB0aGUgcmFuZ2UgaXMgbW92ZWQgdG93YXJkcyB0aGUgcmFuZ2UuCiAgICAvLwogICAgLy8gRXhhbXBsZXM6CiAgICAvLwogICAgLy8gPGRpdj48cD5hYjwvcD48cD5jW2Q8L3A+PC9kaXY+PHA+ZV1mPC9wPiAtLT4gPGRpdj48cD5hYjwvcD48L2Rpdj48cD5jW2Q8L3A+PHA+ZV1mPC9wPgogICAgLy8gPHA+ZVtmPC9wPjxkaXY+PHA+YV1iPC9wPjxwPmNkPC9wPjwvZGl2PiAtLT4gPHA+ZVtmPC9wPjxwPmFdYjwvcD48ZGl2PjxwPmNkPC9wPjwvZGl2PgogICAgLy8KICAgIC8vIFdpdGhvdXQgdGhpcyBzcGVjaWFsIGNvbmRpdGlvbiwgdGhlIGRlZmF1bHQgYWxnb3JpdGhtIGxlYXZlcyBhbiAiYXJ0aWZhY3QiIHJhbmdlIGZyb20gb25lIG9mIGBkaWZmZXJlbmNlU2V0YCBwYXJ0czoKICAgIC8vCiAgICAvLyA8ZGl2PjxwPmFiPC9wPjxwPmNbZDwvcD48L2Rpdj48cD5lXWY8L3A+IC0tPiA8ZGl2PjxwPmFiPC9wPns8L2Rpdj59PHA+Y1tkPC9wPjxwPmVdZjwvcD4KICAgIC8vCiAgICAvLyBUaGlzIHNwZWNpYWwgY2FzZSBpcyBhcHBsaWVkIG9ubHkgaWYgdGhlIHJhbmdlIGlzIHRvIGJlIGtlcHQgdG9nZXRoZXIgKG5vdCBzcHJlYWQpLgoKCiAgICBjb25zdCBtb3ZlUmFuZ2UgPSBSYW5nZS5fY3JlYXRlRnJvbVBvc2l0aW9uQW5kU2hpZnQoc291cmNlUG9zaXRpb24sIGhvd01hbnkpOwoKICAgIGNvbnN0IGluc2VydFBvc2l0aW9uID0gdGFyZ2V0UG9zaXRpb24uX2dldFRyYW5zZm9ybWVkQnlEZWxldGlvbihzb3VyY2VQb3NpdGlvbiwgaG93TWFueSk7CgogICAgaWYgKHRoaXMuY29udGFpbnNQb3NpdGlvbih0YXJnZXRQb3NpdGlvbikgJiYgIXNwcmVhZCkgewogICAgICBpZiAobW92ZVJhbmdlLmNvbnRhaW5zUG9zaXRpb24odGhpcy5zdGFydCkgfHwgbW92ZVJhbmdlLmNvbnRhaW5zUG9zaXRpb24odGhpcy5lbmQpKSB7CiAgICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLnN0YXJ0Ll9nZXRUcmFuc2Zvcm1lZEJ5TW92ZShzb3VyY2VQb3NpdGlvbiwgdGFyZ2V0UG9zaXRpb24sIGhvd01hbnkpOwoKICAgICAgICBjb25zdCBlbmQgPSB0aGlzLmVuZC5fZ2V0VHJhbnNmb3JtZWRCeU1vdmUoc291cmNlUG9zaXRpb24sIHRhcmdldFBvc2l0aW9uLCBob3dNYW55KTsKCiAgICAgICAgcmV0dXJuIFtuZXcgUmFuZ2Uoc3RhcnQsIGVuZCldOwogICAgICB9CiAgICB9IC8vIERlZmF1bHQgYWxnb3JpdGhtLgoKCiAgICBsZXQgcmVzdWx0OwogICAgY29uc3QgZGlmZmVyZW5jZVNldCA9IHRoaXMuZ2V0RGlmZmVyZW5jZShtb3ZlUmFuZ2UpOwogICAgbGV0IGRpZmZlcmVuY2UgPSBudWxsOwogICAgY29uc3QgY29tbW9uID0gdGhpcy5nZXRJbnRlcnNlY3Rpb24obW92ZVJhbmdlKTsKCiAgICBpZiAoZGlmZmVyZW5jZVNldC5sZW5ndGggPT0gMSkgewogICAgICAvLyBgbW92ZVJhbmdlYCBhbmQgdGhpcyByYW5nZSBtYXkgaW50ZXJzZWN0IGJ1dCBtYXkgYmUgc2VwYXJhdGUuCiAgICAgIGRpZmZlcmVuY2UgPSBuZXcgUmFuZ2UoZGlmZmVyZW5jZVNldFswXS5zdGFydC5fZ2V0VHJhbnNmb3JtZWRCeURlbGV0aW9uKHNvdXJjZVBvc2l0aW9uLCBob3dNYW55KSwgZGlmZmVyZW5jZVNldFswXS5lbmQuX2dldFRyYW5zZm9ybWVkQnlEZWxldGlvbihzb3VyY2VQb3NpdGlvbiwgaG93TWFueSkpOwogICAgfSBlbHNlIGlmIChkaWZmZXJlbmNlU2V0Lmxlbmd0aCA9PSAyKSB7CiAgICAgIC8vIGBtb3ZlUmFuZ2VgIGlzIGluc2lkZSB0aGlzIHJhbmdlLgogICAgICBkaWZmZXJlbmNlID0gbmV3IFJhbmdlKHRoaXMuc3RhcnQsIHRoaXMuZW5kLl9nZXRUcmFuc2Zvcm1lZEJ5RGVsZXRpb24oc291cmNlUG9zaXRpb24sIGhvd01hbnkpKTsKICAgIH0gLy8gZWxzZSwgYG1vdmVSYW5nZWAgY29udGFpbnMgdGhpcyByYW5nZS4KCgogICAgaWYgKGRpZmZlcmVuY2UpIHsKICAgICAgcmVzdWx0ID0gZGlmZmVyZW5jZS5fZ2V0VHJhbnNmb3JtZWRCeUluc2VydGlvbihpbnNlcnRQb3NpdGlvbiwgaG93TWFueSwgY29tbW9uICE9PSBudWxsIHx8IHNwcmVhZCk7CiAgICB9IGVsc2UgewogICAgICByZXN1bHQgPSBbXTsKICAgIH0KCiAgICBpZiAoY29tbW9uKSB7CiAgICAgIGNvbnN0IHRyYW5zZm9ybWVkQ29tbW9uID0gbmV3IFJhbmdlKGNvbW1vbi5zdGFydC5fZ2V0Q29tYmluZWQobW92ZVJhbmdlLnN0YXJ0LCBpbnNlcnRQb3NpdGlvbiksIGNvbW1vbi5lbmQuX2dldENvbWJpbmVkKG1vdmVSYW5nZS5zdGFydCwgaW5zZXJ0UG9zaXRpb24pKTsKCiAgICAgIGlmIChyZXN1bHQubGVuZ3RoID09IDIpIHsKICAgICAgICByZXN1bHQuc3BsaWNlKDEsIDAsIHRyYW5zZm9ybWVkQ29tbW9uKTsKICAgICAgfSBlbHNlIHsKICAgICAgICByZXN1bHQucHVzaCh0cmFuc2Zvcm1lZENvbW1vbik7CiAgICAgIH0KICAgIH0KCiAgICByZXR1cm4gcmVzdWx0OwogIH0KICAvKioKICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGlzIHJhbmdlIHRoYXQgaXMgdHJhbnNmb3JtZWQgYnkgZGVsZXRpb24gb2YgYGhvd01hbnlgIG5vZGVzIGZyb20gYGRlbGV0ZVBvc2l0aW9uYC4KICAgKgogICAqIElmIHRoZSBkZWxldGVkIHJhbmdlIGlzIGludGVyc2VjdGluZyB3aXRoIHRoZSB0cmFuc2Zvcm1lZCByYW5nZSwgdGhlIHRyYW5zZm9ybWVkIHJhbmdlIHdpbGwgYmUgc2hyYW5rLgogICAqCiAgICogSWYgdGhlIGRlbGV0ZWQgcmFuZ2UgY29udGFpbnMgdHJhbnNmb3JtZWQgcmFuZ2UsIGBudWxsYCB3aWxsIGJlIHJldHVybmVkLgogICAqCiAgICogQHByb3RlY3RlZAogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0gZGVsZXRpb25Qb3NpdGlvbiBQb3NpdGlvbiBmcm9tIHdoaWNoIG5vZGVzIGFyZSByZW1vdmVkLgogICAqIEBwYXJhbSB7TnVtYmVyfSBob3dNYW55IEhvdyBtYW55IG5vZGVzIGFyZSByZW1vdmVkLgogICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlfG51bGx9IFJlc3VsdCBvZiB0aGUgdHJhbnNmb3JtYXRpb24uCiAgICovCgoKICBfZ2V0VHJhbnNmb3JtZWRCeURlbGV0aW9uKGRlbGV0ZVBvc2l0aW9uLCBob3dNYW55KSB7CiAgICBsZXQgbmV3U3RhcnQgPSB0aGlzLnN0YXJ0Ll9nZXRUcmFuc2Zvcm1lZEJ5RGVsZXRpb24oZGVsZXRlUG9zaXRpb24sIGhvd01hbnkpOwoKICAgIGxldCBuZXdFbmQgPSB0aGlzLmVuZC5fZ2V0VHJhbnNmb3JtZWRCeURlbGV0aW9uKGRlbGV0ZVBvc2l0aW9uLCBob3dNYW55KTsKCiAgICBpZiAobmV3U3RhcnQgPT0gbnVsbCAmJiBuZXdFbmQgPT0gbnVsbCkgewogICAgICByZXR1cm4gbnVsbDsKICAgIH0KCiAgICBpZiAobmV3U3RhcnQgPT0gbnVsbCkgewogICAgICBuZXdTdGFydCA9IGRlbGV0ZVBvc2l0aW9uOwogICAgfQoKICAgIGlmIChuZXdFbmQgPT0gbnVsbCkgewogICAgICBuZXdFbmQgPSBkZWxldGVQb3NpdGlvbjsKICAgIH0KCiAgICByZXR1cm4gbmV3IFJhbmdlKG5ld1N0YXJ0LCBuZXdFbmQpOwogIH0KICAvKioKICAgKiBDcmVhdGVzIGEgbmV3IHJhbmdlLCBzcHJlYWRpbmcgZnJvbSBzcGVjaWZpZWQge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb24gcG9zaXRpb259IHRvIGEgcG9zaXRpb24gbW92ZWQgYnkKICAgKiBnaXZlbiBgc2hpZnRgLiBJZiBgc2hpZnRgIGlzIGEgbmVnYXRpdmUgdmFsdWUsIHNoaWZ0ZWQgcG9zaXRpb24gaXMgdHJlYXRlZCBhcyB0aGUgYmVnaW5uaW5nIG9mIHRoZSByYW5nZS4KICAgKgogICAqIEBwcm90ZWN0ZWQKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259IHBvc2l0aW9uIEJlZ2lubmluZyBvZiB0aGUgcmFuZ2UuCiAgICogQHBhcmFtIHtOdW1iZXJ9IHNoaWZ0IEhvdyBsb25nIHRoZSByYW5nZSBzaG91bGQgYmUuCiAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2V9CiAgICovCgoKICBzdGF0aWMgX2NyZWF0ZUZyb21Qb3NpdGlvbkFuZFNoaWZ0KHBvc2l0aW9uLCBzaGlmdCkgewogICAgY29uc3Qgc3RhcnQgPSBwb3NpdGlvbjsKICAgIGNvbnN0IGVuZCA9IHBvc2l0aW9uLmdldFNoaWZ0ZWRCeShzaGlmdCk7CiAgICByZXR1cm4gc2hpZnQgPiAwID8gbmV3IHRoaXMoc3RhcnQsIGVuZCkgOiBuZXcgdGhpcyhlbmQsIHN0YXJ0KTsKICB9CiAgLyoqCiAgICogQ3JlYXRlcyBhIHJhbmdlIGluc2lkZSBhbiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnQgZWxlbWVudH0gd2hpY2ggc3RhcnRzIGJlZm9yZSB0aGUgZmlyc3QgY2hpbGQgb2YKICAgKiB0aGF0IGVsZW1lbnQgYW5kIGVuZHMgYWZ0ZXIgdGhlIGxhc3QgY2hpbGQgb2YgdGhhdCBlbGVtZW50LgogICAqCiAgICogQHByb3RlY3RlZAogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB3aGljaCBpcyBhIHBhcmVudCBmb3IgdGhlIHJhbmdlLgogICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlfQogICAqLwoKCiAgc3RhdGljIF9jcmVhdGVJbihlbGVtZW50KSB7CiAgICByZXR1cm4gbmV3IHRoaXMoUG9zaXRpb24uX2NyZWF0ZUF0KGVsZW1lbnQsIDApLCBQb3NpdGlvbi5fY3JlYXRlQXQoZWxlbWVudCwgZWxlbWVudC5tYXhPZmZzZXQpKTsKICB9CiAgLyoqCiAgICogQ3JlYXRlcyBhIHJhbmdlIHRoYXQgc3RhcnRzIGJlZm9yZSBnaXZlbiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9pdGVtfkl0ZW0gbW9kZWwgaXRlbX0gYW5kIGVuZHMgYWZ0ZXIgaXQuCiAgICoKICAgKiBAcHJvdGVjdGVkCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbX0gaXRlbQogICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlfQogICAqLwoKCiAgc3RhdGljIF9jcmVhdGVPbihpdGVtKSB7CiAgICByZXR1cm4gdGhpcy5fY3JlYXRlRnJvbVBvc2l0aW9uQW5kU2hpZnQoUG9zaXRpb24uX2NyZWF0ZUJlZm9yZShpdGVtKSwgaXRlbS5vZmZzZXRTaXplKTsKICB9CiAgLyoqCiAgICogQ29tYmluZXMgYWxsIHJhbmdlcyBmcm9tIHRoZSBwYXNzZWQgYXJyYXkgaW50byBhIG9uZSByYW5nZS4gQXQgbGVhc3Qgb25lIHJhbmdlIGhhcyB0byBiZSBwYXNzZWQuCiAgICogUGFzc2VkIHJhbmdlcyBtdXN0IG5vdCBoYXZlIGNvbW1vbiBwYXJ0cy4KICAgKgogICAqIFRoZSBmaXJzdCByYW5nZSBmcm9tIHRoZSBhcnJheSBpcyBhIHJlZmVyZW5jZSByYW5nZS4gSWYgb3RoZXIgcmFuZ2VzIHN0YXJ0IG9yIGVuZCBvbiB0aGUgZXhhY3RseSBzYW1lIHBvc2l0aW9uIHdoZXJlCiAgICogdGhlIHJlZmVyZW5jZSByYW5nZSwgdGhleSBnZXQgY29tYmluZWQgaW50byBvbmUgcmFuZ2UuCiAgICoKICAgKgkJWyAgXVtdICBbICAgIF1bIF1bICAgICAgICAgICAgIF1bIF1bXSAgWyAgXSAgLy8gUGFzc2VkIHJhbmdlcywgc2hvd24gc29ydGVkCiAgICoJCVsgICAgXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSByZXN1bHQgb2YgdGhlIGZ1bmN0aW9uIGlmIHRoZSBmaXJzdCByYW5nZSB3YXMgYSByZWZlcmVuY2UgcmFuZ2UuCiAgICoJICAgICAgICAgICAgWyAgICAgICAgICAgICAgICAgICAgICAgICAgIF0gICAgICAgIC8vIFRoZSByZXN1bHQgb2YgdGhlIGZ1bmN0aW9uIGlmIHRoZSB0aGlyZC10by1zZXZlbnRoIHJhbmdlIHdhcyBhIHJlZmVyZW5jZSByYW5nZS4KICAgKgkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWyAgXSAgLy8gVGhlIHJlc3VsdCBvZiB0aGUgZnVuY3Rpb24gaWYgdGhlIGxhc3QgcmFuZ2Ugd2FzIGEgcmVmZXJlbmNlIHJhbmdlLgogICAqCiAgICogQHBhcmFtIHtBcnJheS48bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZT59IHJhbmdlcyBSYW5nZXMgdG8gY29tYmluZS4KICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZX0gQ29tYmluZWQgcmFuZ2UuCiAgICovCgoKICBzdGF0aWMgX2NyZWF0ZUZyb21SYW5nZXMocmFuZ2VzKSB7CiAgICBpZiAocmFuZ2VzLmxlbmd0aCA9PT0gMCkgewogICAgICAvKioKICAgICAgICogQXQgbGVhc3Qgb25lIHJhbmdlIGhhcyB0byBiZSBwYXNzZWQgdG8KICAgICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2UuX2NyZWF0ZUZyb21SYW5nZXMgYFJhbmdlLl9jcmVhdGVGcm9tUmFuZ2VzKClgfS4KICAgICAgICoKICAgICAgICogQGVycm9yIHJhbmdlLWNyZWF0ZS1mcm9tLXJhbmdlcy1lbXB0eS1hcnJheQogICAgICAgKi8KICAgICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ3JhbmdlLWNyZWF0ZS1mcm9tLXJhbmdlcy1lbXB0eS1hcnJheTogQXQgbGVhc3Qgb25lIHJhbmdlIGhhcyB0byBiZSBwYXNzZWQuJywgbnVsbCk7CiAgICB9IGVsc2UgaWYgKHJhbmdlcy5sZW5ndGggPT0gMSkgewogICAgICByZXR1cm4gcmFuZ2VzWzBdLmNsb25lKCk7CiAgICB9IC8vIDEuIFNldCB0aGUgZmlyc3QgcmFuZ2UgaW4gYHJhbmdlc2AgYXJyYXkgYXMgYSByZWZlcmVuY2UgcmFuZ2UuCiAgICAvLyBJZiB3ZSBhcmUgZ29pbmcgdG8gcmV0dXJuIGp1c3QgYSBvbmUgcmFuZ2UsIG9uZSBvZiB0aGUgcmFuZ2VzIG5lZWQgdG8gYmUgdGhlIHJlZmVyZW5jZSBvbmUuCiAgICAvLyBPdGhlciByYW5nZXMgd2lsbCBiZSBzdHVjayB0byB0aGF0IHJhbmdlLCBpZiBwb3NzaWJsZS4KCgogICAgY29uc3QgcmVmID0gcmFuZ2VzWzBdOyAvLyAyLiBTb3J0IGFsbCB0aGUgcmFuZ2VzIHNvIGl0J3MgZWFzaWVyIHRvIHByb2Nlc3MgdGhlbS4KCiAgICByYW5nZXMuc29ydCgoYSwgYikgPT4gewogICAgICByZXR1cm4gYS5zdGFydC5pc0FmdGVyKGIuc3RhcnQpID8gMSA6IC0xOwogICAgfSk7IC8vIDMuIENoZWNrIGF0IHdoaWNoIGluZGV4IHRoZSByZWZlcmVuY2UgcmFuZ2UgaXMgbm93LgoKICAgIGNvbnN0IHJlZkluZGV4ID0gcmFuZ2VzLmluZGV4T2YocmVmKTsgLy8gNC4gQXQgdGhpcyBtb21lbnQgd2UgZG9uJ3QgbmVlZCB0aGUgb3JpZ2luYWwgcmFuZ2UuCiAgICAvLyBXZSBhcmUgZ29pbmcgdG8gbW9kaWZ5IHRoZSByZXN1bHQgYW5kIHdlIG5lZWQgdG8gcmV0dXJuIGEgbmV3IGluc3RhbmNlIG9mIFJhbmdlLgogICAgLy8gV2UgaGF2ZSB0byBjcmVhdGUgYSBjb3B5IG9mIHRoZSByZWZlcmVuY2UgcmFuZ2UuCgogICAgY29uc3QgcmVzdWx0ID0gbmV3IHRoaXMocmVmLnN0YXJ0LCByZWYuZW5kKTsgLy8gNS4gUmFuZ2VzIHNob3VsZCBiZSBjaGVja2VkIGFuZCBnbHVlZCBzdGFydGluZyBmcm9tIHRoZSByYW5nZSB0aGF0IGlzIGNsb3Nlc3QgdG8gdGhlIHJlZmVyZW5jZSByYW5nZS4KICAgIC8vIFNpbmNlIHJhbmdlcyBhcmUgc29ydGVkLCBzdGFydCB3aXRoIHRoZSByYW5nZSB3aXRoIGluZGV4IHRoYXQgaXMgY2xvc2VzdCB0byByZWZlcmVuY2UgcmFuZ2UgaW5kZXguCgogICAgaWYgKHJlZkluZGV4ID4gMCkgewogICAgICBmb3IgKGxldCBpID0gcmVmSW5kZXggLSAxOyB0cnVlOyBpKyspIHsKICAgICAgICBpZiAocmFuZ2VzW2ldLmVuZC5pc0VxdWFsKHJlc3VsdC5zdGFydCkpIHsKICAgICAgICAgIHJlc3VsdC5zdGFydCA9IFBvc2l0aW9uLl9jcmVhdGVBdChyYW5nZXNbaV0uc3RhcnQpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAvLyBJZiByYW5nZXMgYXJlIG5vdCBzdGFydGluZy9lbmRpbmcgYXQgdGhlIHNhbWUgcG9zaXRpb24gdGhlcmUgaXMgbm8gcG9pbnQgaW4gbG9va2luZyBmdXJ0aGVyLgogICAgICAgICAgYnJlYWs7CiAgICAgICAgfQogICAgICB9CiAgICB9IC8vIDYuIFJhbmdlcyBzaG91bGQgYmUgY2hlY2tlZCBhbmQgZ2x1ZWQgc3RhcnRpbmcgZnJvbSB0aGUgcmFuZ2UgdGhhdCBpcyBjbG9zZXN0IHRvIHRoZSByZWZlcmVuY2UgcmFuZ2UuCiAgICAvLyBTaW5jZSByYW5nZXMgYXJlIHNvcnRlZCwgc3RhcnQgd2l0aCB0aGUgcmFuZ2Ugd2l0aCBpbmRleCB0aGF0IGlzIGNsb3Nlc3QgdG8gcmVmZXJlbmNlIHJhbmdlIGluZGV4LgoKCiAgICBmb3IgKGxldCBpID0gcmVmSW5kZXggKyAxOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7CiAgICAgIGlmIChyYW5nZXNbaV0uc3RhcnQuaXNFcXVhbChyZXN1bHQuZW5kKSkgewogICAgICAgIHJlc3VsdC5lbmQgPSBQb3NpdGlvbi5fY3JlYXRlQXQocmFuZ2VzW2ldLmVuZCk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgLy8gSWYgcmFuZ2VzIGFyZSBub3Qgc3RhcnRpbmcvZW5kaW5nIGF0IHRoZSBzYW1lIHBvc2l0aW9uIHRoZXJlIGlzIG5vIHBvaW50IGluIGxvb2tpbmcgZnVydGhlci4KICAgICAgICBicmVhazsKICAgICAgfQogICAgfQoKICAgIHJldHVybiByZXN1bHQ7CiAgfQogIC8qKgogICAqIENyZWF0ZXMgYSBgUmFuZ2VgIGluc3RhbmNlIGZyb20gZ2l2ZW4gcGxhaW4gb2JqZWN0IChpLmUuIHBhcnNlZCBKU09OIHN0cmluZykuCiAgICoKICAgKiBAcGFyYW0ge09iamVjdH0ganNvbiBQbGFpbiBvYmplY3QgdG8gYmUgY29udmVydGVkIHRvIGBSYW5nZWAuCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50fkRvY3VtZW50fSBkb2MgRG9jdW1lbnQgb2JqZWN0IHRoYXQgd2lsbCBiZSByYW5nZSBvd25lci4KICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR9IGBSYW5nZWAgaW5zdGFuY2UgY3JlYXRlZCB1c2luZyBnaXZlbiBwbGFpbiBvYmplY3QuCiAgICovCgoKICBzdGF0aWMgZnJvbUpTT04oanNvbiwgZG9jKSB7CiAgICByZXR1cm4gbmV3IHRoaXMoUG9zaXRpb24uZnJvbUpTT04oanNvbi5zdGFydCwgZG9jKSwgUG9zaXRpb24uZnJvbUpTT04oanNvbi5lbmQsIGRvYykpOwogIH0gLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLyB0b1N0cmluZygpIHsKICAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vIAlyZXR1cm4gYCR7IHRoaXMucm9vdCB9IFsgJHsgdGhpcy5zdGFydC5wYXRoLmpvaW4oICcsICcgKSB9IF0gLSBbICR7IHRoaXMuZW5kLnBhdGguam9pbiggJywgJyApIH0gXWA7CiAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLyB9CiAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLyBsb2coKSB7CiAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLyAJY29uc29sZS5sb2coICdNb2RlbFBvc2l0aW9uOiAnICsgdGhpcyApOwogIC8vIEBpZiBDS19ERUJVR19FTkdJTkUgLy8gfQoKCn0="},{"version":3,"sources":["/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-engine/src/model/range.js"],"names":["Position","TreeWalker","CKEditorError","compareArrays","Range","constructor","start","end","_createAt","stickiness","isCollapsed","Symbol","iterator","boundaries","ignoreElementEnd","isEqual","isFlat","startParentPath","getParentPath","endParentPath","root","containsPosition","position","isAfter","isBefore","containsRange","otherRange","loose","containsStart","containsEnd","containsItem","item","pos","_createBefore","is","type","isIntersecting","getDifference","ranges","push","getIntersection","commonRangeStart","commonRangeEnd","getMinimalFlatRanges","diffAt","getCommonPath","length","posParent","parent","path","howMany","maxOffset","offset","getShiftedBy","slice","getWalker","options","getItems","treeWalker","value","getPositions","nextPosition","getTransformedByOperation","operation","_getTransformedByInsertOperation","_getTransformedByMoveOperation","_getTransformedBySplitOperation","_getTransformedByMergeOperation","getTransformedByOperations","operations","i","result","splice","range","j","next","getCommonAncestor","toJSON","clone","spread","_getTransformedByInsertion","sourcePosition","targetPosition","_getTransformedByMove","insertionPosition","deletionPosition","insertPosition","newPos","moveRange","_createFromPositionAndShift","_getTransformedByDeletion","differenceSet","difference","common","transformedCommon","_getCombined","deletePosition","newStart","newEnd","shift","_createIn","element","_createOn","offsetSize","_createFromRanges","ref","sort","a","b","refIndex","indexOf","fromJSON","json","doc"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/range\n */\n\nimport Position from './position';\nimport TreeWalker from './treewalker';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport compareArrays from '@ckeditor/ckeditor5-utils/src/comparearrays';\n\n/**\n * Represents a range in the model tree.\n *\n * A range is defined by its {@link module:engine/model/range~Range#start} and {@link module:engine/model/range~Range#end}\n * positions.\n *\n * You can create range instances via its constructor or the `createRange*()` factory methods of\n * {@link module:engine/model/model~Model} and {@link module:engine/model/writer~Writer}.\n */\nexport default class Range {\n\t/**\n\t * Creates a range spanning from `start` position to `end` position.\n\t *\n\t * @param {module:engine/model/position~Position} start Start position.\n\t * @param {module:engine/model/position~Position} [end] End position. If not set, range will be collapsed at `start` position.\n\t */\n\tconstructor( start, end = null ) {\n\t\t/**\n\t\t * Start position.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/position~Position}\n\t\t */\n\t\tthis.start = Position._createAt( start );\n\n\t\t/**\n\t\t * End position.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/position~Position}\n\t\t */\n\t\tthis.end = end ? Position._createAt( end ) : Position._createAt( start );\n\n\t\t// If the range is collapsed, treat in a similar way as a position and set its boundaries stickiness to 'toNone'.\n\t\t// In other case, make the boundaries stick to the \"inside\" of the range.\n\t\tthis.start.stickiness = this.isCollapsed ? 'toNone' : 'toNext';\n\t\tthis.end.stickiness = this.isCollapsed ? 'toNone' : 'toPrevious';\n\t}\n\n\t/**\n\t * Iterable interface.\n\t *\n\t * Iterates over all {@link module:engine/model/item~Item items} that are in this range and returns\n\t * them together with additional information like length or {@link module:engine/model/position~Position positions},\n\t * grouped as {@link module:engine/model/treewalker~TreeWalkerValue}.\n\t * It iterates over all {@link module:engine/model/textproxy~TextProxy text contents} that are inside the range\n\t * and all the {@link module:engine/model/element~Element}s that are entered into when iterating over this range.\n\t *\n\t * This iterator uses {@link module:engine/model/treewalker~TreeWalker} with `boundaries` set to this range\n\t * and `ignoreElementEnd` option set to `true`.\n\t *\n\t * @returns {Iterable.<module:engine/model/treewalker~TreeWalkerValue>}\n\t */\n\t* [ Symbol.iterator ]() {\n\t\tyield* new TreeWalker( { boundaries: this, ignoreElementEnd: true } );\n\t}\n\n\t/**\n\t * Returns whether the range is collapsed, that is if {@link #start} and\n\t * {@link #end} positions are equal.\n\t *\n\t * @type {Boolean}\n\t */\n\tget isCollapsed() {\n\t\treturn this.start.isEqual( this.end );\n\t}\n\n\t/**\n\t * Returns whether this range is flat, that is if {@link #start} position and\n\t * {@link #end} position are in the same {@link module:engine/model/position~Position#parent}.\n\t *\n\t * @type {Boolean}\n\t */\n\tget isFlat() {\n\t\tconst startParentPath = this.start.getParentPath();\n\t\tconst endParentPath = this.end.getParentPath();\n\n\t\treturn compareArrays( startParentPath, endParentPath ) == 'same';\n\t}\n\n\t/**\n\t * Range root element.\n\t *\n\t * @type {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment}\n\t */\n\tget root() {\n\t\treturn this.start.root;\n\t}\n\n\t/**\n\t * Checks whether this range contains given {@link module:engine/model/position~Position position}.\n\t *\n\t * @param {module:engine/model/position~Position} position Position to check.\n\t * @returns {Boolean} `true` if given {@link module:engine/model/position~Position position} is contained\n\t * in this range,`false` otherwise.\n\t */\n\tcontainsPosition( position ) {\n\t\treturn position.isAfter( this.start ) && position.isBefore( this.end );\n\t}\n\n\t/**\n\t * Checks whether this range contains given {@link ~Range range}.\n\t *\n\t * @param {module:engine/model/range~Range} otherRange Range to check.\n\t * @param {Boolean} [loose=false] Whether the check is loose or strict. If the check is strict (`false`), compared range cannot\n\t * start or end at the same position as this range boundaries. If the check is loose (`true`), compared range can start, end or\n\t * even be equal to this range. Note that collapsed ranges are always compared in strict mode.\n\t * @returns {Boolean} `true` if given {@link ~Range range} boundaries are contained by this range, `false` otherwise.\n\t */\n\tcontainsRange( otherRange, loose = false ) {\n\t\tif ( otherRange.isCollapsed ) {\n\t\t\tloose = false;\n\t\t}\n\n\t\tconst containsStart = this.containsPosition( otherRange.start ) || ( loose && this.start.isEqual( otherRange.start ) );\n\t\tconst containsEnd = this.containsPosition( otherRange.end ) || ( loose && this.end.isEqual( otherRange.end ) );\n\n\t\treturn containsStart && containsEnd;\n\t}\n\n\t/**\n\t * Checks whether given {@link module:engine/model/item~Item} is inside this range.\n\t *\n\t * @param {module:engine/model/item~Item} item Model item to check.\n\t */\n\tcontainsItem( item ) {\n\t\tconst pos = Position._createBefore( item );\n\n\t\treturn this.containsPosition( pos ) || this.start.isEqual( pos );\n\t}\n\n\t/**\n\t * Checks whether this object is of the given.\n\t *\n\t *\t\trange.is( 'range' ); // -> true\n\t *\t\trange.is( 'model:range' ); // -> true\n\t *\n\t *\t\trange.is( 'view:range' ); // -> false\n\t *\t\trange.is( 'documentSelection' ); // -> false\n\t *\n\t * {@link module:engine/model/node~Node#is Check the entire list of model objects} which implement the `is()` method.\n\t *\n\t * @param {String} type\n\t * @returns {Boolean}\n\t */\n\tis( type ) {\n\t\treturn type == 'range' || type == 'model:range';\n\t}\n\n\t/**\n\t * Two ranges are equal if their {@link #start} and {@link #end} positions are equal.\n\t *\n\t * @param {module:engine/model/range~Range} otherRange Range to compare with.\n\t * @returns {Boolean} `true` if ranges are equal, `false` otherwise.\n\t */\n\tisEqual( otherRange ) {\n\t\treturn this.start.isEqual( otherRange.start ) && this.end.isEqual( otherRange.end );\n\t}\n\n\t/**\n\t * Checks and returns whether this range intersects with given range.\n\t *\n\t * @param {module:engine/model/range~Range} otherRange Range to compare with.\n\t * @returns {Boolean} `true` if ranges intersect, `false` otherwise.\n\t */\n\tisIntersecting( otherRange ) {\n\t\treturn this.start.isBefore( otherRange.end ) && this.end.isAfter( otherRange.start );\n\t}\n\n\t/**\n\t * Computes which part(s) of this {@link ~Range range} is not a part of given {@link ~Range range}.\n\t * Returned array contains zero, one or two {@link ~Range ranges}.\n\t *\n\t * Examples:\n\t *\n\t *\t\tlet range = model.createRange(\n\t *\t\t\tmodel.createPositionFromPath( root, [ 2, 7 ] ),\n\t *\t\t\tmodel.createPositionFromPath( root, [ 4, 0, 1 ] )\n\t *\t\t);\n\t *\t\tlet otherRange = model.createRange( model.createPositionFromPath( root, [ 1 ] ), model.createPositionFromPath( root, [ 5 ] ) );\n\t *\t\tlet transformed = range.getDifference( otherRange );\n\t *\t\t// transformed array has no ranges because `otherRange` contains `range`\n\t *\n\t *\t\totherRange = model.createRange( model.createPositionFromPath( root, [ 1 ] ), model.createPositionFromPath( root, [ 3 ] ) );\n\t *\t\ttransformed = range.getDifference( otherRange );\n\t *\t\t// transformed array has one range: from [ 3 ] to [ 4, 0, 1 ]\n\t *\n\t *\t\totherRange = model.createRange( model.createPositionFromPath( root, [ 3 ] ), model.createPositionFromPath( root, [ 4 ] ) );\n\t *\t\ttransformed = range.getDifference( otherRange );\n\t *\t\t// transformed array has two ranges: from [ 2, 7 ] to [ 3 ] and from [ 4 ] to [ 4, 0, 1 ]\n\t *\n\t * @param {module:engine/model/range~Range} otherRange Range to differentiate against.\n\t * @returns {Array.<module:engine/model/range~Range>} The difference between ranges.\n\t */\n\tgetDifference( otherRange ) {\n\t\tconst ranges = [];\n\n\t\tif ( this.isIntersecting( otherRange ) ) {\n\t\t\t// Ranges intersect.\n\n\t\t\tif ( this.containsPosition( otherRange.start ) ) {\n\t\t\t\t// Given range start is inside this range. This means that we have to\n\t\t\t\t// add shrunken range - from the start to the middle of this range.\n\t\t\t\tranges.push( new Range( this.start, otherRange.start ) );\n\t\t\t}\n\n\t\t\tif ( this.containsPosition( otherRange.end ) ) {\n\t\t\t\t// Given range end is inside this range. This means that we have to\n\t\t\t\t// add shrunken range - from the middle of this range to the end.\n\t\t\t\tranges.push( new Range( otherRange.end, this.end ) );\n\t\t\t}\n\t\t} else {\n\t\t\t// Ranges do not intersect, return the original range.\n\t\t\tranges.push( new Range( this.start, this.end ) );\n\t\t}\n\n\t\treturn ranges;\n\t}\n\n\t/**\n\t * Returns an intersection of this {@link ~Range range} and given {@link ~Range range}.\n\t * Intersection is a common part of both of those ranges. If ranges has no common part, returns `null`.\n\t *\n\t * Examples:\n\t *\n\t *\t\tlet range = model.createRange(\n\t *\t\t\tmodel.createPositionFromPath( root, [ 2, 7 ] ),\n\t *\t\t\tmodel.createPositionFromPath( root, [ 4, 0, 1 ] )\n\t *\t\t);\n\t *\t\tlet otherRange = model.createRange( model.createPositionFromPath( root, [ 1 ] ), model.createPositionFromPath( root, [ 2 ] ) );\n\t *\t\tlet transformed = range.getIntersection( otherRange ); // null - ranges have no common part\n\t *\n\t *\t\totherRange = model.createRange( model.createPositionFromPath( root, [ 3 ] ), model.createPositionFromPath( root, [ 5 ] ) );\n\t *\t\ttransformed = range.getIntersection( otherRange ); // range from [ 3 ] to [ 4, 0, 1 ]\n\t *\n\t * @param {module:engine/model/range~Range} otherRange Range to check for intersection.\n\t * @returns {module:engine/model/range~Range|null} A common part of given ranges or `null` if ranges have no common part.\n\t */\n\tgetIntersection( otherRange ) {\n\t\tif ( this.isIntersecting( otherRange ) ) {\n\t\t\t// Ranges intersect, so a common range will be returned.\n\t\t\t// At most, it will be same as this range.\n\t\t\tlet commonRangeStart = this.start;\n\t\t\tlet commonRangeEnd = this.end;\n\n\t\t\tif ( this.containsPosition( otherRange.start ) ) {\n\t\t\t\t// Given range start is inside this range. This means thaNt we have to\n\t\t\t\t// shrink common range to the given range start.\n\t\t\t\tcommonRangeStart = otherRange.start;\n\t\t\t}\n\n\t\t\tif ( this.containsPosition( otherRange.end ) ) {\n\t\t\t\t// Given range end is inside this range. This means that we have to\n\t\t\t\t// shrink common range to the given range end.\n\t\t\t\tcommonRangeEnd = otherRange.end;\n\t\t\t}\n\n\t\t\treturn new Range( commonRangeStart, commonRangeEnd );\n\t\t}\n\n\t\t// Ranges do not intersect, so they do not have common part.\n\t\treturn null;\n\t}\n\n\t/**\n\t * Computes and returns the smallest set of {@link #isFlat flat} ranges, that covers this range in whole.\n\t *\n\t * See an example of a model structure (`[` and `]` are range boundaries):\n\t *\n\t *\t\troot                                                            root\n\t *\t\t |- element DIV                         DIV             P2              P3             DIV\n\t *\t\t |   |- element H                   H        P1        f o o           b a r       H         P4\n\t *\t\t |   |   |- \"fir[st\"             fir[st     lorem                               se]cond     ipsum\n\t *\t\t |   |- element P1\n\t *\t\t |   |   |- \"lorem\"                                              ||\n\t *\t\t |- element P2                                                   ||\n\t *\t\t |   |- \"foo\"                                                    VV\n\t *\t\t |- element P3\n\t *\t\t |   |- \"bar\"                                                   root\n\t *\t\t |- element DIV                         DIV             [P2             P3]             DIV\n\t *\t\t |   |- element H                   H       [P1]       f o o           b a r        H         P4\n\t *\t\t |   |   |- \"se]cond\"            fir[st]    lorem                               [se]cond     ipsum\n\t *\t\t |   |- element P4\n\t *\t\t |   |   |- \"ipsum\"\n\t *\n\t * As it can be seen, letters contained in the range are: `stloremfoobarse`, spread across different parents.\n\t * We are looking for minimal set of flat ranges that contains the same nodes.\n\t *\n\t * Minimal flat ranges for above range `( [ 0, 0, 3 ], [ 3, 0, 2 ] )` will be:\n\t *\n\t *\t\t( [ 0, 0, 3 ], [ 0, 0, 5 ] ) = \"st\"\n\t *\t\t( [ 0, 1 ], [ 0, 2 ] ) = element P1 (\"lorem\")\n\t *\t\t( [ 1 ], [ 3 ] ) = element P2, element P3 (\"foobar\")\n\t *\t\t( [ 3, 0, 0 ], [ 3, 0, 2 ] ) = \"se\"\n\t *\n\t * **Note:** if an {@link module:engine/model/element~Element element} is not wholly contained in this range, it won't be returned\n\t * in any of the returned flat ranges. See in the example how `H` elements at the beginning and at the end of the range\n\t * were omitted. Only their parts that were wholly in the range were returned.\n\t *\n\t * **Note:** this method is not returning flat ranges that contain no nodes.\n\t *\n\t * @returns {Array.<module:engine/model/range~Range>} Array of flat ranges covering this range.\n\t */\n\tgetMinimalFlatRanges() {\n\t\tconst ranges = [];\n\t\tconst diffAt = this.start.getCommonPath( this.end ).length;\n\n\t\tconst pos = Position._createAt( this.start );\n\t\tlet posParent = pos.parent;\n\n\t\t// Go up.\n\t\twhile ( pos.path.length > diffAt + 1 ) {\n\t\t\tconst howMany = posParent.maxOffset - pos.offset;\n\n\t\t\tif ( howMany !== 0 ) {\n\t\t\t\tranges.push( new Range( pos, pos.getShiftedBy( howMany ) ) );\n\t\t\t}\n\n\t\t\tpos.path = pos.path.slice( 0, -1 );\n\t\t\tpos.offset++;\n\t\t\tposParent = posParent.parent;\n\t\t}\n\n\t\t// Go down.\n\t\twhile ( pos.path.length <= this.end.path.length ) {\n\t\t\tconst offset = this.end.path[ pos.path.length - 1 ];\n\t\t\tconst howMany = offset - pos.offset;\n\n\t\t\tif ( howMany !== 0 ) {\n\t\t\t\tranges.push( new Range( pos, pos.getShiftedBy( howMany ) ) );\n\t\t\t}\n\n\t\t\tpos.offset = offset;\n\t\t\tpos.path.push( 0 );\n\t\t}\n\n\t\treturn ranges;\n\t}\n\n\t/**\n\t * Creates a {@link module:engine/model/treewalker~TreeWalker TreeWalker} instance with this range as a boundary.\n\t *\n\t * For example, to iterate over all items in the entire document root:\n\t *\n\t *\t\t// Create a range spanning over the entire root content:\n\t *\t\tconst range = editor.model.createRangeIn( editor.model.document.getRoot() );\n\t *\n\t *\t\t// Iterate over all items in this range:\n\t *\t\tfor ( const value of range.getWalker() ) {\n\t *\t\t\tconsole.log( value.item );\n\t *\t\t}\n\t *\n\t * @param {Object} options Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.\n\t * @param {module:engine/model/position~Position} [options.startPosition]\n\t * @param {Boolean} [options.singleCharacters=false]\n\t * @param {Boolean} [options.shallow=false]\n\t * @param {Boolean} [options.ignoreElementEnd=false]\n\t */\n\tgetWalker( options = {} ) {\n\t\toptions.boundaries = this;\n\n\t\treturn new TreeWalker( options );\n\t}\n\n\t/**\n\t * Returns an iterator that iterates over all {@link module:engine/model/item~Item items} that are in this range and returns\n\t * them.\n\t *\n\t * This method uses {@link module:engine/model/treewalker~TreeWalker} with `boundaries` set to this range and `ignoreElementEnd` option\n\t * set to `true`. However it returns only {@link module:engine/model/item~Item model items},\n\t * not {@link module:engine/model/treewalker~TreeWalkerValue}.\n\t *\n\t * You may specify additional options for the tree walker. See {@link module:engine/model/treewalker~TreeWalker} for\n\t * a full list of available options.\n\t *\n\t * @method getItems\n\t * @param {Object} options Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.\n\t * @returns {Iterable.<module:engine/model/item~Item>}\n\t */\n\t* getItems( options = {} ) {\n\t\toptions.boundaries = this;\n\t\toptions.ignoreElementEnd = true;\n\n\t\tconst treeWalker = new TreeWalker( options );\n\n\t\tfor ( const value of treeWalker ) {\n\t\t\tyield value.item;\n\t\t}\n\t}\n\n\t/**\n\t * Returns an iterator that iterates over all {@link module:engine/model/position~Position positions} that are boundaries or\n\t * contained in this range.\n\t *\n\t * This method uses {@link module:engine/model/treewalker~TreeWalker} with `boundaries` set to this range. However it returns only\n\t * {@link module:engine/model/position~Position positions}, not {@link module:engine/model/treewalker~TreeWalkerValue}.\n\t *\n\t * You may specify additional options for the tree walker. See {@link module:engine/model/treewalker~TreeWalker} for\n\t * a full list of available options.\n\t *\n\t * @param {Object} options Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.\n\t * @returns {Iterable.<module:engine/model/position~Position>}\n\t */\n\t* getPositions( options = {} ) {\n\t\toptions.boundaries = this;\n\n\t\tconst treeWalker = new TreeWalker( options );\n\n\t\tyield treeWalker.position;\n\n\t\tfor ( const value of treeWalker ) {\n\t\t\tyield value.nextPosition;\n\t\t}\n\t}\n\n\t/**\n\t * Returns a range that is a result of transforming this range by given `operation`.\n\t *\n\t * **Note:** transformation may break one range into multiple ranges (for example, when a part of the range is\n\t * moved to a different part of document tree). For this reason, an array is returned by this method and it\n\t * may contain one or more `Range` instances.\n\t *\n\t * @param {module:engine/model/operation/operation~Operation} operation Operation to transform range by.\n\t * @returns {Array.<module:engine/model/range~Range>} Range which is the result of transformation.\n\t */\n\tgetTransformedByOperation( operation ) {\n\t\tswitch ( operation.type ) {\n\t\t\tcase 'insert':\n\t\t\t\treturn this._getTransformedByInsertOperation( operation );\n\t\t\tcase 'move':\n\t\t\tcase 'remove':\n\t\t\tcase 'reinsert':\n\t\t\t\treturn this._getTransformedByMoveOperation( operation );\n\t\t\tcase 'split':\n\t\t\t\treturn [ this._getTransformedBySplitOperation( operation ) ];\n\t\t\tcase 'merge':\n\t\t\t\treturn [ this._getTransformedByMergeOperation( operation ) ];\n\t\t}\n\n\t\treturn [ new Range( this.start, this.end ) ];\n\t}\n\n\t/**\n\t * Returns a range that is a result of transforming this range by multiple `operations`.\n\t *\n\t * @see ~Range#getTransformedByOperation\n\t * @param {Iterable.<module:engine/model/operation/operation~Operation>} operations Operations to transform the range by.\n\t * @returns {Array.<module:engine/model/range~Range>} Range which is the result of transformation.\n\t */\n\tgetTransformedByOperations( operations ) {\n\t\tconst ranges = [ new Range( this.start, this.end ) ];\n\n\t\tfor ( const operation of operations ) {\n\t\t\tfor ( let i = 0; i < ranges.length; i++ ) {\n\t\t\t\tconst result = ranges[ i ].getTransformedByOperation( operation );\n\n\t\t\t\tranges.splice( i, 1, ...result );\n\t\t\t\ti += result.length - 1;\n\t\t\t}\n\t\t}\n\n\t\t// It may happen that a range is split into two, and then the part of second \"piece\" is moved into first\n\t\t// \"piece\". In this case we will have incorrect third range, which should not be included in the result --\n\t\t// because it is already included in the first \"piece\". In this loop we are looking for all such ranges that\n\t\t// are inside other ranges and we simply remove them.\n\t\tfor ( let i = 0; i < ranges.length; i++ ) {\n\t\t\tconst range = ranges[ i ];\n\n\t\t\tfor ( let j = i + 1; j < ranges.length; j++ ) {\n\t\t\t\tconst next = ranges[ j ];\n\n\t\t\t\tif ( range.containsRange( next ) || next.containsRange( range ) || range.isEqual( next ) ) {\n\t\t\t\t\tranges.splice( j, 1 );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn ranges;\n\t}\n\n\t/**\n\t * Returns an {@link module:engine/model/element~Element} or {@link module:engine/model/documentfragment~DocumentFragment}\n\t * which is a common ancestor of the range's both ends (in which the entire range is contained).\n\t *\n\t * @returns {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment|null}\n\t */\n\tgetCommonAncestor() {\n\t\treturn this.start.getCommonAncestor( this.end );\n\t}\n\n\t/**\n\t * Converts `Range` to plain object and returns it.\n\t *\n\t * @returns {Object} `Node` converted to plain object.\n\t */\n\ttoJSON() {\n\t\treturn {\n\t\t\tstart: this.start.toJSON(),\n\t\t\tend: this.end.toJSON()\n\t\t};\n\t}\n\n\t/**\n\t * Returns a new range that is equal to current range.\n\t *\n\t * @returns {module:engine/model/range~Range}\n\t */\n\tclone() {\n\t\treturn new this.constructor( this.start, this.end );\n\t}\n\n\t/**\n\t * Returns a result of transforming a copy of this range by insert operation.\n\t *\n\t * One or more ranges may be returned as a result of this transformation.\n\t *\n\t * @protected\n\t * @param {module:engine/model/operation/insertoperation~InsertOperation} operation\n\t * @returns {Array.<module:engine/model/range~Range>}\n\t */\n\t_getTransformedByInsertOperation( operation, spread = false ) {\n\t\treturn this._getTransformedByInsertion( operation.position, operation.howMany, spread );\n\t}\n\n\t/**\n\t * Returns a result of transforming a copy of this range by move operation.\n\t *\n\t * One or more ranges may be returned as a result of this transformation.\n\t *\n\t * @protected\n\t * @param {module:engine/model/operation/moveoperation~MoveOperation} operation\n\t * @returns {Array.<module:engine/model/range~Range>}\n\t */\n\t_getTransformedByMoveOperation( operation, spread = false ) {\n\t\tconst sourcePosition = operation.sourcePosition;\n\t\tconst howMany = operation.howMany;\n\t\tconst targetPosition = operation.targetPosition;\n\n\t\treturn this._getTransformedByMove( sourcePosition, targetPosition, howMany, spread );\n\t}\n\n\t/**\n\t * Returns a result of transforming a copy of this range by split operation.\n\t *\n\t * Always one range is returned. The transformation is done in a way to not break the range.\n\t *\n\t * @protected\n\t * @param {module:engine/model/operation/splitoperation~SplitOperation} operation\n\t * @returns {module:engine/model/range~Range}\n\t */\n\t_getTransformedBySplitOperation( operation ) {\n\t\tconst start = this.start._getTransformedBySplitOperation( operation );\n\t\tlet end = this.end._getTransformedBySplitOperation( operation );\n\n\t\tif ( this.end.isEqual( operation.insertionPosition ) ) {\n\t\t\tend = this.end.getShiftedBy( 1 );\n\t\t}\n\n\t\t// Below may happen when range contains graveyard element used by split operation.\n\t\tif ( start.root != end.root ) {\n\t\t\t// End position was next to the moved graveyard element and was moved with it.\n\t\t\t// Fix it by using old `end` which has proper `root`.\n\t\t\tend = this.end.getShiftedBy( -1 );\n\t\t}\n\n\t\treturn new Range( start, end );\n\t}\n\n\t/**\n\t * Returns a result of transforming a copy of this range by merge operation.\n\t *\n\t * Always one range is returned. The transformation is done in a way to not break the range.\n\t *\n\t * @protected\n\t * @param {module:engine/model/operation/mergeoperation~MergeOperation} operation\n\t * @returns {module:engine/model/range~Range}\n\t */\n\t_getTransformedByMergeOperation( operation ) {\n\t\t// Special case when the marker is set on \"the closing tag\" of an element. Marker can be set like that during\n\t\t// transformations, especially when a content of a few block elements were removed. For example:\n\t\t//\n\t\t// {} is the transformed range, [] is the removed range.\n\t\t// <p>F[o{o</p><p>B}ar</p><p>Xy]z</p>\n\t\t//\n\t\t// <p>Fo{o</p><p>B}ar</p><p>z</p>\n\t\t// <p>F{</p><p>B}ar</p><p>z</p>\n\t\t// <p>F{</p>}<p>z</p>\n\t\t// <p>F{}z</p>\n\t\t//\n\t\tif ( this.start.isEqual( operation.targetPosition ) && this.end.isEqual( operation.deletionPosition ) ) {\n\t\t\treturn new Range( this.start );\n\t\t}\n\n\t\tlet start = this.start._getTransformedByMergeOperation( operation );\n\t\tlet end = this.end._getTransformedByMergeOperation( operation );\n\n\t\tif ( start.root != end.root ) {\n\t\t\t// This happens when the end position was next to the merged (deleted) element.\n\t\t\t// Then, the end position was moved to the graveyard root. In this case we need to fix\n\t\t\t// the range cause its boundaries would be in different roots.\n\t\t\tend = this.end.getShiftedBy( -1 );\n\t\t}\n\n\t\tif ( start.isAfter( end ) ) {\n\t\t\t// This happens in three following cases:\n\t\t\t//\n\t\t\t// Case 1: Merge operation source position is before the target position (due to some transformations, OT, etc.)\n\t\t\t//         This means that start can be moved before the end of the range.\n\t\t\t//\n\t\t\t// Before: <p>a{a</p><p>b}b</p><p>cc</p>\n\t\t\t// Merge:  <p>b}b</p><p>cca{a</p>\n\t\t\t// Fix:    <p>{b}b</p><p>ccaa</p>\n\t\t\t//\n\t\t\t// Case 2: Range start is before merged node but not directly.\n\t\t\t//         Result should include all nodes that were in the original range.\n\t\t\t//\n\t\t\t// Before: <p>aa</p>{<p>cc</p><p>b}b</p>\n\t\t\t// Merge:  <p>aab}b</p>{<p>cc</p>\n\t\t\t// Fix:    <p>aa{bb</p><p>cc</p>}\n\t\t\t//\n\t\t\t//         The range is expanded by an additional `b` letter but it is better than dropping the whole `cc` paragraph.\n\t\t\t//\n\t\t\t// Case 3: Range start is directly before merged node.\n\t\t\t//         Resulting range should include only nodes from the merged element:\n\t\t\t//\n\t\t\t// Before: <p>aa</p>{<p>b}b</p><p>cc</p>\n\t\t\t// Merge:  <p>aab}b</p>{<p>cc</p>\n\t\t\t// Fix:    <p>aa{b}b</p><p>cc</p>\n\t\t\t//\n\n\t\t\tif ( operation.sourcePosition.isBefore( operation.targetPosition ) ) {\n\t\t\t\t// Case 1.\n\t\t\t\tstart = Position._createAt( end );\n\t\t\t\tstart.offset = 0;\n\t\t\t} else {\n\t\t\t\tif ( !operation.deletionPosition.isEqual( start ) ) {\n\t\t\t\t\t// Case 2.\n\t\t\t\t\tend = operation.deletionPosition;\n\t\t\t\t}\n\n\t\t\t\t// In both case 2 and 3 start is at the end of the merge-to element.\n\t\t\t\tstart = operation.targetPosition;\n\t\t\t}\n\n\t\t\treturn new Range( start, end );\n\t\t}\n\n\t\treturn new Range( start, end );\n\t}\n\n\t/**\n\t * Returns an array containing one or two {@link ~Range ranges} that are a result of transforming this\n\t * {@link ~Range range} by inserting `howMany` nodes at `insertPosition`. Two {@link ~Range ranges} are\n\t * returned if the insertion was inside this {@link ~Range range} and `spread` is set to `true`.\n\t *\n\t * Examples:\n\t *\n\t *\t\tlet range = model.createRange(\n\t *\t\t\tmodel.createPositionFromPath( root, [ 2, 7 ] ),\n\t *\t\t\tmodel.createPositionFromPath( root, [ 4, 0, 1 ] )\n\t *\t\t);\n\t *\t\tlet transformed = range._getTransformedByInsertion( model.createPositionFromPath( root, [ 1 ] ), 2 );\n\t *\t\t// transformed array has one range from [ 4, 7 ] to [ 6, 0, 1 ]\n\t *\n\t *\t\ttransformed = range._getTransformedByInsertion( model.createPositionFromPath( root, [ 4, 0, 0 ] ), 4 );\n\t *\t\t// transformed array has one range from [ 2, 7 ] to [ 4, 0, 5 ]\n\t *\n\t *\t\ttransformed = range._getTransformedByInsertion( model.createPositionFromPath( root, [ 3, 2 ] ), 4 );\n\t *\t\t// transformed array has one range, which is equal to original range\n\t *\n\t *\t\ttransformed = range._getTransformedByInsertion( model.createPositionFromPath( root, [ 3, 2 ] ), 4, true );\n\t *\t\t// transformed array has two ranges: from [ 2, 7 ] to [ 3, 2 ] and from [ 3, 6 ] to [ 4, 0, 1 ]\n\t *\n\t * @protected\n\t * @param {module:engine/model/position~Position} insertPosition Position where nodes are inserted.\n\t * @param {Number} howMany How many nodes are inserted.\n\t * @param {Boolean} [spread] Flag indicating whether this {~Range range} should be spread if insertion\n\t * was inside the range. Defaults to `false`.\n\t * @returns {Array.<module:engine/model/range~Range>} Result of the transformation.\n\t */\n\t_getTransformedByInsertion( insertPosition, howMany, spread = false ) {\n\t\tif ( spread && this.containsPosition( insertPosition ) ) {\n\t\t\t// Range has to be spread. The first part is from original start to the spread point.\n\t\t\t// The other part is from spread point to the original end, but transformed by\n\t\t\t// insertion to reflect insertion changes.\n\n\t\t\treturn [\n\t\t\t\tnew Range( this.start, insertPosition ),\n\t\t\t\tnew Range(\n\t\t\t\t\tinsertPosition.getShiftedBy( howMany ),\n\t\t\t\t\tthis.end._getTransformedByInsertion( insertPosition, howMany )\n\t\t\t\t)\n\t\t\t];\n\t\t} else {\n\t\t\tconst range = new Range( this.start, this.end );\n\n\t\t\trange.start = range.start._getTransformedByInsertion( insertPosition, howMany );\n\t\t\trange.end = range.end._getTransformedByInsertion( insertPosition, howMany );\n\n\t\t\treturn [ range ];\n\t\t}\n\t}\n\n\t/**\n\t * Returns an array containing {@link ~Range ranges} that are a result of transforming this\n\t * {@link ~Range range} by moving `howMany` nodes from `sourcePosition` to `targetPosition`.\n\t *\n\t * @protected\n\t * @param {module:engine/model/position~Position} sourcePosition Position from which nodes are moved.\n\t * @param {module:engine/model/position~Position} targetPosition Position to where nodes are moved.\n\t * @param {Number} howMany How many nodes are moved.\n\t * @param {Boolean} [spread=false] Whether the range should be spread if the move points inside the range.\n\t * @returns {Array.<module:engine/model/range~Range>} Result of the transformation.\n\t */\n\t_getTransformedByMove( sourcePosition, targetPosition, howMany, spread = false ) {\n\t\t// Special case for transforming a collapsed range. Just transform it like a position.\n\t\tif ( this.isCollapsed ) {\n\t\t\tconst newPos = this.start._getTransformedByMove( sourcePosition, targetPosition, howMany );\n\n\t\t\treturn [ new Range( newPos ) ];\n\t\t}\n\n\t\t// Special case for transformation when a part of the range is moved towards the range.\n\t\t//\n\t\t// Examples:\n\t\t//\n\t\t// <div><p>ab</p><p>c[d</p></div><p>e]f</p> --> <div><p>ab</p></div><p>c[d</p><p>e]f</p>\n\t\t// <p>e[f</p><div><p>a]b</p><p>cd</p></div> --> <p>e[f</p><p>a]b</p><div><p>cd</p></div>\n\t\t//\n\t\t// Without this special condition, the default algorithm leaves an \"artifact\" range from one of `differenceSet` parts:\n\t\t//\n\t\t// <div><p>ab</p><p>c[d</p></div><p>e]f</p> --> <div><p>ab</p>{</div>}<p>c[d</p><p>e]f</p>\n\t\t//\n\t\t// This special case is applied only if the range is to be kept together (not spread).\n\t\tconst moveRange = Range._createFromPositionAndShift( sourcePosition, howMany );\n\t\tconst insertPosition = targetPosition._getTransformedByDeletion( sourcePosition, howMany );\n\n\t\tif ( this.containsPosition( targetPosition ) && !spread ) {\n\t\t\tif ( moveRange.containsPosition( this.start ) || moveRange.containsPosition( this.end ) ) {\n\t\t\t\tconst start = this.start._getTransformedByMove( sourcePosition, targetPosition, howMany );\n\t\t\t\tconst end = this.end._getTransformedByMove( sourcePosition, targetPosition, howMany );\n\n\t\t\t\treturn [ new Range( start, end ) ];\n\t\t\t}\n\t\t}\n\n\t\t// Default algorithm.\n\t\tlet result;\n\n\t\tconst differenceSet = this.getDifference( moveRange );\n\t\tlet difference = null;\n\n\t\tconst common = this.getIntersection( moveRange );\n\n\t\tif ( differenceSet.length == 1 ) {\n\t\t\t// `moveRange` and this range may intersect but may be separate.\n\t\t\tdifference = new Range(\n\t\t\t\tdifferenceSet[ 0 ].start._getTransformedByDeletion( sourcePosition, howMany ),\n\t\t\t\tdifferenceSet[ 0 ].end._getTransformedByDeletion( sourcePosition, howMany )\n\t\t\t);\n\t\t} else if ( differenceSet.length == 2 ) {\n\t\t\t// `moveRange` is inside this range.\n\t\t\tdifference = new Range(\n\t\t\t\tthis.start,\n\t\t\t\tthis.end._getTransformedByDeletion( sourcePosition, howMany )\n\t\t\t);\n\t\t} // else, `moveRange` contains this range.\n\n\t\tif ( difference ) {\n\t\t\tresult = difference._getTransformedByInsertion( insertPosition, howMany, common !== null || spread );\n\t\t} else {\n\t\t\tresult = [];\n\t\t}\n\n\t\tif ( common ) {\n\t\t\tconst transformedCommon = new Range(\n\t\t\t\tcommon.start._getCombined( moveRange.start, insertPosition ),\n\t\t\t\tcommon.end._getCombined( moveRange.start, insertPosition )\n\t\t\t);\n\n\t\t\tif ( result.length == 2 ) {\n\t\t\t\tresult.splice( 1, 0, transformedCommon );\n\t\t\t} else {\n\t\t\t\tresult.push( transformedCommon );\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Returns a copy of this range that is transformed by deletion of `howMany` nodes from `deletePosition`.\n\t *\n\t * If the deleted range is intersecting with the transformed range, the transformed range will be shrank.\n\t *\n\t * If the deleted range contains transformed range, `null` will be returned.\n\t *\n\t * @protected\n\t * @param {module:engine/model/position~Position} deletionPosition Position from which nodes are removed.\n\t * @param {Number} howMany How many nodes are removed.\n\t * @returns {module:engine/model/range~Range|null} Result of the transformation.\n\t */\n\t_getTransformedByDeletion( deletePosition, howMany ) {\n\t\tlet newStart = this.start._getTransformedByDeletion( deletePosition, howMany );\n\t\tlet newEnd = this.end._getTransformedByDeletion( deletePosition, howMany );\n\n\t\tif ( newStart == null && newEnd == null ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif ( newStart == null ) {\n\t\t\tnewStart = deletePosition;\n\t\t}\n\n\t\tif ( newEnd == null ) {\n\t\t\tnewEnd = deletePosition;\n\t\t}\n\n\t\treturn new Range( newStart, newEnd );\n\t}\n\n\t/**\n\t * Creates a new range, spreading from specified {@link module:engine/model/position~Position position} to a position moved by\n\t * given `shift`. If `shift` is a negative value, shifted position is treated as the beginning of the range.\n\t *\n\t * @protected\n\t * @param {module:engine/model/position~Position} position Beginning of the range.\n\t * @param {Number} shift How long the range should be.\n\t * @returns {module:engine/model/range~Range}\n\t */\n\tstatic _createFromPositionAndShift( position, shift ) {\n\t\tconst start = position;\n\t\tconst end = position.getShiftedBy( shift );\n\n\t\treturn shift > 0 ? new this( start, end ) : new this( end, start );\n\t}\n\n\t/**\n\t * Creates a range inside an {@link module:engine/model/element~Element element} which starts before the first child of\n\t * that element and ends after the last child of that element.\n\t *\n\t * @protected\n\t * @param {module:engine/model/element~Element} element Element which is a parent for the range.\n\t * @returns {module:engine/model/range~Range}\n\t */\n\tstatic _createIn( element ) {\n\t\treturn new this( Position._createAt( element, 0 ), Position._createAt( element, element.maxOffset ) );\n\t}\n\n\t/**\n\t * Creates a range that starts before given {@link module:engine/model/item~Item model item} and ends after it.\n\t *\n\t * @protected\n\t * @param {module:engine/model/item~Item} item\n\t * @returns {module:engine/model/range~Range}\n\t */\n\tstatic _createOn( item ) {\n\t\treturn this._createFromPositionAndShift( Position._createBefore( item ), item.offsetSize );\n\t}\n\n\t/**\n\t * Combines all ranges from the passed array into a one range. At least one range has to be passed.\n\t * Passed ranges must not have common parts.\n\t *\n\t * The first range from the array is a reference range. If other ranges start or end on the exactly same position where\n\t * the reference range, they get combined into one range.\n\t *\n\t *\t\t[  ][]  [    ][ ][             ][ ][]  [  ]  // Passed ranges, shown sorted\n\t *\t\t[    ]                                       // The result of the function if the first range was a reference range.\n\t *\t            [                           ]        // The result of the function if the third-to-seventh range was a reference range.\n\t *\t                                           [  ]  // The result of the function if the last range was a reference range.\n\t *\n\t * @param {Array.<module:engine/model/range~Range>} ranges Ranges to combine.\n\t * @returns {module:engine/model/range~Range} Combined range.\n\t */\n\tstatic _createFromRanges( ranges ) {\n\t\tif ( ranges.length === 0 ) {\n\t\t\t/**\n\t\t\t * At least one range has to be passed to\n\t\t\t * {@link module:engine/model/range~Range._createFromRanges `Range._createFromRanges()`}.\n\t\t\t *\n\t\t\t * @error range-create-from-ranges-empty-array\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'range-create-from-ranges-empty-array: At least one range has to be passed.',\n\t\t\t\tnull\n\t\t\t);\n\t\t} else if ( ranges.length == 1 ) {\n\t\t\treturn ranges[ 0 ].clone();\n\t\t}\n\n\t\t// 1. Set the first range in `ranges` array as a reference range.\n\t\t// If we are going to return just a one range, one of the ranges need to be the reference one.\n\t\t// Other ranges will be stuck to that range, if possible.\n\t\tconst ref = ranges[ 0 ];\n\n\t\t// 2. Sort all the ranges so it's easier to process them.\n\t\tranges.sort( ( a, b ) => {\n\t\t\treturn a.start.isAfter( b.start ) ? 1 : -1;\n\t\t} );\n\n\t\t// 3. Check at which index the reference range is now.\n\t\tconst refIndex = ranges.indexOf( ref );\n\n\t\t// 4. At this moment we don't need the original range.\n\t\t// We are going to modify the result and we need to return a new instance of Range.\n\t\t// We have to create a copy of the reference range.\n\t\tconst result = new this( ref.start, ref.end );\n\n\t\t// 5. Ranges should be checked and glued starting from the range that is closest to the reference range.\n\t\t// Since ranges are sorted, start with the range with index that is closest to reference range index.\n\t\tif ( refIndex > 0 ) {\n\t\t\tfor ( let i = refIndex - 1; true; i++ ) {\n\t\t\t\tif ( ranges[ i ].end.isEqual( result.start ) ) {\n\t\t\t\t\tresult.start = Position._createAt( ranges[ i ].start );\n\t\t\t\t} else {\n\t\t\t\t\t// If ranges are not starting/ending at the same position there is no point in looking further.\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 6. Ranges should be checked and glued starting from the range that is closest to the reference range.\n\t\t// Since ranges are sorted, start with the range with index that is closest to reference range index.\n\t\tfor ( let i = refIndex + 1; i < ranges.length; i++ ) {\n\t\t\tif ( ranges[ i ].start.isEqual( result.end ) ) {\n\t\t\t\tresult.end = Position._createAt( ranges[ i ].end );\n\t\t\t} else {\n\t\t\t\t// If ranges are not starting/ending at the same position there is no point in looking further.\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Creates a `Range` instance from given plain object (i.e. parsed JSON string).\n\t *\n\t * @param {Object} json Plain object to be converted to `Range`.\n\t * @param {module:engine/model/document~Document} doc Document object that will be range owner.\n\t * @returns {module:engine/model/element~Element} `Range` instance created using given plain object.\n\t */\n\tstatic fromJSON( json, doc ) {\n\t\treturn new this( Position.fromJSON( json.start, doc ), Position.fromJSON( json.end, doc ) );\n\t}\n\n\t// @if CK_DEBUG_ENGINE // toString() {\n\t// @if CK_DEBUG_ENGINE // \treturn `${ this.root } [ ${ this.start.path.join( ', ' ) } ] - [ ${ this.end.path.join( ', ' ) } ]`;\n\t// @if CK_DEBUG_ENGINE // }\n\n\t// @if CK_DEBUG_ENGINE // log() {\n\t// @if CK_DEBUG_ENGINE // \tconsole.log( 'ModelPosition: ' + this );\n\t// @if CK_DEBUG_ENGINE // }\n}\n"]}]}