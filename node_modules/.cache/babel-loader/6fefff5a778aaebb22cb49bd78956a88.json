{"remainingRequest":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/babel-loader/lib/index.js!/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-list/src/converters.js","dependencies":[{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-list/src/converters.js","mtime":499162500000},{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js","mtime":499162500000},{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/babel-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:LyoqCiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDE5LCBDS1NvdXJjZSAtIEZyZWRlcmljbyBLbmFiYmVuLiBBbGwgcmlnaHRzIHJlc2VydmVkLgogKiBGb3IgbGljZW5zaW5nLCBzZWUgTElDRU5TRS5tZCBvciBodHRwczovL2NrZWRpdG9yLmNvbS9sZWdhbC9ja2VkaXRvci1vc3MtbGljZW5zZQogKi8KCi8qKgogKiBAbW9kdWxlIGxpc3QvY29udmVydGVycwogKi8KaW1wb3J0IHsgZ2VuZXJhdGVMaUluVWwsIGluamVjdFZpZXdMaXN0LCBtZXJnZVZpZXdMaXN0cywgZ2V0U2libGluZ0xpc3RJdGVtLCBwb3NpdGlvbkFmdGVyVWlFbGVtZW50cyB9IGZyb20gJy4vdXRpbHMnOwppbXBvcnQgVHJlZVdhbGtlciBmcm9tICdAY2tlZGl0b3IvY2tlZGl0b3I1LWVuZ2luZS9zcmMvbW9kZWwvdHJlZXdhbGtlcic7Ci8qKgogKiBBIG1vZGVsLXRvLXZpZXcgY29udmVydGVyIGZvciB0aGUgYGxpc3RJdGVtYCBtb2RlbCBlbGVtZW50IGluc2VydGlvbi4KICoKICogSXQgY3JlYXRlcyBhIGA8dWw+PGxpPjwvbGk+PHVsPmAgKG9yIGA8b2w+YCkgdmlldyBzdHJ1Y3R1cmUgb3V0IG9mIGEgYGxpc3RJdGVtYCBtb2RlbCBlbGVtZW50LCBpbnNlcnRzIGl0IGF0IHRoZSBjb3JyZWN0CiAqIHBvc2l0aW9uLCBhbmQgbWVyZ2VzIHRoZSBsaXN0IHdpdGggc3Vycm91bmRpbmcgbGlzdHMgKGlmIGF2YWlsYWJsZSkuCiAqCiAqIEBzZWUgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL2Rvd25jYXN0ZGlzcGF0Y2hlcn5Eb3duY2FzdERpc3BhdGNoZXIjZXZlbnQ6aW5zZXJ0CiAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9tb2RlbH5Nb2RlbH0gbW9kZWwgTW9kZWwgaW5zdGFuY2UuCiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBhIGNvbnZlcnNpb24gY2FsbGJhY2suCiAqLwoKZXhwb3J0IGZ1bmN0aW9uIG1vZGVsVmlld0luc2VydGlvbihtb2RlbCkgewogIHJldHVybiAoZXZ0LCBkYXRhLCBjb252ZXJzaW9uQXBpKSA9PiB7CiAgICBjb25zdCBjb25zdW1hYmxlID0gY29udmVyc2lvbkFwaS5jb25zdW1hYmxlOwoKICAgIGlmICghY29uc3VtYWJsZS50ZXN0KGRhdGEuaXRlbSwgJ2luc2VydCcpIHx8ICFjb25zdW1hYmxlLnRlc3QoZGF0YS5pdGVtLCAnYXR0cmlidXRlOmxpc3RUeXBlJykgfHwgIWNvbnN1bWFibGUudGVzdChkYXRhLml0ZW0sICdhdHRyaWJ1dGU6bGlzdEluZGVudCcpKSB7CiAgICAgIHJldHVybjsKICAgIH0KCiAgICBjb25zdW1hYmxlLmNvbnN1bWUoZGF0YS5pdGVtLCAnaW5zZXJ0Jyk7CiAgICBjb25zdW1hYmxlLmNvbnN1bWUoZGF0YS5pdGVtLCAnYXR0cmlidXRlOmxpc3RUeXBlJyk7CiAgICBjb25zdW1hYmxlLmNvbnN1bWUoZGF0YS5pdGVtLCAnYXR0cmlidXRlOmxpc3RJbmRlbnQnKTsKICAgIGNvbnN0IG1vZGVsSXRlbSA9IGRhdGEuaXRlbTsKICAgIGNvbnN0IHZpZXdJdGVtID0gZ2VuZXJhdGVMaUluVWwobW9kZWxJdGVtLCBjb252ZXJzaW9uQXBpKTsKICAgIGluamVjdFZpZXdMaXN0KG1vZGVsSXRlbSwgdmlld0l0ZW0sIGNvbnZlcnNpb25BcGksIG1vZGVsKTsKICB9Owp9Ci8qKgogKiBBIG1vZGVsLXRvLXZpZXcgY29udmVydGVyIGZvciB0aGUgYGxpc3RJdGVtYCBtb2RlbCBlbGVtZW50IHJlbW92YWwuCiAqCiAqIEBzZWUgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL2Rvd25jYXN0ZGlzcGF0Y2hlcn5Eb3duY2FzdERpc3BhdGNoZXIjZXZlbnQ6cmVtb3ZlCiAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9tb2RlbH5Nb2RlbH0gbW9kZWwgTW9kZWwgaW5zdGFuY2UuCiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBhIGNvbnZlcnNpb24gY2FsbGJhY2suCiAqLwoKZXhwb3J0IGZ1bmN0aW9uIG1vZGVsVmlld1JlbW92ZShtb2RlbCkgewogIHJldHVybiAoZXZ0LCBkYXRhLCBjb252ZXJzaW9uQXBpKSA9PiB7CiAgICBjb25zdCB2aWV3U3RhcnQgPSBjb252ZXJzaW9uQXBpLm1hcHBlci50b1ZpZXdQb3NpdGlvbihkYXRhLnBvc2l0aW9uKS5nZXRMYXN0TWF0Y2hpbmdQb3NpdGlvbih2YWx1ZSA9PiAhdmFsdWUuaXRlbS5pcygnbGknKSk7CiAgICBjb25zdCB2aWV3SXRlbSA9IHZpZXdTdGFydC5ub2RlQWZ0ZXI7CiAgICBjb25zdCB2aWV3V3JpdGVyID0gY29udmVyc2lvbkFwaS53cml0ZXI7IC8vIDEuIEJyZWFrIHRoZSBjb250YWluZXIgYWZ0ZXIgYW5kIGJlZm9yZSB0aGUgbGlzdCBpdGVtLgogICAgLy8gVGhpcyB3aWxsIGNyZWF0ZSBhIHZpZXcgbGlzdCB3aXRoIG9uZSB2aWV3IGxpc3QgaXRlbSAtIHRoZSBvbmUgdG8gcmVtb3ZlLgoKICAgIHZpZXdXcml0ZXIuYnJlYWtDb250YWluZXIodmlld1dyaXRlci5jcmVhdGVQb3NpdGlvbkJlZm9yZSh2aWV3SXRlbSkpOwogICAgdmlld1dyaXRlci5icmVha0NvbnRhaW5lcih2aWV3V3JpdGVyLmNyZWF0ZVBvc2l0aW9uQWZ0ZXIodmlld0l0ZW0pKTsgLy8gMi4gUmVtb3ZlIHRoZSBsaXN0IHdpdGggdGhlIGl0ZW0gdG8gcmVtb3ZlLgoKICAgIGNvbnN0IHZpZXdMaXN0ID0gdmlld0l0ZW0ucGFyZW50OwogICAgY29uc3Qgdmlld0xpc3RQcmV2ID0gdmlld0xpc3QucHJldmlvdXNTaWJsaW5nOwogICAgY29uc3QgcmVtb3ZlUmFuZ2UgPSB2aWV3V3JpdGVyLmNyZWF0ZVJhbmdlT24odmlld0xpc3QpOwogICAgY29uc3QgcmVtb3ZlZCA9IHZpZXdXcml0ZXIucmVtb3ZlKHJlbW92ZVJhbmdlKTsgLy8gMy4gTWVyZ2UgdGhlIHdob2xlIGNyZWF0ZWQgYnkgYnJlYWtpbmcgYW5kIHJlbW92aW5nIHRoZSBsaXN0LgoKICAgIGlmICh2aWV3TGlzdFByZXYgJiYgdmlld0xpc3RQcmV2Lm5leHRTaWJsaW5nKSB7CiAgICAgIG1lcmdlVmlld0xpc3RzKHZpZXdXcml0ZXIsIHZpZXdMaXN0UHJldiwgdmlld0xpc3RQcmV2Lm5leHRTaWJsaW5nKTsKICAgIH0gLy8gNC4gQnJpbmcgYmFjayBuZXN0ZWQgbGlzdCB0aGF0IHdhcyBpbiB0aGUgcmVtb3ZlZCA8bGk+LgoKCiAgICBjb25zdCBtb2RlbEl0ZW0gPSBjb252ZXJzaW9uQXBpLm1hcHBlci50b01vZGVsRWxlbWVudCh2aWV3SXRlbSk7CiAgICBob2lzdE5lc3RlZExpc3RzKG1vZGVsSXRlbS5nZXRBdHRyaWJ1dGUoJ2xpc3RJbmRlbnQnKSArIDEsIGRhdGEucG9zaXRpb24sIHJlbW92ZVJhbmdlLnN0YXJ0LCB2aWV3SXRlbSwgY29udmVyc2lvbkFwaSwgbW9kZWwpOyAvLyA1LiBVbmJpbmQgcmVtb3ZlZCB2aWV3IGl0ZW0gYW5kIGFsbCBjaGlsZHJlbi4KCiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHZpZXdXcml0ZXIuY3JlYXRlUmFuZ2VJbihyZW1vdmVkKS5nZXRJdGVtcygpKSB7CiAgICAgIGNvbnZlcnNpb25BcGkubWFwcGVyLnVuYmluZFZpZXdFbGVtZW50KGNoaWxkKTsKICAgIH0KCiAgICBldnQuc3RvcCgpOwogIH07Cn0KLyoqCiAqIEEgbW9kZWwtdG8tdmlldyBjb252ZXJ0ZXIgZm9yIHRoZSBgdHlwZWAgYXR0cmlidXRlIGNoYW5nZSBvbiB0aGUgYGxpc3RJdGVtYCBtb2RlbCBlbGVtZW50LgogKgogKiBUaGlzIGNoYW5nZSBtZWFucyB0aGF0IHRoZSBgPGxpPmAgZWxlbWVudCBwYXJlbnQgY2hhbmdlcyBmcm9tIGA8dWw+YCB0byBgPG9sPmAgKG9yIHZpY2UgdmVyc2EpLiBUaGlzIGlzIGFjY29tcGxpc2hlZAogKiBieSBicmVha2luZyB2aWV3IGVsZW1lbnRzIGFuZCBjaGFuZ2luZyB0aGVpciBuYW1lLiBUaGUgbmV4dCB7QGxpbmsgbW9kdWxlOmxpc3QvY29udmVydGVyc35tb2RlbFZpZXdNZXJnZUFmdGVyQ2hhbmdlVHlwZX0KICogY29udmVydGVyIHdpbGwgYXR0ZW1wdCB0byBtZXJnZSBzcGxpdCBub2Rlcy4KICoKICogU3BsaXR0aW5nIHRoaXMgY29udmVyc2lvbiBpbnRvIDIgc3RlcHMgbWFrZXMgaXQgcG9zc2libGUgdG8gYWRkIGFuIGFkZGl0aW9uYWwgY29udmVyc2lvbiBpbiB0aGUgbWlkZGxlLgogKiBDaGVjayB7QGxpbmsgbW9kdWxlOmxpc3QvdG9kb2xpc3Rjb252ZXJ0ZXJzfm1vZGVsVmlld0NoYW5nZVR5cGV9IHRvIHNlZSBhbiBleGFtcGxlIG9mIGl0LgogKgogKiBAc2VlIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi9kb3duY2FzdGRpc3BhdGNoZXJ+RG93bmNhc3REaXNwYXRjaGVyI2V2ZW50OmF0dHJpYnV0ZQogKiBAcGFyYW0ge21vZHVsZTp1dGlscy9ldmVudGluZm9+RXZlbnRJbmZvfSBldnQgQW4gb2JqZWN0IGNvbnRhaW5pbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGZpcmVkIGV2ZW50LgogKiBAcGFyYW0ge09iamVjdH0gZGF0YSBBZGRpdGlvbmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjaGFuZ2UuCiAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL2Rvd25jYXN0ZGlzcGF0Y2hlcn5Eb3duY2FzdENvbnZlcnNpb25BcGl9IGNvbnZlcnNpb25BcGkgQ29udmVyc2lvbiBpbnRlcmZhY2UuCiAqLwoKZXhwb3J0IGZ1bmN0aW9uIG1vZGVsVmlld0NoYW5nZVR5cGUoZXZ0LCBkYXRhLCBjb252ZXJzaW9uQXBpKSB7CiAgaWYgKCFjb252ZXJzaW9uQXBpLmNvbnN1bWFibGUuY29uc3VtZShkYXRhLml0ZW0sICdhdHRyaWJ1dGU6bGlzdFR5cGUnKSkgewogICAgcmV0dXJuOwogIH0KCiAgY29uc3Qgdmlld0l0ZW0gPSBjb252ZXJzaW9uQXBpLm1hcHBlci50b1ZpZXdFbGVtZW50KGRhdGEuaXRlbSk7CiAgY29uc3Qgdmlld1dyaXRlciA9IGNvbnZlcnNpb25BcGkud3JpdGVyOyAvLyBCcmVhayB0aGUgY29udGFpbmVyIGFmdGVyIGFuZCBiZWZvcmUgdGhlIGxpc3QgaXRlbS4KICAvLyBUaGlzIHdpbGwgY3JlYXRlIGEgdmlldyBsaXN0IHdpdGggb25lIHZpZXcgbGlzdCBpdGVtIC0tIHRoZSBvbmUgdGhhdCBjaGFuZ2VkIHR5cGUuCgogIHZpZXdXcml0ZXIuYnJlYWtDb250YWluZXIodmlld1dyaXRlci5jcmVhdGVQb3NpdGlvbkJlZm9yZSh2aWV3SXRlbSkpOwogIHZpZXdXcml0ZXIuYnJlYWtDb250YWluZXIodmlld1dyaXRlci5jcmVhdGVQb3NpdGlvbkFmdGVyKHZpZXdJdGVtKSk7IC8vIENoYW5nZSBuYW1lIG9mIHRoZSB2aWV3IGxpc3QgdGhhdCBob2xkcyB0aGUgY2hhbmdlZCB2aWV3IGl0ZW0uCiAgLy8gV2UgY2Fubm90IGp1c3QgY2hhbmdlIG5hbWUgcHJvcGVydHksIGJlY2F1c2UgdGhhdCB3b3VsZCBub3QgcmVuZGVyIHByb3Blcmx5LgoKICBjb25zdCB2aWV3TGlzdCA9IHZpZXdJdGVtLnBhcmVudDsKICBjb25zdCBsaXN0TmFtZSA9IGRhdGEuYXR0cmlidXRlTmV3VmFsdWUgPT0gJ251bWJlcmVkJyA/ICdvbCcgOiAndWwnOwogIHZpZXdXcml0ZXIucmVuYW1lKGxpc3ROYW1lLCB2aWV3TGlzdCk7Cn0KLyoqCiAqIEEgbW9kZWwtdG8tdmlldyBjb252ZXJ0ZXIgdGhhdCBhdHRlbXB0cyB0byBtZXJnZSBub2RlcyBzcGxpdCBieSB7QGxpbmsgbW9kdWxlOmxpc3QvY29udmVydGVyc35tb2RlbFZpZXdDaGFuZ2VUeXBlfS4KICoKICogQHNlZSBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vZG93bmNhc3RkaXNwYXRjaGVyfkRvd25jYXN0RGlzcGF0Y2hlciNldmVudDphdHRyaWJ1dGUKICogQHBhcmFtIHttb2R1bGU6dXRpbHMvZXZlbnRpbmZvfkV2ZW50SW5mb30gZXZ0IEFuIG9iamVjdCBjb250YWluaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSBmaXJlZCBldmVudC4KICogQHBhcmFtIHtPYmplY3R9IGRhdGEgQWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY2hhbmdlLgogKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvY29udmVyc2lvbi9kb3duY2FzdGRpc3BhdGNoZXJ+RG93bmNhc3RDb252ZXJzaW9uQXBpfSBjb252ZXJzaW9uQXBpIENvbnZlcnNpb24gaW50ZXJmYWNlLgogKi8KCmV4cG9ydCBmdW5jdGlvbiBtb2RlbFZpZXdNZXJnZUFmdGVyQ2hhbmdlVHlwZShldnQsIGRhdGEsIGNvbnZlcnNpb25BcGkpIHsKICBjb25zdCB2aWV3SXRlbSA9IGNvbnZlcnNpb25BcGkubWFwcGVyLnRvVmlld0VsZW1lbnQoZGF0YS5pdGVtKTsKICBjb25zdCB2aWV3TGlzdCA9IHZpZXdJdGVtLnBhcmVudDsKICBjb25zdCB2aWV3V3JpdGVyID0gY29udmVyc2lvbkFwaS53cml0ZXI7IC8vIE1lcmdlIHRoZSBjaGFuZ2VkIHZpZXcgbGlzdCB3aXRoIG90aGVyIGxpc3RzLCBpZiBwb3NzaWJsZS4KCiAgbWVyZ2VWaWV3TGlzdHModmlld1dyaXRlciwgdmlld0xpc3QsIHZpZXdMaXN0Lm5leHRTaWJsaW5nKTsKICBtZXJnZVZpZXdMaXN0cyh2aWV3V3JpdGVyLCB2aWV3TGlzdC5wcmV2aW91c1NpYmxpbmcsIHZpZXdMaXN0KTsgLy8gQ29uc3VtYWJsZSBpbnNlcnRpb24gb2YgY2hpbGRyZW4gaW5zaWRlIHRoZSBpdGVtLiBUaGV5IGFyZSBhbHJlYWR5IGhhbmRsZWQgYnkgcmUtYnVpbGRpbmcgdGhlIGl0ZW0gaW4gdmlldy4KCiAgZm9yIChjb25zdCBjaGlsZCBvZiBkYXRhLml0ZW0uZ2V0Q2hpbGRyZW4oKSkgewogICAgY29udmVyc2lvbkFwaS5jb25zdW1hYmxlLmNvbnN1bWUoY2hpbGQsICdpbnNlcnQnKTsKICB9Cn0KLyoqCiAqIEEgbW9kZWwtdG8tdmlldyBjb252ZXJ0ZXIgZm9yIHRoZSBgbGlzdEluZGVudGAgYXR0cmlidXRlIGNoYW5nZSBvbiB0aGUgYGxpc3RJdGVtYCBtb2RlbCBlbGVtZW50LgogKgogKiBAc2VlIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi9kb3duY2FzdGRpc3BhdGNoZXJ+RG93bmNhc3REaXNwYXRjaGVyI2V2ZW50OmF0dHJpYnV0ZQogKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvbW9kZWx+TW9kZWx9IG1vZGVsIE1vZGVsIGluc3RhbmNlLgogKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYSBjb252ZXJzaW9uIGNhbGxiYWNrLgogKi8KCmV4cG9ydCBmdW5jdGlvbiBtb2RlbFZpZXdDaGFuZ2VJbmRlbnQobW9kZWwpIHsKICByZXR1cm4gKGV2dCwgZGF0YSwgY29udmVyc2lvbkFwaSkgPT4gewogICAgaWYgKCFjb252ZXJzaW9uQXBpLmNvbnN1bWFibGUuY29uc3VtZShkYXRhLml0ZW0sICdhdHRyaWJ1dGU6bGlzdEluZGVudCcpKSB7CiAgICAgIHJldHVybjsKICAgIH0KCiAgICBjb25zdCB2aWV3SXRlbSA9IGNvbnZlcnNpb25BcGkubWFwcGVyLnRvVmlld0VsZW1lbnQoZGF0YS5pdGVtKTsKICAgIGNvbnN0IHZpZXdXcml0ZXIgPSBjb252ZXJzaW9uQXBpLndyaXRlcjsgLy8gMS4gQnJlYWsgdGhlIGNvbnRhaW5lciBhZnRlciBhbmQgYmVmb3JlIHRoZSBsaXN0IGl0ZW0uCiAgICAvLyBUaGlzIHdpbGwgY3JlYXRlIGEgdmlldyBsaXN0IHdpdGggb25lIHZpZXcgbGlzdCBpdGVtIC0tIHRoZSBvbmUgdGhhdCBjaGFuZ2VkIHR5cGUuCgogICAgdmlld1dyaXRlci5icmVha0NvbnRhaW5lcih2aWV3V3JpdGVyLmNyZWF0ZVBvc2l0aW9uQmVmb3JlKHZpZXdJdGVtKSk7CiAgICB2aWV3V3JpdGVyLmJyZWFrQ29udGFpbmVyKHZpZXdXcml0ZXIuY3JlYXRlUG9zaXRpb25BZnRlcih2aWV3SXRlbSkpOyAvLyAyLiBFeHRyYWN0IHZpZXcgbGlzdCB3aXRoIGNoYW5nZWQgdmlldyBsaXN0IGl0ZW0gYW5kIG1lcmdlICJob2xlIiBwb3NzaWJseSBjcmVhdGVkIGJ5IGJyZWFraW5nIGFuZCByZW1vdmluZyBlbGVtZW50cy4KCiAgICBjb25zdCB2aWV3TGlzdCA9IHZpZXdJdGVtLnBhcmVudDsKICAgIGNvbnN0IHZpZXdMaXN0UHJldiA9IHZpZXdMaXN0LnByZXZpb3VzU2libGluZzsKICAgIGNvbnN0IHJlbW92ZVJhbmdlID0gdmlld1dyaXRlci5jcmVhdGVSYW5nZU9uKHZpZXdMaXN0KTsKICAgIHZpZXdXcml0ZXIucmVtb3ZlKHJlbW92ZVJhbmdlKTsKCiAgICBpZiAodmlld0xpc3RQcmV2ICYmIHZpZXdMaXN0UHJldi5uZXh0U2libGluZykgewogICAgICBtZXJnZVZpZXdMaXN0cyh2aWV3V3JpdGVyLCB2aWV3TGlzdFByZXYsIHZpZXdMaXN0UHJldi5uZXh0U2libGluZyk7CiAgICB9IC8vIDMuIEJyaW5nIGJhY2sgbmVzdGVkIGxpc3QgdGhhdCB3YXMgaW4gdGhlIHJlbW92ZWQgPGxpPi4KCgogICAgaG9pc3ROZXN0ZWRMaXN0cyhkYXRhLmF0dHJpYnV0ZU9sZFZhbHVlICsgMSwgZGF0YS5yYW5nZS5zdGFydCwgcmVtb3ZlUmFuZ2Uuc3RhcnQsIHZpZXdJdGVtLCBjb252ZXJzaW9uQXBpLCBtb2RlbCk7IC8vIDQuIEluamVjdCB2aWV3IGxpc3QgbGlrZSBpdCBpcyBuZXdseSBpbnNlcnRlZC4KCiAgICBpbmplY3RWaWV3TGlzdChkYXRhLml0ZW0sIHZpZXdJdGVtLCBjb252ZXJzaW9uQXBpLCBtb2RlbCk7IC8vIDUuIENvbnN1bWUgaW5zZXJ0aW9uIG9mIGNoaWxkcmVuIGluc2lkZSB0aGUgaXRlbS4gVGhleSBhcmUgYWxyZWFkeSBoYW5kbGVkIGJ5IHJlLWJ1aWxkaW5nIHRoZSBpdGVtIGluIHZpZXcuCgogICAgZm9yIChjb25zdCBjaGlsZCBvZiBkYXRhLml0ZW0uZ2V0Q2hpbGRyZW4oKSkgewogICAgICBjb252ZXJzaW9uQXBpLmNvbnN1bWFibGUuY29uc3VtZShjaGlsZCwgJ2luc2VydCcpOwogICAgfQogIH07Cn0KLyoqCiAqIEEgc3BlY2lhbCBtb2RlbC10by12aWV3IGNvbnZlcnRlciBpbnRyb2R1Y2VkIGJ5IHRoZSB7QGxpbmsgbW9kdWxlOmxpc3QvbGlzdH5MaXN0IGxpc3QgZmVhdHVyZX0uIFRoaXMgY29udmVydGVyIGlzIGZpcmVkIGZvcgogKiBpbnNlcnQgY2hhbmdlIG9mIGV2ZXJ5IG1vZGVsIGl0ZW0sIGFuZCBzaG91bGQgYmUgZmlyZWQgYmVmb3JlIHRoZSBhY3R1YWwgY29udmVydGVyLiBUaGUgY29udmVydGVyIGNoZWNrcyB3aGV0aGVyIHRoZSBpbnNlcnRlZAogKiBtb2RlbCBpdGVtIGlzIGEgbm9uLWBsaXN0SXRlbWAgZWxlbWVudC4gSWYgaXQgaXMsIGFuZCBpdCBpcyBpbnNlcnRlZCBpbnNpZGUgYSB2aWV3IGxpc3QsIHRoZSBjb252ZXJ0ZXIgYnJlYWtzIHRoZQogKiBsaXN0IHNvIHRoZSBtb2RlbCBlbGVtZW50IGlzIGluc2VydGVkIHRvIHRoZSB2aWV3IHBhcmVudCBlbGVtZW50IGNvcnJlc3BvbmRpbmcgdG8gaXRzIG1vZGVsIHBhcmVudCBlbGVtZW50LgogKgogKiBUaGUgY29udmVydGVyIHByZXZlbnRzIHN1Y2ggc2l0dWF0aW9uczoKICoKICoJCS8vIE1vZGVsOiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFZpZXc6CiAqCQk8bGlzdEl0ZW0+Zm9vPC9saXN0SXRlbT4gICAgICAgICA8dWw+CiAqCQk8bGlzdEl0ZW0+YmFyPC9saXN0SXRlbT4gICAgICAgICAgICAgPGxpPmZvbzwvbGk+CiAqCQkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxpPmJhcjwvbGk+CiAqCQkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3VsPgogKgogKgkJLy8gQWZ0ZXIgY2hhbmdlOiAgICAgICAgICAgICAgICAgLy8gQ29ycmVjdCB2aWV3IGd1YXJhbnRlZWQgYnkgdGhpcyBjb252ZXJ0ZXI6CiAqCQk8bGlzdEl0ZW0+Zm9vPC9saXN0SXRlbT4gICAgICAgICA8dWw+PGxpPmZvbzwvbGk+PC91bD48cD54eHg8L3A+PHVsPjxsaT5iYXI8L2xpPjwvdWw+CiAqCQk8cGFyYWdyYXBoPnh4eDwvcGFyYWdyYXBoPiAgICAgICAvLyBJbnN0ZWFkIG9mIHRoaXMgd3JvbmcgdmlldyBzdGF0ZToKICoJCTxsaXN0SXRlbT5iYXI8L2xpc3RJdGVtPiAgICAgICAgIDx1bD48bGk+Zm9vPC9saT48cD54eHg8L3A+PGxpPmJhcjwvbGk+PC91bD4KICoKICogQHNlZSBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vZG93bmNhc3RkaXNwYXRjaGVyfkRvd25jYXN0RGlzcGF0Y2hlciNldmVudDppbnNlcnQKICogQHBhcmFtIHttb2R1bGU6dXRpbHMvZXZlbnRpbmZvfkV2ZW50SW5mb30gZXZ0IEFuIG9iamVjdCBjb250YWluaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSBmaXJlZCBldmVudC4KICogQHBhcmFtIHtPYmplY3R9IGRhdGEgQWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY2hhbmdlLgogKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvY29udmVyc2lvbi9kb3duY2FzdGRpc3BhdGNoZXJ+RG93bmNhc3RDb252ZXJzaW9uQXBpfSBjb252ZXJzaW9uQXBpIENvbnZlcnNpb24gaW50ZXJmYWNlLgogKi8KCmV4cG9ydCBmdW5jdGlvbiBtb2RlbFZpZXdTcGxpdE9uSW5zZXJ0KGV2dCwgZGF0YSwgY29udmVyc2lvbkFwaSkgewogIGlmIChkYXRhLml0ZW0ubmFtZSAhPSAnbGlzdEl0ZW0nKSB7CiAgICBsZXQgdmlld1Bvc2l0aW9uID0gY29udmVyc2lvbkFwaS5tYXBwZXIudG9WaWV3UG9zaXRpb24oZGF0YS5yYW5nZS5zdGFydCk7CiAgICBjb25zdCB2aWV3V3JpdGVyID0gY29udmVyc2lvbkFwaS53cml0ZXI7CiAgICBjb25zdCBsaXN0cyA9IFtdOyAvLyBCcmVhayBtdWx0aXBsZSBVTHMvT0xzIGlmIHRoZXJlIGFyZS4KICAgIC8vCiAgICAvLyBJbWFnaW5lIGZvbGxvd2luZyBsaXN0OgogICAgLy8KICAgIC8vIDEgLS0tLS0tLS0KICAgIC8vICAgMS4xIC0tLS0tLS0tCiAgICAvLyAgICAgMS4xLjEgLS0tLS0tLS0KICAgIC8vICAgICAxLjEuMiAtLS0tLS0tLQogICAgLy8gICAgIDEuMS4zIC0tLS0tLS0tCiAgICAvLyAgICAgICAxLjEuMy4xIC0tLS0tLS0tCiAgICAvLyAgIDEuMiAtLS0tLS0tLQogICAgLy8gICAgIDEuMi4xIC0tLS0tLS0tCiAgICAvLyAyIC0tLS0tLS0tCiAgICAvLwogICAgLy8gSW5zZXJ0IHBhcmFncmFwaCBhZnRlciBpdGVtIDEuMS4xOgogICAgLy8KICAgIC8vIDEgLS0tLS0tLS0KICAgIC8vICAgMS4xIC0tLS0tLS0tCiAgICAvLyAgICAgMS4xLjEgLS0tLS0tLS0KICAgIC8vCiAgICAvLyBMb3JlbSBpcHN1bS4KICAgIC8vCiAgICAvLyAgICAgMS4xLjIgLS0tLS0tLS0KICAgIC8vICAgICAxLjEuMyAtLS0tLS0tLQogICAgLy8gICAgICAgMS4xLjMuMSAtLS0tLS0tLQogICAgLy8gICAxLjIgLS0tLS0tLS0KICAgIC8vICAgICAxLjIuMSAtLS0tLS0tLQogICAgLy8gMiAtLS0tLS0tLQogICAgLy8KICAgIC8vIEluIHRoaXMgY2FzZSAxLjEuMiBoYXMgdG8gYmVjb21lIGJlZ2lubmluZyBvZiBhIG5ldyBsaXN0LgogICAgLy8gV2UgbmVlZCB0byBicmVhayBsaXN0IGJlZm9yZSAxLjEuMiAob2J2aW91cyksIHRoZW4gd2UgbmVlZCB0byBicmVhayBsaXN0IGFsc28gYmVmb3JlIDEuMi4KICAgIC8vIFRoZW4gd2UgbmVlZCB0byBtb3ZlIHRob3NlIGJyb2tlbiBwaWVjZXMgb25lIGFmdGVyIGFub3RoZXIgYW5kIG1lcmdlOgogICAgLy8KICAgIC8vIDEgLS0tLS0tLS0KICAgIC8vICAgMS4xIC0tLS0tLS0tCiAgICAvLyAgICAgMS4xLjEgLS0tLS0tLS0KICAgIC8vCiAgICAvLyBMb3JlbSBpcHN1bS4KICAgIC8vCiAgICAvLyAxLjEuMiAtLS0tLS0tLQogICAgLy8gICAxLjEuMyAtLS0tLS0tLQogICAgLy8gICAgIDEuMS4zLjEgLS0tLS0tLS0KICAgIC8vIDEuMiAtLS0tLS0tLQogICAgLy8gICAxLjIuMSAtLS0tLS0tLQogICAgLy8gMiAtLS0tLS0tLQogICAgLy8KCiAgICB3aGlsZSAodmlld1Bvc2l0aW9uLnBhcmVudC5uYW1lID09ICd1bCcgfHwgdmlld1Bvc2l0aW9uLnBhcmVudC5uYW1lID09ICdvbCcpIHsKICAgICAgdmlld1Bvc2l0aW9uID0gdmlld1dyaXRlci5icmVha0NvbnRhaW5lcih2aWV3UG9zaXRpb24pOwoKICAgICAgaWYgKHZpZXdQb3NpdGlvbi5wYXJlbnQubmFtZSAhPSAnbGknKSB7CiAgICAgICAgYnJlYWs7CiAgICAgIH0gLy8gUmVtb3ZlIGxpc3RzIHRoYXQgYXJlIGFmdGVyIGluc2VydGVkIGVsZW1lbnQuCiAgICAgIC8vIFRoZXkgd2lsbCBiZSBicm91Z2h0IGJhY2sgbGF0ZXIsIGJlbG93IHRoZSBpbnNlcnRlZCBlbGVtZW50LgoKCiAgICAgIGNvbnN0IHJlbW92ZVN0YXJ0ID0gdmlld1Bvc2l0aW9uOwogICAgICBjb25zdCByZW1vdmVFbmQgPSB2aWV3V3JpdGVyLmNyZWF0ZVBvc2l0aW9uQXQodmlld1Bvc2l0aW9uLnBhcmVudCwgJ2VuZCcpOyAvLyBEb24ndCByZW1vdmUgaWYgdGhlcmUgaXMgbm90aGluZyB0byByZW1vdmUuCgogICAgICBpZiAoIXJlbW92ZVN0YXJ0LmlzRXF1YWwocmVtb3ZlRW5kKSkgewogICAgICAgIGNvbnN0IHJlbW92ZWQgPSB2aWV3V3JpdGVyLnJlbW92ZSh2aWV3V3JpdGVyLmNyZWF0ZVJhbmdlKHJlbW92ZVN0YXJ0LCByZW1vdmVFbmQpKTsKICAgICAgICBsaXN0cy5wdXNoKHJlbW92ZWQpOwogICAgICB9CgogICAgICB2aWV3UG9zaXRpb24gPSB2aWV3V3JpdGVyLmNyZWF0ZVBvc2l0aW9uQWZ0ZXIodmlld1Bvc2l0aW9uLnBhcmVudCk7CiAgICB9IC8vIEJyaW5nIGJhY2sgcmVtb3ZlZCBsaXN0cy4KCgogICAgaWYgKGxpc3RzLmxlbmd0aCA+IDApIHsKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0cy5sZW5ndGg7IGkrKykgewogICAgICAgIGNvbnN0IHByZXZpb3VzTGlzdCA9IHZpZXdQb3NpdGlvbi5ub2RlQmVmb3JlOwogICAgICAgIGNvbnN0IGluc2VydGVkUmFuZ2UgPSB2aWV3V3JpdGVyLmluc2VydCh2aWV3UG9zaXRpb24sIGxpc3RzW2ldKTsKICAgICAgICB2aWV3UG9zaXRpb24gPSBpbnNlcnRlZFJhbmdlLmVuZDsgLy8gRG9uJ3QgbWVyZ2UgZmlyc3QgbGlzdCEgV2Ugd2FudCBhIHNwbGl0IGluIHRoYXQgcGxhY2UgKHRoaXMgaXMgd2h5IHRoaXMgY29udmVydGVyIGlzIGludHJvZHVjZWQpLgoKICAgICAgICBpZiAoaSA+IDApIHsKICAgICAgICAgIGNvbnN0IG1lcmdlUG9zID0gbWVyZ2VWaWV3TGlzdHModmlld1dyaXRlciwgcHJldmlvdXNMaXN0LCBwcmV2aW91c0xpc3QubmV4dFNpYmxpbmcpOyAvLyBJZiBgbWVyZ2VQb3NgIGlzIGluIGBwcmV2aW91c0xpc3RgIGl0IG1lYW5zIHRoYXQgdGhlIGxpc3RzIGdvdCBtZXJnZWQuCiAgICAgICAgICAvLyBJbiB0aGlzIGNhc2UsIHdlIG5lZWQgdG8gZml4IGluc2VydCBwb3NpdGlvbi4KCiAgICAgICAgICBpZiAobWVyZ2VQb3MgJiYgbWVyZ2VQb3MucGFyZW50ID09IHByZXZpb3VzTGlzdCkgewogICAgICAgICAgICB2aWV3UG9zaXRpb24ub2Zmc2V0LS07CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9IC8vIE1lcmdlIGxhc3QgaW5zZXJ0ZWQgbGlzdCB3aXRoIGVsZW1lbnQgYWZ0ZXIgaXQuCgoKICAgICAgbWVyZ2VWaWV3TGlzdHModmlld1dyaXRlciwgdmlld1Bvc2l0aW9uLm5vZGVCZWZvcmUsIHZpZXdQb3NpdGlvbi5ub2RlQWZ0ZXIpOwogICAgfQogIH0KfQovKioKICogQSBzcGVjaWFsIG1vZGVsLXRvLXZpZXcgY29udmVydGVyIGludHJvZHVjZWQgYnkgdGhlIHtAbGluayBtb2R1bGU6bGlzdC9saXN0fkxpc3QgbGlzdCBmZWF0dXJlfS4gVGhpcyBjb252ZXJ0ZXIgdGFrZXMgY2FyZSBvZgogKiBtZXJnaW5nIHZpZXcgbGlzdHMgYWZ0ZXIgc29tZXRoaW5nIGlzIHJlbW92ZWQgb3IgbW92ZWQgZnJvbSBuZWFyIHRoZW0uCiAqCiAqIEV4YW1wbGU6CiAqCiAqCQkvLyBNb2RlbDogICAgICAgICAgICAgICAgICAgICAgICAvLyBWaWV3OgogKgkJPGxpc3RJdGVtPmZvbzwvbGlzdEl0ZW0+ICAgICAgICAgPHVsPjxsaT5mb288L2xpPjwvdWw+CiAqCQk8cGFyYWdyYXBoPnh4eDwvcGFyYWdyYXBoPiAgICAgICA8cD54eHg8L3A+CiAqCQk8bGlzdEl0ZW0+YmFyPC9saXN0SXRlbT4gICAgICAgICA8dWw+PGxpPmJhcjwvbGk+PC91bD4KICoKICoJCS8vIEFmdGVyIGNoYW5nZTogICAgICAgICAgICAgICAgIC8vIENvcnJlY3QgdmlldyBndWFyYW50ZWVkIGJ5IHRoaXMgY29udmVydGVyOgogKgkJPGxpc3RJdGVtPmZvbzwvbGlzdEl0ZW0+ICAgICAgICAgPHVsPgogKgkJPGxpc3RJdGVtPmJhcjwvbGlzdEl0ZW0+ICAgICAgICAgICAgIDxsaT5mb288L2xpPgogKgkJICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaT5iYXI8L2xpPgogKgkJICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC91bD4KICoKICogQHNlZSBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vZG93bmNhc3RkaXNwYXRjaGVyfkRvd25jYXN0RGlzcGF0Y2hlciNldmVudDpyZW1vdmUKICogQHBhcmFtIHttb2R1bGU6dXRpbHMvZXZlbnRpbmZvfkV2ZW50SW5mb30gZXZ0IEFuIG9iamVjdCBjb250YWluaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSBmaXJlZCBldmVudC4KICogQHBhcmFtIHtPYmplY3R9IGRhdGEgQWRkaXRpb25hbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY2hhbmdlLgogKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvY29udmVyc2lvbi9kb3duY2FzdGRpc3BhdGNoZXJ+RG93bmNhc3RDb252ZXJzaW9uQXBpfSBjb252ZXJzaW9uQXBpIENvbnZlcnNpb24gaW50ZXJmYWNlLgogKi8KCmV4cG9ydCBmdW5jdGlvbiBtb2RlbFZpZXdNZXJnZUFmdGVyKGV2dCwgZGF0YSwgY29udmVyc2lvbkFwaSkgewogIGNvbnN0IHZpZXdQb3NpdGlvbiA9IGNvbnZlcnNpb25BcGkubWFwcGVyLnRvVmlld1Bvc2l0aW9uKGRhdGEucG9zaXRpb24pOwogIGNvbnN0IHZpZXdJdGVtUHJldiA9IHZpZXdQb3NpdGlvbi5ub2RlQmVmb3JlOwogIGNvbnN0IHZpZXdJdGVtTmV4dCA9IHZpZXdQb3NpdGlvbi5ub2RlQWZ0ZXI7IC8vIE1lcmdlIGxpc3RzIGlmIHNvbWV0aGluZyAocmVtb3ZlLCBtb3ZlKSB3YXMgZG9uZSBmcm9tIGluc2lkZSBvZiBsaXN0LgogIC8vIE1lcmdpbmcgd2lsbCBiZSBkb25lIG9ubHkgaWYgYm90aCBpdGVtcyBhcmUgdmlldyBsaXN0cyBvZiB0aGUgc2FtZSB0eXBlLgogIC8vIFRoZSBjaGVjayBpcyBkb25lIGluc2lkZSB0aGUgaGVscGVyIGZ1bmN0aW9uLgoKICBtZXJnZVZpZXdMaXN0cyhjb252ZXJzaW9uQXBpLndyaXRlciwgdmlld0l0ZW1QcmV2LCB2aWV3SXRlbU5leHQpOwp9Ci8qKgogKiBBIHZpZXctdG8tbW9kZWwgY29udmVydGVyIHRoYXQgY29udmVydHMgdGhlIGA8bGk+YCB2aWV3IGVsZW1lbnRzIGludG8gdGhlIGBsaXN0SXRlbWAgbW9kZWwgZWxlbWVudHMuCiAqCiAqIFRvIHNldCBjb3JyZWN0IHZhbHVlcyBvZiB0aGUgYGxpc3RUeXBlYCBhbmQgYGxpc3RJbmRlbnRgIGF0dHJpYnV0ZXMgdGhlIGNvbnZlcnRlcjoKICogKiBjaGVja3MgYDxsaT5gJ3MgcGFyZW50LAogKiAqIHN0b3JlcyBhbmQgaW5jcmVhc2VzIHRoZSBgY29udmVyc2lvbkFwaS5zdG9yZS5pbmRlbnRgIHZhbHVlIHdoZW4gYDxsaT5gJ3Mgc3ViLWl0ZW1zIGFyZSBjb252ZXJ0ZWQuCiAqCiAqIEBzZWUgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL3VwY2FzdGRpc3BhdGNoZXJ+VXBjYXN0RGlzcGF0Y2hlciNldmVudDplbGVtZW50CiAqIEBwYXJhbSB7bW9kdWxlOnV0aWxzL2V2ZW50aW5mb35FdmVudEluZm99IGV2dCBBbiBvYmplY3QgY29udGFpbmluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgZmlyZWQgZXZlbnQuCiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIEFuIG9iamVjdCBjb250YWluaW5nIGNvbnZlcnNpb24gaW5wdXQgYW5kIGEgcGxhY2Vob2xkZXIgZm9yIGNvbnZlcnNpb24gb3V0cHV0IGFuZCBwb3NzaWJseSBvdGhlciB2YWx1ZXMuCiAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL3VwY2FzdGRpc3BhdGNoZXJ+VXBjYXN0Q29udmVyc2lvbkFwaX0gY29udmVyc2lvbkFwaSBDb252ZXJzaW9uIGludGVyZmFjZSB0byBiZSB1c2VkIGJ5IHRoZSBjYWxsYmFjay4KICovCgpleHBvcnQgZnVuY3Rpb24gdmlld01vZGVsQ29udmVydGVyKGV2dCwgZGF0YSwgY29udmVyc2lvbkFwaSkgewogIGlmIChjb252ZXJzaW9uQXBpLmNvbnN1bWFibGUuY29uc3VtZShkYXRhLnZpZXdJdGVtLCB7CiAgICBuYW1lOiB0cnVlCiAgfSkpIHsKICAgIGNvbnN0IHdyaXRlciA9IGNvbnZlcnNpb25BcGkud3JpdGVyOyAvLyAxLiBDcmVhdGUgYGxpc3RJdGVtYCBtb2RlbCBlbGVtZW50LgoKICAgIGNvbnN0IGxpc3RJdGVtID0gd3JpdGVyLmNyZWF0ZUVsZW1lbnQoJ2xpc3RJdGVtJyk7IC8vIDIuIEhhbmRsZSBgbGlzdEl0ZW1gIG1vZGVsIGVsZW1lbnQgYXR0cmlidXRlcy4KCiAgICBjb25zdCBpbmRlbnQgPSBnZXRJbmRlbnQoZGF0YS52aWV3SXRlbSk7CiAgICB3cml0ZXIuc2V0QXR0cmlidXRlKCdsaXN0SW5kZW50JywgaW5kZW50LCBsaXN0SXRlbSk7IC8vIFNldCAnYnVsbGV0ZWQnIGFzIGRlZmF1bHQuIElmIHRoaXMgaXRlbSBpcyBwYXN0ZWQgaW50byBhIGNvbnRleHQsCgogICAgY29uc3QgdHlwZSA9IGRhdGEudmlld0l0ZW0ucGFyZW50ICYmIGRhdGEudmlld0l0ZW0ucGFyZW50Lm5hbWUgPT0gJ29sJyA/ICdudW1iZXJlZCcgOiAnYnVsbGV0ZWQnOwogICAgd3JpdGVyLnNldEF0dHJpYnV0ZSgnbGlzdFR5cGUnLCB0eXBlLCBsaXN0SXRlbSk7IC8vIFRyeSB0byBmaW5kIGFsbG93ZWQgcGFyZW50IGZvciBsaXN0IGl0ZW0uCgogICAgY29uc3Qgc3BsaXRSZXN1bHQgPSBjb252ZXJzaW9uQXBpLnNwbGl0VG9BbGxvd2VkUGFyZW50KGxpc3RJdGVtLCBkYXRhLm1vZGVsQ3Vyc29yKTsgLy8gV2hlbiB0aGVyZSBpcyBubyBhbGxvd2VkIHBhcmVudCBpdCBtZWFucyB0aGF0IGxpc3QgaXRlbSBjYW5ub3QgYmUgY29udmVydGVkIGF0IGN1cnJlbnQgbW9kZWwgcG9zaXRpb24KICAgIC8vIGFuZCBpbiBhbnkgb2YgcG9zaXRpb24gYW5jZXN0b3JzLgoKICAgIGlmICghc3BsaXRSZXN1bHQpIHsKICAgICAgcmV0dXJuOwogICAgfQoKICAgIHdyaXRlci5pbnNlcnQobGlzdEl0ZW0sIHNwbGl0UmVzdWx0LnBvc2l0aW9uKTsKICAgIGNvbnN0IG5leHRQb3NpdGlvbiA9IHZpZXdUb01vZGVsTGlzdEl0ZW1DaGlsZHJlbkNvbnZlcnRlcihsaXN0SXRlbSwgZGF0YS52aWV3SXRlbS5nZXRDaGlsZHJlbigpLCBjb252ZXJzaW9uQXBpKTsgLy8gUmVzdWx0IHJhbmdlIHN0YXJ0cyBiZWZvcmUgdGhlIGZpcnN0IGl0ZW0gYW5kIGVuZHMgYWZ0ZXIgdGhlIGxhc3QuCgogICAgZGF0YS5tb2RlbFJhbmdlID0gd3JpdGVyLmNyZWF0ZVJhbmdlKGRhdGEubW9kZWxDdXJzb3IsIG5leHRQb3NpdGlvbik7IC8vIFdoZW4gYGRhdGEubW9kZWxDdXJzb3JgIHBhcmVudCBoYWQgdG8gYmUgc3BsaXQgdG8gaW5zZXJ0IGxpc3QgaXRlbS4uLgoKICAgIGlmIChzcGxpdFJlc3VsdC5jdXJzb3JQYXJlbnQpIHsKICAgICAgLy8gQ29udGludWUgY29udmVyc2lvbiBpbiB0aGUgc3BsaXQgZWxlbWVudC4KICAgICAgZGF0YS5tb2RlbEN1cnNvciA9IHdyaXRlci5jcmVhdGVQb3NpdGlvbkF0KHNwbGl0UmVzdWx0LmN1cnNvclBhcmVudCwgMCk7CiAgICB9IGVsc2UgewogICAgICAvLyBPdGhlcndpc2UgY29udGludWUgY29udmVyc2lvbiBhZnRlciB0aGUgbGFzdCBsaXN0IGl0ZW0uCiAgICAgIGRhdGEubW9kZWxDdXJzb3IgPSBkYXRhLm1vZGVsUmFuZ2UuZW5kOwogICAgfQogIH0KfQovKioKICogQSB2aWV3LXRvLW1vZGVsIGNvbnZlcnRlciBmb3IgdGhlIGA8dWw+YCBhbmQgYDxvbD5gIHZpZXcgZWxlbWVudHMgdGhhdCBjbGVhbnMgdGhlIGlucHV0IHZpZXcgb2YgZ2FyYmFnZS4KICogVGhpcyBpcyBtb3N0bHkgdG8gY2xlYW4gd2hpdGVzcGFjZXMgZnJvbSBiZXR3ZWVuIHRoZSBgPGxpPmAgdmlldyBlbGVtZW50cyBpbnNpZGUgdGhlIHZpZXcgbGlzdCBlbGVtZW50LCBob3dldmVyLCBhbHNvCiAqIGluY29ycmVjdCBkYXRhIGNhbiBiZSBjbGVhcmVkIGlmIHRoZSB2aWV3IHdhcyBpbmNvcnJlY3QuCiAqCiAqIEBzZWUgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL3VwY2FzdGRpc3BhdGNoZXJ+VXBjYXN0RGlzcGF0Y2hlciNldmVudDplbGVtZW50CiAqIEBwYXJhbSB7bW9kdWxlOnV0aWxzL2V2ZW50aW5mb35FdmVudEluZm99IGV2dCBBbiBvYmplY3QgY29udGFpbmluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgZmlyZWQgZXZlbnQuCiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIEFuIG9iamVjdCBjb250YWluaW5nIGNvbnZlcnNpb24gaW5wdXQgYW5kIGEgcGxhY2Vob2xkZXIgZm9yIGNvbnZlcnNpb24gb3V0cHV0IGFuZCBwb3NzaWJseSBvdGhlciB2YWx1ZXMuCiAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL3VwY2FzdGRpc3BhdGNoZXJ+VXBjYXN0Q29udmVyc2lvbkFwaX0gY29udmVyc2lvbkFwaSBDb252ZXJzaW9uIGludGVyZmFjZSB0byBiZSB1c2VkIGJ5IHRoZSBjYWxsYmFjay4KICovCgpleHBvcnQgZnVuY3Rpb24gY2xlYW5MaXN0KGV2dCwgZGF0YSwgY29udmVyc2lvbkFwaSkgewogIGlmIChjb252ZXJzaW9uQXBpLmNvbnN1bWFibGUudGVzdChkYXRhLnZpZXdJdGVtLCB7CiAgICBuYW1lOiB0cnVlCiAgfSkpIHsKICAgIC8vIENhY2hpbmcgY2hpbGRyZW4gYmVjYXVzZSB3aGVuIHdlIHN0YXJ0IHJlbW92aW5nIHRoZW0gaXRlcmF0aW5nIGZhaWxzLgogICAgY29uc3QgY2hpbGRyZW4gPSBBcnJheS5mcm9tKGRhdGEudmlld0l0ZW0uZ2V0Q2hpbGRyZW4oKSk7CgogICAgZm9yIChjb25zdCBjaGlsZCBvZiBjaGlsZHJlbikgewogICAgICBjb25zdCBpc1dyb25nRWxlbWVudCA9ICEoY2hpbGQuaXMoJ2xpJykgfHwgaXNMaXN0KGNoaWxkKSk7CgogICAgICBpZiAoaXNXcm9uZ0VsZW1lbnQpIHsKICAgICAgICBjaGlsZC5fcmVtb3ZlKCk7CiAgICAgIH0KICAgIH0KICB9Cn0KLyoqCiAqIEEgdmlldy10by1tb2RlbCBjb252ZXJ0ZXIgZm9yIHRoZSBgPGxpPmAgZWxlbWVudHMgdGhhdCBjbGVhbnMgd2hpdGVzcGFjZSBmb3JtYXR0aW5nIGZyb20gdGhlIGlucHV0IHZpZXcuCiAqCiAqIEBzZWUgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL3VwY2FzdGRpc3BhdGNoZXJ+VXBjYXN0RGlzcGF0Y2hlciNldmVudDplbGVtZW50CiAqIEBwYXJhbSB7bW9kdWxlOnV0aWxzL2V2ZW50aW5mb35FdmVudEluZm99IGV2dCBBbiBvYmplY3QgY29udGFpbmluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgZmlyZWQgZXZlbnQuCiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIEFuIG9iamVjdCBjb250YWluaW5nIGNvbnZlcnNpb24gaW5wdXQgYW5kIGEgcGxhY2Vob2xkZXIgZm9yIGNvbnZlcnNpb24gb3V0cHV0IGFuZCBwb3NzaWJseSBvdGhlciB2YWx1ZXMuCiAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL3VwY2FzdGRpc3BhdGNoZXJ+VXBjYXN0Q29udmVyc2lvbkFwaX0gY29udmVyc2lvbkFwaSBDb252ZXJzaW9uIGludGVyZmFjZSB0byBiZSB1c2VkIGJ5IHRoZSBjYWxsYmFjay4KICovCgpleHBvcnQgZnVuY3Rpb24gY2xlYW5MaXN0SXRlbShldnQsIGRhdGEsIGNvbnZlcnNpb25BcGkpIHsKICBpZiAoY29udmVyc2lvbkFwaS5jb25zdW1hYmxlLnRlc3QoZGF0YS52aWV3SXRlbSwgewogICAgbmFtZTogdHJ1ZQogIH0pKSB7CiAgICBpZiAoZGF0YS52aWV3SXRlbS5jaGlsZENvdW50ID09PSAwKSB7CiAgICAgIHJldHVybjsKICAgIH0KCiAgICBjb25zdCBjaGlsZHJlbiA9IFsuLi5kYXRhLnZpZXdJdGVtLmdldENoaWxkcmVuKCldOwogICAgbGV0IGZvdW5kTGlzdCA9IGZhbHNlOwogICAgbGV0IGZpcnN0Tm9kZSA9IHRydWU7CgogICAgZm9yIChjb25zdCBjaGlsZCBvZiBjaGlsZHJlbikgewogICAgICBpZiAoZm91bmRMaXN0ICYmICFpc0xpc3QoY2hpbGQpKSB7CiAgICAgICAgY2hpbGQuX3JlbW92ZSgpOwogICAgICB9CgogICAgICBpZiAoY2hpbGQuaXMoJ3RleHQnKSkgewogICAgICAgIC8vIElmIHRoaXMgaXMgdGhlIGZpcnN0IG5vZGUgYW5kIGl0J3MgYSB0ZXh0IG5vZGUsIGxlZnQtdHJpbSBpdC4KICAgICAgICBpZiAoZmlyc3ROb2RlKSB7CiAgICAgICAgICBjaGlsZC5fZGF0YSA9IGNoaWxkLmRhdGEucmVwbGFjZSgvXlxzKy8sICcnKTsKICAgICAgICB9IC8vIElmIHRoaXMgaXMgdGhlIGxhc3QgdGV4dCBub2RlIGJlZm9yZSA8dWw+IG9yIDxvbD4sIHJpZ2h0LXRyaW0gaXQuCgoKICAgICAgICBpZiAoIWNoaWxkLm5leHRTaWJsaW5nIHx8IGlzTGlzdChjaGlsZC5uZXh0U2libGluZykpIHsKICAgICAgICAgIGNoaWxkLl9kYXRhID0gY2hpbGQuZGF0YS5yZXBsYWNlKC9ccyskLywgJycpOwogICAgICAgIH0KICAgICAgfSBlbHNlIGlmIChpc0xpc3QoY2hpbGQpKSB7CiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIDx1bD4gb3IgPG9sPiwgZG8gbm90IHByb2Nlc3MgaXQsIGp1c3QgbWFyayB0aGF0IHdlIGFscmVhZHkgdmlzaXRlZCBsaXN0IGVsZW1lbnQuCiAgICAgICAgZm91bmRMaXN0ID0gdHJ1ZTsKICAgICAgfQoKICAgICAgZmlyc3ROb2RlID0gZmFsc2U7CiAgICB9CiAgfQp9Ci8qKgogKiBSZXR1cm5zIGEgY2FsbGJhY2sgZm9yIG1vZGVsIHBvc2l0aW9uIHRvIHZpZXcgcG9zaXRpb24gbWFwcGluZyBmb3Ige0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi9tYXBwZXJ+TWFwcGVyfS4gVGhlIGNhbGxiYWNrIGZpeGVzCiAqIHBvc2l0aW9ucyBiZXR3ZWVuIHRoZSBgbGlzdEl0ZW1gIGVsZW1lbnRzIHRoYXQgd291bGQgYmUgaW5jb3JyZWN0bHkgbWFwcGVkIGJlY2F1c2Ugb2YgaG93IGxpc3QgaXRlbXMgYXJlIHJlcHJlc2VudGVkIGluIHRoZSBtb2RlbAogKiBhbmQgaW4gdGhlIHZpZXcuCiAqCiAqIEBzZWUgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL21hcHBlcn5NYXBwZXIjZXZlbnQ6bW9kZWxUb1ZpZXdQb3NpdGlvbgogKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy92aWV3flZpZXd9IHZpZXcgQSB2aWV3IGluc3RhbmNlLgogKiBAcmV0dXJucyB7RnVuY3Rpb259CiAqLwoKZXhwb3J0IGZ1bmN0aW9uIG1vZGVsVG9WaWV3UG9zaXRpb24odmlldykgewogIHJldHVybiAoZXZ0LCBkYXRhKSA9PiB7CiAgICBpZiAoZGF0YS5pc1BoYW50b20pIHsKICAgICAgcmV0dXJuOwogICAgfQoKICAgIGNvbnN0IG1vZGVsSXRlbSA9IGRhdGEubW9kZWxQb3NpdGlvbi5ub2RlQmVmb3JlOwoKICAgIGlmIChtb2RlbEl0ZW0gJiYgbW9kZWxJdGVtLmlzKCdsaXN0SXRlbScpKSB7CiAgICAgIGNvbnN0IHZpZXdJdGVtID0gZGF0YS5tYXBwZXIudG9WaWV3RWxlbWVudChtb2RlbEl0ZW0pOwogICAgICBjb25zdCB0b3Btb3N0Vmlld0xpc3QgPSB2aWV3SXRlbS5nZXRBbmNlc3RvcnMoKS5maW5kKGlzTGlzdCk7CiAgICAgIGNvbnN0IHdhbGtlciA9IHZpZXcuY3JlYXRlUG9zaXRpb25BdCh2aWV3SXRlbSwgMCkuZ2V0V2Fsa2VyKCk7CgogICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHdhbGtlcikgewogICAgICAgIGlmICh2YWx1ZS50eXBlID09ICdlbGVtZW50U3RhcnQnICYmIHZhbHVlLml0ZW0uaXMoJ2xpJykpIHsKICAgICAgICAgIGRhdGEudmlld1Bvc2l0aW9uID0gdmFsdWUucHJldmlvdXNQb3NpdGlvbjsKICAgICAgICAgIGJyZWFrOwogICAgICAgIH0gZWxzZSBpZiAodmFsdWUudHlwZSA9PSAnZWxlbWVudEVuZCcgJiYgdmFsdWUuaXRlbSA9PSB0b3Btb3N0Vmlld0xpc3QpIHsKICAgICAgICAgIGRhdGEudmlld1Bvc2l0aW9uID0gdmFsdWUubmV4dFBvc2l0aW9uOwogICAgICAgICAgYnJlYWs7CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgfTsKfQovKioKICogVGhlIGNhbGxiYWNrIGZvciB2aWV3IHBvc2l0aW9uIHRvIG1vZGVsIHBvc2l0aW9uIG1hcHBpbmcgZm9yIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vbWFwcGVyfk1hcHBlcn0uIFRoZSBjYWxsYmFjayBmaXhlcwogKiBwb3NpdGlvbnMgYmV0d2VlbiB0aGUgYDxsaT5gIGVsZW1lbnRzIHRoYXQgd291bGQgYmUgaW5jb3JyZWN0bHkgbWFwcGVkIGJlY2F1c2Ugb2YgaG93IGxpc3QgaXRlbXMgYXJlIHJlcHJlc2VudGVkIGluIHRoZSBtb2RlbAogKiBhbmQgaW4gdGhlIHZpZXcuCiAqCiAqIEBzZWUgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL21hcHBlcn5NYXBwZXIjZXZlbnQ6dmlld1RvTW9kZWxQb3NpdGlvbgogKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvbW9kZWx+TW9kZWx9IG1vZGVsIE1vZGVsIGluc3RhbmNlLgogKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYSBjb252ZXJzaW9uIGNhbGxiYWNrLgogKi8KCmV4cG9ydCBmdW5jdGlvbiB2aWV3VG9Nb2RlbFBvc2l0aW9uKG1vZGVsKSB7CiAgcmV0dXJuIChldnQsIGRhdGEpID0+IHsKICAgIGNvbnN0IHZpZXdQb3MgPSBkYXRhLnZpZXdQb3NpdGlvbjsKICAgIGNvbnN0IHZpZXdQYXJlbnQgPSB2aWV3UG9zLnBhcmVudDsKICAgIGNvbnN0IG1hcHBlciA9IGRhdGEubWFwcGVyOwoKICAgIGlmICh2aWV3UGFyZW50Lm5hbWUgPT0gJ3VsJyB8fCB2aWV3UGFyZW50Lm5hbWUgPT0gJ29sJykgewogICAgICAvLyBQb3NpdGlvbiBpcyBkaXJlY3RseSBpbiA8dWw+IG9yIDxvbD4uCiAgICAgIGlmICghdmlld1Bvcy5pc0F0RW5kKSB7CiAgICAgICAgLy8gSWYgcG9zaXRpb24gaXMgbm90IGF0IHRoZSBlbmQsIGl0IG11c3QgYmUgYmVmb3JlIDxsaT4uCiAgICAgICAgLy8gR2V0IHRoYXQgPGxpPiwgbWFwIGl0IHRvIGBsaXN0SXRlbWAgYW5kIHNldCBtb2RlbCBwb3NpdGlvbiBiZWZvcmUgdGhhdCBgbGlzdEl0ZW1gLgogICAgICAgIGNvbnN0IG1vZGVsTm9kZSA9IG1hcHBlci50b01vZGVsRWxlbWVudCh2aWV3UG9zLm5vZGVBZnRlcik7CiAgICAgICAgZGF0YS5tb2RlbFBvc2l0aW9uID0gbW9kZWwuY3JlYXRlUG9zaXRpb25CZWZvcmUobW9kZWxOb2RlKTsKICAgICAgfSBlbHNlIHsKICAgICAgICAvLyBQb3NpdGlvbiBpcyBhdCB0aGUgZW5kIG9mIDx1bD4gb3IgPG9sPiwgc28gdGhlcmUgaXMgbm8gPGxpPiBhZnRlciBpdCB0byBiZSBtYXBwZWQuCiAgICAgICAgLy8gVGhlcmUgaXMgPGxpPiBiZWZvcmUgdGhlIHBvc2l0aW9uLCBidXQgd2UgY2Fubm90IGp1c3QgbWFwIGl0IHRvIGBsaXN0SXRlbWAgYW5kIHNldCBtb2RlbCBwb3NpdGlvbiBhZnRlciBpdCwKICAgICAgICAvLyBiZWNhdXNlIHRoYXQgPGxpPiBtYXkgY29udGFpbiBuZXN0ZWQgaXRlbXMuCiAgICAgICAgLy8gV2Ugd2lsbCBjaGVjayAibW9kZWwgbGVuZ3RoIiBvZiB0aGF0IDxsaT4sIGluIG90aGVyIHdvcmRzIC0gaG93IG1hbnkgYGxpc3RJdGVtYHMgYXJlIGluIHRoYXQgPGxpPi4KICAgICAgICBjb25zdCBtb2RlbE5vZGUgPSBtYXBwZXIudG9Nb2RlbEVsZW1lbnQodmlld1Bvcy5ub2RlQmVmb3JlKTsKICAgICAgICBjb25zdCBtb2RlbExlbmd0aCA9IG1hcHBlci5nZXRNb2RlbExlbmd0aCh2aWV3UG9zLm5vZGVCZWZvcmUpOyAvLyBUaGVuIHdlIGdldCBtb2RlbCBwb3NpdGlvbiBiZWZvcmUgbWFwcGVkIGBsaXN0SXRlbWAgYW5kIHNoaWZ0IGl0IGFjY29yZGluZ2x5LgoKICAgICAgICBkYXRhLm1vZGVsUG9zaXRpb24gPSBtb2RlbC5jcmVhdGVQb3NpdGlvbkJlZm9yZShtb2RlbE5vZGUpLmdldFNoaWZ0ZWRCeShtb2RlbExlbmd0aCk7CiAgICAgIH0KCiAgICAgIGV2dC5zdG9wKCk7CiAgICB9IGVsc2UgaWYgKHZpZXdQYXJlbnQubmFtZSA9PSAnbGknICYmIHZpZXdQb3Mubm9kZUJlZm9yZSAmJiAodmlld1Bvcy5ub2RlQmVmb3JlLm5hbWUgPT0gJ3VsJyB8fCB2aWV3UG9zLm5vZGVCZWZvcmUubmFtZSA9PSAnb2wnKSkgewogICAgICAvLyBJbiBtb3N0IGNhc2VzIHdoZW4gdmlldyBwb3NpdGlvbiBpcyBpbiA8bGk+IGl0IGlzIGluIHRleHQgYW5kIHRoaXMgaXMgYSBjb3JyZWN0IHBvc2l0aW9uLgogICAgICAvLyBIb3dldmVyLCBpZiBwb3NpdGlvbiBpcyBhZnRlciA8dWw+IG9yIDxvbD4gd2UgaGF2ZSB0byBmaXggaXQgLS0gYmVjYXVzZSBpbiBtb2RlbCA8dWw+LzxvbD4gYXJlIG5vdCBpbiB0aGUgYGxpc3RJdGVtYC4KICAgICAgY29uc3QgbW9kZWxOb2RlID0gbWFwcGVyLnRvTW9kZWxFbGVtZW50KHZpZXdQYXJlbnQpOyAvLyBDaGVjayBhbGwgPHVsPnMgYW5kIDxvbD5zIHRoYXQgYXJlIGluIHRoZSA8bGk+IGJ1dCBiZWZvcmUgbWFwcGVkIHBvc2l0aW9uLgogICAgICAvLyBHZXQgbW9kZWwgbGVuZ3RoIG9mIHRob3NlIGVsZW1lbnRzIGFuZCB0aGVuIGFkZCBpdCB0byB0aGUgb2Zmc2V0IG9mIGBsaXN0SXRlbWAgbWFwcGVkIHRvIHRoZSBvcmlnaW5hbCA8bGk+LgoKICAgICAgbGV0IG1vZGVsTGVuZ3RoID0gMTsgLy8gU3RhcnRzIGZyb20gMSBiZWNhdXNlIHRoZSBvcmlnaW5hbCA8bGk+IGhhcyB0byBiZSBjb3VudGVkIGluIHRvby4KCiAgICAgIGxldCB2aWV3TGlzdCA9IHZpZXdQb3Mubm9kZUJlZm9yZTsKCiAgICAgIHdoaWxlICh2aWV3TGlzdCAmJiBpc0xpc3Qodmlld0xpc3QpKSB7CiAgICAgICAgbW9kZWxMZW5ndGggKz0gbWFwcGVyLmdldE1vZGVsTGVuZ3RoKHZpZXdMaXN0KTsKICAgICAgICB2aWV3TGlzdCA9IHZpZXdMaXN0LnByZXZpb3VzU2libGluZzsKICAgICAgfQoKICAgICAgZGF0YS5tb2RlbFBvc2l0aW9uID0gbW9kZWwuY3JlYXRlUG9zaXRpb25CZWZvcmUobW9kZWxOb2RlKS5nZXRTaGlmdGVkQnkobW9kZWxMZW5ndGgpOwogICAgICBldnQuc3RvcCgpOwogICAgfQogIH07Cn0KLyoqCiAqIFBvc3QtZml4ZXIgdGhhdCByZWFjdHMgdG8gY2hhbmdlcyBvbiBkb2N1bWVudCBhbmQgZml4ZXMgaW5jb3JyZWN0IG1vZGVsIHN0YXRlcy4KICoKICogSW4gdGhlIGV4YW1wbGUgYmVsb3csIHRoZXJlIGlzIGEgY29ycmVjdCBsaXN0IHN0cnVjdHVyZS4KICogVGhlbiB0aGUgbWlkZGxlIGVsZW1lbnQgaXMgcmVtb3ZlZCBzbyB0aGUgbGlzdCBzdHJ1Y3R1cmUgd2lsbCBiZWNvbWUgaW5jb3JyZWN0OgogKgogKgkJPGxpc3RJdGVtIGxpc3RUeXBlPSJidWxsZXRlZCIgbGlzdEluZGVudD0wPkl0ZW0gMTwvbGlzdEl0ZW0+CiAqCQk8bGlzdEl0ZW0gbGlzdFR5cGU9ImJ1bGxldGVkIiBsaXN0SW5kZW50PTE+SXRlbSAyPC9saXN0SXRlbT4gICA8LS0tIHRoaXMgaXMgcmVtb3ZlZC4KICoJCTxsaXN0SXRlbSBsaXN0VHlwZT0iYnVsbGV0ZWQiIGxpc3RJbmRlbnQ9Mj5JdGVtIDM8L2xpc3RJdGVtPgogKgogKiBUaGUgbGlzdCBzdHJ1Y3R1cmUgYWZ0ZXIgdGhlIG1pZGRsZSBlbGVtZW50IGlzIHJlbW92ZWQ6CiAqCiAqIAkJPGxpc3RJdGVtIGxpc3RUeXBlPSJidWxsZXRlZCIgbGlzdEluZGVudD0wPkl0ZW0gMTwvbGlzdEl0ZW0+CiAqCQk8bGlzdEl0ZW0gbGlzdFR5cGU9ImJ1bGxldGVkIiBsaXN0SW5kZW50PTI+SXRlbSAzPC9saXN0SXRlbT4KICoKICogU2hvdWxkIGJlY29tZToKICoKICoJCTxsaXN0SXRlbSBsaXN0VHlwZT0iYnVsbGV0ZWQiIGxpc3RJbmRlbnQ9MD5JdGVtIDE8L2xpc3RJdGVtPgogKgkJPGxpc3RJdGVtIGxpc3RUeXBlPSJidWxsZXRlZCIgbGlzdEluZGVudD0xPkl0ZW0gMzwvbGlzdEl0ZW0+ICAgPC0tLSBub3RlIHRoYXQgaW5kZW50IGdvdCBwb3N0LWZpeGVkLgogKgogKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvbW9kZWx+TW9kZWx9IG1vZGVsIFRoZSBkYXRhIG1vZGVsLgogKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvd3JpdGVyfldyaXRlcn0gd3JpdGVyIFRoZSB3cml0ZXIgdG8gZG8gY2hhbmdlcyB3aXRoLgogKiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIGFueSBjaGFuZ2UgaGFzIGJlZW4gYXBwbGllZCwgYGZhbHNlYCBvdGhlcndpc2UuCiAqLwoKZXhwb3J0IGZ1bmN0aW9uIG1vZGVsQ2hhbmdlUG9zdEZpeGVyKG1vZGVsLCB3cml0ZXIpIHsKICBjb25zdCBjaGFuZ2VzID0gbW9kZWwuZG9jdW1lbnQuZGlmZmVyLmdldENoYW5nZXMoKTsKICBjb25zdCBpdGVtVG9MaXN0SGVhZCA9IG5ldyBNYXAoKTsKICBsZXQgYXBwbGllZCA9IGZhbHNlOwoKICBmb3IgKGNvbnN0IGVudHJ5IG9mIGNoYW5nZXMpIHsKICAgIGlmIChlbnRyeS50eXBlID09ICdpbnNlcnQnICYmIGVudHJ5Lm5hbWUgPT0gJ2xpc3RJdGVtJykgewogICAgICBfYWRkTGlzdFRvRml4KGVudHJ5LnBvc2l0aW9uKTsKICAgIH0gZWxzZSBpZiAoZW50cnkudHlwZSA9PSAnaW5zZXJ0JyAmJiBlbnRyeS5uYW1lICE9ICdsaXN0SXRlbScpIHsKICAgICAgaWYgKGVudHJ5Lm5hbWUgIT0gJyR0ZXh0JykgewogICAgICAgIC8vIEluIGNhc2Ugb2YgcmVuYW1lZCBlbGVtZW50LgogICAgICAgIGNvbnN0IGl0ZW0gPSBlbnRyeS5wb3NpdGlvbi5ub2RlQWZ0ZXI7CgogICAgICAgIGlmIChpdGVtLmhhc0F0dHJpYnV0ZSgnbGlzdEluZGVudCcpKSB7CiAgICAgICAgICB3cml0ZXIucmVtb3ZlQXR0cmlidXRlKCdsaXN0SW5kZW50JywgaXRlbSk7CiAgICAgICAgICBhcHBsaWVkID0gdHJ1ZTsKICAgICAgICB9CgogICAgICAgIGlmIChpdGVtLmhhc0F0dHJpYnV0ZSgnbGlzdFR5cGUnKSkgewogICAgICAgICAgd3JpdGVyLnJlbW92ZUF0dHJpYnV0ZSgnbGlzdFR5cGUnLCBpdGVtKTsKICAgICAgICAgIGFwcGxpZWQgPSB0cnVlOwogICAgICAgIH0KCiAgICAgICAgZm9yIChjb25zdCBpbm5lckl0ZW0gb2YgQXJyYXkuZnJvbShtb2RlbC5jcmVhdGVSYW5nZUluKGl0ZW0pKS5maWx0ZXIoZSA9PiBlLml0ZW0uaXMoJ2xpc3RJdGVtJykpKSB7CiAgICAgICAgICBfYWRkTGlzdFRvRml4KGlubmVySXRlbS5wcmV2aW91c1Bvc2l0aW9uKTsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIGNvbnN0IHBvc0FmdGVyID0gZW50cnkucG9zaXRpb24uZ2V0U2hpZnRlZEJ5KGVudHJ5Lmxlbmd0aCk7CgogICAgICBfYWRkTGlzdFRvRml4KHBvc0FmdGVyKTsKICAgIH0gZWxzZSBpZiAoZW50cnkudHlwZSA9PSAncmVtb3ZlJyAmJiBlbnRyeS5uYW1lID09ICdsaXN0SXRlbScpIHsKICAgICAgX2FkZExpc3RUb0ZpeChlbnRyeS5wb3NpdGlvbik7CiAgICB9IGVsc2UgaWYgKGVudHJ5LnR5cGUgPT0gJ2F0dHJpYnV0ZScgJiYgZW50cnkuYXR0cmlidXRlS2V5ID09ICdsaXN0SW5kZW50JykgewogICAgICBfYWRkTGlzdFRvRml4KGVudHJ5LnJhbmdlLnN0YXJ0KTsKICAgIH0gZWxzZSBpZiAoZW50cnkudHlwZSA9PSAnYXR0cmlidXRlJyAmJiBlbnRyeS5hdHRyaWJ1dGVLZXkgPT0gJ2xpc3RUeXBlJykgewogICAgICBfYWRkTGlzdFRvRml4KGVudHJ5LnJhbmdlLnN0YXJ0KTsKICAgIH0KICB9CgogIGZvciAoY29uc3QgbGlzdEhlYWQgb2YgaXRlbVRvTGlzdEhlYWQudmFsdWVzKCkpIHsKICAgIF9maXhMaXN0SW5kZW50cyhsaXN0SGVhZCk7CgogICAgX2ZpeExpc3RUeXBlcyhsaXN0SGVhZCk7CiAgfQoKICByZXR1cm4gYXBwbGllZDsKCiAgZnVuY3Rpb24gX2FkZExpc3RUb0ZpeChwb3NpdGlvbikgewogICAgY29uc3QgcHJldiA9IHBvc2l0aW9uLm5vZGVCZWZvcmU7CgogICAgaWYgKCFwcmV2IHx8ICFwcmV2LmlzKCdsaXN0SXRlbScpKSB7CiAgICAgIGNvbnN0IGl0ZW0gPSBwb3NpdGlvbi5ub2RlQWZ0ZXI7CgogICAgICBpZiAoaXRlbSAmJiBpdGVtLmlzKCdsaXN0SXRlbScpKSB7CiAgICAgICAgaXRlbVRvTGlzdEhlYWQuc2V0KGl0ZW0sIGl0ZW0pOwogICAgICB9CiAgICB9IGVsc2UgewogICAgICBsZXQgbGlzdEhlYWQgPSBwcmV2OwoKICAgICAgaWYgKGl0ZW1Ub0xpc3RIZWFkLmhhcyhsaXN0SGVhZCkpIHsKICAgICAgICByZXR1cm47CiAgICAgIH0KCiAgICAgIHdoaWxlIChsaXN0SGVhZC5wcmV2aW91c1NpYmxpbmcgJiYgbGlzdEhlYWQucHJldmlvdXNTaWJsaW5nLmlzKCdsaXN0SXRlbScpKSB7CiAgICAgICAgbGlzdEhlYWQgPSBsaXN0SGVhZC5wcmV2aW91c1NpYmxpbmc7CgogICAgICAgIGlmIChpdGVtVG9MaXN0SGVhZC5oYXMobGlzdEhlYWQpKSB7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICB9CgogICAgICBpdGVtVG9MaXN0SGVhZC5zZXQocG9zaXRpb24ubm9kZUJlZm9yZSwgbGlzdEhlYWQpOwogICAgfQogIH0KCiAgZnVuY3Rpb24gX2ZpeExpc3RJbmRlbnRzKGl0ZW0pIHsKICAgIGxldCBtYXhJbmRlbnQgPSAwOwogICAgbGV0IGZpeEJ5ID0gbnVsbDsKCiAgICB3aGlsZSAoaXRlbSAmJiBpdGVtLmlzKCdsaXN0SXRlbScpKSB7CiAgICAgIGNvbnN0IGl0ZW1JbmRlbnQgPSBpdGVtLmdldEF0dHJpYnV0ZSgnbGlzdEluZGVudCcpOwoKICAgICAgaWYgKGl0ZW1JbmRlbnQgPiBtYXhJbmRlbnQpIHsKICAgICAgICBsZXQgbmV3SW5kZW50OwoKICAgICAgICBpZiAoZml4QnkgPT09IG51bGwpIHsKICAgICAgICAgIGZpeEJ5ID0gaXRlbUluZGVudCAtIG1heEluZGVudDsKICAgICAgICAgIG5ld0luZGVudCA9IG1heEluZGVudDsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgaWYgKGZpeEJ5ID4gaXRlbUluZGVudCkgewogICAgICAgICAgICBmaXhCeSA9IGl0ZW1JbmRlbnQ7CiAgICAgICAgICB9CgogICAgICAgICAgbmV3SW5kZW50ID0gaXRlbUluZGVudCAtIGZpeEJ5OwogICAgICAgIH0KCiAgICAgICAgd3JpdGVyLnNldEF0dHJpYnV0ZSgnbGlzdEluZGVudCcsIG5ld0luZGVudCwgaXRlbSk7CiAgICAgICAgYXBwbGllZCA9IHRydWU7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgZml4QnkgPSBudWxsOwogICAgICAgIG1heEluZGVudCA9IGl0ZW0uZ2V0QXR0cmlidXRlKCdsaXN0SW5kZW50JykgKyAxOwogICAgICB9CgogICAgICBpdGVtID0gaXRlbS5uZXh0U2libGluZzsKICAgIH0KICB9CgogIGZ1bmN0aW9uIF9maXhMaXN0VHlwZXMoaXRlbSkgewogICAgbGV0IHR5cGVzU3RhY2sgPSBbXTsKICAgIGxldCBwcmV2ID0gbnVsbDsKCiAgICB3aGlsZSAoaXRlbSAmJiBpdGVtLmlzKCdsaXN0SXRlbScpKSB7CiAgICAgIGNvbnN0IGl0ZW1JbmRlbnQgPSBpdGVtLmdldEF0dHJpYnV0ZSgnbGlzdEluZGVudCcpOwoKICAgICAgaWYgKHByZXYgJiYgcHJldi5nZXRBdHRyaWJ1dGUoJ2xpc3RJbmRlbnQnKSA+IGl0ZW1JbmRlbnQpIHsKICAgICAgICB0eXBlc1N0YWNrID0gdHlwZXNTdGFjay5zbGljZSgwLCBpdGVtSW5kZW50ICsgMSk7CiAgICAgIH0KCiAgICAgIGlmIChpdGVtSW5kZW50ICE9IDApIHsKICAgICAgICBpZiAodHlwZXNTdGFja1tpdGVtSW5kZW50XSkgewogICAgICAgICAgY29uc3QgdHlwZSA9IHR5cGVzU3RhY2tbaXRlbUluZGVudF07CgogICAgICAgICAgaWYgKGl0ZW0uZ2V0QXR0cmlidXRlKCdsaXN0VHlwZScpICE9IHR5cGUpIHsKICAgICAgICAgICAgd3JpdGVyLnNldEF0dHJpYnV0ZSgnbGlzdFR5cGUnLCB0eXBlLCBpdGVtKTsKICAgICAgICAgICAgYXBwbGllZCA9IHRydWU7CiAgICAgICAgICB9CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHR5cGVzU3RhY2tbaXRlbUluZGVudF0gPSBpdGVtLmdldEF0dHJpYnV0ZSgnbGlzdFR5cGUnKTsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIHByZXYgPSBpdGVtOwogICAgICBpdGVtID0gaXRlbS5uZXh0U2libGluZzsKICAgIH0KICB9Cn0KLyoqCiAqIEEgZml4ZXIgZm9yIHBhc3RlZCBjb250ZW50IHRoYXQgaW5jbHVkZXMgbGlzdCBpdGVtcy4KICoKICogSXQgZml4ZXMgaW5kZW50YXRpb24gb2YgcGFzdGVkIGxpc3QgaXRlbXMgc28gdGhlIHBhc3RlZCBpdGVtcyBtYXRjaCBjb3JyZWN0bHkgdG8gdGhlIGNvbnRleHQgdGhleSBhcmUgcGFzdGVkIGludG8uCiAqCiAqIEV4YW1wbGU6CiAqCiAqCQk8bGlzdEl0ZW0gbGlzdFR5cGU9ImJ1bGxldGVkIiBsaXN0SW5kZW50PTA+QTwvbGlzdEl0ZW0+CiAqCQk8bGlzdEl0ZW0gbGlzdFR5cGU9ImJ1bGxldGVkIiBsaXN0SW5kZW50PTE+Ql48L2xpc3RJdGVtPgogKgkJLy8gQXQgXiBwYXN0ZTogIDxsaXN0SXRlbSBsaXN0VHlwZT0iYnVsbGV0ZWQiIGxpc3RJbmRlbnQ9ND5YPC9saXN0SXRlbT4KICoJCS8vICAgICAgICAgICAgICA8bGlzdEl0ZW0gbGlzdFR5cGU9ImJ1bGxldGVkIiBsaXN0SW5kZW50PTU+WTwvbGlzdEl0ZW0+CiAqCQk8bGlzdEl0ZW0gbGlzdFR5cGU9ImJ1bGxldGVkIiBsaXN0SW5kZW50PTI+QzwvbGlzdEl0ZW0+CiAqCiAqIFNob3VsZCBiZWNvbWU6CiAqCiAqCQk8bGlzdEl0ZW0gbGlzdFR5cGU9ImJ1bGxldGVkIiBsaXN0SW5kZW50PTA+QTwvbGlzdEl0ZW0+CiAqCQk8bGlzdEl0ZW0gbGlzdFR5cGU9ImJ1bGxldGVkIiBsaXN0SW5kZW50PTE+Qlg8L2xpc3RJdGVtPgogKgkJPGxpc3RJdGVtIGxpc3RUeXBlPSJidWxsZXRlZCIgbGlzdEluZGVudD0yPlkvbGlzdEl0ZW0+CiAqCQk8bGlzdEl0ZW0gbGlzdFR5cGU9ImJ1bGxldGVkIiBsaXN0SW5kZW50PTI+QzwvbGlzdEl0ZW0+CiAqCiAqIEBwYXJhbSB7bW9kdWxlOnV0aWxzL2V2ZW50aW5mb35FdmVudEluZm99IGV2dCBBbiBvYmplY3QgY29udGFpbmluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgZmlyZWQgZXZlbnQuCiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgQXJndW1lbnRzIG9mIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL21vZGVsfk1vZGVsI2luc2VydENvbnRlbnR9LgogKi8KCmV4cG9ydCBmdW5jdGlvbiBtb2RlbEluZGVudFBhc3RlRml4ZXIoZXZ0LCBbY29udGVudCwgc2VsZWN0YWJsZV0pIHsKICAvLyBDaGVjayB3aGV0aGVyIGluc2VydGVkIGNvbnRlbnQgc3RhcnRzIGZyb20gYSBgbGlzdEl0ZW1gLiBJZiBpdCBkb2VzIG5vdCwgaXQgbWVhbnMgdGhhdCB0aGVyZSBhcmUgc29tZSBvdGhlcgogIC8vIGVsZW1lbnRzIGJlZm9yZSBpdCBhbmQgdGhlcmUgaXMgbm8gbmVlZCB0byBmaXggaW5kZW50cywgYmVjYXVzZSBldmVuIGlmIHdlIGluc2VydCB0aGF0IGNvbnRlbnQgaW50byBhIGxpc3QsCiAgLy8gdGhhdCBsaXN0IHdpbGwgYmUgYnJva2VuLgogIC8vIE5vdGU6IHdlIGFsc28gbmVlZCB0byBoYW5kbGUgc2luZ3VsYXIgZWxlbWVudHMgYmVjYXVzZSBpbnNlcnRpbmcgaXRlbSB3aXRoIGluZGVudCAwIGludG8gMCwxLFtdLDIKICAvLyB3b3VsZCBjcmVhdGUgaW5jb3JyZWN0IG1vZGVsLgogIGxldCBpdGVtID0gY29udGVudC5pcygnZG9jdW1lbnRGcmFnbWVudCcpID8gY29udGVudC5nZXRDaGlsZCgwKSA6IGNvbnRlbnQ7CiAgbGV0IHNlbGVjdGlvbjsKCiAgaWYgKCFzZWxlY3RhYmxlKSB7CiAgICBzZWxlY3Rpb24gPSB0aGlzLmRvY3VtZW50LnNlbGVjdGlvbjsKICB9IGVsc2UgewogICAgc2VsZWN0aW9uID0gdGhpcy5jcmVhdGVTZWxlY3Rpb24oc2VsZWN0YWJsZSk7CiAgfQoKICBpZiAoaXRlbSAmJiBpdGVtLmlzKCdsaXN0SXRlbScpKSB7CiAgICAvLyBHZXQgYSByZWZlcmVuY2UgbGlzdCBpdGVtLiBJbnNlcnRlZCBsaXN0IGl0ZW1zIHdpbGwgYmUgZml4ZWQgYWNjb3JkaW5nIHRvIHRoYXQgaXRlbS4KICAgIGNvbnN0IHBvcyA9IHNlbGVjdGlvbi5nZXRGaXJzdFBvc2l0aW9uKCk7CiAgICBsZXQgcmVmSXRlbSA9IG51bGw7CgogICAgaWYgKHBvcy5wYXJlbnQuaXMoJ2xpc3RJdGVtJykpIHsKICAgICAgcmVmSXRlbSA9IHBvcy5wYXJlbnQ7CiAgICB9IGVsc2UgaWYgKHBvcy5ub2RlQmVmb3JlICYmIHBvcy5ub2RlQmVmb3JlLmlzKCdsaXN0SXRlbScpKSB7CiAgICAgIHJlZkl0ZW0gPSBwb3Mubm9kZUJlZm9yZTsKICAgIH0gLy8gSWYgdGhlcmUgaXMgYHJlZkl0ZW1gIGl0IG1lYW5zIHRoYXQgd2UgZG8gaW5zZXJ0IGxpc3QgaXRlbXMgaW50byBhbiBleGlzdGluZyBsaXN0LgoKCiAgICBpZiAocmVmSXRlbSkgewogICAgICAvLyBGaXJzdCBsaXN0IGl0ZW0gaW4gYGRhdGFgIGhhcyBpbmRlbnQgZXF1YWwgdG8gMCAoaXQgaXMgYSBmaXJzdCBsaXN0IGl0ZW0pLiBJdCBzaG91bGQgaGF2ZSBpbmRlbnQgZXF1YWwKICAgICAgLy8gdG8gdGhlIGluZGVudCBvZiByZWZlcmVuY2UgaXRlbS4gV2UgaGF2ZSB0byBmaXggdGhlIGZpcnN0IGl0ZW0gYW5kIGFsbCBvZiBpdCdzIGNoaWxkcmVuIGFuZCBmb2xsb3dpbmcgc2libGluZ3MuCiAgICAgIC8vIEluZGVudCBvZiBhbGwgdGhvc2UgaXRlbXMgaGFzIHRvIGJlIGFkanVzdGVkIHRvIHJlZmVyZW5jZSBpdGVtLgogICAgICBjb25zdCBpbmRlbnRDaGFuZ2UgPSByZWZJdGVtLmdldEF0dHJpYnV0ZSgnbGlzdEluZGVudCcpOyAvLyBGaXggb25seSBpZiB0aGVyZSBpcyBhbnl0aGluZyB0byBmaXguCgogICAgICBpZiAoaW5kZW50Q2hhbmdlID4gMCkgewogICAgICAgIC8vIEFkanVzdCBpbmRlbnQgb2YgYWxsICJmaXJzdCIgbGlzdCBpdGVtcyBpbiBpbnNlcnRlZCBkYXRhLgogICAgICAgIHdoaWxlIChpdGVtICYmIGl0ZW0uaXMoJ2xpc3RJdGVtJykpIHsKICAgICAgICAgIGl0ZW0uX3NldEF0dHJpYnV0ZSgnbGlzdEluZGVudCcsIGl0ZW0uZ2V0QXR0cmlidXRlKCdsaXN0SW5kZW50JykgKyBpbmRlbnRDaGFuZ2UpOwoKICAgICAgICAgIGl0ZW0gPSBpdGVtLm5leHRTaWJsaW5nOwogICAgICAgIH0KICAgICAgfQogICAgfQogIH0KfSAvLyBIZWxwZXIgZnVuY3Rpb24gdGhhdCBjb252ZXJ0cyBjaGlsZHJlbiBvZiBhIGdpdmVuIGA8bGk+YCB2aWV3IGVsZW1lbnQgaW50byBjb3JyZXNwb25kaW5nIG1vZGVsIGVsZW1lbnRzLgovLyBUaGUgZnVuY3Rpb24gbWFpbnRhaW5zIHByb3BlciBvcmRlciBvZiBlbGVtZW50cyBpZiBtb2RlbCBgbGlzdEl0ZW1gIGlzIHNwbGl0IGR1cmluZyB0aGUgY29udmVyc2lvbgovLyBkdWUgdG8gYmxvY2sgY2hpbGRyZW4gY29udmVyc2lvbi4KLy8KLy8gQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudH0gbGlzdEl0ZW1Nb2RlbCBMaXN0IGl0ZW0gbW9kZWwgZWxlbWVudCB0byB3aGljaCBjb252ZXJ0ZWQgY2hpbGRyZW4gd2lsbCBiZSBpbnNlcnRlZC4KLy8gQHBhcmFtIHtJdGVyYWJsZS48bW9kdWxlOmVuZ2luZS92aWV3L25vZGV+Tm9kZT59IHZpZXdDaGlsZHJlbiBWaWV3IGVsZW1lbnRzIHdoaWNoIHdpbGwgYmUgY29udmVydGVkLgovLyBAcGFyYW0ge21vZHVsZTplbmdpbmUvY29udmVyc2lvbi91cGNhc3RkaXNwYXRjaGVyflVwY2FzdENvbnZlcnNpb25BcGl9IGNvbnZlcnNpb25BcGkgQ29udmVyc2lvbiBpbnRlcmZhY2UgdG8gYmUgdXNlZCBieSB0aGUgY2FsbGJhY2suCi8vIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufSBQb3NpdGlvbiBvbiB3aGljaCBuZXh0IGVsZW1lbnRzIHNob3VsZCBiZSBpbnNlcnRlZCBhZnRlciBjaGlsZHJlbiBjb252ZXJzaW9uLgoKZnVuY3Rpb24gdmlld1RvTW9kZWxMaXN0SXRlbUNoaWxkcmVuQ29udmVydGVyKGxpc3RJdGVtTW9kZWwsIHZpZXdDaGlsZHJlbiwgY29udmVyc2lvbkFwaSkgewogIGNvbnN0IHsKICAgIHdyaXRlciwKICAgIHNjaGVtYQogIH0gPSBjb252ZXJzaW9uQXBpOyAvLyBBIHBvc2l0aW9uIGFmdGVyIHRoZSBsYXN0IGluc2VydGVkIGBsaXN0SXRlbWAuCgogIGxldCBuZXh0UG9zaXRpb24gPSB3cml0ZXIuY3JlYXRlUG9zaXRpb25BZnRlcihsaXN0SXRlbU1vZGVsKTsgLy8gQ2hlY2sgYWxsIGNoaWxkcmVuIG9mIHRoZSBjb252ZXJ0ZWQgYDxsaT5gLiBBdCB0aGlzIHBvaW50IHdlIGFzc3VtZSB0aGVyZSBhcmUgbm8gIndoaXRlc3BhY2UiIHZpZXcgdGV4dCBub2RlcwogIC8vIGluIHZpZXcgbGlzdCwgYmV0d2VlbiB2aWV3IGxpc3QgaXRlbXMuIFRoaXMgc2hvdWxkIGJlIGhhbmRsZWQgYnkgYDx1bD5gIGFuZCBgPG9sPmAgY29udmVydGVycy4KCiAgZm9yIChjb25zdCBjaGlsZCBvZiB2aWV3Q2hpbGRyZW4pIHsKICAgIGlmIChjaGlsZC5uYW1lID09ICd1bCcgfHwgY2hpbGQubmFtZSA9PSAnb2wnKSB7CiAgICAgIC8vIElmIHRoZSBjaGlsZHJlbiBpcyBhIGxpc3QsIHdlIHdpbGwgaW5zZXJ0IGl0cyBjb252ZXJzaW9uIHJlc3VsdCBhZnRlciBjdXJyZW50bHkgaGFuZGxlZCBgbGlzdEl0ZW1gLgogICAgICAvLyBUaGVuLCBuZXh0IGluc2VydGlvbiBwb3NpdGlvbiB3aWxsIGJlIHNldCBhZnRlciBhbGwgdGhlIG5ldyBsaXN0IGl0ZW1zIChhbmQgbWF5YmUgb3RoZXIgZWxlbWVudHMgaWYKICAgICAgLy8gc29tZXRoaW5nIHNwbGl0IGxpc3QgaXRlbSkuCiAgICAgIC8vCiAgICAgIC8vIElmIHRoaXMgaXMgYSBsaXN0LCB3ZSBleHBlY3QgdGhhdCBzb21lIGBsaXN0SXRlbWBzIGFuZCBwb3NzaWJseSBvdGhlciBibG9ja3Mgd2lsbCBiZSBpbnNlcnRlZCwgaG93ZXZlciBgLm1vZGVsQ3Vyc29yYAogICAgICAvLyBzaG91bGQgYmUgc2V0IGFmdGVyIGxhc3QgYGxpc3RJdGVtYCAob3IgYmxvY2spLiBUaGlzIGlzIHdoeSBpdCBmZWVscyBzYWZlIHRvIHVzZSBpdCBhcyBgbmV4dFBvc2l0aW9uYAogICAgICBuZXh0UG9zaXRpb24gPSBjb252ZXJzaW9uQXBpLmNvbnZlcnRJdGVtKGNoaWxkLCBuZXh0UG9zaXRpb24pLm1vZGVsQ3Vyc29yOwogICAgfSBlbHNlIHsKICAgICAgLy8gSWYgdGhpcyBpcyBub3QgYSBsaXN0LCB0cnkgaW5zZXJ0aW5nIGNvbnRlbnQgYXQgdGhlIGVuZCBvZiB0aGUgY3VycmVudGx5IGhhbmRsZWQgYGxpc3RJdGVtYC4KICAgICAgY29uc3QgcmVzdWx0ID0gY29udmVyc2lvbkFwaS5jb252ZXJ0SXRlbShjaGlsZCwgd3JpdGVyLmNyZWF0ZVBvc2l0aW9uQXQobGlzdEl0ZW1Nb2RlbCwgJ2VuZCcpKTsgLy8gSXQgbWF5IGVuZCB1cCB0aGF0IHRoZSBjdXJyZW50IGBsaXN0SXRlbWAgYmVjb21lcyBzcGxpdCAoaWYgdGhhdCBjb250ZW50IGNhbm5vdCBiZSBpbnNpZGUgYGxpc3RJdGVtYCkuIEZvciBleGFtcGxlOgogICAgICAvLwogICAgICAvLyA8bGk+PHA+Rm9vPC9wPjwvbGk+CiAgICAgIC8vCiAgICAgIC8vIHdpbGwgYmUgY29udmVydGVkIHRvOgogICAgICAvLwogICAgICAvLyA8bGlzdEl0ZW0+PC9saXN0SXRlbT48cGFyYWdyYXBoPkZvbzwvcGFyYWdyYXBoPjxsaXN0SXRlbT48L2xpc3RJdGVtPgogICAgICAvLwoKICAgICAgY29uc3QgY29udmVydGVkQ2hpbGQgPSByZXN1bHQubW9kZWxSYW5nZS5zdGFydC5ub2RlQWZ0ZXI7CiAgICAgIGNvbnN0IHdhc1NwbGl0ID0gY29udmVydGVkQ2hpbGQgJiYgY29udmVydGVkQ2hpbGQuaXMoJ2VsZW1lbnQnKSAmJiAhc2NoZW1hLmNoZWNrQ2hpbGQobGlzdEl0ZW1Nb2RlbCwgY29udmVydGVkQ2hpbGQubmFtZSk7CgogICAgICBpZiAod2FzU3BsaXQpIHsKICAgICAgICAvLyBBcyBgbGFzdExpc3RJdGVtYCBnb3Qgc3BsaXQsIHdlIG5lZWQgdG8gdXBkYXRlIGl0IHRvIHRoZSBzZWNvbmQgcGFydCBvZiB0aGUgc3BsaXQgYGxpc3RJdGVtYCBlbGVtZW50LgogICAgICAgIC8vCiAgICAgICAgLy8gYG1vZGVsQ3Vyc29yYCBzaG91bGQgYmUgc2V0IHRvIGEgcG9zaXRpb24gd2hlcmUgdGhlIGNvbnZlcnNpb24gc2hvdWxkIGNvbnRpbnVlLiBUaGVyZSBhcmUgbXVsdGlwbGUgcG9zc2libGUgc2NlbmFyaW9zCiAgICAgICAgLy8gdGhhdCBtYXkgaGFwcGVuLiBVc3VhbGx5LCBgbW9kZWxDdXJzb3JgIChtYXJrZWQgYXMgYCNgIGJlbG93KSB3b3VsZCBwb2ludCB0byB0aGUgc2Vjb25kIGxpc3QgaXRlbSBhZnRlciBjb252ZXJzaW9uOgogICAgICAgIC8vCiAgICAgICAgLy8JCWA8bGk+PHA+Rm9vPC9wPjwvbGk+YCAtPiBgPGxpc3RJdGVtPjwvbGlzdEl0ZW0+PHBhcmFncmFwaD5Gb288L3BhcmFncmFwaD48bGlzdEl0ZW0+IzwvbGlzdEl0ZW0+YAogICAgICAgIC8vCiAgICAgICAgLy8gSG93ZXZlciwgaW4gc29tZSBjYXNlcywgbGlrZSBhdXRvLXBhcmFncmFwaGluZywgdGhlIHBvc2l0aW9uIGlzIHBsYWNlZCBhdCB0aGUgZW5kIG9mIHRoZSBibG9jayBlbGVtZW50OgogICAgICAgIC8vCiAgICAgICAgLy8JCWA8bGk+PGRpdj5Gb288L2Rpdj48L2xpPmAgLT4gYDxsaXN0SXRlbT48L2xpc3RJdGVtPjxwYXJhZ3JhcGg+Rm9vIzwvcGFyYWdyYXBoPjxsaXN0SXRlbT48L2xpc3RJdGVtPmAKICAgICAgICAvLwogICAgICAgIC8vIG9yIGFmdGVyIGFuIGVsZW1lbnQgaWYgYW5vdGhlciBlbGVtZW50IGJyb2tlbiBhdXRvLXBhcmFncmFwaGVkIGVsZW1lbnQ6CiAgICAgICAgLy8KICAgICAgICAvLwkJYDxsaT48ZGl2PjxoMj5Gb288L2gyPjwvZGl2PjwvbGk+YCAtPiBgPGxpc3RJdGVtPjwvbGlzdEl0ZW0+PGhlYWRpbmcxPkZvbzwvaGVhZGluZzE+IzxsaXN0SXRlbT48L2xpc3RJdGVtPmAKICAgICAgICAvLwogICAgICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgZm9yIHN1Y2ggY2FzZXMgYW5kIHVzZSBwcm9wZXIgbGlzdCBpdGVtIGFuZCBwb3NpdGlvbiBiYXNlZCBvbiBpdC4KICAgICAgICAvLwogICAgICAgIGlmIChyZXN1bHQubW9kZWxDdXJzb3IucGFyZW50LmlzKCdsaXN0SXRlbScpKSB7CiAgICAgICAgICAvLyAoMSkuCiAgICAgICAgICBsaXN0SXRlbU1vZGVsID0gcmVzdWx0Lm1vZGVsQ3Vyc29yLnBhcmVudDsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgLy8gKDIpLCAoMykuCiAgICAgICAgICBsaXN0SXRlbU1vZGVsID0gZmluZE5leHRMaXN0SXRlbShyZXN1bHQubW9kZWxDdXJzb3IpOwogICAgICAgIH0KCiAgICAgICAgbmV4dFBvc2l0aW9uID0gd3JpdGVyLmNyZWF0ZVBvc2l0aW9uQWZ0ZXIobGlzdEl0ZW1Nb2RlbCk7CiAgICAgIH0KICAgIH0KICB9CgogIHJldHVybiBuZXh0UG9zaXRpb247Cn0gLy8gSGVscGVyIGZ1bmN0aW9uIHRoYXQgc2Vla3MgZm9yIGEgbmV4dCBsaXN0IGl0ZW0gc3RhcnRpbmcgZnJvbSBnaXZlbiBgc3RhcnRQb3NpdGlvbmAuCgoKZnVuY3Rpb24gZmluZE5leHRMaXN0SXRlbShzdGFydFBvc2l0aW9uKSB7CiAgY29uc3QgdHJlZVdhbGtlciA9IG5ldyBUcmVlV2Fsa2VyKHsKICAgIHN0YXJ0UG9zaXRpb24KICB9KTsKICBsZXQgdmFsdWU7CgogIGRvIHsKICAgIHZhbHVlID0gdHJlZVdhbGtlci5uZXh0KCk7CiAgfSB3aGlsZSAoIXZhbHVlLnZhbHVlLml0ZW0uaXMoJ2xpc3RJdGVtJykpOwoKICByZXR1cm4gdmFsdWUudmFsdWUuaXRlbTsKfSAvLyBIZWxwZXIgZnVuY3Rpb24gdGhhdCB0YWtlcyBhbGwgY2hpbGRyZW4gb2YgZ2l2ZW4gYHZpZXdSZW1vdmVkSXRlbWAgYW5kIG1vdmVzIHRoZW0gaW4gYSBjb3JyZWN0IHBsYWNlLCBhY2NvcmRpbmcKLy8gdG8gb3RoZXIgZ2l2ZW4gcGFyYW1ldGVycy4KCgpmdW5jdGlvbiBob2lzdE5lc3RlZExpc3RzKG5leHRJbmRlbnQsIG1vZGVsUmVtb3ZlU3RhcnRQb3NpdGlvbiwgdmlld1JlbW92ZVN0YXJ0UG9zaXRpb24sIHZpZXdSZW1vdmVkSXRlbSwgY29udmVyc2lvbkFwaSwgbW9kZWwpIHsKICAvLyBGaW5kIGNvcnJlY3QgcHJldmlvdXMgbW9kZWwgbGlzdCBpdGVtIGVsZW1lbnQuCiAgLy8gVGhlIGVsZW1lbnQgaGFzIHRvIGhhdmUgZWl0aGVyIHNhbWUgb3Igc21hbGxlciBpbmRlbnQgdGhhbiBnaXZlbiByZWZlcmVuY2UgaW5kZW50LgogIC8vIFRoaXMgd2lsbCBiZSB0aGUgbW9kZWwgZWxlbWVudCB3aGljaCB3aWxsIGdldCBuZXN0ZWQgaXRlbXMgKGlmIGl0IGhhcyBzbWFsbGVyIGluZGVudCkgb3Igc2libGluZyBpdGVtcyAoaWYgaXQgaGFzIHNhbWUgaW5kZW50KS4KICAvLyBLZWVwIGluIG1pbmQgdGhhdCBzdWNoIGVsZW1lbnQgbWlnaHQgbm90IGJlIGZvdW5kLCBpZiByZW1vdmVkIGl0ZW0gd2FzIHRoZSBmaXJzdCBpdGVtLgogIGNvbnN0IHByZXZNb2RlbEl0ZW0gPSBnZXRTaWJsaW5nTGlzdEl0ZW0obW9kZWxSZW1vdmVTdGFydFBvc2l0aW9uLm5vZGVCZWZvcmUsIHsKICAgIHNhbWVJbmRlbnQ6IHRydWUsCiAgICBzbWFsbGVySW5kZW50OiB0cnVlLAogICAgbGlzdEluZGVudDogbmV4dEluZGVudCwKICAgIGZvbzogJ2InCiAgfSk7CiAgY29uc3QgbWFwcGVyID0gY29udmVyc2lvbkFwaS5tYXBwZXI7CiAgY29uc3Qgdmlld1dyaXRlciA9IGNvbnZlcnNpb25BcGkud3JpdGVyOyAvLyBJbmRlbnQgb2YgZm91bmQgZWxlbWVudCBvciBgbnVsbGAgaWYgdGhlIGVsZW1lbnQgaGFzIG5vdCBiZWVuIGZvdW5kLgoKICBjb25zdCBwcmV2SW5kZW50ID0gcHJldk1vZGVsSXRlbSA/IHByZXZNb2RlbEl0ZW0uZ2V0QXR0cmlidXRlKCdsaXN0SW5kZW50JykgOiBudWxsOwogIGxldCBpbnNlcnRQb3NpdGlvbjsKCiAgaWYgKCFwcmV2TW9kZWxJdGVtKSB7CiAgICAvLyBJZiBlbGVtZW50IGhhcyBub3QgYmVlbiBmb3VuZCwgc2ltcGx5IGluc2VydCBsaXN0cyBhdCB0aGUgcG9zaXRpb24gd2hlcmUgdGhlIHJlbW92ZWQgaXRlbSB3YXM6CiAgICAvLwogICAgLy8gTG9yZW0gaXBzdW0uCiAgICAvLyAxIC0tLS0tLS0tICAgICAgICAgICA8LS0tIHRoaXMgaXMgcmVtb3ZlZCwgbm8gcHJldmlvdXMgbGlzdCBpdGVtLCBwdXQgbmVzdGVkIGl0ZW1zIGluIHBsYWNlIG9mIHJlbW92ZWQgaXRlbS4KICAgIC8vICAgMS4xIC0tLS0tLS0tICAgICAgIDwtLS0gdGhpcyBpcyByZWZlcmVuY2UgaW5kZW50LgogICAgLy8gICAgIDEuMS4xIC0tLS0tLS0tCiAgICAvLyAgICAgMS4xLjIgLS0tLS0tLS0KICAgIC8vICAgMS4yIC0tLS0tLS0tCiAgICAvLwogICAgLy8gQmVjb21lczoKICAgIC8vCiAgICAvLyBMb3JlbSBpcHN1bS4KICAgIC8vIDEuMSAtLS0tLS0tLQogICAgLy8gICAxLjEuMSAtLS0tLS0tLQogICAgLy8gICAxLjEuMiAtLS0tLS0tLQogICAgLy8gMS4yIC0tLS0tLS0tCiAgICBpbnNlcnRQb3NpdGlvbiA9IHZpZXdSZW1vdmVTdGFydFBvc2l0aW9uOwogIH0gZWxzZSBpZiAocHJldkluZGVudCA9PSBuZXh0SW5kZW50KSB7CiAgICAvLyBJZiBlbGVtZW50IGhhcyBiZWVuIGZvdW5kIGFuZCBoYXMgc2FtZSBpbmRlbnQgYXMgcmVmZXJlbmNlIGluZGVudCBpdCBtZWFucyB0aGF0IG5lc3RlZCBpdGVtcyBzaG91bGQKICAgIC8vIGJlY29tZSBzaWJsaW5ncyBvZiBmb3VuZCBlbGVtZW50OgogICAgLy8KICAgIC8vIDEgLS0tLS0tLS0KICAgIC8vICAgMS4xIC0tLS0tLS0tCiAgICAvLyAgIDEuMiAtLS0tLS0tLSAgICAgICA8LS0tIHRoaXMgaXMgYHByZXZNb2RlbEl0ZW1gLgogICAgLy8gMiAtLS0tLS0tLSAgICAgICAgICAgPC0tLSB0aGlzIGlzIHJlbW92ZWQsIHByZXZpb3VzIGxpc3QgaXRlbSBoYXMgaW5kZW50IHNhbWUgYXMgcmVmZXJlbmNlIGluZGVudC4KICAgIC8vICAgMi4xIC0tLS0tLS0tICAgICAgIDwtLS0gdGhpcyBpcyByZWZlcmVuY2UgaW5kZW50LCB0aGlzIGFuZCAyLjIgc2hvdWxkIGJlY29tZSBzaWJsaW5ncyBvZiAxLjIuCiAgICAvLyAgIDIuMiAtLS0tLS0tLQogICAgLy8KICAgIC8vIEJlY29tZXM6CiAgICAvLwogICAgLy8gMSAtLS0tLS0tLQogICAgLy8gICAxLjEgLS0tLS0tLS0KICAgIC8vICAgMS4yIC0tLS0tLS0tCiAgICAvLyAgIDIuMSAtLS0tLS0tLQogICAgLy8gICAyLjIgLS0tLS0tLS0KICAgIGNvbnN0IHByZXZWaWV3TGlzdCA9IG1hcHBlci50b1ZpZXdFbGVtZW50KHByZXZNb2RlbEl0ZW0pLnBhcmVudDsKICAgIGluc2VydFBvc2l0aW9uID0gdmlld1dyaXRlci5jcmVhdGVQb3NpdGlvbkFmdGVyKHByZXZWaWV3TGlzdCk7CiAgfSBlbHNlIHsKICAgIC8vIElmIGVsZW1lbnQgaGFzIGJlZW4gZm91bmQgYW5kIGhhcyBzbWFsbGVyIGluZGVudCBhcyByZWZlcmVuY2UgaW5kZW50IGl0IG1lYW5zIHRoYXQgbmVzdGVkIGl0ZW1zCiAgICAvLyBzaG91bGQgYmVjb21lIG5lc3RlZCBpdGVtcyBvZiBmb3VuZCBpdGVtOgogICAgLy8KICAgIC8vIDEgLS0tLS0tLS0gICAgICAgICAgIDwtLS0gdGhpcyBpcyBgcHJldk1vZGVsSXRlbWAuCiAgICAvLyAgIDEuMSAtLS0tLS0tLSAgICAgICA8LS0tIHRoaXMgaXMgcmVtb3ZlZCwgcHJldmlvdXMgbGlzdCBpdGVtIGhhcyBpbmRlbnQgc21hbGxlciB0aGFuIHJlZmVyZW5jZSBpbmRlbnQuCiAgICAvLyAgICAgMS4xLjEgLS0tLS0tLS0gICA8LS0tIHRoaXMgaXMgcmVmZXJlbmNlIGluZGVudCwgdGhpcyBhbmQgMS4xLjEgc2hvdWxkIGJlY29tZSBuZXN0ZWQgaXRlbXMgb2YgMS4KICAgIC8vICAgICAxLjEuMiAtLS0tLS0tLQogICAgLy8gICAxLjIgLS0tLS0tLS0KICAgIC8vCiAgICAvLyBCZWNvbWVzOgogICAgLy8KICAgIC8vIDEgLS0tLS0tLS0KICAgIC8vICAgMS4xLjEgLS0tLS0tLS0KICAgIC8vICAgMS4xLjIgLS0tLS0tLS0KICAgIC8vICAgMS4yIC0tLS0tLS0tCiAgICAvLwogICAgLy8gTm90ZTogaW4gdGhpcyBjYXNlIDEuMS4xIGhhdmUgaW5kZW50IDIgd2hpbGUgMSBoYXZlIGluZGVudCAwLiBJbiBtb2RlbCB0aGF0IHNob3VsZCBub3QgYmUgcG9zc2libGUsCiAgICAvLyBiZWNhdXNlIGZvbGxvd2luZyBpdGVtIG1heSBoYXZlIGluZGVudCBiaWdnZXIgb25seSBieSBvbmUuIEJ1dCB0aGlzIGlzIGZpeGVkIGJ5IHBvc3RmaXhlci4KICAgIGNvbnN0IG1vZGVsUG9zaXRpb24gPSBtb2RlbC5jcmVhdGVQb3NpdGlvbkF0KHByZXZNb2RlbEl0ZW0sICdlbmQnKTsKICAgIGluc2VydFBvc2l0aW9uID0gbWFwcGVyLnRvVmlld1Bvc2l0aW9uKG1vZGVsUG9zaXRpb24pOwogIH0KCiAgaW5zZXJ0UG9zaXRpb24gPSBwb3NpdGlvbkFmdGVyVWlFbGVtZW50cyhpbnNlcnRQb3NpdGlvbik7IC8vIEhhbmRsZSBtdWx0aXBsZSBsaXN0cy4gVGhpcyBoYXBwZW5zIGlmIGxpc3QgaXRlbSBoYXMgbmVzdGVkIG51bWJlcmVkIGFuZCBidWxsZXRlZCBsaXN0cy4gRm9sbG93aW5nIGxpc3RzCiAgLy8gYXJlIGluc2VydGVkIGFmdGVyIHRoZSBmaXJzdCBsaXN0IChubyBuZWVkIHRvIHJlY2FsY3VsYXRlIGluc2VydGlvbiBwb3NpdGlvbiBmb3IgdGhlbSkuCgogIGZvciAoY29uc3QgY2hpbGQgb2YgWy4uLnZpZXdSZW1vdmVkSXRlbS5nZXRDaGlsZHJlbigpXSkgewogICAgaWYgKGlzTGlzdChjaGlsZCkpIHsKICAgICAgaW5zZXJ0UG9zaXRpb24gPSB2aWV3V3JpdGVyLm1vdmUodmlld1dyaXRlci5jcmVhdGVSYW5nZU9uKGNoaWxkKSwgaW5zZXJ0UG9zaXRpb24pLmVuZDsKICAgICAgbWVyZ2VWaWV3TGlzdHModmlld1dyaXRlciwgY2hpbGQsIGNoaWxkLm5leHRTaWJsaW5nKTsKICAgICAgbWVyZ2VWaWV3TGlzdHModmlld1dyaXRlciwgY2hpbGQucHJldmlvdXNTaWJsaW5nLCBjaGlsZCk7CiAgICB9CiAgfQp9IC8vIENoZWNrcyBpZiB2aWV3IGVsZW1lbnQgaXMgYSBsaXN0IHR5cGUgKHVsIG9yIG9sKS4KLy8KLy8gQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50fSB2aWV3RWxlbWVudAovLyBAcmV0dXJucyB7Qm9vbGVhbn0KCgpmdW5jdGlvbiBpc0xpc3Qodmlld0VsZW1lbnQpIHsKICByZXR1cm4gdmlld0VsZW1lbnQuaXMoJ29sJykgfHwgdmlld0VsZW1lbnQuaXMoJ3VsJyk7Cn0gLy8gQ2FsY3VsYXRlcyB0aGUgaW5kZW50IHZhbHVlIGZvciBhIGxpc3QgaXRlbS4gSGFuZGxlcyBIVE1MIGNvbXBsaWFudCBhbmQgbm9uLWNvbXBsaWFudCBsaXN0cy4KLy8KLy8gQWxzbywgZml4ZXMgbm9uIEhUTUwgY29tcGxpYW50IGxpc3RzIGluZGVudHM6Ci8vCi8vCQliZWZvcmU6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpeGVkIGxpc3Q6Ci8vCQlPTCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9MCi8vCQl8LT4gTEkgKHBhcmVudCBMSXM6IDApICAgICAgICAgICAgICAgICAgICAgIHwtPiBMSSAgICAgKGluZGVudDogMCkKLy8JCSAgICB8LT4gT0wgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfC0+IE9MCi8vCQkgICAgICAgIHwtPiBPTCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8Ci8vCQkgICAgICAgIHwgICB8LT4gT0wgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8Ci8vCQkgICAgICAgIHwgICAgICAgfC0+IE9MICAgICAgICAgICAgICAgICAgICAgICAgICB8Ci8vCQkgICAgICAgIHwgICAgICAgICAgIHwtPiBMSSAocGFyZW50IExJczogMSkgICAgICB8LT4gTEkgKGluZGVudDogMSkKLy8JCSAgICAgICAgfC0+IExJIChwYXJlbnQgTElzOiAxKSAgICAgICAgICAgICAgICAgIHwtPiBMSSAoaW5kZW50OiAxKQovLwovLwkJYmVmb3JlOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXhlZCBsaXN0OgovLwkJT0wgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPTAovLwkJfC0+IE9MICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8Ci8vCQkgICAgfC0+IE9MICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwKLy8JCSAgICAgICAgIHwtPiBPTCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfAovLwkJICAgICAgICAgICAgIHwtPiBMSSAocGFyZW50IExJczogMCkgICAgICAgICB8LT4gTEkgICAgICAgIChpbmRlbnQ6IDApCi8vCi8vCQliZWZvcmU6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpeGVkIGxpc3Q6Ci8vCQlPTCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9MCi8vCQl8LT4gTEkgKHBhcmVudCBMSXM6IDApICAgICAgICAgICAgICAgICAgICAgIHwtPiBMSSAgICAgICAgIChpbmRlbnQ6IDApCi8vCQl8LT4gT0wgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8LT4gT0wKLy8JCSAgICB8LT4gTEkgKHBhcmVudCBMSXM6IDApICAgICAgICAgICAgICAgICAgICAgICAgICB8LT4gTEkgKGluZGVudDogMSkKLy8KLy8gQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50fSBsaXN0SXRlbQovLyBAcGFyYW0ge09iamVjdH0gY29udmVyc2lvblN0b3JlCi8vIEByZXR1cm5zIHtOdW1iZXJ9CgoKZnVuY3Rpb24gZ2V0SW5kZW50KGxpc3RJdGVtKSB7CiAgbGV0IGluZGVudCA9IDA7CiAgbGV0IHBhcmVudCA9IGxpc3RJdGVtLnBhcmVudDsKCiAgd2hpbGUgKHBhcmVudCkgewogICAgLy8gRWFjaCBMSSBpbiB0aGUgdHJlZSB3aWxsIHJlc3VsdCBpbiBhbiBpbmNyZWFzZWQgaW5kZW50IGZvciBIVE1MIGNvbXBsaWFudCBsaXN0cy4KICAgIGlmIChwYXJlbnQuaXMoJ2xpJykpIHsKICAgICAgaW5kZW50Kys7CiAgICB9IGVsc2UgewogICAgICAvLyBJZiBob3dldmVyIHRoZSBsaXN0IGlzIG5lc3RlZCBpbiBvdGhlciBsaXN0IHdlIHNob3VsZCBjaGVjayBwcmV2aW91cyBzaWJsaW5nIG9mIGFueSBvZiB0aGUgbGlzdCBlbGVtZW50cy4uLgogICAgICBjb25zdCBwcmV2aW91c1NpYmxpbmcgPSBwYXJlbnQucHJldmlvdXNTaWJsaW5nOyAvLyAuLi5iZWNhdXNlIHRoZSB3ZSBtaWdodCBuZWVkIGluY3JlYXNlIGl0cyBpbmRlbnQ6CiAgICAgIC8vCQliZWZvcmU6ICAgICAgICAgICAgICAgICAgICAgICAgICAgZml4ZWQgbGlzdDoKICAgICAgLy8JCU9MICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPTAogICAgICAvLwkJfC0+IExJIChwYXJlbnQgTElzOiAwKSAgICAgICAgICAgIHwtPiBMSSAgICAgICAgIChpbmRlbnQ6IDApCiAgICAgIC8vCQl8LT4gT0wgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwtPiBPTAogICAgICAvLwkJICAgIHwtPiBMSSAocGFyZW50IExJczogMCkgICAgICAgICAgICAgICAgfC0+IExJIChpbmRlbnQ6IDEpCgogICAgICBpZiAocHJldmlvdXNTaWJsaW5nICYmIHByZXZpb3VzU2libGluZy5pcygnbGknKSkgewogICAgICAgIGluZGVudCsrOwogICAgICB9CiAgICB9CgogICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDsKICB9CgogIHJldHVybiBpbmRlbnQ7Cn0="},{"version":3,"sources":["/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-list/src/converters.js"],"names":["generateLiInUl","injectViewList","mergeViewLists","getSiblingListItem","positionAfterUiElements","TreeWalker","modelViewInsertion","model","evt","data","conversionApi","consumable","test","item","consume","modelItem","viewItem","modelViewRemove","viewStart","mapper","toViewPosition","position","getLastMatchingPosition","value","is","nodeAfter","viewWriter","writer","breakContainer","createPositionBefore","createPositionAfter","viewList","parent","viewListPrev","previousSibling","removeRange","createRangeOn","removed","remove","nextSibling","toModelElement","hoistNestedLists","getAttribute","start","child","createRangeIn","getItems","unbindViewElement","stop","modelViewChangeType","toViewElement","listName","attributeNewValue","rename","modelViewMergeAfterChangeType","getChildren","modelViewChangeIndent","attributeOldValue","range","modelViewSplitOnInsert","name","viewPosition","lists","removeStart","removeEnd","createPositionAt","isEqual","createRange","push","length","i","previousList","nodeBefore","insertedRange","insert","end","mergePos","offset","modelViewMergeAfter","viewItemPrev","viewItemNext","viewModelConverter","listItem","createElement","indent","getIndent","setAttribute","type","splitResult","splitToAllowedParent","modelCursor","nextPosition","viewToModelListItemChildrenConverter","modelRange","cursorParent","cleanList","children","Array","from","isWrongElement","isList","_remove","cleanListItem","childCount","foundList","firstNode","_data","replace","modelToViewPosition","view","isPhantom","modelPosition","topmostViewList","getAncestors","find","walker","getWalker","previousPosition","viewToModelPosition","viewPos","viewParent","isAtEnd","modelNode","modelLength","getModelLength","getShiftedBy","modelChangePostFixer","changes","document","differ","getChanges","itemToListHead","Map","applied","entry","_addListToFix","hasAttribute","removeAttribute","innerItem","filter","e","posAfter","attributeKey","listHead","values","_fixListIndents","_fixListTypes","prev","set","has","maxIndent","fixBy","itemIndent","newIndent","typesStack","slice","modelIndentPasteFixer","content","selectable","getChild","selection","createSelection","pos","getFirstPosition","refItem","indentChange","_setAttribute","listItemModel","viewChildren","schema","convertItem","result","convertedChild","wasSplit","checkChild","findNextListItem","startPosition","treeWalker","next","nextIndent","modelRemoveStartPosition","viewRemoveStartPosition","viewRemovedItem","prevModelItem","sameIndent","smallerIndent","listIndent","foo","prevIndent","insertPosition","prevViewList","move","viewElement"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module list/converters\n */\n\nimport {\n\tgenerateLiInUl,\n\tinjectViewList,\n\tmergeViewLists,\n\tgetSiblingListItem,\n\tpositionAfterUiElements\n} from './utils';\nimport TreeWalker from '@ckeditor/ckeditor5-engine/src/model/treewalker';\n\n/**\n * A model-to-view converter for the `listItem` model element insertion.\n *\n * It creates a `<ul><li></li><ul>` (or `<ol>`) view structure out of a `listItem` model element, inserts it at the correct\n * position, and merges the list with surrounding lists (if available).\n *\n * @see module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:insert\n * @param {module:engine/model/model~Model} model Model instance.\n * @returns {Function} Returns a conversion callback.\n */\nexport function modelViewInsertion( model ) {\n\treturn ( evt, data, conversionApi ) => {\n\t\tconst consumable = conversionApi.consumable;\n\n\t\tif ( !consumable.test( data.item, 'insert' ) ||\n\t\t\t!consumable.test( data.item, 'attribute:listType' ) ||\n\t\t\t!consumable.test( data.item, 'attribute:listIndent' )\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\tconsumable.consume( data.item, 'insert' );\n\t\tconsumable.consume( data.item, 'attribute:listType' );\n\t\tconsumable.consume( data.item, 'attribute:listIndent' );\n\n\t\tconst modelItem = data.item;\n\t\tconst viewItem = generateLiInUl( modelItem, conversionApi );\n\n\t\tinjectViewList( modelItem, viewItem, conversionApi, model );\n\t};\n}\n\n/**\n * A model-to-view converter for the `listItem` model element removal.\n *\n * @see module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:remove\n * @param {module:engine/model/model~Model} model Model instance.\n * @returns {Function} Returns a conversion callback.\n */\nexport function modelViewRemove( model ) {\n\treturn ( evt, data, conversionApi ) => {\n\t\tconst viewStart = conversionApi.mapper.toViewPosition( data.position ).getLastMatchingPosition( value => !value.item.is( 'li' ) );\n\t\tconst viewItem = viewStart.nodeAfter;\n\t\tconst viewWriter = conversionApi.writer;\n\n\t\t// 1. Break the container after and before the list item.\n\t\t// This will create a view list with one view list item - the one to remove.\n\t\tviewWriter.breakContainer( viewWriter.createPositionBefore( viewItem ) );\n\t\tviewWriter.breakContainer( viewWriter.createPositionAfter( viewItem ) );\n\n\t\t// 2. Remove the list with the item to remove.\n\t\tconst viewList = viewItem.parent;\n\t\tconst viewListPrev = viewList.previousSibling;\n\t\tconst removeRange = viewWriter.createRangeOn( viewList );\n\t\tconst removed = viewWriter.remove( removeRange );\n\n\t\t// 3. Merge the whole created by breaking and removing the list.\n\t\tif ( viewListPrev && viewListPrev.nextSibling ) {\n\t\t\tmergeViewLists( viewWriter, viewListPrev, viewListPrev.nextSibling );\n\t\t}\n\n\t\t// 4. Bring back nested list that was in the removed <li>.\n\t\tconst modelItem = conversionApi.mapper.toModelElement( viewItem );\n\n\t\thoistNestedLists( modelItem.getAttribute( 'listIndent' ) + 1, data.position, removeRange.start, viewItem, conversionApi, model );\n\n\t\t// 5. Unbind removed view item and all children.\n\t\tfor ( const child of viewWriter.createRangeIn( removed ).getItems() ) {\n\t\t\tconversionApi.mapper.unbindViewElement( child );\n\t\t}\n\n\t\tevt.stop();\n\t};\n}\n\n/**\n * A model-to-view converter for the `type` attribute change on the `listItem` model element.\n *\n * This change means that the `<li>` element parent changes from `<ul>` to `<ol>` (or vice versa). This is accomplished\n * by breaking view elements and changing their name. The next {@link module:list/converters~modelViewMergeAfterChangeType}\n * converter will attempt to merge split nodes.\n *\n * Splitting this conversion into 2 steps makes it possible to add an additional conversion in the middle.\n * Check {@link module:list/todolistconverters~modelViewChangeType} to see an example of it.\n *\n * @see module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute\n * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the fired event.\n * @param {Object} data Additional information about the change.\n * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface.\n */\nexport function modelViewChangeType( evt, data, conversionApi ) {\n\tif ( !conversionApi.consumable.consume( data.item, 'attribute:listType' ) ) {\n\t\treturn;\n\t}\n\n\tconst viewItem = conversionApi.mapper.toViewElement( data.item );\n\tconst viewWriter = conversionApi.writer;\n\n\t// Break the container after and before the list item.\n\t// This will create a view list with one view list item -- the one that changed type.\n\tviewWriter.breakContainer( viewWriter.createPositionBefore( viewItem ) );\n\tviewWriter.breakContainer( viewWriter.createPositionAfter( viewItem ) );\n\n\t// Change name of the view list that holds the changed view item.\n\t// We cannot just change name property, because that would not render properly.\n\tconst viewList = viewItem.parent;\n\tconst listName = data.attributeNewValue == 'numbered' ? 'ol' : 'ul';\n\n\tviewWriter.rename( listName, viewList );\n}\n\n/**\n * A model-to-view converter that attempts to merge nodes split by {@link module:list/converters~modelViewChangeType}.\n *\n * @see module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute\n * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the fired event.\n * @param {Object} data Additional information about the change.\n * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface.\n */\nexport function modelViewMergeAfterChangeType( evt, data, conversionApi ) {\n\tconst viewItem = conversionApi.mapper.toViewElement( data.item );\n\tconst viewList = viewItem.parent;\n\tconst viewWriter = conversionApi.writer;\n\n\t// Merge the changed view list with other lists, if possible.\n\tmergeViewLists( viewWriter, viewList, viewList.nextSibling );\n\tmergeViewLists( viewWriter, viewList.previousSibling, viewList );\n\n\t// Consumable insertion of children inside the item. They are already handled by re-building the item in view.\n\tfor ( const child of data.item.getChildren() ) {\n\t\tconversionApi.consumable.consume( child, 'insert' );\n\t}\n}\n\n/**\n * A model-to-view converter for the `listIndent` attribute change on the `listItem` model element.\n *\n * @see module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute\n * @param {module:engine/model/model~Model} model Model instance.\n * @returns {Function} Returns a conversion callback.\n */\nexport function modelViewChangeIndent( model ) {\n\treturn ( evt, data, conversionApi ) => {\n\t\tif ( !conversionApi.consumable.consume( data.item, 'attribute:listIndent' ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst viewItem = conversionApi.mapper.toViewElement( data.item );\n\t\tconst viewWriter = conversionApi.writer;\n\n\t\t// 1. Break the container after and before the list item.\n\t\t// This will create a view list with one view list item -- the one that changed type.\n\t\tviewWriter.breakContainer( viewWriter.createPositionBefore( viewItem ) );\n\t\tviewWriter.breakContainer( viewWriter.createPositionAfter( viewItem ) );\n\n\t\t// 2. Extract view list with changed view list item and merge \"hole\" possibly created by breaking and removing elements.\n\t\tconst viewList = viewItem.parent;\n\t\tconst viewListPrev = viewList.previousSibling;\n\t\tconst removeRange = viewWriter.createRangeOn( viewList );\n\t\tviewWriter.remove( removeRange );\n\n\t\tif ( viewListPrev && viewListPrev.nextSibling ) {\n\t\t\tmergeViewLists( viewWriter, viewListPrev, viewListPrev.nextSibling );\n\t\t}\n\n\t\t// 3. Bring back nested list that was in the removed <li>.\n\t\thoistNestedLists( data.attributeOldValue + 1, data.range.start, removeRange.start, viewItem, conversionApi, model );\n\n\t\t// 4. Inject view list like it is newly inserted.\n\t\tinjectViewList( data.item, viewItem, conversionApi, model );\n\n\t\t// 5. Consume insertion of children inside the item. They are already handled by re-building the item in view.\n\t\tfor ( const child of data.item.getChildren() ) {\n\t\t\tconversionApi.consumable.consume( child, 'insert' );\n\t\t}\n\t};\n}\n\n/**\n * A special model-to-view converter introduced by the {@link module:list/list~List list feature}. This converter is fired for\n * insert change of every model item, and should be fired before the actual converter. The converter checks whether the inserted\n * model item is a non-`listItem` element. If it is, and it is inserted inside a view list, the converter breaks the\n * list so the model element is inserted to the view parent element corresponding to its model parent element.\n *\n * The converter prevents such situations:\n *\n *\t\t// Model:                        // View:\n *\t\t<listItem>foo</listItem>         <ul>\n *\t\t<listItem>bar</listItem>             <li>foo</li>\n *\t\t                                     <li>bar</li>\n *\t\t                                 </ul>\n *\n *\t\t// After change:                 // Correct view guaranteed by this converter:\n *\t\t<listItem>foo</listItem>         <ul><li>foo</li></ul><p>xxx</p><ul><li>bar</li></ul>\n *\t\t<paragraph>xxx</paragraph>       // Instead of this wrong view state:\n *\t\t<listItem>bar</listItem>         <ul><li>foo</li><p>xxx</p><li>bar</li></ul>\n *\n * @see module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:insert\n * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the fired event.\n * @param {Object} data Additional information about the change.\n * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface.\n */\nexport function modelViewSplitOnInsert( evt, data, conversionApi ) {\n\tif ( data.item.name != 'listItem' ) {\n\t\tlet viewPosition = conversionApi.mapper.toViewPosition( data.range.start );\n\n\t\tconst viewWriter = conversionApi.writer;\n\t\tconst lists = [];\n\n\t\t// Break multiple ULs/OLs if there are.\n\t\t//\n\t\t// Imagine following list:\n\t\t//\n\t\t// 1 --------\n\t\t//   1.1 --------\n\t\t//     1.1.1 --------\n\t\t//     1.1.2 --------\n\t\t//     1.1.3 --------\n\t\t//       1.1.3.1 --------\n\t\t//   1.2 --------\n\t\t//     1.2.1 --------\n\t\t// 2 --------\n\t\t//\n\t\t// Insert paragraph after item 1.1.1:\n\t\t//\n\t\t// 1 --------\n\t\t//   1.1 --------\n\t\t//     1.1.1 --------\n\t\t//\n\t\t// Lorem ipsum.\n\t\t//\n\t\t//     1.1.2 --------\n\t\t//     1.1.3 --------\n\t\t//       1.1.3.1 --------\n\t\t//   1.2 --------\n\t\t//     1.2.1 --------\n\t\t// 2 --------\n\t\t//\n\t\t// In this case 1.1.2 has to become beginning of a new list.\n\t\t// We need to break list before 1.1.2 (obvious), then we need to break list also before 1.2.\n\t\t// Then we need to move those broken pieces one after another and merge:\n\t\t//\n\t\t// 1 --------\n\t\t//   1.1 --------\n\t\t//     1.1.1 --------\n\t\t//\n\t\t// Lorem ipsum.\n\t\t//\n\t\t// 1.1.2 --------\n\t\t//   1.1.3 --------\n\t\t//     1.1.3.1 --------\n\t\t// 1.2 --------\n\t\t//   1.2.1 --------\n\t\t// 2 --------\n\t\t//\n\t\twhile ( viewPosition.parent.name == 'ul' || viewPosition.parent.name == 'ol' ) {\n\t\t\tviewPosition = viewWriter.breakContainer( viewPosition );\n\n\t\t\tif ( viewPosition.parent.name != 'li' ) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Remove lists that are after inserted element.\n\t\t\t// They will be brought back later, below the inserted element.\n\t\t\tconst removeStart = viewPosition;\n\t\t\tconst removeEnd = viewWriter.createPositionAt( viewPosition.parent, 'end' );\n\n\t\t\t// Don't remove if there is nothing to remove.\n\t\t\tif ( !removeStart.isEqual( removeEnd ) ) {\n\t\t\t\tconst removed = viewWriter.remove( viewWriter.createRange( removeStart, removeEnd ) );\n\t\t\t\tlists.push( removed );\n\t\t\t}\n\n\t\t\tviewPosition = viewWriter.createPositionAfter( viewPosition.parent );\n\t\t}\n\n\t\t// Bring back removed lists.\n\t\tif ( lists.length > 0 ) {\n\t\t\tfor ( let i = 0; i < lists.length; i++ ) {\n\t\t\t\tconst previousList = viewPosition.nodeBefore;\n\t\t\t\tconst insertedRange = viewWriter.insert( viewPosition, lists[ i ] );\n\t\t\t\tviewPosition = insertedRange.end;\n\n\t\t\t\t// Don't merge first list! We want a split in that place (this is why this converter is introduced).\n\t\t\t\tif ( i > 0 ) {\n\t\t\t\t\tconst mergePos = mergeViewLists( viewWriter, previousList, previousList.nextSibling );\n\n\t\t\t\t\t// If `mergePos` is in `previousList` it means that the lists got merged.\n\t\t\t\t\t// In this case, we need to fix insert position.\n\t\t\t\t\tif ( mergePos && mergePos.parent == previousList ) {\n\t\t\t\t\t\tviewPosition.offset--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Merge last inserted list with element after it.\n\t\t\tmergeViewLists( viewWriter, viewPosition.nodeBefore, viewPosition.nodeAfter );\n\t\t}\n\t}\n}\n\n/**\n * A special model-to-view converter introduced by the {@link module:list/list~List list feature}. This converter takes care of\n * merging view lists after something is removed or moved from near them.\n *\n * Example:\n *\n *\t\t// Model:                        // View:\n *\t\t<listItem>foo</listItem>         <ul><li>foo</li></ul>\n *\t\t<paragraph>xxx</paragraph>       <p>xxx</p>\n *\t\t<listItem>bar</listItem>         <ul><li>bar</li></ul>\n *\n *\t\t// After change:                 // Correct view guaranteed by this converter:\n *\t\t<listItem>foo</listItem>         <ul>\n *\t\t<listItem>bar</listItem>             <li>foo</li>\n *\t\t                                     <li>bar</li>\n *\t\t                                 </ul>\n *\n * @see module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:remove\n * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the fired event.\n * @param {Object} data Additional information about the change.\n * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface.\n */\nexport function modelViewMergeAfter( evt, data, conversionApi ) {\n\tconst viewPosition = conversionApi.mapper.toViewPosition( data.position );\n\tconst viewItemPrev = viewPosition.nodeBefore;\n\tconst viewItemNext = viewPosition.nodeAfter;\n\n\t// Merge lists if something (remove, move) was done from inside of list.\n\t// Merging will be done only if both items are view lists of the same type.\n\t// The check is done inside the helper function.\n\tmergeViewLists( conversionApi.writer, viewItemPrev, viewItemNext );\n}\n\n/**\n * A view-to-model converter that converts the `<li>` view elements into the `listItem` model elements.\n *\n * To set correct values of the `listType` and `listIndent` attributes the converter:\n * * checks `<li>`'s parent,\n * * stores and increases the `conversionApi.store.indent` value when `<li>`'s sub-items are converted.\n *\n * @see module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:element\n * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the fired event.\n * @param {Object} data An object containing conversion input and a placeholder for conversion output and possibly other values.\n * @param {module:engine/conversion/upcastdispatcher~UpcastConversionApi} conversionApi Conversion interface to be used by the callback.\n */\nexport function viewModelConverter( evt, data, conversionApi ) {\n\tif ( conversionApi.consumable.consume( data.viewItem, { name: true } ) ) {\n\t\tconst writer = conversionApi.writer;\n\n\t\t// 1. Create `listItem` model element.\n\t\tconst listItem = writer.createElement( 'listItem' );\n\n\t\t// 2. Handle `listItem` model element attributes.\n\t\tconst indent = getIndent( data.viewItem );\n\n\t\twriter.setAttribute( 'listIndent', indent, listItem );\n\n\t\t// Set 'bulleted' as default. If this item is pasted into a context,\n\t\tconst type = data.viewItem.parent && data.viewItem.parent.name == 'ol' ? 'numbered' : 'bulleted';\n\t\twriter.setAttribute( 'listType', type, listItem );\n\n\t\t// Try to find allowed parent for list item.\n\t\tconst splitResult = conversionApi.splitToAllowedParent( listItem, data.modelCursor );\n\n\t\t// When there is no allowed parent it means that list item cannot be converted at current model position\n\t\t// and in any of position ancestors.\n\t\tif ( !splitResult ) {\n\t\t\treturn;\n\t\t}\n\n\t\twriter.insert( listItem, splitResult.position );\n\n\t\tconst nextPosition = viewToModelListItemChildrenConverter( listItem, data.viewItem.getChildren(), conversionApi );\n\n\t\t// Result range starts before the first item and ends after the last.\n\t\tdata.modelRange = writer.createRange( data.modelCursor, nextPosition );\n\n\t\t// When `data.modelCursor` parent had to be split to insert list item...\n\t\tif ( splitResult.cursorParent ) {\n\t\t\t// Continue conversion in the split element.\n\t\t\tdata.modelCursor = writer.createPositionAt( splitResult.cursorParent, 0 );\n\t\t} else {\n\t\t\t// Otherwise continue conversion after the last list item.\n\t\t\tdata.modelCursor = data.modelRange.end;\n\t\t}\n\t}\n}\n\n/**\n * A view-to-model converter for the `<ul>` and `<ol>` view elements that cleans the input view of garbage.\n * This is mostly to clean whitespaces from between the `<li>` view elements inside the view list element, however, also\n * incorrect data can be cleared if the view was incorrect.\n *\n * @see module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:element\n * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the fired event.\n * @param {Object} data An object containing conversion input and a placeholder for conversion output and possibly other values.\n * @param {module:engine/conversion/upcastdispatcher~UpcastConversionApi} conversionApi Conversion interface to be used by the callback.\n */\nexport function cleanList( evt, data, conversionApi ) {\n\tif ( conversionApi.consumable.test( data.viewItem, { name: true } ) ) {\n\t\t// Caching children because when we start removing them iterating fails.\n\t\tconst children = Array.from( data.viewItem.getChildren() );\n\n\t\tfor ( const child of children ) {\n\t\t\tconst isWrongElement = !( child.is( 'li' ) || isList( child ) );\n\n\t\t\tif ( isWrongElement ) {\n\t\t\t\tchild._remove();\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * A view-to-model converter for the `<li>` elements that cleans whitespace formatting from the input view.\n *\n * @see module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:element\n * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the fired event.\n * @param {Object} data An object containing conversion input and a placeholder for conversion output and possibly other values.\n * @param {module:engine/conversion/upcastdispatcher~UpcastConversionApi} conversionApi Conversion interface to be used by the callback.\n */\nexport function cleanListItem( evt, data, conversionApi ) {\n\tif ( conversionApi.consumable.test( data.viewItem, { name: true } ) ) {\n\t\tif ( data.viewItem.childCount === 0 ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst children = [ ...data.viewItem.getChildren() ];\n\n\t\tlet foundList = false;\n\t\tlet firstNode = true;\n\n\t\tfor ( const child of children ) {\n\t\t\tif ( foundList && !isList( child ) ) {\n\t\t\t\tchild._remove();\n\t\t\t}\n\n\t\t\tif ( child.is( 'text' ) ) {\n\t\t\t\t// If this is the first node and it's a text node, left-trim it.\n\t\t\t\tif ( firstNode ) {\n\t\t\t\t\tchild._data = child.data.replace( /^\\s+/, '' );\n\t\t\t\t}\n\n\t\t\t\t// If this is the last text node before <ul> or <ol>, right-trim it.\n\t\t\t\tif ( !child.nextSibling || isList( child.nextSibling ) ) {\n\t\t\t\t\tchild._data = child.data.replace( /\\s+$/, '' );\n\t\t\t\t}\n\t\t\t} else if ( isList( child ) ) {\n\t\t\t\t// If this is a <ul> or <ol>, do not process it, just mark that we already visited list element.\n\t\t\t\tfoundList = true;\n\t\t\t}\n\n\t\t\tfirstNode = false;\n\t\t}\n\t}\n}\n\n/**\n * Returns a callback for model position to view position mapping for {@link module:engine/conversion/mapper~Mapper}. The callback fixes\n * positions between the `listItem` elements that would be incorrectly mapped because of how list items are represented in the model\n * and in the view.\n *\n * @see module:engine/conversion/mapper~Mapper#event:modelToViewPosition\n * @param {module:engine/view/view~View} view A view instance.\n * @returns {Function}\n */\nexport function modelToViewPosition( view ) {\n\treturn ( evt, data ) => {\n\t\tif ( data.isPhantom ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst modelItem = data.modelPosition.nodeBefore;\n\n\t\tif ( modelItem && modelItem.is( 'listItem' ) ) {\n\t\t\tconst viewItem = data.mapper.toViewElement( modelItem );\n\t\t\tconst topmostViewList = viewItem.getAncestors().find( isList );\n\t\t\tconst walker = view.createPositionAt( viewItem, 0 ).getWalker();\n\n\t\t\tfor ( const value of walker ) {\n\t\t\t\tif ( value.type == 'elementStart' && value.item.is( 'li' ) ) {\n\t\t\t\t\tdata.viewPosition = value.previousPosition;\n\n\t\t\t\t\tbreak;\n\t\t\t\t} else if ( value.type == 'elementEnd' && value.item == topmostViewList ) {\n\t\t\t\t\tdata.viewPosition = value.nextPosition;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\n/**\n * The callback for view position to model position mapping for {@link module:engine/conversion/mapper~Mapper}. The callback fixes\n * positions between the `<li>` elements that would be incorrectly mapped because of how list items are represented in the model\n * and in the view.\n *\n * @see module:engine/conversion/mapper~Mapper#event:viewToModelPosition\n * @param {module:engine/model/model~Model} model Model instance.\n * @returns {Function} Returns a conversion callback.\n */\nexport function viewToModelPosition( model ) {\n\treturn ( evt, data ) => {\n\t\tconst viewPos = data.viewPosition;\n\t\tconst viewParent = viewPos.parent;\n\t\tconst mapper = data.mapper;\n\n\t\tif ( viewParent.name == 'ul' || viewParent.name == 'ol' ) {\n\t\t\t// Position is directly in <ul> or <ol>.\n\t\t\tif ( !viewPos.isAtEnd ) {\n\t\t\t\t// If position is not at the end, it must be before <li>.\n\t\t\t\t// Get that <li>, map it to `listItem` and set model position before that `listItem`.\n\t\t\t\tconst modelNode = mapper.toModelElement( viewPos.nodeAfter );\n\n\t\t\t\tdata.modelPosition = model.createPositionBefore( modelNode );\n\t\t\t} else {\n\t\t\t\t// Position is at the end of <ul> or <ol>, so there is no <li> after it to be mapped.\n\t\t\t\t// There is <li> before the position, but we cannot just map it to `listItem` and set model position after it,\n\t\t\t\t// because that <li> may contain nested items.\n\t\t\t\t// We will check \"model length\" of that <li>, in other words - how many `listItem`s are in that <li>.\n\t\t\t\tconst modelNode = mapper.toModelElement( viewPos.nodeBefore );\n\t\t\t\tconst modelLength = mapper.getModelLength( viewPos.nodeBefore );\n\n\t\t\t\t// Then we get model position before mapped `listItem` and shift it accordingly.\n\t\t\t\tdata.modelPosition = model.createPositionBefore( modelNode ).getShiftedBy( modelLength );\n\t\t\t}\n\n\t\t\tevt.stop();\n\t\t} else if (\n\t\t\tviewParent.name == 'li' &&\n\t\t\tviewPos.nodeBefore &&\n\t\t\t( viewPos.nodeBefore.name == 'ul' || viewPos.nodeBefore.name == 'ol' )\n\t\t) {\n\t\t\t// In most cases when view position is in <li> it is in text and this is a correct position.\n\t\t\t// However, if position is after <ul> or <ol> we have to fix it -- because in model <ul>/<ol> are not in the `listItem`.\n\t\t\tconst modelNode = mapper.toModelElement( viewParent );\n\n\t\t\t// Check all <ul>s and <ol>s that are in the <li> but before mapped position.\n\t\t\t// Get model length of those elements and then add it to the offset of `listItem` mapped to the original <li>.\n\t\t\tlet modelLength = 1; // Starts from 1 because the original <li> has to be counted in too.\n\t\t\tlet viewList = viewPos.nodeBefore;\n\n\t\t\twhile ( viewList && isList( viewList ) ) {\n\t\t\t\tmodelLength += mapper.getModelLength( viewList );\n\n\t\t\t\tviewList = viewList.previousSibling;\n\t\t\t}\n\n\t\t\tdata.modelPosition = model.createPositionBefore( modelNode ).getShiftedBy( modelLength );\n\n\t\t\tevt.stop();\n\t\t}\n\t};\n}\n\n/**\n * Post-fixer that reacts to changes on document and fixes incorrect model states.\n *\n * In the example below, there is a correct list structure.\n * Then the middle element is removed so the list structure will become incorrect:\n *\n *\t\t<listItem listType=\"bulleted\" listIndent=0>Item 1</listItem>\n *\t\t<listItem listType=\"bulleted\" listIndent=1>Item 2</listItem>   <--- this is removed.\n *\t\t<listItem listType=\"bulleted\" listIndent=2>Item 3</listItem>\n *\n * The list structure after the middle element is removed:\n *\n * \t\t<listItem listType=\"bulleted\" listIndent=0>Item 1</listItem>\n *\t\t<listItem listType=\"bulleted\" listIndent=2>Item 3</listItem>\n *\n * Should become:\n *\n *\t\t<listItem listType=\"bulleted\" listIndent=0>Item 1</listItem>\n *\t\t<listItem listType=\"bulleted\" listIndent=1>Item 3</listItem>   <--- note that indent got post-fixed.\n *\n * @param {module:engine/model/model~Model} model The data model.\n * @param {module:engine/model/writer~Writer} writer The writer to do changes with.\n * @returns {Boolean} `true` if any change has been applied, `false` otherwise.\n */\nexport function modelChangePostFixer( model, writer ) {\n\tconst changes = model.document.differ.getChanges();\n\tconst itemToListHead = new Map();\n\n\tlet applied = false;\n\n\tfor ( const entry of changes ) {\n\t\tif ( entry.type == 'insert' && entry.name == 'listItem' ) {\n\t\t\t_addListToFix( entry.position );\n\t\t} else if ( entry.type == 'insert' && entry.name != 'listItem' ) {\n\t\t\tif ( entry.name != '$text' ) {\n\t\t\t\t// In case of renamed element.\n\t\t\t\tconst item = entry.position.nodeAfter;\n\n\t\t\t\tif ( item.hasAttribute( 'listIndent' ) ) {\n\t\t\t\t\twriter.removeAttribute( 'listIndent', item );\n\n\t\t\t\t\tapplied = true;\n\t\t\t\t}\n\n\t\t\t\tif ( item.hasAttribute( 'listType' ) ) {\n\t\t\t\t\twriter.removeAttribute( 'listType', item );\n\n\t\t\t\t\tapplied = true;\n\t\t\t\t}\n\n\t\t\t\tfor ( const innerItem of Array.from( model.createRangeIn( item ) ).filter( e => e.item.is( 'listItem' ) ) ) {\n\t\t\t\t\t_addListToFix( innerItem.previousPosition );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst posAfter = entry.position.getShiftedBy( entry.length );\n\n\t\t\t_addListToFix( posAfter );\n\t\t} else if ( entry.type == 'remove' && entry.name == 'listItem' ) {\n\t\t\t_addListToFix( entry.position );\n\t\t} else if ( entry.type == 'attribute' && entry.attributeKey == 'listIndent' ) {\n\t\t\t_addListToFix( entry.range.start );\n\t\t} else if ( entry.type == 'attribute' && entry.attributeKey == 'listType' ) {\n\t\t\t_addListToFix( entry.range.start );\n\t\t}\n\t}\n\n\tfor ( const listHead of itemToListHead.values() ) {\n\t\t_fixListIndents( listHead );\n\t\t_fixListTypes( listHead );\n\t}\n\n\treturn applied;\n\n\tfunction _addListToFix( position ) {\n\t\tconst prev = position.nodeBefore;\n\n\t\tif ( !prev || !prev.is( 'listItem' ) ) {\n\t\t\tconst item = position.nodeAfter;\n\n\t\t\tif ( item && item.is( 'listItem' ) ) {\n\t\t\t\titemToListHead.set( item, item );\n\t\t\t}\n\t\t} else {\n\t\t\tlet listHead = prev;\n\n\t\t\tif ( itemToListHead.has( listHead ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\twhile ( listHead.previousSibling && listHead.previousSibling.is( 'listItem' ) ) {\n\t\t\t\tlistHead = listHead.previousSibling;\n\n\t\t\t\tif ( itemToListHead.has( listHead ) ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\titemToListHead.set( position.nodeBefore, listHead );\n\t\t}\n\t}\n\n\tfunction _fixListIndents( item ) {\n\t\tlet maxIndent = 0;\n\t\tlet fixBy = null;\n\n\t\twhile ( item && item.is( 'listItem' ) ) {\n\t\t\tconst itemIndent = item.getAttribute( 'listIndent' );\n\n\t\t\tif ( itemIndent > maxIndent ) {\n\t\t\t\tlet newIndent;\n\n\t\t\t\tif ( fixBy === null ) {\n\t\t\t\t\tfixBy = itemIndent - maxIndent;\n\t\t\t\t\tnewIndent = maxIndent;\n\t\t\t\t} else {\n\t\t\t\t\tif ( fixBy > itemIndent ) {\n\t\t\t\t\t\tfixBy = itemIndent;\n\t\t\t\t\t}\n\n\t\t\t\t\tnewIndent = itemIndent - fixBy;\n\t\t\t\t}\n\n\t\t\t\twriter.setAttribute( 'listIndent', newIndent, item );\n\n\t\t\t\tapplied = true;\n\t\t\t} else {\n\t\t\t\tfixBy = null;\n\t\t\t\tmaxIndent = item.getAttribute( 'listIndent' ) + 1;\n\t\t\t}\n\n\t\t\titem = item.nextSibling;\n\t\t}\n\t}\n\n\tfunction _fixListTypes( item ) {\n\t\tlet typesStack = [];\n\t\tlet prev = null;\n\n\t\twhile ( item && item.is( 'listItem' ) ) {\n\t\t\tconst itemIndent = item.getAttribute( 'listIndent' );\n\n\t\t\tif ( prev && prev.getAttribute( 'listIndent' ) > itemIndent ) {\n\t\t\t\ttypesStack = typesStack.slice( 0, itemIndent + 1 );\n\t\t\t}\n\n\t\t\tif ( itemIndent != 0 ) {\n\t\t\t\tif ( typesStack[ itemIndent ] ) {\n\t\t\t\t\tconst type = typesStack[ itemIndent ];\n\n\t\t\t\t\tif ( item.getAttribute( 'listType' ) != type ) {\n\t\t\t\t\t\twriter.setAttribute( 'listType', type, item );\n\n\t\t\t\t\t\tapplied = true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ttypesStack[ itemIndent ] = item.getAttribute( 'listType' );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tprev = item;\n\t\t\titem = item.nextSibling;\n\t\t}\n\t}\n}\n\n/**\n * A fixer for pasted content that includes list items.\n *\n * It fixes indentation of pasted list items so the pasted items match correctly to the context they are pasted into.\n *\n * Example:\n *\n *\t\t<listItem listType=\"bulleted\" listIndent=0>A</listItem>\n *\t\t<listItem listType=\"bulleted\" listIndent=1>B^</listItem>\n *\t\t// At ^ paste:  <listItem listType=\"bulleted\" listIndent=4>X</listItem>\n *\t\t//              <listItem listType=\"bulleted\" listIndent=5>Y</listItem>\n *\t\t<listItem listType=\"bulleted\" listIndent=2>C</listItem>\n *\n * Should become:\n *\n *\t\t<listItem listType=\"bulleted\" listIndent=0>A</listItem>\n *\t\t<listItem listType=\"bulleted\" listIndent=1>BX</listItem>\n *\t\t<listItem listType=\"bulleted\" listIndent=2>Y/listItem>\n *\t\t<listItem listType=\"bulleted\" listIndent=2>C</listItem>\n *\n * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the fired event.\n * @param {Array} args Arguments of {@link module:engine/model/model~Model#insertContent}.\n */\nexport function modelIndentPasteFixer( evt, [ content, selectable ] ) {\n\t// Check whether inserted content starts from a `listItem`. If it does not, it means that there are some other\n\t// elements before it and there is no need to fix indents, because even if we insert that content into a list,\n\t// that list will be broken.\n\t// Note: we also need to handle singular elements because inserting item with indent 0 into 0,1,[],2\n\t// would create incorrect model.\n\tlet item = content.is( 'documentFragment' ) ? content.getChild( 0 ) : content;\n\n\tlet selection;\n\n\tif ( !selectable ) {\n\t\tselection = this.document.selection;\n\t} else {\n\t\tselection = this.createSelection( selectable );\n\t}\n\n\tif ( item && item.is( 'listItem' ) ) {\n\t\t// Get a reference list item. Inserted list items will be fixed according to that item.\n\t\tconst pos = selection.getFirstPosition();\n\t\tlet refItem = null;\n\n\t\tif ( pos.parent.is( 'listItem' ) ) {\n\t\t\trefItem = pos.parent;\n\t\t} else if ( pos.nodeBefore && pos.nodeBefore.is( 'listItem' ) ) {\n\t\t\trefItem = pos.nodeBefore;\n\t\t}\n\n\t\t// If there is `refItem` it means that we do insert list items into an existing list.\n\t\tif ( refItem ) {\n\t\t\t// First list item in `data` has indent equal to 0 (it is a first list item). It should have indent equal\n\t\t\t// to the indent of reference item. We have to fix the first item and all of it's children and following siblings.\n\t\t\t// Indent of all those items has to be adjusted to reference item.\n\t\t\tconst indentChange = refItem.getAttribute( 'listIndent' );\n\n\t\t\t// Fix only if there is anything to fix.\n\t\t\tif ( indentChange > 0 ) {\n\t\t\t\t// Adjust indent of all \"first\" list items in inserted data.\n\t\t\t\twhile ( item && item.is( 'listItem' ) ) {\n\t\t\t\t\titem._setAttribute( 'listIndent', item.getAttribute( 'listIndent' ) + indentChange );\n\n\t\t\t\t\titem = item.nextSibling;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Helper function that converts children of a given `<li>` view element into corresponding model elements.\n// The function maintains proper order of elements if model `listItem` is split during the conversion\n// due to block children conversion.\n//\n// @param {module:engine/model/element~Element} listItemModel List item model element to which converted children will be inserted.\n// @param {Iterable.<module:engine/view/node~Node>} viewChildren View elements which will be converted.\n// @param {module:engine/conversion/upcastdispatcher~UpcastConversionApi} conversionApi Conversion interface to be used by the callback.\n// @returns {module:engine/model/position~Position} Position on which next elements should be inserted after children conversion.\nfunction viewToModelListItemChildrenConverter( listItemModel, viewChildren, conversionApi ) {\n\tconst { writer, schema } = conversionApi;\n\n\t// A position after the last inserted `listItem`.\n\tlet nextPosition = writer.createPositionAfter( listItemModel );\n\n\t// Check all children of the converted `<li>`. At this point we assume there are no \"whitespace\" view text nodes\n\t// in view list, between view list items. This should be handled by `<ul>` and `<ol>` converters.\n\tfor ( const child of viewChildren ) {\n\t\tif ( child.name == 'ul' || child.name == 'ol' ) {\n\t\t\t// If the children is a list, we will insert its conversion result after currently handled `listItem`.\n\t\t\t// Then, next insertion position will be set after all the new list items (and maybe other elements if\n\t\t\t// something split list item).\n\t\t\t//\n\t\t\t// If this is a list, we expect that some `listItem`s and possibly other blocks will be inserted, however `.modelCursor`\n\t\t\t// should be set after last `listItem` (or block). This is why it feels safe to use it as `nextPosition`\n\t\t\tnextPosition = conversionApi.convertItem( child, nextPosition ).modelCursor;\n\t\t} else {\n\t\t\t// If this is not a list, try inserting content at the end of the currently handled `listItem`.\n\t\t\tconst result = conversionApi.convertItem( child, writer.createPositionAt( listItemModel, 'end' ) );\n\n\t\t\t// It may end up that the current `listItem` becomes split (if that content cannot be inside `listItem`). For example:\n\t\t\t//\n\t\t\t// <li><p>Foo</p></li>\n\t\t\t//\n\t\t\t// will be converted to:\n\t\t\t//\n\t\t\t// <listItem></listItem><paragraph>Foo</paragraph><listItem></listItem>\n\t\t\t//\n\t\t\tconst convertedChild = result.modelRange.start.nodeAfter;\n\t\t\tconst wasSplit = convertedChild && convertedChild.is( 'element' ) && !schema.checkChild( listItemModel, convertedChild.name );\n\n\t\t\tif ( wasSplit ) {\n\t\t\t\t// As `lastListItem` got split, we need to update it to the second part of the split `listItem` element.\n\t\t\t\t//\n\t\t\t\t// `modelCursor` should be set to a position where the conversion should continue. There are multiple possible scenarios\n\t\t\t\t// that may happen. Usually, `modelCursor` (marked as `#` below) would point to the second list item after conversion:\n\t\t\t\t//\n\t\t\t\t//\t\t`<li><p>Foo</p></li>` -> `<listItem></listItem><paragraph>Foo</paragraph><listItem>#</listItem>`\n\t\t\t\t//\n\t\t\t\t// However, in some cases, like auto-paragraphing, the position is placed at the end of the block element:\n\t\t\t\t//\n\t\t\t\t//\t\t`<li><div>Foo</div></li>` -> `<listItem></listItem><paragraph>Foo#</paragraph><listItem></listItem>`\n\t\t\t\t//\n\t\t\t\t// or after an element if another element broken auto-paragraphed element:\n\t\t\t\t//\n\t\t\t\t//\t\t`<li><div><h2>Foo</h2></div></li>` -> `<listItem></listItem><heading1>Foo</heading1>#<listItem></listItem>`\n\t\t\t\t//\n\t\t\t\t// We need to check for such cases and use proper list item and position based on it.\n\t\t\t\t//\n\t\t\t\tif ( result.modelCursor.parent.is( 'listItem' ) ) {\n\t\t\t\t\t// (1).\n\t\t\t\t\tlistItemModel = result.modelCursor.parent;\n\t\t\t\t} else {\n\t\t\t\t\t// (2), (3).\n\t\t\t\t\tlistItemModel = findNextListItem( result.modelCursor );\n\t\t\t\t}\n\n\t\t\t\tnextPosition = writer.createPositionAfter( listItemModel );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nextPosition;\n}\n\n// Helper function that seeks for a next list item starting from given `startPosition`.\nfunction findNextListItem( startPosition ) {\n\tconst treeWalker = new TreeWalker( { startPosition } );\n\n\tlet value;\n\n\tdo {\n\t\tvalue = treeWalker.next();\n\t} while ( !value.value.item.is( 'listItem' ) );\n\n\treturn value.value.item;\n}\n\n// Helper function that takes all children of given `viewRemovedItem` and moves them in a correct place, according\n// to other given parameters.\nfunction hoistNestedLists( nextIndent, modelRemoveStartPosition, viewRemoveStartPosition, viewRemovedItem, conversionApi, model ) {\n\t// Find correct previous model list item element.\n\t// The element has to have either same or smaller indent than given reference indent.\n\t// This will be the model element which will get nested items (if it has smaller indent) or sibling items (if it has same indent).\n\t// Keep in mind that such element might not be found, if removed item was the first item.\n\tconst prevModelItem = getSiblingListItem( modelRemoveStartPosition.nodeBefore, {\n\t\tsameIndent: true,\n\t\tsmallerIndent: true,\n\t\tlistIndent: nextIndent,\n\t\tfoo: 'b'\n\t} );\n\n\tconst mapper = conversionApi.mapper;\n\tconst viewWriter = conversionApi.writer;\n\n\t// Indent of found element or `null` if the element has not been found.\n\tconst prevIndent = prevModelItem ? prevModelItem.getAttribute( 'listIndent' ) : null;\n\n\tlet insertPosition;\n\n\tif ( !prevModelItem ) {\n\t\t// If element has not been found, simply insert lists at the position where the removed item was:\n\t\t//\n\t\t// Lorem ipsum.\n\t\t// 1 --------           <--- this is removed, no previous list item, put nested items in place of removed item.\n\t\t//   1.1 --------       <--- this is reference indent.\n\t\t//     1.1.1 --------\n\t\t//     1.1.2 --------\n\t\t//   1.2 --------\n\t\t//\n\t\t// Becomes:\n\t\t//\n\t\t// Lorem ipsum.\n\t\t// 1.1 --------\n\t\t//   1.1.1 --------\n\t\t//   1.1.2 --------\n\t\t// 1.2 --------\n\t\tinsertPosition = viewRemoveStartPosition;\n\t} else if ( prevIndent == nextIndent ) {\n\t\t// If element has been found and has same indent as reference indent it means that nested items should\n\t\t// become siblings of found element:\n\t\t//\n\t\t// 1 --------\n\t\t//   1.1 --------\n\t\t//   1.2 --------       <--- this is `prevModelItem`.\n\t\t// 2 --------           <--- this is removed, previous list item has indent same as reference indent.\n\t\t//   2.1 --------       <--- this is reference indent, this and 2.2 should become siblings of 1.2.\n\t\t//   2.2 --------\n\t\t//\n\t\t// Becomes:\n\t\t//\n\t\t// 1 --------\n\t\t//   1.1 --------\n\t\t//   1.2 --------\n\t\t//   2.1 --------\n\t\t//   2.2 --------\n\t\tconst prevViewList = mapper.toViewElement( prevModelItem ).parent;\n\t\tinsertPosition = viewWriter.createPositionAfter( prevViewList );\n\t} else {\n\t\t// If element has been found and has smaller indent as reference indent it means that nested items\n\t\t// should become nested items of found item:\n\t\t//\n\t\t// 1 --------           <--- this is `prevModelItem`.\n\t\t//   1.1 --------       <--- this is removed, previous list item has indent smaller than reference indent.\n\t\t//     1.1.1 --------   <--- this is reference indent, this and 1.1.1 should become nested items of 1.\n\t\t//     1.1.2 --------\n\t\t//   1.2 --------\n\t\t//\n\t\t// Becomes:\n\t\t//\n\t\t// 1 --------\n\t\t//   1.1.1 --------\n\t\t//   1.1.2 --------\n\t\t//   1.2 --------\n\t\t//\n\t\t// Note: in this case 1.1.1 have indent 2 while 1 have indent 0. In model that should not be possible,\n\t\t// because following item may have indent bigger only by one. But this is fixed by postfixer.\n\t\tconst modelPosition = model.createPositionAt( prevModelItem, 'end' );\n\t\tinsertPosition = mapper.toViewPosition( modelPosition );\n\t}\n\n\tinsertPosition = positionAfterUiElements( insertPosition );\n\n\t// Handle multiple lists. This happens if list item has nested numbered and bulleted lists. Following lists\n\t// are inserted after the first list (no need to recalculate insertion position for them).\n\tfor ( const child of [ ...viewRemovedItem.getChildren() ] ) {\n\t\tif ( isList( child ) ) {\n\t\t\tinsertPosition = viewWriter.move( viewWriter.createRangeOn( child ), insertPosition ).end;\n\n\t\t\tmergeViewLists( viewWriter, child, child.nextSibling );\n\t\t\tmergeViewLists( viewWriter, child.previousSibling, child );\n\t\t}\n\t}\n}\n\n// Checks if view element is a list type (ul or ol).\n//\n// @param {module:engine/view/element~Element} viewElement\n// @returns {Boolean}\nfunction isList( viewElement ) {\n\treturn viewElement.is( 'ol' ) || viewElement.is( 'ul' );\n}\n\n// Calculates the indent value for a list item. Handles HTML compliant and non-compliant lists.\n//\n// Also, fixes non HTML compliant lists indents:\n//\n//\t\tbefore:                                     fixed list:\n//\t\tOL                                          OL\n//\t\t|-> LI (parent LIs: 0)                      |-> LI     (indent: 0)\n//\t\t    |-> OL                                  |-> OL\n//\t\t        |-> OL                                  |\n//\t\t        |   |-> OL                              |\n//\t\t        |       |-> OL                          |\n//\t\t        |           |-> LI (parent LIs: 1)      |-> LI (indent: 1)\n//\t\t        |-> LI (parent LIs: 1)                  |-> LI (indent: 1)\n//\n//\t\tbefore:                                     fixed list:\n//\t\tOL                                          OL\n//\t\t|-> OL                                      |\n//\t\t    |-> OL                                  |\n//\t\t         |-> OL                             |\n//\t\t             |-> LI (parent LIs: 0)         |-> LI        (indent: 0)\n//\n//\t\tbefore:                                     fixed list:\n//\t\tOL                                          OL\n//\t\t|-> LI (parent LIs: 0)                      |-> LI         (indent: 0)\n//\t\t|-> OL                                          |-> OL\n//\t\t    |-> LI (parent LIs: 0)                          |-> LI (indent: 1)\n//\n// @param {module:engine/view/element~Element} listItem\n// @param {Object} conversionStore\n// @returns {Number}\nfunction getIndent( listItem ) {\n\tlet indent = 0;\n\n\tlet parent = listItem.parent;\n\n\twhile ( parent ) {\n\t\t// Each LI in the tree will result in an increased indent for HTML compliant lists.\n\t\tif ( parent.is( 'li' ) ) {\n\t\t\tindent++;\n\t\t} else {\n\t\t\t// If however the list is nested in other list we should check previous sibling of any of the list elements...\n\t\t\tconst previousSibling = parent.previousSibling;\n\n\t\t\t// ...because the we might need increase its indent:\n\t\t\t//\t\tbefore:                           fixed list:\n\t\t\t//\t\tOL                                OL\n\t\t\t//\t\t|-> LI (parent LIs: 0)            |-> LI         (indent: 0)\n\t\t\t//\t\t|-> OL                                |-> OL\n\t\t\t//\t\t    |-> LI (parent LIs: 0)                |-> LI (indent: 1)\n\t\t\tif ( previousSibling && previousSibling.is( 'li' ) ) {\n\t\t\t\tindent++;\n\t\t\t}\n\t\t}\n\n\t\tparent = parent.parent;\n\t}\n\n\treturn indent;\n}\n"]}]}