{"remainingRequest":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/babel-loader/lib/index.js!/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-engine/src/conversion/upcastdispatcher.js","dependencies":[{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-engine/src/conversion/upcastdispatcher.js","mtime":499162500000},{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js","mtime":499162500000},{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/babel-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:LyoqCiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDE5LCBDS1NvdXJjZSAtIEZyZWRlcmljbyBLbmFiYmVuLiBBbGwgcmlnaHRzIHJlc2VydmVkLgogKiBGb3IgbGljZW5zaW5nLCBzZWUgTElDRU5TRS5tZCBvciBodHRwczovL2NrZWRpdG9yLmNvbS9sZWdhbC9ja2VkaXRvci1vc3MtbGljZW5zZQogKi8KCi8qKgogKiBAbW9kdWxlIGVuZ2luZS9jb252ZXJzaW9uL3VwY2FzdGRpc3BhdGNoZXIKICovCmltcG9ydCBWaWV3Q29uc3VtYWJsZSBmcm9tICcuL3ZpZXdjb25zdW1hYmxlJzsKaW1wb3J0IE1vZGVsUmFuZ2UgZnJvbSAnLi4vbW9kZWwvcmFuZ2UnOwppbXBvcnQgTW9kZWxQb3NpdGlvbiBmcm9tICcuLi9tb2RlbC9wb3NpdGlvbic7CmltcG9ydCB7IFNjaGVtYUNvbnRleHQgfSBmcm9tICcuLi9tb2RlbC9zY2hlbWEnOwppbXBvcnQgQ0tFZGl0b3JFcnJvciBmcm9tICdAY2tlZGl0b3IvY2tlZGl0b3I1LXV0aWxzL3NyYy9ja2VkaXRvcmVycm9yJzsKaW1wb3J0IEVtaXR0ZXJNaXhpbiBmcm9tICdAY2tlZGl0b3IvY2tlZGl0b3I1LXV0aWxzL3NyYy9lbWl0dGVybWl4aW4nOwppbXBvcnQgbWl4IGZyb20gJ0Bja2VkaXRvci9ja2VkaXRvcjUtdXRpbHMvc3JjL21peCc7Ci8qKgogKiBgVXBjYXN0RGlzcGF0Y2hlcmAgaXMgYSBjZW50cmFsIHBvaW50IG9mIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdmlldyB2aWV3fSBjb252ZXJzaW9uLCB3aGljaCBpcyBhIHByb2Nlc3Mgb2YKICogY29udmVydGluZyBnaXZlbiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudCB2aWV3IGRvY3VtZW50IGZyYWdtZW50fSBvcgogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudH0gaW50byBhbm90aGVyIHN0cnVjdHVyZS4KICogSW4gZGVmYXVsdCBhcHBsaWNhdGlvbiwge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy92aWV3IHZpZXd9IGlzIGNvbnZlcnRlZCB0byB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9tb2RlbH0uCiAqCiAqIER1cmluZyBjb252ZXJzaW9uIHByb2Nlc3MsIGZvciBhbGwge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9ub2Rlfk5vZGUgdmlldyBub2Rlc30gZnJvbSB0aGUgY29udmVydGVkIHZpZXcgZG9jdW1lbnQgZnJhZ21lbnQsCiAqIGBVcGNhc3REaXNwYXRjaGVyYCBmaXJlcyBjb3JyZXNwb25kaW5nIGV2ZW50cy4gU3BlY2lhbCBjYWxsYmFja3MgY2FsbGVkICJjb252ZXJ0ZXJzIiBzaG91bGQgbGlzdGVuIHRvCiAqIGBVcGNhc3REaXNwYXRjaGVyYCBmb3IgdGhvc2UgZXZlbnRzLgogKgogKiBFYWNoIGNhbGxiYWNrLCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50LCBpcyBwYXNzZWQgYSBzcGVjaWFsIG9iamVjdCBgZGF0YWAgdGhhdCBoYXMgYHZpZXdJdGVtYCwgYG1vZGVsQ3Vyc29yYCBhbmQKICogYG1vZGVsUmFuZ2VgIHByb3BlcnRpZXMuIGB2aWV3SXRlbWAgcHJvcGVydHkgY29udGFpbnMge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9ub2Rlfk5vZGUgdmlldyBub2RlfSBvcgogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudCB2aWV3IGRvY3VtZW50IGZyYWdtZW50fQogKiB0aGF0IGlzIGNvbnZlcnRlZCBhdCB0aGUgbW9tZW50IGFuZCBtaWdodCBiZSBoYW5kbGVkIGJ5IHRoZSBjYWxsYmFjay4gYG1vZGVsUmFuZ2VgIHByb3BlcnR5IHNob3VsZCBiZSB1c2VkIHRvIHNhdmUgdGhlIHJlc3VsdAogKiBvZiBjb252ZXJzaW9uIGFuZCBpcyBhbHdheXMgYSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZX0gd2hlbiBjb252ZXJzaW9uIHJlc3VsdCBpcyBjb3JyZWN0LgogKiBgbW9kZWxDdXJzb3JgIHByb3BlcnR5IGlzIGEge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb24gcG9zaXRpb259IG9uIHdoaWNoIGNvbnZlcnNpb24gcmVzdWx0IHdpbGwgYmUgaW5zZXJ0ZWQKICogYW5kIGlzIGEgY29udGV4dCBhY2NvcmRpbmcgdG8ge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYSBzY2hlbWF9IHdpbGwgYmUgY2hlY2tlZCBiZWZvcmUgdGhlIGNvbnZlcnNpb24uCiAqIFNlZSBhbHNvIHtAbGluayB+VXBjYXN0RGlzcGF0Y2hlciNjb252ZXJ0fS4gSXQgaXMgYWxzbyBzaGFyZWQgYnkgcmVmZXJlbmNlIGJ5IGFsbCBjYWxsYmFja3MgbGlzdGVuaW5nIHRvIGdpdmVuIGV2ZW50LgogKgogKiBUaGUgdGhpcmQgcGFyYW1ldGVyIHBhc3NlZCB0byBhIGNhbGxiYWNrIGlzIGFuIGluc3RhbmNlIG9mIHtAbGluayB+VXBjYXN0RGlzcGF0Y2hlcn0KICogd2hpY2ggcHJvdmlkZXMgYWRkaXRpb25hbCB0b29scyBmb3IgY29udmVydGVycy4KICoKICogRXhhbXBsZXMgb2YgcHJvdmlkaW5nIGNhbGxiYWNrcyBmb3IgYFVwY2FzdERpc3BhdGNoZXJgOgogKgogKgkJLy8gQ29udmVydGVyIGZvciBsaW5rcyAoPGE+KS4KICoJCWVkaXRvci5kYXRhLnVwY2FzdERpc3BhdGNoZXIub24oICdlbGVtZW50OmEnLCAoIGV2dCwgZGF0YSwgY29udmVyc2lvbkFwaSApID0+IHsKICoJCQlpZiAoIGNvbnZlcnNpb25BcGkuY29uc3VtYWJsZS5jb25zdW1lKCBkYXRhLnZpZXdJdGVtLCB7IG5hbWU6IHRydWUsIGF0dHJpYnV0ZXM6IFsgJ2hyZWYnIF0gfSApICkgewogKgkJCQkvLyA8YT4gZWxlbWVudCBpcyBpbmxpbmUgYW5kIGlzIHJlcHJlc2VudGVkIGJ5IGFuIGF0dHJpYnV0ZSBpbiB0aGUgbW9kZWwuCiAqCQkJCS8vIFRoaXMgaXMgd2h5IHdlIG5lZWQgdG8gY29udmVydCBvbmx5IGNoaWxkcmVuLgogKgkJCQljb25zdCB7IG1vZGVsUmFuZ2UgfSA9IGNvbnZlcnNpb25BcGkuY29udmVydENoaWxkcmVuKCBkYXRhLnZpZXdJdGVtLCBkYXRhLm1vZGVsQ3Vyc29yICk7CiAqCiAqCQkJCWZvciAoIGxldCBpdGVtIG9mIG1vZGVsUmFuZ2UuZ2V0SXRlbXMoKSApIHsKICoJCQkJCWlmICggY29udmVyc2lvbkFwaS5zY2hlbWEuY2hlY2tBdHRyaWJ1dGUoIGl0ZW0sICdsaW5rSHJlZicgKSApIHsKICoJCQkJCQljb252ZXJzaW9uQXBpLndyaXRlci5zZXRBdHRyaWJ1dGUoICdsaW5rSHJlZicsIGRhdGEudmlld0l0ZW0uZ2V0QXR0cmlidXRlKCAnaHJlZicgKSwgaXRlbSApOwogKgkJCQkJfQogKgkJCQl9CiAqCQkJfQogKgkJfSApOwogKgogKgkJLy8gQ29udmVydCA8cD4ncyBmb250LXNpemUgc3R5bGUuCiAqCQkvLyBOb3RlOiBZb3Ugc2hvdWxkIHVzZSBhIGxvdy1wcmlvcml0eSBvYnNlcnZlciBpbiBvcmRlciB0byBlbnN1cmUgdGhhdAogKgkJLy8gaXQncyBleGVjdXRlZCBhZnRlciB0aGUgZWxlbWVudC10by1lbGVtZW50IGNvbnZlcnRlci4KICoJCWVkaXRvci5kYXRhLnVwY2FzdERpc3BhdGNoZXIub24oICdlbGVtZW50OnAnLCAoIGV2dCwgZGF0YSwgY29udmVyc2lvbkFwaSApID0+IHsKICoJCQljb25zdCB7IGNvbnN1bWFibGUsIHNjaGVtYSwgd3JpdGVyIH0gPSBjb252ZXJzaW9uQXBpOwogKgogKgkJCWlmICggIWNvbnN1bWFibGUuY29uc3VtZSggZGF0YS52aWV3SXRlbSwgeyBzdHlsZTogJ2ZvbnQtc2l6ZScgfSApICkgewogKgkJCQlyZXR1cm47CiAqCQkJfQogKgogKgkJCWNvbnN0IGZvbnRTaXplID0gZGF0YS52aWV3SXRlbS5nZXRTdHlsZSggJ2ZvbnQtc2l6ZScgKTsKICoKICoJCQkvLyBEb24ndCBnbyBmb3IgdGhlIG1vZGVsIGVsZW1lbnQgYWZ0ZXIgZGF0YS5tb2RlbEN1cnNvciBiZWNhdXNlIGl0IG1pZ2h0IGhhcHBlbgogKgkJCS8vIHRoYXQgYSBzaW5nbGUgdmlldyBlbGVtZW50IHdhcyBjb252ZXJ0ZWQgdG8gbXVsdGlwbGUgbW9kZWwgZWxlbWVudHMuIEdldCBhbGwgb2YgdGhlbS4KICoJCQlmb3IgKCBjb25zdCBpdGVtIG9mIGRhdGEubW9kZWxSYW5nZS5nZXRJdGVtcyggeyBzaGFsbG93OiB0cnVlIH0gKSApIHsKICoJCQkJaWYgKCBzY2hlbWEuY2hlY2tBdHRyaWJ1dGUoIGl0ZW0sICdmb250U2l6ZScgKSApIHsKICoJCQkJCXdyaXRlci5zZXRBdHRyaWJ1dGUoICdmb250U2l6ZScsIGZvbnRTaXplLCBpdGVtICk7CiAqCQkJCX0KICoJCQl9CiAqCQl9LCB7IHByaW9yaXR5OiAnbG93JyB9ICk7CiAqCiAqCQkvLyBDb252ZXJ0IGFsbCBlbGVtZW50cyB3aGljaCBoYXZlIG5vIGN1c3RvbSBjb252ZXJ0ZXIgaW50byBwYXJhZ3JhcGggKGF1dG9wYXJhZ3JhcGhpbmcpLgogKiAgCWVkaXRvci5kYXRhLnVwY2FzdERpc3BhdGNoZXIub24oICdlbGVtZW50JywgKCBldnQsIGRhdGEsIGNvbnZlcnNpb25BcGkgKSA9PiB7CiAqICAJIAkvLyBXaGVuIGVsZW1lbnQgaXMgYWxyZWFkeSBjb25zdW1lZCBieSBoaWdoZXIgcHJpb3JpdHkgY29udmVydGVycyB0aGVuIGRvIG5vdGhpbmcuCiAqICAJIAlpZiAoIGNvbnZlcnNpb25BcGkuY29uc3VtYWJsZS50ZXN0KCBkYXRhLnZpZXdJdGVtLCB7IG5hbWU6IGRhdGEudmlld0l0ZW0ubmFtZSB9ICkgKSB7CiAqICAJIAkJCWNvbnN0IHBhcmFncmFwaCA9IGNvbnZlcnNpb25BcGkud3JpdGVyLmNyZWF0ZUVsZW1lbnQoICdwYXJhZ3JhcGgnICk7CiAqCiAqICAJIAkJCS8vIEZpbmQgYWxsb3dlZCBwYXJlbnQgZm9yIHBhcmFncmFwaCB0aGF0IHdlIGFyZSBnb2luZyB0byBpbnNlcnQuIElmIGN1cnJlbnQgcGFyZW50IGRvZXMgbm90IGFsbG93CiAqICAJIAkJCS8vIHRvIGluc2VydCBwYXJhZ3JhcGggYnV0IG9uZSBvZiB0aGUgYW5jZXN0b3JzIGRvZXMgdGhlbiBzcGxpdCBub2RlcyB0byBhbGxvd2VkIHBhcmVudC4KICogIAkgCQkJY29uc3Qgc3BsaXRSZXN1bHQgPSBjb252ZXJzaW9uQXBpLnNwbGl0VG9BbGxvd2VkUGFyZW50KCBwYXJhZ3JhcGgsIGRhdGEubW9kZWxDdXJzb3IgKTsKICoKICogIAkgCQkJLy8gV2hlbiB0aGVyZSBpcyBubyBzcGxpdCByZXN1bHQgaXQgbWVhbnMgdGhhdCB3ZSBjYW4ndCBpbnNlcnQgcGFyYWdyYXBoIGluIHRoaXMgcG9zaXRpb24uCiAqICAJIAkJCWlmICggc3BsaXRSZXN1bHQgKSB7CiAqICAJIAkJCQkvLyBJbnNlcnQgcGFyYWdyYXBoIGluIGFsbG93ZWQgcG9zaXRpb24uCiAqICAJIAkJCQljb252ZXJzaW9uQXBpLndyaXRlci5pbnNlcnQoIHBhcmFncmFwaCwgc3BsaXRSZXN1bHQucG9zaXRpb24gKTsKICoKICogIAkgCQkJCS8vIENvbnZlcnQgY2hpbGRyZW4gdG8gcGFyYWdyYXBoLgogKiAgCSAJCQkJY29uc3QgeyBtb2RlbFJhbmdlIH0gPSBjb252ZXJzaW9uQXBpLmNvbnZlcnRDaGlsZHJlbigKICogIAkgCQkJCQlkYXRhLnZpZXdJdGVtLAogKiAgCSAJCQkJCWNvbnZlcnNpb25BcGkud3JpdGVyLmNyZWF0ZVBvc2l0aW9uQXQoIHBhcmFncmFwaCwgMCApCiAqICAJIAkJCQkpOwogKgogKiAJCQkJCQkvLyBTZXQgYXMgY29udmVyc2lvbiByZXN1bHQsIGF0dHJpYnV0ZSBjb252ZXJ0ZXJzIG1heSB1c2UgdGhpcyBwcm9wZXJ0eS4KICogIAkgCQkJCWRhdGEubW9kZWxSYW5nZSA9IGNvbnZlcnNpb25BcGkud3JpdGVyLmNyZWF0ZVJhbmdlKAogKiAgCSAJCQkJCWNvbnZlcnNpb25BcGkud3JpdGVyLmNyZWF0ZVBvc2l0aW9uQmVmb3JlKCBwYXJhZ3JhcGggKSwKICogIAkgCQkJCQltb2RlbFJhbmdlLmVuZAogKiAgCSAJCQkJKTsKICoKICogIAkgCQkJCS8vIENvbnRpbnVlIGNvbnZlcnNpb24gaW5zaWRlIHBhcmFncmFwaC4KICogIAkgCQkJCWRhdGEubW9kZWxDdXJzb3IgPSBkYXRhLm1vZGVsUmFuZ2UuZW5kOwogKiAgCSAJCQl9CiAqICAJIAkJfQogKiAgCSAJfQogKiAgCSB9LCB7IHByaW9yaXR5OiAnbG93JyB9ICk7CiAqCiAqIEJlZm9yZSBlYWNoIGNvbnZlcnNpb24gcHJvY2VzcywgYFVwY2FzdERpc3BhdGNoZXJgIGZpcmVzIHtAbGluayB+VXBjYXN0RGlzcGF0Y2hlciNldmVudDp2aWV3Q2xlYW51cH0KICogZXZlbnQgd2hpY2ggY2FuIGJlIHVzZWQgdG8gcHJlcGFyZSB0cmVlIHZpZXcgZm9yIGNvbnZlcnNpb24uCiAqCiAqIEBtaXhlcyBtb2R1bGU6dXRpbHMvZW1pdHRlcm1peGlufkVtaXR0ZXJNaXhpbgogKiBAZmlyZXMgdmlld0NsZWFudXAKICogQGZpcmVzIGVsZW1lbnQKICogQGZpcmVzIHRleHQKICogQGZpcmVzIGRvY3VtZW50RnJhZ21lbnQKICovCgpleHBvcnQgZGVmYXVsdCBjbGFzcyBVcGNhc3REaXNwYXRjaGVyIHsKICAvKioKICAgKiBDcmVhdGVzIGEgYFVwY2FzdERpc3BhdGNoZXJgIHRoYXQgb3BlcmF0ZXMgdXNpbmcgcGFzc2VkIEFQSS4KICAgKgogICAqIEBzZWUgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL3VwY2FzdGRpc3BhdGNoZXJ+VXBjYXN0Q29udmVyc2lvbkFwaQogICAqIEBwYXJhbSB7T2JqZWN0fSBbY29udmVyc2lvbkFwaV0gQWRkaXRpb25hbCBwcm9wZXJ0aWVzIGZvciBpbnRlcmZhY2UgdGhhdCB3aWxsIGJlIHBhc3NlZCB0byBldmVudHMgZmlyZWQKICAgKiBieSBgVXBjYXN0RGlzcGF0Y2hlcmAuCiAgICovCiAgY29uc3RydWN0b3IoY29udmVyc2lvbkFwaSA9IHt9KSB7CiAgICAvKioKICAgICAqIExpc3Qgb2YgdGhlIGVsZW1lbnRzIHRoYXQgd2VyZSBjcmVhdGVkIGR1cmluZyBzcGxpdHRpbmcuCiAgICAgKgogICAgICogQWZ0ZXIgY29udmVyc2lvbiBwcm9jZXNzIHRoZSBsaXN0IGlzIGNsZWFyZWQuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEB0eXBlIHtNYXAuPG1vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50LEFycmF5Ljxtb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudD4+fQogICAgICovCiAgICB0aGlzLl9zcGxpdFBhcnRzID0gbmV3IE1hcCgpOwogICAgLyoqCiAgICAgKiBQb3NpdGlvbiBpbiB0aGUgdGVtcG9yYXJ5IHN0cnVjdHVyZSB3aGVyZSB0aGUgY29udmVydGVkIGNvbnRlbnQgaXMgaW5zZXJ0ZWQuIFRoZSBzdHJ1Y3R1cmUgcmVmbGVjdCB0aGUgY29udGV4dCBvZgogICAgICogdGhlIHRhcmdldCBwb3NpdGlvbiB3aGVyZSB0aGUgY29udGVudCB3aWxsIGJlIGluc2VydGVkLiBUaGlzIHByb3BlcnR5IGlzIGJ1aWxkIGJhc2VkIG9uIHRoZSBjb250ZXh0IHBhcmFtZXRlciBvZiB0aGUKICAgICAqIGNvbnZlcnQgbWV0aG9kLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAdHlwZSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbnxudWxsfQogICAgICovCgogICAgdGhpcy5fbW9kZWxDdXJzb3IgPSBudWxsOwogICAgLyoqCiAgICAgKiBJbnRlcmZhY2UgcGFzc2VkIGJ5IGRpc3BhdGNoZXIgdG8gdGhlIGV2ZW50cyBjYWxsYmFja3MuCiAgICAgKgogICAgICogQG1lbWJlciB7bW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL3VwY2FzdGRpc3BhdGNoZXJ+VXBjYXN0Q29udmVyc2lvbkFwaX0KICAgICAqLwoKICAgIHRoaXMuY29udmVyc2lvbkFwaSA9IE9iamVjdC5hc3NpZ24oe30sIGNvbnZlcnNpb25BcGkpOyAvLyBgY29udmVydEl0ZW1gLCBgY29udmVydENoaWxkcmVuYCBhbmQgYHNwbGl0VG9BbGxvd2VkUGFyZW50YCBhcmUgYm91bmQgdG8gdGhpcyBgVXBjYXN0RGlzcGF0Y2hlcmAKICAgIC8vIGluc3RhbmNlIGFuZCBzZXQgb24gYGNvbnZlcnNpb25BcGlgLiBUaGlzIHdheSBvbmx5IGEgcGFydCBvZiBgVXBjYXN0RGlzcGF0Y2hlcmAgQVBJIGlzIGV4cG9zZWQuCgogICAgdGhpcy5jb252ZXJzaW9uQXBpLmNvbnZlcnRJdGVtID0gdGhpcy5fY29udmVydEl0ZW0uYmluZCh0aGlzKTsKICAgIHRoaXMuY29udmVyc2lvbkFwaS5jb252ZXJ0Q2hpbGRyZW4gPSB0aGlzLl9jb252ZXJ0Q2hpbGRyZW4uYmluZCh0aGlzKTsKICAgIHRoaXMuY29udmVyc2lvbkFwaS5zcGxpdFRvQWxsb3dlZFBhcmVudCA9IHRoaXMuX3NwbGl0VG9BbGxvd2VkUGFyZW50LmJpbmQodGhpcyk7CiAgICB0aGlzLmNvbnZlcnNpb25BcGkuZ2V0U3BsaXRQYXJ0cyA9IHRoaXMuX2dldFNwbGl0UGFydHMuYmluZCh0aGlzKTsKICB9CiAgLyoqCiAgICogU3RhcnRzIHRoZSBjb252ZXJzaW9uIHByb2Nlc3MuIFRoZSBlbnRyeSBwb2ludCBmb3IgdGhlIGNvbnZlcnNpb24uCiAgICoKICAgKiBAZmlyZXMgZWxlbWVudAogICAqIEBmaXJlcyB0ZXh0CiAgICogQGZpcmVzIGRvY3VtZW50RnJhZ21lbnQKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnR8bW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudH0gdmlld0l0ZW0KICAgKiBQYXJ0IG9mIHRoZSB2aWV3IHRvIGJlIGNvbnZlcnRlZC4KICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvd3JpdGVyfldyaXRlcn0gd3JpdGVyIEluc3RhbmNlIG9mIG1vZGVsIHdyaXRlci4KICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYUNvbnRleHREZWZpbml0aW9ufSBbY29udGV4dD1bJyRyb290J11dIEVsZW1lbnRzIHdpbGwgYmUgY29udmVydGVkIGFjY29yZGluZyB0byB0aGlzIGNvbnRleHQuCiAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50fSBNb2RlbCBkYXRhIHRoYXQgaXMgYSByZXN1bHQgb2YgdGhlIGNvbnZlcnNpb24gcHJvY2VzcwogICAqIHdyYXBwZWQgaW4gYERvY3VtZW50RnJhZ21lbnRgLiBDb252ZXJ0ZWQgbWFya2VyIGVsZW1lbnRzIHdpbGwgYmUgc2V0IGFzIHRoYXQgZG9jdW1lbnQgZnJhZ21lbnQncwogICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudCNtYXJrZXJzIHN0YXRpYyBtYXJrZXJzIG1hcH0uCiAgICovCgoKICBjb252ZXJ0KHZpZXdJdGVtLCB3cml0ZXIsIGNvbnRleHQgPSBbJyRyb290J10pIHsKICAgIHRoaXMuZmlyZSgndmlld0NsZWFudXAnLCB2aWV3SXRlbSk7IC8vIENyZWF0ZSBjb250ZXh0IHRyZWUgYW5kIHNldCBwb3NpdGlvbiBpbiB0aGUgdG9wIGVsZW1lbnQuCiAgICAvLyBJdGVtcyB3aWxsIGJlIGNvbnZlcnRlZCBhY2NvcmRpbmcgdG8gdGhpcyBwb3NpdGlvbi4KCiAgICB0aGlzLl9tb2RlbEN1cnNvciA9IGNyZWF0ZUNvbnRleHRUcmVlKGNvbnRleHQsIHdyaXRlcik7IC8vIFN0b3JlIHdyaXRlciBpbiBjb252ZXJzaW9uIGFzIGEgY29udmVyc2lvbiBBUEkKICAgIC8vIHRvIGJlIHN1cmUgdGhhdCBjb252ZXJzaW9uIHByb2Nlc3Mgd2lsbCB1c2UgdGhlIHNhbWUgYmF0Y2guCgogICAgdGhpcy5jb252ZXJzaW9uQXBpLndyaXRlciA9IHdyaXRlcjsgLy8gQ3JlYXRlIGNvbnN1bWFibGUgdmFsdWVzIGxpc3QgZm9yIGNvbnZlcnNpb24gcHJvY2Vzcy4KCiAgICB0aGlzLmNvbnZlcnNpb25BcGkuY29uc3VtYWJsZSA9IFZpZXdDb25zdW1hYmxlLmNyZWF0ZUZyb20odmlld0l0ZW0pOyAvLyBDdXN0b20gZGF0YSBzdG9yZWQgYnkgY29udmVydGVyIGZvciBjb252ZXJzaW9uIHByb2Nlc3MuCgogICAgdGhpcy5jb252ZXJzaW9uQXBpLnN0b3JlID0ge307IC8vIERvIHRoZSBjb252ZXJzaW9uLgoKICAgIGNvbnN0IHsKICAgICAgbW9kZWxSYW5nZQogICAgfSA9IHRoaXMuX2NvbnZlcnRJdGVtKHZpZXdJdGVtLCB0aGlzLl9tb2RlbEN1cnNvcik7IC8vIENvbnZlcnNpb24gcmVzdWx0IGlzIGFsd2F5cyBhIGRvY3VtZW50IGZyYWdtZW50IHNvIGxldCdzIGNyZWF0ZSBpdC4KCgogICAgY29uc3QgZG9jdW1lbnRGcmFnbWVudCA9IHdyaXRlci5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7IC8vIFdoZW4gdGhlcmUgaXMgYSBjb252ZXJzaW9uIHJlc3VsdC4KCiAgICBpZiAobW9kZWxSYW5nZSkgewogICAgICAvLyBSZW1vdmUgYWxsIGVtcHR5IGVsZW1lbnRzIHRoYXQgd2VyZSBjcmVhdGUgd2hpbGUgc3BsaXR0aW5nLgogICAgICB0aGlzLl9yZW1vdmVFbXB0eUVsZW1lbnRzKCk7IC8vIE1vdmUgYWxsIGl0ZW1zIHRoYXQgd2VyZSBjb252ZXJ0ZWQgaW4gY29udGV4dCB0cmVlIHRvIHRoZSBkb2N1bWVudCBmcmFnbWVudC4KCgogICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgQXJyYXkuZnJvbSh0aGlzLl9tb2RlbEN1cnNvci5wYXJlbnQuZ2V0Q2hpbGRyZW4oKSkpIHsKICAgICAgICB3cml0ZXIuYXBwZW5kKGl0ZW0sIGRvY3VtZW50RnJhZ21lbnQpOwogICAgICB9IC8vIEV4dHJhY3QgdGVtcG9yYXJ5IG1hcmtlcnMgZWxlbWVudHMgZnJvbSBtb2RlbCBhbmQgc2V0IGFzIHN0YXRpYyBtYXJrZXJzIGNvbGxlY3Rpb24uCgoKICAgICAgZG9jdW1lbnRGcmFnbWVudC5tYXJrZXJzID0gZXh0cmFjdE1hcmtlcnNGcm9tTW9kZWxGcmFnbWVudChkb2N1bWVudEZyYWdtZW50LCB3cml0ZXIpOwogICAgfSAvLyBDbGVhciBjb250ZXh0IHBvc2l0aW9uLgoKCiAgICB0aGlzLl9tb2RlbEN1cnNvciA9IG51bGw7IC8vIENsZWFyIHNwbGl0IGVsZW1lbnRzIGxpc3RzLgoKICAgIHRoaXMuX3NwbGl0UGFydHMuY2xlYXIoKTsgLy8gQ2xlYXIgY29udmVyc2lvbiBBUEkuCgoKICAgIHRoaXMuY29udmVyc2lvbkFwaS53cml0ZXIgPSBudWxsOwogICAgdGhpcy5jb252ZXJzaW9uQXBpLnN0b3JlID0gbnVsbDsgLy8gUmV0dXJuIGZyYWdtZW50IGFzIGNvbnZlcnNpb24gcmVzdWx0LgoKICAgIHJldHVybiBkb2N1bWVudEZyYWdtZW50OwogIH0KICAvKioKICAgKiBAcHJpdmF0ZQogICAqIEBzZWUgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL3VwY2FzdGRpc3BhdGNoZXJ+VXBjYXN0Q29udmVyc2lvbkFwaSNjb252ZXJ0SXRlbQogICAqLwoKCiAgX2NvbnZlcnRJdGVtKHZpZXdJdGVtLCBtb2RlbEN1cnNvcikgewogICAgY29uc3QgZGF0YSA9IE9iamVjdC5hc3NpZ24oewogICAgICB2aWV3SXRlbSwKICAgICAgbW9kZWxDdXJzb3IsCiAgICAgIG1vZGVsUmFuZ2U6IG51bGwKICAgIH0pOwoKICAgIGlmICh2aWV3SXRlbS5pcygnZWxlbWVudCcpKSB7CiAgICAgIHRoaXMuZmlyZSgnZWxlbWVudDonICsgdmlld0l0ZW0ubmFtZSwgZGF0YSwgdGhpcy5jb252ZXJzaW9uQXBpKTsKICAgIH0gZWxzZSBpZiAodmlld0l0ZW0uaXMoJ3RleHQnKSkgewogICAgICB0aGlzLmZpcmUoJ3RleHQnLCBkYXRhLCB0aGlzLmNvbnZlcnNpb25BcGkpOwogICAgfSBlbHNlIHsKICAgICAgdGhpcy5maXJlKCdkb2N1bWVudEZyYWdtZW50JywgZGF0YSwgdGhpcy5jb252ZXJzaW9uQXBpKTsKICAgIH0gLy8gSGFuZGxlIGluY29ycmVjdCBjb252ZXJzaW9uIHJlc3VsdC4KCgogICAgaWYgKGRhdGEubW9kZWxSYW5nZSAmJiAhKGRhdGEubW9kZWxSYW5nZSBpbnN0YW5jZW9mIE1vZGVsUmFuZ2UpKSB7CiAgICAgIC8qKgogICAgICAgKiBJbmNvcnJlY3QgY29udmVyc2lvbiByZXN1bHQgd2FzIGRyb3BwZWQuCiAgICAgICAqCiAgICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlIE1vZGVsIHJhbmdlfSBzaG91bGQgYmUgYSBjb252ZXJzaW9uIHJlc3VsdC4KICAgICAgICoKICAgICAgICogQGVycm9yIHZpZXctY29udmVyc2lvbi1kaXNwYXRjaGVyLWluY29ycmVjdC1yZXN1bHQKICAgICAgICovCiAgICAgIHRocm93IG5ldyBDS0VkaXRvckVycm9yKCd2aWV3LWNvbnZlcnNpb24tZGlzcGF0Y2hlci1pbmNvcnJlY3QtcmVzdWx0OiBJbmNvcnJlY3QgY29udmVyc2lvbiByZXN1bHQgd2FzIGRyb3BwZWQuJywgdGhpcyk7CiAgICB9CgogICAgcmV0dXJuIHsKICAgICAgbW9kZWxSYW5nZTogZGF0YS5tb2RlbFJhbmdlLAogICAgICBtb2RlbEN1cnNvcjogZGF0YS5tb2RlbEN1cnNvcgogICAgfTsKICB9CiAgLyoqCiAgICogQHByaXZhdGUKICAgKiBAc2VlIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi91cGNhc3RkaXNwYXRjaGVyflVwY2FzdENvbnZlcnNpb25BcGkjY29udmVydENoaWxkcmVuCiAgICovCgoKICBfY29udmVydENoaWxkcmVuKHZpZXdJdGVtLCBtb2RlbEN1cnNvcikgewogICAgY29uc3QgbW9kZWxSYW5nZSA9IG5ldyBNb2RlbFJhbmdlKG1vZGVsQ3Vyc29yKTsKICAgIGxldCBuZXh0TW9kZWxDdXJzb3IgPSBtb2RlbEN1cnNvcjsKCiAgICBmb3IgKGNvbnN0IHZpZXdDaGlsZCBvZiBBcnJheS5mcm9tKHZpZXdJdGVtLmdldENoaWxkcmVuKCkpKSB7CiAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2NvbnZlcnRJdGVtKHZpZXdDaGlsZCwgbmV4dE1vZGVsQ3Vyc29yKTsKCiAgICAgIGlmIChyZXN1bHQubW9kZWxSYW5nZSBpbnN0YW5jZW9mIE1vZGVsUmFuZ2UpIHsKICAgICAgICBtb2RlbFJhbmdlLmVuZCA9IHJlc3VsdC5tb2RlbFJhbmdlLmVuZDsKICAgICAgICBuZXh0TW9kZWxDdXJzb3IgPSByZXN1bHQubW9kZWxDdXJzb3I7CiAgICAgIH0KICAgIH0KCiAgICByZXR1cm4gewogICAgICBtb2RlbFJhbmdlLAogICAgICBtb2RlbEN1cnNvcjogbmV4dE1vZGVsQ3Vyc29yCiAgICB9OwogIH0KICAvKioKICAgKiBAcHJpdmF0ZQogICAqIEBzZWUgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL3VwY2FzdGRpc3BhdGNoZXJ+VXBjYXN0Q29udmVyc2lvbkFwaSNzcGxpdFRvQWxsb3dlZFBhcmVudAogICAqLwoKCiAgX3NwbGl0VG9BbGxvd2VkUGFyZW50KG5vZGUsIG1vZGVsQ3Vyc29yKSB7CiAgICAvLyBUcnkgdG8gZmluZCBhbGxvd2VkIHBhcmVudC4KICAgIGNvbnN0IGFsbG93ZWRQYXJlbnQgPSB0aGlzLmNvbnZlcnNpb25BcGkuc2NoZW1hLmZpbmRBbGxvd2VkUGFyZW50KG1vZGVsQ3Vyc29yLCBub2RlKTsgLy8gV2hlbiB0aGVyZSBpcyBubyBwYXJlbnQgdGhhdCBhbGxvd3MgdG8gaW5zZXJ0IG5vZGUgdGhlbiByZXR1cm4gYG51bGxgLgoKICAgIGlmICghYWxsb3dlZFBhcmVudCkgewogICAgICByZXR1cm4gbnVsbDsKICAgIH0gLy8gV2hlbiBjdXJyZW50IHBvc2l0aW9uIHBhcmVudCBhbGxvd3MgdG8gaW5zZXJ0IG5vZGUgdGhlbiByZXR1cm4gdGhpcyBwb3NpdGlvbi4KCgogICAgaWYgKGFsbG93ZWRQYXJlbnQgPT09IG1vZGVsQ3Vyc29yLnBhcmVudCkgewogICAgICByZXR1cm4gewogICAgICAgIHBvc2l0aW9uOiBtb2RlbEN1cnNvcgogICAgICB9OwogICAgfSAvLyBXaGVuIGFsbG93ZWQgcGFyZW50IGlzIGluIGNvbnRleHQgdHJlZS4KCgogICAgaWYgKHRoaXMuX21vZGVsQ3Vyc29yLnBhcmVudC5nZXRBbmNlc3RvcnMoKS5pbmNsdWRlcyhhbGxvd2VkUGFyZW50KSkgewogICAgICByZXR1cm4gbnVsbDsKICAgIH0gLy8gU3BsaXQgZWxlbWVudCB0byBhbGxvd2VkIHBhcmVudC4KCgogICAgY29uc3Qgc3BsaXRSZXN1bHQgPSB0aGlzLmNvbnZlcnNpb25BcGkud3JpdGVyLnNwbGl0KG1vZGVsQ3Vyc29yLCBhbGxvd2VkUGFyZW50KTsgLy8gVXNpbmcgdGhlIHJhbmdlIHJldHVybmVkIGJ5IGBtb2RlbC5Xcml0ZXIjc3BsaXRgLCB3ZSB3aWxsIHBhaXIgb3JpZ2luYWwgZWxlbWVudHMgd2l0aCB0aGVpciBzcGxpdCBwYXJ0cy4KICAgIC8vCiAgICAvLyBUaGUgcmFuZ2UgcmV0dXJuZWQgZnJvbSB0aGUgd3JpdGVyIHNwYW5zICJvdmVyIHRoZSBzcGxpdCIgb3IsIHByZWNpc2VseSBzYXlpbmcsIGZyb20gdGhlIGVuZCBvZiB0aGUgb3JpZ2luYWwgZWxlbWVudCAodGhlIG9uZQogICAgLy8gdGhhdCBnb3Qgc3BsaXQpIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIG90aGVyIHBhcnQgb2YgdGhhdCBlbGVtZW50OgogICAgLy8KICAgIC8vIDxsaW1pdD48YT48Yj48Yz5YW11ZPC9jPjwvYj48YT48L2xpbWl0PiAtPgogICAgLy8gPGxpbWl0PjxhPjxiPjxjPlhbPC9jPjwvYj48L2E+PGE+PGI+PGM+XVk8L2M+PC9iPjwvYT4KICAgIC8vCiAgICAvLyBBZnRlciB0aGUgc3BsaXQgdGhlcmUgY2Fubm90IGJlIGFueSBmdWxsIG5vZGUgYmV0d2VlbiB0aGUgcG9zaXRpb25zIGluIGBzcGxpdFJhbmdlYC4gVGhlIHBvc2l0aW9ucyBhcmUgdG91Y2hpbmcuCiAgICAvLyBBbHNvLCBiZWNhdXNlIG9mIGhvdyBzcGxpdHRpbmcgd29ya3MsIGl0IGlzIGVhc3kgdG8gbm90aWNlLCB0aGF0ICJjbG9zaW5nIHRhZ3MiIGFyZSBpbiB0aGUgcmV2ZXJzZSBvcmRlciB0aGFuICJvcGVuaW5nIHRhZ3MiLgogICAgLy8gQWxzbywgc2luY2Ugd2Ugc3BsaXQgYWxsIHRob3NlIGVsZW1lbnRzLCBlYWNoIG9mIHRoZW0gaGFzIHRvIGhhdmUgdGhlIG90aGVyIHBhcnQuCiAgICAvLwogICAgLy8gV2l0aCB0aG9zZSBvYnNlcnZhdGlvbnMgaW4gbWluZCwgd2Ugd2lsbCBwYWlyIHRoZSBvcmlnaW5hbCBlbGVtZW50cyB3aXRoIHRoZWlyIHNwbGl0IHBhcnRzIGJ5IHNhdmluZyAiY2xvc2luZyB0YWdzIiBhbmQgbWF0Y2hpbmcKICAgIC8vIHRoZW0gd2l0aCAib3BlbmluZyB0YWdzIiBpbiB0aGUgcmV2ZXJzZSBvcmRlci4gRm9yIHRoYXQgd2UgY2FuIHVzZSBhIHN0YWNrLgoKICAgIGNvbnN0IHN0YWNrID0gW107CgogICAgZm9yIChjb25zdCB0cmVlV2Fsa2VyVmFsdWUgb2Ygc3BsaXRSZXN1bHQucmFuZ2UuZ2V0V2Fsa2VyKCkpIHsKICAgICAgaWYgKHRyZWVXYWxrZXJWYWx1ZS50eXBlID09ICdlbGVtZW50RW5kJykgewogICAgICAgIHN0YWNrLnB1c2godHJlZVdhbGtlclZhbHVlLml0ZW0pOwogICAgICB9IGVsc2UgewogICAgICAgIC8vIFRoZXJlIHNob3VsZCBub3QgYmUgYW55IHRleHQgbm9kZXMgYWZ0ZXIgdGhlIGVsZW1lbnQgaXMgc3BsaXQsIHNvIHRoZSBvbmx5IG90aGVyIHZhbHVlIGlzIGBlbGVtZW50U3RhcnRgLgogICAgICAgIGNvbnN0IG9yaWdpbmFsUGFydCA9IHN0YWNrLnBvcCgpOwogICAgICAgIGNvbnN0IHNwbGl0UGFydCA9IHRyZWVXYWxrZXJWYWx1ZS5pdGVtOwoKICAgICAgICB0aGlzLl9yZWdpc3RlclNwbGl0UGFpcihvcmlnaW5hbFBhcnQsIHNwbGl0UGFydCk7CiAgICAgIH0KICAgIH0KCiAgICByZXR1cm4gewogICAgICBwb3NpdGlvbjogc3BsaXRSZXN1bHQucG9zaXRpb24sCiAgICAgIGN1cnNvclBhcmVudDogc3BsaXRSZXN1bHQucmFuZ2UuZW5kLnBhcmVudAogICAgfTsKICB9CiAgLyoqCiAgICogUmVnaXN0ZXJzIHRoYXQgYHNwbGl0UGFydGAgZWxlbWVudCBpcyBhIHNwbGl0IHBhcnQgb2YgdGhlIGBvcmlnaW5hbFBhcnRgIGVsZW1lbnQuCiAgICoKICAgKiBEYXRhIHNldCBieSB0aGlzIG1ldGhvZCBpcyB1c2VkIGJ5IHtAbGluayAjX2dldFNwbGl0UGFydHN9IGFuZCB7QGxpbmsgI19yZW1vdmVFbXB0eUVsZW1lbnRzfS4KICAgKgogICAqIEBwcml2YXRlCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudH0gb3JpZ2luYWxQYXJ0CiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudH0gc3BsaXRQYXJ0CiAgICovCgoKICBfcmVnaXN0ZXJTcGxpdFBhaXIob3JpZ2luYWxQYXJ0LCBzcGxpdFBhcnQpIHsKICAgIGlmICghdGhpcy5fc3BsaXRQYXJ0cy5oYXMob3JpZ2luYWxQYXJ0KSkgewogICAgICB0aGlzLl9zcGxpdFBhcnRzLnNldChvcmlnaW5hbFBhcnQsIFtvcmlnaW5hbFBhcnRdKTsKICAgIH0KCiAgICBjb25zdCBsaXN0ID0gdGhpcy5fc3BsaXRQYXJ0cy5nZXQob3JpZ2luYWxQYXJ0KTsKCiAgICB0aGlzLl9zcGxpdFBhcnRzLnNldChzcGxpdFBhcnQsIGxpc3QpOwoKICAgIGxpc3QucHVzaChzcGxpdFBhcnQpOwogIH0KICAvKioKICAgKiBAcHJpdmF0ZQogICAqIEBzZWUgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL3VwY2FzdGRpc3BhdGNoZXJ+VXBjYXN0Q29udmVyc2lvbkFwaSNnZXRTcGxpdFBhcnRzCiAgICovCgoKICBfZ2V0U3BsaXRQYXJ0cyhlbGVtZW50KSB7CiAgICBsZXQgcGFydHM7CgogICAgaWYgKCF0aGlzLl9zcGxpdFBhcnRzLmhhcyhlbGVtZW50KSkgewogICAgICBwYXJ0cyA9IFtlbGVtZW50XTsKICAgIH0gZWxzZSB7CiAgICAgIHBhcnRzID0gdGhpcy5fc3BsaXRQYXJ0cy5nZXQoZWxlbWVudCk7CiAgICB9CgogICAgcmV0dXJuIHBhcnRzOwogIH0KICAvKioKICAgKiBDaGVja3MgaWYgdGhlcmUgYXJlIGFueSBlbXB0eSBlbGVtZW50cyBjcmVhdGVkIHdoaWxlIHNwbGl0dGluZyBhbmQgcmVtb3ZlcyB0aGVtLgogICAqCiAgICogVGhpcyBtZXRob2Qgd29ya3MgcmVjdXJzaXZlbHkgdG8gcmUtY2hlY2sgZW1wdHkgZWxlbWVudHMgYWdhaW4gYWZ0ZXIgYXQgbGVhc3Qgb25lIGVsZW1lbnQgd2FzIHJlbW92ZWQgaW4gdGhlIGluaXRpYWwgY2FsbCwKICAgKiBhcyBzb21lIGVsZW1lbnRzIG1pZ2h0IGhhdmUgYmVjb21lIGVtcHR5IGFmdGVyIG90aGVyIGVtcHR5IGVsZW1lbnRzIHdlcmUgcmVtb3ZlZCBmcm9tIHRoZW0uCiAgICoKICAgKiBAcHJpdmF0ZQogICAqLwoKCiAgX3JlbW92ZUVtcHR5RWxlbWVudHMoKSB7CiAgICBsZXQgYW55UmVtb3ZlZCA9IGZhbHNlOwoKICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiB0aGlzLl9zcGxpdFBhcnRzLmtleXMoKSkgewogICAgICBpZiAoZWxlbWVudC5pc0VtcHR5KSB7CiAgICAgICAgdGhpcy5jb252ZXJzaW9uQXBpLndyaXRlci5yZW1vdmUoZWxlbWVudCk7CgogICAgICAgIHRoaXMuX3NwbGl0UGFydHMuZGVsZXRlKGVsZW1lbnQpOwoKICAgICAgICBhbnlSZW1vdmVkID0gdHJ1ZTsKICAgICAgfQogICAgfQoKICAgIGlmIChhbnlSZW1vdmVkKSB7CiAgICAgIHRoaXMuX3JlbW92ZUVtcHR5RWxlbWVudHMoKTsKICAgIH0KICB9CiAgLyoqCiAgICogRmlyZWQgYmVmb3JlIHRoZSBmaXJzdCBjb252ZXJzaW9uIGV2ZW50LCBhdCB0aGUgYmVnaW5uaW5nIG9mIHVwY2FzdCAodmlldyB0byBtb2RlbCBjb252ZXJzaW9uKSBwcm9jZXNzLgogICAqCiAgICogQGV2ZW50IHZpZXdDbGVhbnVwCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50fG1vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnR9CiAgICogdmlld0l0ZW0gUGFydCBvZiB0aGUgdmlldyB0byBiZSBjb252ZXJ0ZWQuCiAgICovCgogIC8qKgogICAqIEZpcmVkIHdoZW4ge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnR9IGlzIGNvbnZlcnRlZC4KICAgKgogICAqIGBlbGVtZW50YCBpcyBhIG5hbWVzcGFjZSBldmVudCBmb3IgYSBjbGFzcyBvZiBldmVudHMuIE5hbWVzIG9mIGFjdHVhbGx5IGNhbGxlZCBldmVudHMgZm9sbG93IHRoaXMgcGF0dGVybjoKICAgKiBgZWxlbWVudDo8ZWxlbWVudE5hbWU+YCB3aGVyZSBgZWxlbWVudE5hbWVgIGlzIHRoZSBuYW1lIG9mIGNvbnZlcnRlZCBlbGVtZW50LiBUaGlzIHdheSBsaXN0ZW5lcnMgbWF5IGxpc3RlbiB0bwogICAqIGFsbCBlbGVtZW50cyBjb252ZXJzaW9uIG9yIHRvIGNvbnZlcnNpb24gb2Ygc3BlY2lmaWMgZWxlbWVudHMuCiAgICoKICAgKiBAZXZlbnQgZWxlbWVudAogICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIENvbnZlcnNpb24gZGF0YS4gS2VlcCBpbiBtaW5kIHRoYXQgdGhpcyBvYmplY3QgaXMgc2hhcmVkIGJ5IHJlZmVyZW5jZSBiZXR3ZWVuIGFsbAogICAqIGNhbGxiYWNrcyB0aGF0IHdpbGwgYmUgY2FsbGVkLiBUaGlzIG1lYW5zIHRoYXQgY2FsbGJhY2tzIGNhbiBvdmVycmlkZSB2YWx1ZXMgaWYgbmVlZGVkLCBhbmQgdGhvc2UgdmFsdWVzIHdpbGwKICAgKiBiZSBhdmFpbGFibGUgaW4gb3RoZXIgY2FsbGJhY2tzLgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L2l0ZW1+SXRlbX0gZGF0YS52aWV3SXRlbSBDb252ZXJ0ZWQgaXRlbS4KICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259IGRhdGEubW9kZWxDdXJzb3IgUG9zaXRpb24gd2hlcmUgYSBjb252ZXJ0ZXIgc2hvdWxkIHN0YXJ0IGNoYW5nZXMuCiAgICogQ2hhbmdlIHRoaXMgdmFsdWUgZm9yIHRoZSBuZXh0IGNvbnZlcnRlciB0byB0ZWxsIHdoZXJlIHRoZSBjb252ZXJzaW9uIHNob3VsZCBjb250aW51ZS4KICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2V9IGRhdGEubW9kZWxSYW5nZSBUaGUgY3VycmVudCBzdGF0ZSBvZiBjb252ZXJzaW9uIHJlc3VsdC4gRXZlcnkgY2hhbmdlIHRvCiAgICogY29udmVydGVkIGVsZW1lbnQgc2hvdWxkIGJlIHJlZmxlY3RlZCBieSBzZXR0aW5nIG9yIG1vZGlmeWluZyB0aGlzIHByb3BlcnR5LgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL3VwY2FzdGRpc3BhdGNoZXJ+VXBjYXN0Q29udmVyc2lvbkFwaX0gY29udmVyc2lvbkFwaSBDb252ZXJzaW9uIHV0aWxpdGllcyB0byBiZSB1c2VkIGJ5IGNhbGxiYWNrLgogICAqLwoKICAvKioKICAgKiBGaXJlZCB3aGVuIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdGV4dH5UZXh0fSBpcyBjb252ZXJ0ZWQuCiAgICoKICAgKiBAZXZlbnQgdGV4dAogICAqIEBzZWUgI2V2ZW50OmVsZW1lbnQKICAgKi8KCiAgLyoqCiAgICogRmlyZWQgd2hlbiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudH0gaXMgY29udmVydGVkLgogICAqCiAgICogQGV2ZW50IGRvY3VtZW50RnJhZ21lbnQKICAgKiBAc2VlICNldmVudDplbGVtZW50CiAgICovCgoKfQptaXgoVXBjYXN0RGlzcGF0Y2hlciwgRW1pdHRlck1peGluKTsgLy8gVHJhdmVyc2VzIGdpdmVuIG1vZGVsIGl0ZW0gYW5kIHNlYXJjaGVzIGVsZW1lbnRzIHdoaWNoIG1hcmtzIG1hcmtlciByYW5nZS4gRm91bmQgZWxlbWVudCBpcyByZW1vdmVkIGZyb20KLy8gRG9jdW1lbnRGcmFnbWVudCBidXQgcGF0aCBvZiB0aGlzIGVsZW1lbnQgaXMgc3RvcmVkIGluIGEgTWFwIHdoaWNoIGlzIHRoZW4gcmV0dXJuZWQuCi8vCi8vIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudHxtb2R1bGU6ZW5naW5lL3ZpZXcvbm9kZX5Ob2RlfSBtb2RlbEl0ZW0gRnJhZ21lbnQgb2YgbW9kZWwuCi8vIEByZXR1cm5zIHtNYXA8U3RyaW5nLCBtb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlPn0gTGlzdCBvZiBzdGF0aWMgbWFya2Vycy4KCmZ1bmN0aW9uIGV4dHJhY3RNYXJrZXJzRnJvbU1vZGVsRnJhZ21lbnQobW9kZWxJdGVtLCB3cml0ZXIpIHsKICBjb25zdCBtYXJrZXJFbGVtZW50cyA9IG5ldyBTZXQoKTsKICBjb25zdCBtYXJrZXJzID0gbmV3IE1hcCgpOyAvLyBDcmVhdGUgTW9kZWxUcmVlV2Fsa2VyLgoKICBjb25zdCByYW5nZSA9IE1vZGVsUmFuZ2UuX2NyZWF0ZUluKG1vZGVsSXRlbSkuZ2V0SXRlbXMoKTsgLy8gV2FsayB0aHJvdWdoIERvY3VtZW50RnJhZ21lbnQgYW5kIGNvbGxlY3QgbWFya2VyIGVsZW1lbnRzLgoKCiAgZm9yIChjb25zdCBpdGVtIG9mIHJhbmdlKSB7CiAgICAvLyBDaGVjayBpZiBjdXJyZW50IGVsZW1lbnQgaXMgYSBtYXJrZXIuCiAgICBpZiAoaXRlbS5uYW1lID09ICckbWFya2VyJykgewogICAgICBtYXJrZXJFbGVtZW50cy5hZGQoaXRlbSk7CiAgICB9CiAgfSAvLyBXYWxrIHRocm91Z2ggY29sbGVjdGVkIG1hcmtlciBlbGVtZW50cyBzdG9yZSBpdHMgcGF0aCBhbmQgcmVtb3ZlIGl0cyBmcm9tIHRoZSBEb2N1bWVudEZyYWdtZW50LgoKCiAgZm9yIChjb25zdCBtYXJrZXJFbGVtZW50IG9mIG1hcmtlckVsZW1lbnRzKSB7CiAgICBjb25zdCBtYXJrZXJOYW1lID0gbWFya2VyRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtbmFtZScpOwogICAgY29uc3QgY3VycmVudFBvc2l0aW9uID0gd3JpdGVyLmNyZWF0ZVBvc2l0aW9uQmVmb3JlKG1hcmtlckVsZW1lbnQpOyAvLyBXaGVuIG1hcmtlciBvZiBnaXZlbiBuYW1lIGlzIG5vdCBzdG9yZWQgaXQgbWVhbnMgdGhhdCB3ZSBoYXZlIGZvdW5kIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHJhbmdlLgoKICAgIGlmICghbWFya2Vycy5oYXMobWFya2VyTmFtZSkpIHsKICAgICAgbWFya2Vycy5zZXQobWFya2VyTmFtZSwgbmV3IE1vZGVsUmFuZ2UoY3VycmVudFBvc2l0aW9uLmNsb25lKCkpKTsgLy8gT3RoZXJ3aXNlIGlzIG1lYW5zIHRoYXQgd2UgaGF2ZSBmb3VuZCBlbmQgb2YgdGhlIG1hcmtlciByYW5nZS4KICAgIH0gZWxzZSB7CiAgICAgIG1hcmtlcnMuZ2V0KG1hcmtlck5hbWUpLmVuZCA9IGN1cnJlbnRQb3NpdGlvbi5jbG9uZSgpOwogICAgfSAvLyBSZW1vdmUgbWFya2VyIGVsZW1lbnQgZnJvbSBEb2N1bWVudEZyYWdtZW50LgoKCiAgICB3cml0ZXIucmVtb3ZlKG1hcmtlckVsZW1lbnQpOwogIH0KCiAgcmV0dXJuIG1hcmtlcnM7Cn0gLy8gQ3JlYXRlcyBtb2RlbCBmcmFnbWVudCBhY2NvcmRpbmcgdG8gZ2l2ZW4gY29udGV4dCBhbmQgcmV0dXJucyBwb3NpdGlvbiBpbiB0aGUgYm90dG9tICh0aGUgZGVlcGVzdCkgZWxlbWVudC4KCgpmdW5jdGlvbiBjcmVhdGVDb250ZXh0VHJlZShjb250ZXh0RGVmaW5pdGlvbiwgd3JpdGVyKSB7CiAgbGV0IHBvc2l0aW9uOwoKICBmb3IgKGNvbnN0IGl0ZW0gb2YgbmV3IFNjaGVtYUNvbnRleHQoY29udGV4dERlZmluaXRpb24pKSB7CiAgICBjb25zdCBhdHRyaWJ1dGVzID0ge307CgogICAgZm9yIChjb25zdCBrZXkgb2YgaXRlbS5nZXRBdHRyaWJ1dGVLZXlzKCkpIHsKICAgICAgYXR0cmlidXRlc1trZXldID0gaXRlbS5nZXRBdHRyaWJ1dGUoa2V5KTsKICAgIH0KCiAgICBjb25zdCBjdXJyZW50ID0gd3JpdGVyLmNyZWF0ZUVsZW1lbnQoaXRlbS5uYW1lLCBhdHRyaWJ1dGVzKTsKCiAgICBpZiAocG9zaXRpb24pIHsKICAgICAgd3JpdGVyLmFwcGVuZChjdXJyZW50LCBwb3NpdGlvbik7CiAgICB9CgogICAgcG9zaXRpb24gPSBNb2RlbFBvc2l0aW9uLl9jcmVhdGVBdChjdXJyZW50LCAwKTsKICB9CgogIHJldHVybiBwb3NpdGlvbjsKfQovKioKICogQ29udmVyc2lvbiBpbnRlcmZhY2UgdGhhdCBpcyByZWdpc3RlcmVkIGZvciBnaXZlbiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL3VwY2FzdGRpc3BhdGNoZXJ+VXBjYXN0RGlzcGF0Y2hlcn0KICogYW5kIGlzIHBhc3NlZCBhcyBvbmUgb2YgcGFyYW1ldGVycyB3aGVuIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vdXBjYXN0ZGlzcGF0Y2hlcn5VcGNhc3REaXNwYXRjaGVyIGRpc3BhdGNoZXJ9CiAqIGZpcmVzIGl0J3MgZXZlbnRzLgogKgogKiBAaW50ZXJmYWNlIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi91cGNhc3RkaXNwYXRjaGVyflVwY2FzdENvbnZlcnNpb25BcGkKICovCgovKioKICogU3RhcnRzIGNvbnZlcnNpb24gb2YgZ2l2ZW4gaXRlbSBieSBmaXJpbmcgYW4gYXBwcm9wcmlhdGUgZXZlbnQuCiAqCiAqIEV2ZXJ5IGZpcmVkIGV2ZW50IGlzIHBhc3NlZCAoYXMgZmlyc3QgcGFyYW1ldGVyKSBhbiBvYmplY3Qgd2l0aCBgbW9kZWxSYW5nZWAgcHJvcGVydHkuIEV2ZXJ5IGV2ZW50IG1heSBzZXQgYW5kL29yCiAqIG1vZGlmeSB0aGF0IHByb3BlcnR5LiBXaGVuIGFsbCBjYWxsYmFja3MgYXJlIGRvbmUsIHRoZSBmaW5hbCB2YWx1ZSBvZiBgbW9kZWxSYW5nZWAgcHJvcGVydHkgaXMgcmV0dXJuZWQgYnkgdGhpcyBtZXRob2QuCiAqIFRoZSBgbW9kZWxSYW5nZWAgbXVzdCBiZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZSBtb2RlbCByYW5nZX0gb3IgYG51bGxgIChhcyBzZXQgYnkgZGVmYXVsdCkuCiAqCiAqIEBtZXRob2QgI2NvbnZlcnRJdGVtCiAqIEBmaXJlcyBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vdXBjYXN0ZGlzcGF0Y2hlcn5VcGNhc3REaXNwYXRjaGVyI2V2ZW50OmVsZW1lbnQKICogQGZpcmVzIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi91cGNhc3RkaXNwYXRjaGVyflVwY2FzdERpc3BhdGNoZXIjZXZlbnQ6dGV4dAogKiBAZmlyZXMgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL3VwY2FzdGRpc3BhdGNoZXJ+VXBjYXN0RGlzcGF0Y2hlciNldmVudDpkb2N1bWVudEZyYWdtZW50CiAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L2l0ZW1+SXRlbX0gdmlld0l0ZW0gSXRlbSB0byBjb252ZXJ0LgogKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259IG1vZGVsQ3Vyc29yIFBvc2l0aW9uIG9mIGNvbnZlcnNpb24uCiAqIEByZXR1cm5zIHtPYmplY3R9IHJlc3VsdCBDb252ZXJzaW9uIHJlc3VsdC4KICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2V8bnVsbH0gcmVzdWx0Lm1vZGVsUmFuZ2UgTW9kZWwgcmFuZ2UgY29udGFpbmluZyByZXN1bHQgb2YgaXRlbSBjb252ZXJzaW9uLAogKiBjcmVhdGVkIGFuZCBtb2RpZmllZCBieSBjYWxsYmFja3MgYXR0YWNoZWQgdG8gZmlyZWQgZXZlbnQsIG9yIGBudWxsYCBpZiB0aGUgY29udmVyc2lvbiByZXN1bHQgd2FzIGluY29ycmVjdC4KICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259IHJlc3VsdC5tb2RlbEN1cnNvciBQb3NpdGlvbiB3aGVyZSBjb252ZXJzaW9uIHNob3VsZCBiZSBjb250aW51ZWQuCiAqLwoKLyoqCiAqIFN0YXJ0cyBjb252ZXJzaW9uIG9mIGFsbCBjaGlsZHJlbiBvZiBnaXZlbiBpdGVtIGJ5IGZpcmluZyBhcHByb3ByaWF0ZSBldmVudHMgZm9yIGFsbCB0aG9zZSBjaGlsZHJlbi4KICoKICogQG1ldGhvZCAjY29udmVydENoaWxkcmVuCiAqIEBmaXJlcyBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vdXBjYXN0ZGlzcGF0Y2hlcn5VcGNhc3REaXNwYXRjaGVyI2V2ZW50OmVsZW1lbnQKICogQGZpcmVzIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi91cGNhc3RkaXNwYXRjaGVyflVwY2FzdERpc3BhdGNoZXIjZXZlbnQ6dGV4dAogKiBAZmlyZXMgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL3VwY2FzdGRpc3BhdGNoZXJ+VXBjYXN0RGlzcGF0Y2hlciNldmVudDpkb2N1bWVudEZyYWdtZW50CiAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L2l0ZW1+SXRlbX0gdmlld0l0ZW0gRWxlbWVudCB3aGljaCBjaGlsZHJlbiBzaG91bGQgYmUgY29udmVydGVkLgogKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259IG1vZGVsQ3Vyc29yIFBvc2l0aW9uIG9mIGNvbnZlcnNpb24uCiAqIEByZXR1cm5zIHtPYmplY3R9IHJlc3VsdCBDb252ZXJzaW9uIHJlc3VsdC4KICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2V9IHJlc3VsdC5tb2RlbFJhbmdlIE1vZGVsIHJhbmdlIGNvbnRhaW5pbmcgcmVzdWx0cyBvZiBjb252ZXJzaW9uIG9mIGFsbCBjaGlsZHJlbiBvZiBnaXZlbiBpdGVtLgogKiBXaGVuIG5vIGNoaWxkcmVuIHdhcyBjb252ZXJ0ZWQgdGhlbiByYW5nZSBpcyBjb2xsYXBzZWQuCiAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufSByZXN1bHQubW9kZWxDdXJzb3IgUG9zaXRpb24gd2hlcmUgY29udmVyc2lvbiBzaG91bGQgYmUgY29udGludWVkLgogKi8KCi8qKgogKiBDaGVja3Mge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYSBzY2hlbWF9IHRvIGZpbmQgYWxsb3dlZCBwYXJlbnQgZm9yIGVsZW1lbnQgdGhhdCB3ZSBhcmUgZ29pbmcgdG8gaW5zZXJ0CiAqIHN0YXJ0aW5nIGZyb20gZ2l2ZW4gcG9zaXRpb24uIElmIGN1cnJlbnQgcGFyZW50IGRvZXMgbm90IGFsbG93IHRvIGluc2VydCBlbGVtZW50IGJ1dCBvbmUgb2YgdGhlIGFuY2VzdG9ycyBkb2VzIHRoZW4KICogc3BsaXQgbm9kZXMgdG8gYWxsb3dlZCBwYXJlbnQuCiAqCiAqIElmIHNjaGVtYSBhbGxvd3MgdG8gaW5zZXJ0IG5vZGUgaW4gZ2l2ZW4gcG9zaXRpb24sIG5vdGhpbmcgaXMgc3BsaXQgYW5kIG9iamVjdCB3aXRoIHRoYXQgcG9zaXRpb24gaXMgcmV0dXJuZWQuCiAqCiAqIElmIGl0IHdhcyBub3QgcG9zc2libGUgdG8gZmluZCBhbGxvd2VkIHBhcmVudCwgYG51bGxgIGlzIHJldHVybmVkLCBub3RoaW5nIGlzIHNwbGl0LgogKgogKiBPdGhlcndpc2UsIGFuY2VzdG9ycyBhcmUgc3BsaXQgYW5kIG9iamVjdCB3aXRoIHBvc2l0aW9uIGFuZCB0aGUgY29weSBvZiB0aGUgc3BsaXQgZWxlbWVudCBpcyByZXR1cm5lZC4KICoKICogRm9yIGluc3RhbmNlLCBpZiBgPGltYWdlPmAgaXMgbm90IGFsbG93ZWQgaW4gYDxwYXJhZ3JhcGg+YCBidXQgaXMgYWxsb3dlZCBpbiBgJHJvb3RgOgogKgogKgkJPHBhcmFncmFwaD5mb29bXWJhcjwvcGFyYWdyYXBoPgogKgogKiAgCS0+IHNwbGl0IGZvciBgPGltYWdlPmAgLT4KICoKICogIAk8cGFyYWdyYXBoPmZvbzwvcGFyYWdyYXBoPltdPHBhcmFncmFwaD5iYXI8L3BhcmFncmFwaD4KICoKICogSW4gdGhlIHNhbXBsZSBhYm92ZSBwb3NpdGlvbiBiZXR3ZWVuIGA8cGFyYWdyYXBoPmAgZWxlbWVudHMgd2lsbCBiZSByZXR1cm5lZCBhcyBgcG9zaXRpb25gIGFuZCB0aGUgc2Vjb25kIGBwYXJhZ3JhcGhgCiAqIGFzIGBjdXJzb3JQYXJlbnRgLgogKgogKiBAbWV0aG9kICNzcGxpdFRvQWxsb3dlZFBhcmVudAogKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259IHBvc2l0aW9uIFBvc2l0aW9uIG9uIHdoaWNoIGVsZW1lbnQgaXMgZ29pbmcgdG8gYmUgaW5zZXJ0ZWQuCiAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9ub2Rlfk5vZGV9IG5vZGUgTm9kZSB0byBpbnNlcnQuCiAqIEByZXR1cm5zIHtPYmplY3R8bnVsbH0gU3BsaXQgcmVzdWx0LiBJZiBpdCB3YXMgbm90IHBvc3NpYmxlIHRvIGZpbmQgYWxsb3dlZCBwb3NpdGlvbiBgbnVsbGAgaXMgcmV0dXJuZWQuCiAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufSBwb3NpdGlvbiBiZXR3ZWVuIHNwbGl0IGVsZW1lbnRzLgogKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR9IFtjdXJzb3JQYXJlbnRdIEVsZW1lbnQgaW5zaWRlIHdoaWNoIGN1cnNvciBzaG91bGQgYmUgcGxhY2VkIHRvCiAqIGNvbnRpbnVlIGNvbnZlcnNpb24uIFdoZW4gZWxlbWVudCBpcyBub3QgZGVmaW5lZCBpdCBtZWFucyB0aGF0IHRoZXJlIHdhcyBubyBzcGxpdC4KICovCgovKioKICogUmV0dXJucyBhbGwgdGhlIHNwbGl0IHBhcnRzIG9mIGdpdmVuIGBlbGVtZW50YCB0aGF0IHdlcmUgY3JlYXRlZCBkdXJpbmcgdXBjYXN0aW5nIHRocm91Z2ggdXNpbmcge0BsaW5rICNzcGxpdFRvQWxsb3dlZFBhcmVudH0uCiAqIEl0IGVuYWJsZXMgeW91IHRvIGVhc2lseSB0cmFjayB0aG9zZSBlbGVtZW50cyBhbmQgY29udGludWUgcHJvY2Vzc2luZyB0aGVtIGFmdGVyIHRoZXkgYXJlIHNwbGl0IGR1cmluZyB0aGVpciBjaGlsZHJlbiBjb252ZXJzaW9uLgogKgogKgkJPHBhcmFncmFwaD5Gb288aW1hZ2UgLz5iYXI8aW1hZ2UgLz5iYXo8L3BhcmFncmFwaD4gLT4KICoJCTxwYXJhZ3JhcGg+Rm9vPC9wYXJhZ3JhcGg+PGltYWdlIC8+PHBhcmFncmFwaD5iYXI8L3BhcmFncmFwaD48aW1hZ2UgLz48cGFyYWdyYXBoPmJhejwvcGFyYWdyYXBoPgogKgogKiBGb3IgYSByZWZlcmVuY2UgdG8gYW55IG9mIGFib3ZlIHBhcmFncmFwaHMsIHRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiBhbGwgdGhyZWUgcGFyYWdyYXBocyAodGhlIG9yaWdpbmFsIGVsZW1lbnQgaW5jbHVkZWQpLAogKiBzb3J0ZWQgaW4gdGhlIG9yZGVyIG9mIHRoZWlyIGNyZWF0aW9uICh0aGUgb3JpZ2luYWwgZWxlbWVudCBpcyB0aGUgZmlyc3Qgb25lKS4KICoKICogSWYgZ2l2ZW4gYGVsZW1lbnRgIHdhcyBub3Qgc3BsaXQsIGFuIGFycmF5IHdpdGggc2luZ2xlIGVsZW1lbnQgaXMgcmV0dXJuZWQuCiAqCiAqIEV4YW1wbGUgb2YgYSB1c2FnZSBpbiBhIGNvbnZlcnRlciBjb2RlOgogKgogKgkJY29uc3QgbXlFbGVtZW50ID0gY29udmVyc2lvbkFwaS53cml0ZXIuY3JlYXRlRWxlbWVudCggJ215RWxlbWVudCcgKTsKICoKICoJCS8vIENoaWxkcmVuIGNvbnZlcnNpb24gbWF5IHNwbGl0IGBteUVsZW1lbnRgLgogKgkJY29udmVyc2lvbkFwaS5jb252ZXJ0Q2hpbGRyZW4oIG15RWxlbWVudCwgbW9kZWxDdXJzb3IgKTsKICoKICoJCWNvbnN0IHNwbGl0UGFydHMgPSBjb252ZXJzaW9uQXBpLmdldFNwbGl0UGFydHMoIG15RWxlbWVudCApOwogKgkJY29uc3QgbGFzdFNwbGl0UGFydCA9IHNwbGl0UGFydHNbIHNwbGl0UGFydHMubGVuZ3RoIC0gMSBdOwogKgogKgkJLy8gU2V0dGluZyBgZGF0YS5tb2RlbFJhbmdlYCBiYXNpbmcgb24gc3BsaXQgcGFydHM6CiAqCQlkYXRhLm1vZGVsUmFuZ2UgPSBjb252ZXJzaW9uQXBpLndyaXRlci5jcmVhdGVSYW5nZSgKICoJCQljb252ZXJzaW9uQXBpLndyaXRlci5jcmVhdGVQb3NpdGlvbkJlZm9yZSggbXlFbGVtZW50ICksCiAqCQkJY29udmVyc2lvbkFwaS53cml0ZXIuY3JlYXRlUG9zaXRpb25BZnRlciggbGFzdFNwbGl0UGFydCApCiAqCQkpOwogKgogKgkJLy8gU2V0dGluZyBgZGF0YS5tb2RlbEN1cnNvcmAgdG8gY29udGludWUgYWZ0ZXIgdGhlIGxhc3Qgc3BsaXQgZWxlbWVudDoKICoJCWRhdGEubW9kZWxDdXJzb3IgPSBjb252ZXJzaW9uQXBpLndyaXRlci5jcmVhdGVQb3NpdGlvbkFmdGVyKCBsYXN0U3BsaXRQYXJ0ICk7CiAqCiAqICoqVGlwOioqIGlmIHlvdSBhcmUgdW5hYmxlIHRvIGdldCBhIHJlZmVyZW5jZSB0byB0aGUgb3JpZ2luYWwgZWxlbWVudCAoZm9yIGV4YW1wbGUgYmVjYXVzZSB0aGUgY29kZSBpcyBzcGxpdCBpbnRvIG11bHRpcGxlIGNvbnZlcnRlcnMKICogb3IgZXZlbiBjbGFzc2VzKSBidXQgaXQgd2FzIGFscmVhZHkgY29udmVydGVkLCB5b3UgbWlnaHQgd2FudCB0byBjaGVjayBmaXJzdCBlbGVtZW50IGluIGBkYXRhLm1vZGVsUmFuZ2VgLiBUaGlzIGlzIGEgY29tbW9uIHNpdHVhdGlvbgogKiBpZiBhbiBhdHRyaWJ1dGUgY29udmVydGVyIGlzIHNlcGFyYXRlZCBmcm9tIGFuIGVsZW1lbnQgY29udmVydGVyLgogKgogKiBAbWV0aG9kICNnZXRTcGxpdFBhcnRzCiAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR9IGVsZW1lbnQKICogQHJldHVybnMge0FycmF5Ljxtb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudD59CiAqLwoKLyoqCiAqIFN0b3JlcyBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IHBhcnRzIG9mIHByb2Nlc3NlZCB2aWV3IGl0ZW0gYXJlIHN0aWxsIHdhaXRpbmcgdG8gYmUgaGFuZGxlZC4gQWZ0ZXIgYSBwaWVjZSBvZiB2aWV3IGl0ZW0KICogd2FzIGNvbnZlcnRlZCwgYXBwcm9wcmlhdGUgY29uc3VtYWJsZSB2YWx1ZSBzaG91bGQgYmUge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi92aWV3Y29uc3VtYWJsZX5WaWV3Q29uc3VtYWJsZSNjb25zdW1lIGNvbnN1bWVkfS4KICoKICogQG1lbWJlciB7bW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL3ZpZXdjb25zdW1hYmxlflZpZXdDb25zdW1hYmxlfSAjY29uc3VtYWJsZQogKi8KCi8qKgogKiBDdXN0b20gZGF0YSBzdG9yZWQgYnkgY29udmVydGVycyBmb3IgY29udmVyc2lvbiBwcm9jZXNzLiBDdXN0b20gcHJvcGVydGllcyBvZiB0aGlzIG9iamVjdCBjYW4gYmUgZGVmaW5lZCBhbmQgdXNlIHRvCiAqIHBhc3MgcGFyYW1ldGVycyBiZXR3ZWVuIGNvbnZlcnRlcnMuCiAqCiAqIFRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhpcyBwcm9wZXJ0eSBhbmQgYGRhdGFgIHBhcmFtZXRlciBvZgogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL3VwY2FzdGRpc3BhdGNoZXJ+VXBjYXN0RGlzcGF0Y2hlciNldmVudDplbGVtZW50fSBpcyB0aGF0IGBkYXRhYCBwYXJhbWV0ZXJzIGFsbG93cyB5b3UKICogdG8gcGFzcyBwYXJhbWV0ZXJzIHdpdGhpbiBhIHNpbmdsZSBldmVudCBhbmQgYHN0b3JlYCB3aXRoaW4gdGhlIHdob2xlIGNvbnZlcnNpb24uCiAqCiAqIEBtZW1iZXIge09iamVjdH0gI3N0b3JlCiAqLwoKLyoqCiAqIFRoZSBtb2RlbCdzIHNjaGVtYSBpbnN0YW5jZS4KICoKICogQG1lbWJlciB7bW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hfSAjc2NoZW1hCiAqLwoKLyoqCiAqIFRoZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC93cml0ZXJ+V3JpdGVyfSBpbnN0YW5jZSB1c2VkIHRvIG1hbmlwdWxhdGUgZGF0YSBkdXJpbmcgY29udmVyc2lvbi4KICoKICogQG1lbWJlciB7bW9kdWxlOmVuZ2luZS9tb2RlbC93cml0ZXJ+V3JpdGVyfSAjd3JpdGVyCiAqLw=="},{"version":3,"sources":["/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-engine/src/conversion/upcastdispatcher.js"],"names":["ViewConsumable","ModelRange","ModelPosition","SchemaContext","CKEditorError","EmitterMixin","mix","UpcastDispatcher","constructor","conversionApi","_splitParts","Map","_modelCursor","Object","assign","convertItem","_convertItem","bind","convertChildren","_convertChildren","splitToAllowedParent","_splitToAllowedParent","getSplitParts","_getSplitParts","convert","viewItem","writer","context","fire","createContextTree","consumable","createFrom","store","modelRange","documentFragment","createDocumentFragment","_removeEmptyElements","item","Array","from","parent","getChildren","append","markers","extractMarkersFromModelFragment","clear","modelCursor","data","is","name","nextModelCursor","viewChild","result","end","node","allowedParent","schema","findAllowedParent","position","getAncestors","includes","splitResult","split","stack","treeWalkerValue","range","getWalker","type","push","originalPart","pop","splitPart","_registerSplitPair","cursorParent","has","set","list","get","element","parts","anyRemoved","keys","isEmpty","remove","delete","modelItem","markerElements","Set","_createIn","getItems","add","markerElement","markerName","getAttribute","currentPosition","createPositionBefore","clone","contextDefinition","attributes","key","getAttributeKeys","current","createElement","_createAt"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/conversion/upcastdispatcher\n */\n\nimport ViewConsumable from './viewconsumable';\nimport ModelRange from '../model/range';\nimport ModelPosition from '../model/position';\nimport { SchemaContext } from '../model/schema';\n\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\n\n/**\n * `UpcastDispatcher` is a central point of {@link module:engine/view/view view} conversion, which is a process of\n * converting given {@link module:engine/view/documentfragment~DocumentFragment view document fragment} or\n * {@link module:engine/view/element~Element} into another structure.\n * In default application, {@link module:engine/view/view view} is converted to {@link module:engine/model/model}.\n *\n * During conversion process, for all {@link module:engine/view/node~Node view nodes} from the converted view document fragment,\n * `UpcastDispatcher` fires corresponding events. Special callbacks called \"converters\" should listen to\n * `UpcastDispatcher` for those events.\n *\n * Each callback, as the second argument, is passed a special object `data` that has `viewItem`, `modelCursor` and\n * `modelRange` properties. `viewItem` property contains {@link module:engine/view/node~Node view node} or\n * {@link module:engine/view/documentfragment~DocumentFragment view document fragment}\n * that is converted at the moment and might be handled by the callback. `modelRange` property should be used to save the result\n * of conversion and is always a {@link module:engine/model/range~Range} when conversion result is correct.\n * `modelCursor` property is a {@link module:engine/model/position~Position position} on which conversion result will be inserted\n * and is a context according to {@link module:engine/model/schema~Schema schema} will be checked before the conversion.\n * See also {@link ~UpcastDispatcher#convert}. It is also shared by reference by all callbacks listening to given event.\n *\n * The third parameter passed to a callback is an instance of {@link ~UpcastDispatcher}\n * which provides additional tools for converters.\n *\n * Examples of providing callbacks for `UpcastDispatcher`:\n *\n *\t\t// Converter for links (<a>).\n *\t\teditor.data.upcastDispatcher.on( 'element:a', ( evt, data, conversionApi ) => {\n *\t\t\tif ( conversionApi.consumable.consume( data.viewItem, { name: true, attributes: [ 'href' ] } ) ) {\n *\t\t\t\t// <a> element is inline and is represented by an attribute in the model.\n *\t\t\t\t// This is why we need to convert only children.\n *\t\t\t\tconst { modelRange } = conversionApi.convertChildren( data.viewItem, data.modelCursor );\n *\n *\t\t\t\tfor ( let item of modelRange.getItems() ) {\n *\t\t\t\t\tif ( conversionApi.schema.checkAttribute( item, 'linkHref' ) ) {\n *\t\t\t\t\t\tconversionApi.writer.setAttribute( 'linkHref', data.viewItem.getAttribute( 'href' ), item );\n *\t\t\t\t\t}\n *\t\t\t\t}\n *\t\t\t}\n *\t\t} );\n *\n *\t\t// Convert <p>'s font-size style.\n *\t\t// Note: You should use a low-priority observer in order to ensure that\n *\t\t// it's executed after the element-to-element converter.\n *\t\teditor.data.upcastDispatcher.on( 'element:p', ( evt, data, conversionApi ) => {\n *\t\t\tconst { consumable, schema, writer } = conversionApi;\n *\n *\t\t\tif ( !consumable.consume( data.viewItem, { style: 'font-size' } ) ) {\n *\t\t\t\treturn;\n *\t\t\t}\n *\n *\t\t\tconst fontSize = data.viewItem.getStyle( 'font-size' );\n *\n *\t\t\t// Don't go for the model element after data.modelCursor because it might happen\n *\t\t\t// that a single view element was converted to multiple model elements. Get all of them.\n *\t\t\tfor ( const item of data.modelRange.getItems( { shallow: true } ) ) {\n *\t\t\t\tif ( schema.checkAttribute( item, 'fontSize' ) ) {\n *\t\t\t\t\twriter.setAttribute( 'fontSize', fontSize, item );\n *\t\t\t\t}\n *\t\t\t}\n *\t\t}, { priority: 'low' } );\n *\n *\t\t// Convert all elements which have no custom converter into paragraph (autoparagraphing).\n *  \teditor.data.upcastDispatcher.on( 'element', ( evt, data, conversionApi ) => {\n *  \t \t// When element is already consumed by higher priority converters then do nothing.\n *  \t \tif ( conversionApi.consumable.test( data.viewItem, { name: data.viewItem.name } ) ) {\n *  \t \t\t\tconst paragraph = conversionApi.writer.createElement( 'paragraph' );\n *\n *  \t \t\t\t// Find allowed parent for paragraph that we are going to insert. If current parent does not allow\n *  \t \t\t\t// to insert paragraph but one of the ancestors does then split nodes to allowed parent.\n *  \t \t\t\tconst splitResult = conversionApi.splitToAllowedParent( paragraph, data.modelCursor );\n *\n *  \t \t\t\t// When there is no split result it means that we can't insert paragraph in this position.\n *  \t \t\t\tif ( splitResult ) {\n *  \t \t\t\t\t// Insert paragraph in allowed position.\n *  \t \t\t\t\tconversionApi.writer.insert( paragraph, splitResult.position );\n *\n *  \t \t\t\t\t// Convert children to paragraph.\n *  \t \t\t\t\tconst { modelRange } = conversionApi.convertChildren(\n *  \t \t\t\t\t\tdata.viewItem,\n *  \t \t\t\t\t\tconversionApi.writer.createPositionAt( paragraph, 0 )\n *  \t \t\t\t\t);\n *\n * \t\t\t\t\t\t// Set as conversion result, attribute converters may use this property.\n *  \t \t\t\t\tdata.modelRange = conversionApi.writer.createRange(\n *  \t \t\t\t\t\tconversionApi.writer.createPositionBefore( paragraph ),\n *  \t \t\t\t\t\tmodelRange.end\n *  \t \t\t\t\t);\n *\n *  \t \t\t\t\t// Continue conversion inside paragraph.\n *  \t \t\t\t\tdata.modelCursor = data.modelRange.end;\n *  \t \t\t\t}\n *  \t \t\t}\n *  \t \t}\n *  \t }, { priority: 'low' } );\n *\n * Before each conversion process, `UpcastDispatcher` fires {@link ~UpcastDispatcher#event:viewCleanup}\n * event which can be used to prepare tree view for conversion.\n *\n * @mixes module:utils/emittermixin~EmitterMixin\n * @fires viewCleanup\n * @fires element\n * @fires text\n * @fires documentFragment\n */\nexport default class UpcastDispatcher {\n\t/**\n\t * Creates a `UpcastDispatcher` that operates using passed API.\n\t *\n\t * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi\n\t * @param {Object} [conversionApi] Additional properties for interface that will be passed to events fired\n\t * by `UpcastDispatcher`.\n\t */\n\tconstructor( conversionApi = {} ) {\n\t\t/**\n\t\t * List of the elements that were created during splitting.\n\t\t *\n\t\t * After conversion process the list is cleared.\n\t\t *\n\t\t * @private\n\t\t * @type {Map.<module:engine/model/element~Element,Array.<module:engine/model/element~Element>>}\n\t\t */\n\t\tthis._splitParts = new Map();\n\n\t\t/**\n\t\t * Position in the temporary structure where the converted content is inserted. The structure reflect the context of\n\t\t * the target position where the content will be inserted. This property is build based on the context parameter of the\n\t\t * convert method.\n\t\t *\n\t\t * @private\n\t\t * @type {module:engine/model/position~Position|null}\n\t\t */\n\t\tthis._modelCursor = null;\n\n\t\t/**\n\t\t * Interface passed by dispatcher to the events callbacks.\n\t\t *\n\t\t * @member {module:engine/conversion/upcastdispatcher~UpcastConversionApi}\n\t\t */\n\t\tthis.conversionApi = Object.assign( {}, conversionApi );\n\n\t\t// `convertItem`, `convertChildren` and `splitToAllowedParent` are bound to this `UpcastDispatcher`\n\t\t// instance and set on `conversionApi`. This way only a part of `UpcastDispatcher` API is exposed.\n\t\tthis.conversionApi.convertItem = this._convertItem.bind( this );\n\t\tthis.conversionApi.convertChildren = this._convertChildren.bind( this );\n\t\tthis.conversionApi.splitToAllowedParent = this._splitToAllowedParent.bind( this );\n\t\tthis.conversionApi.getSplitParts = this._getSplitParts.bind( this );\n\t}\n\n\t/**\n\t * Starts the conversion process. The entry point for the conversion.\n\t *\n\t * @fires element\n\t * @fires text\n\t * @fires documentFragment\n\t * @param {module:engine/view/documentfragment~DocumentFragment|module:engine/view/element~Element} viewItem\n\t * Part of the view to be converted.\n\t * @param {module:engine/model/writer~Writer} writer Instance of model writer.\n\t * @param {module:engine/model/schema~SchemaContextDefinition} [context=['$root']] Elements will be converted according to this context.\n\t * @returns {module:engine/model/documentfragment~DocumentFragment} Model data that is a result of the conversion process\n\t * wrapped in `DocumentFragment`. Converted marker elements will be set as that document fragment's\n\t * {@link module:engine/model/documentfragment~DocumentFragment#markers static markers map}.\n\t */\n\tconvert( viewItem, writer, context = [ '$root' ] ) {\n\t\tthis.fire( 'viewCleanup', viewItem );\n\n\t\t// Create context tree and set position in the top element.\n\t\t// Items will be converted according to this position.\n\t\tthis._modelCursor = createContextTree( context, writer );\n\n\t\t// Store writer in conversion as a conversion API\n\t\t// to be sure that conversion process will use the same batch.\n\t\tthis.conversionApi.writer = writer;\n\n\t\t// Create consumable values list for conversion process.\n\t\tthis.conversionApi.consumable = ViewConsumable.createFrom( viewItem );\n\n\t\t// Custom data stored by converter for conversion process.\n\t\tthis.conversionApi.store = {};\n\n\t\t// Do the conversion.\n\t\tconst { modelRange } = this._convertItem( viewItem, this._modelCursor );\n\n\t\t// Conversion result is always a document fragment so let's create it.\n\t\tconst documentFragment = writer.createDocumentFragment();\n\n\t\t// When there is a conversion result.\n\t\tif ( modelRange ) {\n\t\t\t// Remove all empty elements that were create while splitting.\n\t\t\tthis._removeEmptyElements();\n\n\t\t\t// Move all items that were converted in context tree to the document fragment.\n\t\t\tfor ( const item of Array.from( this._modelCursor.parent.getChildren() ) ) {\n\t\t\t\twriter.append( item, documentFragment );\n\t\t\t}\n\n\t\t\t// Extract temporary markers elements from model and set as static markers collection.\n\t\t\tdocumentFragment.markers = extractMarkersFromModelFragment( documentFragment, writer );\n\t\t}\n\n\t\t// Clear context position.\n\t\tthis._modelCursor = null;\n\n\t\t// Clear split elements lists.\n\t\tthis._splitParts.clear();\n\n\t\t// Clear conversion API.\n\t\tthis.conversionApi.writer = null;\n\t\tthis.conversionApi.store = null;\n\n\t\t// Return fragment as conversion result.\n\t\treturn documentFragment;\n\t}\n\n\t/**\n\t * @private\n\t * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#convertItem\n\t */\n\t_convertItem( viewItem, modelCursor ) {\n\t\tconst data = Object.assign( { viewItem, modelCursor, modelRange: null } );\n\n\t\tif ( viewItem.is( 'element' ) ) {\n\t\t\tthis.fire( 'element:' + viewItem.name, data, this.conversionApi );\n\t\t} else if ( viewItem.is( 'text' ) ) {\n\t\t\tthis.fire( 'text', data, this.conversionApi );\n\t\t} else {\n\t\t\tthis.fire( 'documentFragment', data, this.conversionApi );\n\t\t}\n\n\t\t// Handle incorrect conversion result.\n\t\tif ( data.modelRange && !( data.modelRange instanceof ModelRange ) ) {\n\t\t\t/**\n\t\t\t * Incorrect conversion result was dropped.\n\t\t\t *\n\t\t\t * {@link module:engine/model/range~Range Model range} should be a conversion result.\n\t\t\t *\n\t\t\t * @error view-conversion-dispatcher-incorrect-result\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'view-conversion-dispatcher-incorrect-result: Incorrect conversion result was dropped.', this );\n\t\t}\n\n\t\treturn { modelRange: data.modelRange, modelCursor: data.modelCursor };\n\t}\n\n\t/**\n\t * @private\n\t * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#convertChildren\n\t */\n\t_convertChildren( viewItem, modelCursor ) {\n\t\tconst modelRange = new ModelRange( modelCursor );\n\t\tlet nextModelCursor = modelCursor;\n\n\t\tfor ( const viewChild of Array.from( viewItem.getChildren() ) ) {\n\t\t\tconst result = this._convertItem( viewChild, nextModelCursor );\n\n\t\t\tif ( result.modelRange instanceof ModelRange ) {\n\t\t\t\tmodelRange.end = result.modelRange.end;\n\t\t\t\tnextModelCursor = result.modelCursor;\n\t\t\t}\n\t\t}\n\n\t\treturn { modelRange, modelCursor: nextModelCursor };\n\t}\n\n\t/**\n\t * @private\n\t * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#splitToAllowedParent\n\t */\n\t_splitToAllowedParent( node, modelCursor ) {\n\t\t// Try to find allowed parent.\n\t\tconst allowedParent = this.conversionApi.schema.findAllowedParent( modelCursor, node );\n\n\t\t// When there is no parent that allows to insert node then return `null`.\n\t\tif ( !allowedParent ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// When current position parent allows to insert node then return this position.\n\t\tif ( allowedParent === modelCursor.parent ) {\n\t\t\treturn { position: modelCursor };\n\t\t}\n\n\t\t// When allowed parent is in context tree.\n\t\tif ( this._modelCursor.parent.getAncestors().includes( allowedParent ) ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Split element to allowed parent.\n\t\tconst splitResult = this.conversionApi.writer.split( modelCursor, allowedParent );\n\n\t\t// Using the range returned by `model.Writer#split`, we will pair original elements with their split parts.\n\t\t//\n\t\t// The range returned from the writer spans \"over the split\" or, precisely saying, from the end of the original element (the one\n\t\t// that got split) to the beginning of the other part of that element:\n\t\t//\n\t\t// <limit><a><b><c>X[]Y</c></b><a></limit> ->\n\t\t// <limit><a><b><c>X[</c></b></a><a><b><c>]Y</c></b></a>\n\t\t//\n\t\t// After the split there cannot be any full node between the positions in `splitRange`. The positions are touching.\n\t\t// Also, because of how splitting works, it is easy to notice, that \"closing tags\" are in the reverse order than \"opening tags\".\n\t\t// Also, since we split all those elements, each of them has to have the other part.\n\t\t//\n\t\t// With those observations in mind, we will pair the original elements with their split parts by saving \"closing tags\" and matching\n\t\t// them with \"opening tags\" in the reverse order. For that we can use a stack.\n\t\tconst stack = [];\n\n\t\tfor ( const treeWalkerValue of splitResult.range.getWalker() ) {\n\t\t\tif ( treeWalkerValue.type == 'elementEnd' ) {\n\t\t\t\tstack.push( treeWalkerValue.item );\n\t\t\t} else {\n\t\t\t\t// There should not be any text nodes after the element is split, so the only other value is `elementStart`.\n\t\t\t\tconst originalPart = stack.pop();\n\t\t\t\tconst splitPart = treeWalkerValue.item;\n\n\t\t\t\tthis._registerSplitPair( originalPart, splitPart );\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tposition: splitResult.position,\n\t\t\tcursorParent: splitResult.range.end.parent\n\t\t};\n\t}\n\n\t/**\n\t * Registers that `splitPart` element is a split part of the `originalPart` element.\n\t *\n\t * Data set by this method is used by {@link #_getSplitParts} and {@link #_removeEmptyElements}.\n\t *\n\t * @private\n\t * @param {module:engine/model/element~Element} originalPart\n\t * @param {module:engine/model/element~Element} splitPart\n\t */\n\t_registerSplitPair( originalPart, splitPart ) {\n\t\tif ( !this._splitParts.has( originalPart ) ) {\n\t\t\tthis._splitParts.set( originalPart, [ originalPart ] );\n\t\t}\n\n\t\tconst list = this._splitParts.get( originalPart );\n\n\t\tthis._splitParts.set( splitPart, list );\n\t\tlist.push( splitPart );\n\t}\n\n\t/**\n\t * @private\n\t * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#getSplitParts\n\t */\n\t_getSplitParts( element ) {\n\t\tlet parts;\n\n\t\tif ( !this._splitParts.has( element ) ) {\n\t\t\tparts = [ element ];\n\t\t} else {\n\t\t\tparts = this._splitParts.get( element );\n\t\t}\n\n\t\treturn parts;\n\t}\n\n\t/**\n\t * Checks if there are any empty elements created while splitting and removes them.\n\t *\n\t * This method works recursively to re-check empty elements again after at least one element was removed in the initial call,\n\t * as some elements might have become empty after other empty elements were removed from them.\n\t *\n\t * @private\n\t */\n\t_removeEmptyElements() {\n\t\tlet anyRemoved = false;\n\n\t\tfor ( const element of this._splitParts.keys() ) {\n\t\t\tif ( element.isEmpty ) {\n\t\t\t\tthis.conversionApi.writer.remove( element );\n\t\t\t\tthis._splitParts.delete( element );\n\n\t\t\t\tanyRemoved = true;\n\t\t\t}\n\t\t}\n\n\t\tif ( anyRemoved ) {\n\t\t\tthis._removeEmptyElements();\n\t\t}\n\t}\n\n\t/**\n\t * Fired before the first conversion event, at the beginning of upcast (view to model conversion) process.\n\t *\n\t * @event viewCleanup\n\t * @param {module:engine/view/documentfragment~DocumentFragment|module:engine/view/element~Element}\n\t * viewItem Part of the view to be converted.\n\t */\n\n\t/**\n\t * Fired when {@link module:engine/view/element~Element} is converted.\n\t *\n\t * `element` is a namespace event for a class of events. Names of actually called events follow this pattern:\n\t * `element:<elementName>` where `elementName` is the name of converted element. This way listeners may listen to\n\t * all elements conversion or to conversion of specific elements.\n\t *\n\t * @event element\n\t * @param {Object} data Conversion data. Keep in mind that this object is shared by reference between all\n\t * callbacks that will be called. This means that callbacks can override values if needed, and those values will\n\t * be available in other callbacks.\n\t * @param {module:engine/view/item~Item} data.viewItem Converted item.\n\t * @param {module:engine/model/position~Position} data.modelCursor Position where a converter should start changes.\n\t * Change this value for the next converter to tell where the conversion should continue.\n\t * @param {module:engine/model/range~Range} data.modelRange The current state of conversion result. Every change to\n\t * converted element should be reflected by setting or modifying this property.\n\t * @param {module:engine/conversion/upcastdispatcher~UpcastConversionApi} conversionApi Conversion utilities to be used by callback.\n\t */\n\n\t/**\n\t * Fired when {@link module:engine/view/text~Text} is converted.\n\t *\n\t * @event text\n\t * @see #event:element\n\t */\n\n\t/**\n\t * Fired when {@link module:engine/view/documentfragment~DocumentFragment} is converted.\n\t *\n\t * @event documentFragment\n\t * @see #event:element\n\t */\n}\n\nmix( UpcastDispatcher, EmitterMixin );\n\n// Traverses given model item and searches elements which marks marker range. Found element is removed from\n// DocumentFragment but path of this element is stored in a Map which is then returned.\n//\n// @param {module:engine/view/documentfragment~DocumentFragment|module:engine/view/node~Node} modelItem Fragment of model.\n// @returns {Map<String, module:engine/model/range~Range>} List of static markers.\nfunction extractMarkersFromModelFragment( modelItem, writer ) {\n\tconst markerElements = new Set();\n\tconst markers = new Map();\n\n\t// Create ModelTreeWalker.\n\tconst range = ModelRange._createIn( modelItem ).getItems();\n\n\t// Walk through DocumentFragment and collect marker elements.\n\tfor ( const item of range ) {\n\t\t// Check if current element is a marker.\n\t\tif ( item.name == '$marker' ) {\n\t\t\tmarkerElements.add( item );\n\t\t}\n\t}\n\n\t// Walk through collected marker elements store its path and remove its from the DocumentFragment.\n\tfor ( const markerElement of markerElements ) {\n\t\tconst markerName = markerElement.getAttribute( 'data-name' );\n\t\tconst currentPosition = writer.createPositionBefore( markerElement );\n\n\t\t// When marker of given name is not stored it means that we have found the beginning of the range.\n\t\tif ( !markers.has( markerName ) ) {\n\t\t\tmarkers.set( markerName, new ModelRange( currentPosition.clone() ) );\n\t\t// Otherwise is means that we have found end of the marker range.\n\t\t} else {\n\t\t\tmarkers.get( markerName ).end = currentPosition.clone();\n\t\t}\n\n\t\t// Remove marker element from DocumentFragment.\n\t\twriter.remove( markerElement );\n\t}\n\n\treturn markers;\n}\n\n// Creates model fragment according to given context and returns position in the bottom (the deepest) element.\nfunction createContextTree( contextDefinition, writer ) {\n\tlet position;\n\n\tfor ( const item of new SchemaContext( contextDefinition ) ) {\n\t\tconst attributes = {};\n\n\t\tfor ( const key of item.getAttributeKeys() ) {\n\t\t\tattributes[ key ] = item.getAttribute( key );\n\t\t}\n\n\t\tconst current = writer.createElement( item.name, attributes );\n\n\t\tif ( position ) {\n\t\t\twriter.append( current, position );\n\t\t}\n\n\t\tposition = ModelPosition._createAt( current, 0 );\n\t}\n\n\treturn position;\n}\n\n/**\n * Conversion interface that is registered for given {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher}\n * and is passed as one of parameters when {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher dispatcher}\n * fires it's events.\n *\n * @interface module:engine/conversion/upcastdispatcher~UpcastConversionApi\n */\n\n/**\n * Starts conversion of given item by firing an appropriate event.\n *\n * Every fired event is passed (as first parameter) an object with `modelRange` property. Every event may set and/or\n * modify that property. When all callbacks are done, the final value of `modelRange` property is returned by this method.\n * The `modelRange` must be {@link module:engine/model/range~Range model range} or `null` (as set by default).\n *\n * @method #convertItem\n * @fires module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:element\n * @fires module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:text\n * @fires module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:documentFragment\n * @param {module:engine/view/item~Item} viewItem Item to convert.\n * @param {module:engine/model/position~Position} modelCursor Position of conversion.\n * @returns {Object} result Conversion result.\n * @returns {module:engine/model/range~Range|null} result.modelRange Model range containing result of item conversion,\n * created and modified by callbacks attached to fired event, or `null` if the conversion result was incorrect.\n * @returns {module:engine/model/position~Position} result.modelCursor Position where conversion should be continued.\n */\n\n/**\n * Starts conversion of all children of given item by firing appropriate events for all those children.\n *\n * @method #convertChildren\n * @fires module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:element\n * @fires module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:text\n * @fires module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:documentFragment\n * @param {module:engine/view/item~Item} viewItem Element which children should be converted.\n * @param {module:engine/model/position~Position} modelCursor Position of conversion.\n * @returns {Object} result Conversion result.\n * @returns {module:engine/model/range~Range} result.modelRange Model range containing results of conversion of all children of given item.\n * When no children was converted then range is collapsed.\n * @returns {module:engine/model/position~Position} result.modelCursor Position where conversion should be continued.\n */\n\n/**\n * Checks {@link module:engine/model/schema~Schema schema} to find allowed parent for element that we are going to insert\n * starting from given position. If current parent does not allow to insert element but one of the ancestors does then\n * split nodes to allowed parent.\n *\n * If schema allows to insert node in given position, nothing is split and object with that position is returned.\n *\n * If it was not possible to find allowed parent, `null` is returned, nothing is split.\n *\n * Otherwise, ancestors are split and object with position and the copy of the split element is returned.\n *\n * For instance, if `<image>` is not allowed in `<paragraph>` but is allowed in `$root`:\n *\n *\t\t<paragraph>foo[]bar</paragraph>\n *\n *  \t-> split for `<image>` ->\n *\n *  \t<paragraph>foo</paragraph>[]<paragraph>bar</paragraph>\n *\n * In the sample above position between `<paragraph>` elements will be returned as `position` and the second `paragraph`\n * as `cursorParent`.\n *\n * @method #splitToAllowedParent\n * @param {module:engine/model/position~Position} position Position on which element is going to be inserted.\n * @param {module:engine/model/node~Node} node Node to insert.\n * @returns {Object|null} Split result. If it was not possible to find allowed position `null` is returned.\n * @returns {module:engine/model/position~Position} position between split elements.\n * @returns {module:engine/model/element~Element} [cursorParent] Element inside which cursor should be placed to\n * continue conversion. When element is not defined it means that there was no split.\n */\n\n/**\n * Returns all the split parts of given `element` that were created during upcasting through using {@link #splitToAllowedParent}.\n * It enables you to easily track those elements and continue processing them after they are split during their children conversion.\n *\n *\t\t<paragraph>Foo<image />bar<image />baz</paragraph> ->\n *\t\t<paragraph>Foo</paragraph><image /><paragraph>bar</paragraph><image /><paragraph>baz</paragraph>\n *\n * For a reference to any of above paragraphs, the function will return all three paragraphs (the original element included),\n * sorted in the order of their creation (the original element is the first one).\n *\n * If given `element` was not split, an array with single element is returned.\n *\n * Example of a usage in a converter code:\n *\n *\t\tconst myElement = conversionApi.writer.createElement( 'myElement' );\n *\n *\t\t// Children conversion may split `myElement`.\n *\t\tconversionApi.convertChildren( myElement, modelCursor );\n *\n *\t\tconst splitParts = conversionApi.getSplitParts( myElement );\n *\t\tconst lastSplitPart = splitParts[ splitParts.length - 1 ];\n *\n *\t\t// Setting `data.modelRange` basing on split parts:\n *\t\tdata.modelRange = conversionApi.writer.createRange(\n *\t\t\tconversionApi.writer.createPositionBefore( myElement ),\n *\t\t\tconversionApi.writer.createPositionAfter( lastSplitPart )\n *\t\t);\n *\n *\t\t// Setting `data.modelCursor` to continue after the last split element:\n *\t\tdata.modelCursor = conversionApi.writer.createPositionAfter( lastSplitPart );\n *\n * **Tip:** if you are unable to get a reference to the original element (for example because the code is split into multiple converters\n * or even classes) but it was already converted, you might want to check first element in `data.modelRange`. This is a common situation\n * if an attribute converter is separated from an element converter.\n *\n * @method #getSplitParts\n * @param {module:engine/model/element~Element} element\n * @returns {Array.<module:engine/model/element~Element>}\n */\n\n/**\n * Stores information about what parts of processed view item are still waiting to be handled. After a piece of view item\n * was converted, appropriate consumable value should be {@link module:engine/conversion/viewconsumable~ViewConsumable#consume consumed}.\n *\n * @member {module:engine/conversion/viewconsumable~ViewConsumable} #consumable\n */\n\n/**\n * Custom data stored by converters for conversion process. Custom properties of this object can be defined and use to\n * pass parameters between converters.\n *\n * The difference between this property and `data` parameter of\n * {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:element} is that `data` parameters allows you\n * to pass parameters within a single event and `store` within the whole conversion.\n *\n * @member {Object} #store\n */\n\n/**\n * The model's schema instance.\n *\n * @member {module:engine/model/schema~Schema} #schema\n */\n\n/**\n * The {@link module:engine/model/writer~Writer} instance used to manipulate data during conversion.\n *\n * @member {module:engine/model/writer~Writer} #writer\n */\n"]}]}