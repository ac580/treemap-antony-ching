{"remainingRequest":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/babel-loader/lib/index.js!/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-engine/src/model/position.js","dependencies":[{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-engine/src/model/position.js","mtime":499162500000},{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js","mtime":499162500000},{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/babel-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:LyoqCiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDE5LCBDS1NvdXJjZSAtIEZyZWRlcmljbyBLbmFiYmVuLiBBbGwgcmlnaHRzIHJlc2VydmVkLgogKiBGb3IgbGljZW5zaW5nLCBzZWUgTElDRU5TRS5tZCBvciBodHRwczovL2NrZWRpdG9yLmNvbS9sZWdhbC9ja2VkaXRvci1vc3MtbGljZW5zZQogKi8KCi8qKgogKiBAbW9kdWxlIGVuZ2luZS9tb2RlbC9wb3NpdGlvbgogKi8KaW1wb3J0IFRyZWVXYWxrZXIgZnJvbSAnLi90cmVld2Fsa2VyJzsKaW1wb3J0IGNvbXBhcmVBcnJheXMgZnJvbSAnQGNrZWRpdG9yL2NrZWRpdG9yNS11dGlscy9zcmMvY29tcGFyZWFycmF5cyc7CmltcG9ydCBDS0VkaXRvckVycm9yIGZyb20gJ0Bja2VkaXRvci9ja2VkaXRvcjUtdXRpbHMvc3JjL2NrZWRpdG9yZXJyb3InOwppbXBvcnQgVGV4dCBmcm9tICcuL3RleHQnOwppbXBvcnQgeyBsYXN0IH0gZnJvbSAnbG9kYXNoLWVzJzsgLy8gVG8gY2hlY2sgaWYgY29tcG9uZW50IGlzIGxvYWRlZCBtb3JlIHRoYW4gb25jZS4KCmltcG9ydCAnQGNrZWRpdG9yL2NrZWRpdG9yNS11dGlscy9zcmMvdmVyc2lvbic7Ci8qKgogKiBSZXByZXNlbnRzIGEgcG9zaXRpb24gaW4gdGhlIG1vZGVsIHRyZWUuCiAqCiAqIEEgcG9zaXRpb24gaXMgcmVwcmVzZW50ZWQgYnkgaXRzIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9uI3Jvb3R9IGFuZAogKiBhIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9uI3BhdGh9IGluIHRoYXQgcm9vdC4KICoKICogWW91IGNhbiBjcmVhdGUgcG9zaXRpb24gaW5zdGFuY2VzIHZpYSBpdHMgY29uc3RydWN0b3Igb3IgdGhlIGBjcmVhdGVQb3NpdGlvbiooKWAgZmFjdG9yeSBtZXRob2RzIG9mCiAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL21vZGVsfk1vZGVsfSBhbmQge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvd3JpdGVyfldyaXRlcn0uCiAqCiAqICoqTm90ZToqKiBQb3NpdGlvbiBpcyBiYXNlZCBvbiBvZmZzZXRzLCBub3QgaW5kZXhlcy4gVGhpcyBtZWFucyB0aGF0IGEgcG9zaXRpb24gYmV0d2VlbiB0d28gdGV4dCBub2RlcwogKiBgZm9vYCBhbmQgYGJhcmAgaGFzIG9mZnNldCBgM2AsIG5vdCBgMWAuIFNlZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbiNwYXRofSBmb3IgbW9yZSBpbmZvcm1hdGlvbi4KICoKICogU2luY2UgYSBwb3NpdGlvbiBpbiB0aGUgbW9kZWwgaXMgcmVwcmVzZW50ZWQgYnkgYSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbiNyb290IHBvc2l0aW9uIHJvb3R9IGFuZAogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbiNwYXRoIHBvc2l0aW9uIHBhdGh9IGl0IGlzIHBvc3NpYmxlIHRvIGNyZWF0ZSBwb3NpdGlvbnMgcGxhY2VkIGluIG5vbi1leGlzdGluZyBwbGFjZXMuCiAqIFRoaXMgcmVxdWlyZW1lbnQgaXMgaW1wb3J0YW50IGZvciBvcGVyYXRpb25hbCB0cmFuc2Zvcm1hdGlvbiBhbGdvcml0aG1zLgogKgogKiBBbHNvLCB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9vcGVyYXRpb24vb3BlcmF0aW9ufk9wZXJhdGlvbiBvcGVyYXRpb25zfQogKiBrZXB0IGluIHRoZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudH5Eb2N1bWVudCNoaXN0b3J5IGRvY3VtZW50IGhpc3Rvcnl9CiAqIGFyZSBzdG9yaW5nIHBvc2l0aW9ucyAoYW5kIHJhbmdlcykgd2hpY2ggd2VyZSBjb3JyZWN0IHdoZW4gdGhvc2Ugb3BlcmF0aW9ucyB3ZXJlIGFwcGxpZWQsIGJ1dCBtYXkgbm90IGJlIGNvcnJlY3QKICogYWZ0ZXIgdGhlIGRvY3VtZW50IGhhcyBjaGFuZ2VkLgogKgogKiBXaGVuIGNoYW5nZXMgYXJlIGFwcGxpZWQgdG8gdGhlIG1vZGVsLCBpdCBtYXkgYWxzbyBoYXBwZW4gdGhhdCB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbiNwYXJlbnQgcG9zaXRpb24gcGFyZW50fQogKiB3aWxsIGNoYW5nZSBldmVuIGlmIHBvc2l0aW9uIHBhdGggaGFzIG5vdCBjaGFuZ2VkLiBLZWVwIGluIG1pbmQsIHRoYXQgaWYgYSBwb3NpdGlvbiBsZWFkcyB0byBub24tZXhpc3RpbmcgZWxlbWVudCwKICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb24jcGFyZW50fSBhbmQgc29tZSBvdGhlciBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIHdpbGwgdGhyb3cgZXJyb3JzLgogKgogKiBJbiBtb3N0IGNhc2VzLCBwb3NpdGlvbiB3aXRoIHdyb25nIHBhdGggaXMgY2F1c2VkIGJ5IGFuIGVycm9yIGluIGNvZGUsIGJ1dCBpdCBpcyBzb21ldGltZXMgbmVlZGVkLCBhcyBkZXNjcmliZWQgYWJvdmUuCiAqLwoKZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9zaXRpb24gewogIC8qKgogICAqIENyZWF0ZXMgYSBwb3NpdGlvbi4KICAgKgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR8bW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnR9IHJvb3QgUm9vdCBvZiB0aGUgcG9zaXRpb24uCiAgICogQHBhcmFtIHtBcnJheS48TnVtYmVyPn0gcGF0aCBQb3NpdGlvbiBwYXRoLiBTZWUge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb24jcGF0aH0uCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9uU3RpY2tpbmVzc30gW3N0aWNraW5lc3M9J3RvTm9uZSddIFBvc2l0aW9uIHN0aWNraW5lc3MuCiAgICogU2VlIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9uU3RpY2tpbmVzc30uCiAgICovCiAgY29uc3RydWN0b3Iocm9vdCwgcGF0aCwgc3RpY2tpbmVzcyA9ICd0b05vbmUnKSB7CiAgICBpZiAoIXJvb3QuaXMoJ2VsZW1lbnQnKSAmJiAhcm9vdC5pcygnZG9jdW1lbnRGcmFnbWVudCcpKSB7CiAgICAgIC8qKgogICAgICAgKiBQb3NpdGlvbiByb290IGlzIGludmFsaWQuCiAgICAgICAqCiAgICAgICAqIFBvc2l0aW9ucyBjYW4gb25seSBiZSBhbmNob3JlZCBpbiBlbGVtZW50cyBvciBkb2N1bWVudCBmcmFnbWVudHMuCiAgICAgICAqCiAgICAgICAqIEBlcnJvciBtb2RlbC1wb3NpdGlvbi1yb290LWludmFsaWQKICAgICAgICovCiAgICAgIHRocm93IG5ldyBDS0VkaXRvckVycm9yKCdtb2RlbC1wb3NpdGlvbi1yb290LWludmFsaWQ6IFBvc2l0aW9uIHJvb3QgaW52YWxpZC4nLCByb290KTsKICAgIH0KCiAgICBpZiAoIShwYXRoIGluc3RhbmNlb2YgQXJyYXkpIHx8IHBhdGgubGVuZ3RoID09PSAwKSB7CiAgICAgIC8qKgogICAgICAgKiBQb3NpdGlvbiBwYXRoIG11c3QgYmUgYW4gYXJyYXkgd2l0aCBhdCBsZWFzdCBvbmUgaXRlbS4KICAgICAgICoKICAgICAgICogQGVycm9yIG1vZGVsLXBvc2l0aW9uLXBhdGgtaW5jb3JyZWN0LWZvcm1hdAogICAgICAgKiBAcGFyYW0gcGF0aAogICAgICAgKi8KICAgICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ21vZGVsLXBvc2l0aW9uLXBhdGgtaW5jb3JyZWN0LWZvcm1hdDogUG9zaXRpb24gcGF0aCBtdXN0IGJlIGFuIGFycmF5IHdpdGggYXQgbGVhc3Qgb25lIGl0ZW0uJywgcm9vdCwgewogICAgICAgIHBhdGgKICAgICAgfSk7CiAgICB9IC8vIE5vcm1hbGl6ZSB0aGUgcm9vdCBhbmQgcGF0aCAoaWYgZWxlbWVudCB3YXMgcGFzc2VkKS4KCgogICAgcGF0aCA9IHJvb3QuZ2V0UGF0aCgpLmNvbmNhdChwYXRoKTsKICAgIHJvb3QgPSByb290LnJvb3Q7CiAgICAvKioKICAgICAqIFJvb3Qgb2YgdGhlIHBvc2l0aW9uIHBhdGguCiAgICAgKgogICAgICogQHJlYWRvbmx5CiAgICAgKiBAbWVtYmVyIHttb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudHxtb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudH0KICAgICAqIG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb24jcm9vdAogICAgICovCgogICAgdGhpcy5yb290ID0gcm9vdDsKICAgIC8qKgogICAgICogUG9zaXRpb24gb2YgdGhlIG5vZGUgaW4gdGhlIHRyZWUuICoqUGF0aCBjb250YWlucyBvZmZzZXRzLCBub3QgaW5kZXhlcy4qKgogICAgICoKICAgICAqIFBvc2l0aW9uIGNhbiBiZSBwbGFjZWQgYmVmb3JlLCBhZnRlciBvciBpbiBhIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL25vZGV+Tm9kZSBub2RlfSBpZiB0aGF0IG5vZGUgaGFzCiAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9ub2Rlfk5vZGUjb2Zmc2V0U2l6ZX0gZ3JlYXRlciB0aGFuIGAxYC4gSXRlbXMgaW4gcG9zaXRpb24gcGF0aCBhcmUKICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL25vZGV+Tm9kZSNzdGFydE9mZnNldCBzdGFydGluZyBvZmZzZXRzfSBvZiBwb3NpdGlvbiBhbmNlc3RvcnMsIHN0YXJ0aW5nIGZyb20gZGlyZWN0IHJvb3QgY2hpbGRyZW4sCiAgICAgKiBkb3duIHRvIHRoZSBwb3NpdGlvbiBvZmZzZXQgaW4gaXQncyBwYXJlbnQuCiAgICAgKgogICAgICoJCSBST09UCiAgICAgKgkJICB8LSBQICAgICAgICAgICAgYmVmb3JlOiBbIDAgXSAgICAgICAgIGFmdGVyOiBbIDEgXQogICAgICoJCSAgfC0gVUwgICAgICAgICAgIGJlZm9yZTogWyAxIF0gICAgICAgICBhZnRlcjogWyAyIF0KICAgICAqCQkgICAgIHwtIExJICAgICAgICBiZWZvcmU6IFsgMSwgMCBdICAgICAgYWZ0ZXI6IFsgMSwgMSBdCiAgICAgKgkJICAgICB8ICB8LSBmb28gICAgYmVmb3JlOiBbIDEsIDAsIDAgXSAgIGFmdGVyOiBbIDEsIDAsIDMgXQogICAgICoJCSAgICAgfC0gTEkgICAgICAgIGJlZm9yZTogWyAxLCAxIF0gICAgICBhZnRlcjogWyAxLCAyIF0KICAgICAqCQkgICAgICAgIHwtIGJhciAgICBiZWZvcmU6IFsgMSwgMSwgMCBdICAgYWZ0ZXI6IFsgMSwgMSwgMyBdCiAgICAgKgogICAgICogYGZvb2AgYW5kIGBiYXJgIGFyZSByZXByZXNlbnRpbmcge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvdGV4dH5UZXh0IHRleHQgbm9kZXN9LiBTaW5jZSB0ZXh0IG5vZGVzIGhhcyBvZmZzZXQgc2l6ZQogICAgICogZ3JlYXRlciB0aGFuIGAxYCB5b3UgY2FuIHBsYWNlIHBvc2l0aW9uIG9mZnNldCBiZXR3ZWVuIHRoZWlyIHN0YXJ0IGFuZCBlbmQ6CiAgICAgKgogICAgICoJCSBST09UCiAgICAgKgkJICB8LSBQCiAgICAgKgkJICB8LSBVTAogICAgICoJCSAgICAgfC0gTEkKICAgICAqCQkgICAgIHwgIHwtIGZeb3xvICBeIGhhcyBwYXRoOiBbIDEsIDAsIDEgXSAgIHwgaGFzIHBhdGg6IFsgMSwgMCwgMiBdCiAgICAgKgkJICAgICB8LSBMSQogICAgICoJCSAgICAgICAgfC0gYl5hfHIgIF4gaGFzIHBhdGg6IFsgMSwgMSwgMSBdICAgfCBoYXMgcGF0aDogWyAxLCAxLCAyIF0KICAgICAqCiAgICAgKiBAcmVhZG9ubHkKICAgICAqIEBtZW1iZXIge0FycmF5LjxOdW1iZXI+fSBtb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9uI3BhdGgKICAgICAqLwoKICAgIHRoaXMucGF0aCA9IHBhdGg7CiAgICAvKioKICAgICAqIFBvc2l0aW9uIHN0aWNraW5lc3MuIFNlZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvblN0aWNraW5lc3N9LgogICAgICoKICAgICAqIEBtZW1iZXIge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb25TdGlja2luZXNzfSBtb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9uI3N0aWNraW5lc3MKICAgICAqLwoKICAgIHRoaXMuc3RpY2tpbmVzcyA9IHN0aWNraW5lc3M7CiAgfQogIC8qKgogICAqIE9mZnNldCBhdCB3aGljaCB0aGlzIHBvc2l0aW9uIGlzIGxvY2F0ZWQgaW4gaXRzIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9uI3BhcmVudCBwYXJlbnR9LiBJdCBpcyBlcXVhbAogICAqIHRvIHRoZSBsYXN0IGl0ZW0gaW4gcG9zaXRpb24ge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb24jcGF0aCBwYXRofS4KICAgKgogICAqIEB0eXBlIHtOdW1iZXJ9CiAgICovCgoKICBnZXQgb2Zmc2V0KCkgewogICAgcmV0dXJuIGxhc3QodGhpcy5wYXRoKTsKICB9CiAgLyoqCiAgICogQHBhcmFtIHtOdW1iZXJ9IG5ld09mZnNldAogICAqLwoKCiAgc2V0IG9mZnNldChuZXdPZmZzZXQpIHsKICAgIHRoaXMucGF0aFt0aGlzLnBhdGgubGVuZ3RoIC0gMV0gPSBuZXdPZmZzZXQ7CiAgfQogIC8qKgogICAqIFBhcmVudCBlbGVtZW50IG9mIHRoaXMgcG9zaXRpb24uCiAgICoKICAgKiBLZWVwIGluIG1pbmQgdGhhdCBgcGFyZW50YCB2YWx1ZSBpcyBjYWxjdWxhdGVkIHdoZW4gdGhlIHByb3BlcnR5IGlzIGFjY2Vzc2VkLgogICAqIElmIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9uI3BhdGggcG9zaXRpb24gcGF0aH0KICAgKiBsZWFkcyB0byBhIG5vbi1leGlzdGluZyBlbGVtZW50LCBgcGFyZW50YCBwcm9wZXJ0eSB3aWxsIHRocm93IGVycm9yLgogICAqCiAgICogQWxzbyBpdCBpcyBhIGdvb2QgaWRlYSB0byBjYWNoZSBgcGFyZW50YCBwcm9wZXJ0eSBpZiBpdCBpcyB1c2VkIGZyZXF1ZW50bHkgaW4gYW4gYWxnb3JpdGhtIChpLmUuIGluIGEgbG9uZyBsb29wKS4KICAgKgogICAqIEByZWFkb25seQogICAqIEB0eXBlIHttb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudHxtb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudH0KICAgKi8KCgogIGdldCBwYXJlbnQoKSB7CiAgICBsZXQgcGFyZW50ID0gdGhpcy5yb290OwoKICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wYXRoLmxlbmd0aCAtIDE7IGkrKykgewogICAgICBwYXJlbnQgPSBwYXJlbnQuZ2V0Q2hpbGQocGFyZW50Lm9mZnNldFRvSW5kZXgodGhpcy5wYXRoW2ldKSk7CgogICAgICBpZiAoIXBhcmVudCkgewogICAgICAgIHRocm93IG5ldyBDS0VkaXRvckVycm9yKCdtb2RlbC1wb3NpdGlvbi1wYXRoLWluY29ycmVjdDogVGhlIHBvc2l0aW9uXCdzIHBhdGggaXMgaW5jb3JyZWN0LicsIHRoaXMsIHsKICAgICAgICAgIHBvc2l0aW9uOiB0aGlzCiAgICAgICAgfSk7CiAgICAgIH0KICAgIH0KCiAgICBpZiAocGFyZW50LmlzKCd0ZXh0JykpIHsKICAgICAgLyoqCiAgICAgICAqIFRoZSBwb3NpdGlvbidzIHBhdGggaXMgaW5jb3JyZWN0LiBUaGlzIG1lYW5zIHRoYXQgYSBwb3NpdGlvbiBkb2VzIG5vdCBwb2ludCB0bwogICAgICAgKiBhIGNvcnJlY3QgcGxhY2UgaW4gdGhlIHRyZWUgYW5kIGhlbmNlLCBzb21lIG9mIGl0cyBtZXRob2RzIGFuZCBnZXR0ZXJzIGNhbm5vdCB3b3JrIGNvcnJlY3RseS4KICAgICAgICoKICAgICAgICogKipOb3RlKio6IFVubGlrZSBET00gYW5kIHZpZXcgcG9zaXRpb25zLCBpbiB0aGUgbW9kZWwsIHRoZQogICAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbiNwYXJlbnQgcG9zaXRpb24ncyBwYXJlbnR9IGlzIGFsd2F5cyBhbiBlbGVtZW50IG9yIGEgZG9jdW1lbnQgZnJhZ21lbnQuCiAgICAgICAqIFRoZSBsYXN0IG9mZnNldCBpbiB0aGUge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb24jcGF0aCBwb3NpdGlvbidzIHBhdGh9IGlzIHRoZSBwb2ludCBpbiB0aGlzIGVsZW1lbnQgd2hlcmUKICAgICAgICogdGhpcyBwb3NpdGlvbiBwb2ludHMuCiAgICAgICAqCiAgICAgICAqIFJlYWQgbW9yZSBhYm91dCBtb2RlbCBwb3NpdGlvbnMgYW5kIG9mZnNldHMgaW4KICAgICAgICogdGhlIHtAZ2xpbmsgZnJhbWV3b3JrL2d1aWRlcy9hcmNoaXRlY3R1cmUvZWRpdGluZy1lbmdpbmUjaW5kZXhlcy1hbmQtb2Zmc2V0cyBFZGl0aW5nIGVuZ2luZSBhcmNoaXRlY3R1cmUgZ3VpZGV9LgogICAgICAgKgogICAgICAgKiBAZXJyb3IgcG9zaXRpb24taW5jb3JyZWN0LXBhdGgKICAgICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufSBwb3NpdGlvbiBUaGUgaW5jb3JyZWN0IHBvc2l0aW9uLgogICAgICAgKi8KICAgICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ21vZGVsLXBvc2l0aW9uLXBhdGgtaW5jb3JyZWN0OiBUaGUgcG9zaXRpb25cJ3MgcGF0aCBpcyBpbmNvcnJlY3QuJywgdGhpcywgewogICAgICAgIHBvc2l0aW9uOiB0aGlzCiAgICAgIH0pOwogICAgfQoKICAgIHJldHVybiBwYXJlbnQ7CiAgfQogIC8qKgogICAqIFBvc2l0aW9uIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9uI29mZnNldCBvZmZzZXR9IGNvbnZlcnRlZCB0byBhbiBpbmRleCBpbiBwb3NpdGlvbidzIHBhcmVudCBub2RlLiBJdCBpcwogICAqIGVxdWFsIHRvIHRoZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9ub2Rlfk5vZGUjaW5kZXggaW5kZXh9IG9mIGEgbm9kZSBhZnRlciB0aGlzIHBvc2l0aW9uLiBJZiBwb3NpdGlvbiBpcyBwbGFjZWQKICAgKiBpbiB0ZXh0IG5vZGUsIHBvc2l0aW9uIGluZGV4IGlzIGVxdWFsIHRvIHRoZSBpbmRleCBvZiB0aGF0IHRleHQgbm9kZS4KICAgKgogICAqIEByZWFkb25seQogICAqIEB0eXBlIHtOdW1iZXJ9CiAgICovCgoKICBnZXQgaW5kZXgoKSB7CiAgICByZXR1cm4gdGhpcy5wYXJlbnQub2Zmc2V0VG9JbmRleCh0aGlzLm9mZnNldCk7CiAgfQogIC8qKgogICAqIFJldHVybnMge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvdGV4dH5UZXh0IHRleHQgbm9kZX0gaW5zdGFuY2UgaW4gd2hpY2ggdGhpcyBwb3NpdGlvbiBpcyBwbGFjZWQgb3IgYG51bGxgIGlmIHRoaXMKICAgKiBwb3NpdGlvbiBpcyBub3QgaW4gYSB0ZXh0IG5vZGUuCiAgICoKICAgKiBAcmVhZG9ubHkKICAgKiBAdHlwZSB7bW9kdWxlOmVuZ2luZS9tb2RlbC90ZXh0flRleHR8bnVsbH0KICAgKi8KCgogIGdldCB0ZXh0Tm9kZSgpIHsKICAgIGNvbnN0IG5vZGUgPSB0aGlzLnBhcmVudC5nZXRDaGlsZCh0aGlzLmluZGV4KTsKICAgIHJldHVybiBub2RlIGluc3RhbmNlb2YgVGV4dCAmJiBub2RlLnN0YXJ0T2Zmc2V0IDwgdGhpcy5vZmZzZXQgPyBub2RlIDogbnVsbDsKICB9CiAgLyoqCiAgICogTm9kZSBkaXJlY3RseSBhZnRlciB0aGlzIHBvc2l0aW9uIG9yIGBudWxsYCBpZiB0aGlzIHBvc2l0aW9uIGlzIGluIHRleHQgbm9kZS4KICAgKgogICAqIEByZWFkb25seQogICAqIEB0eXBlIHttb2R1bGU6ZW5naW5lL21vZGVsL25vZGV+Tm9kZXxudWxsfQogICAqLwoKCiAgZ2V0IG5vZGVBZnRlcigpIHsKICAgIHJldHVybiB0aGlzLnRleHROb2RlID09PSBudWxsID8gdGhpcy5wYXJlbnQuZ2V0Q2hpbGQodGhpcy5pbmRleCkgOiBudWxsOwogIH0KICAvKioKICAgKiBOb2RlIGRpcmVjdGx5IGJlZm9yZSB0aGlzIHBvc2l0aW9uIG9yIGBudWxsYCBpZiB0aGlzIHBvc2l0aW9uIGlzIGluIHRleHQgbm9kZS4KICAgKgogICAqIEByZWFkb25seQogICAqIEB0eXBlIHtOb2RlfQogICAqLwoKCiAgZ2V0IG5vZGVCZWZvcmUoKSB7CiAgICByZXR1cm4gdGhpcy50ZXh0Tm9kZSA9PT0gbnVsbCA/IHRoaXMucGFyZW50LmdldENoaWxkKHRoaXMuaW5kZXggLSAxKSA6IG51bGw7CiAgfQogIC8qKgogICAqIElzIGB0cnVlYCBpZiBwb3NpdGlvbiBpcyBhdCB0aGUgYmVnaW5uaW5nIG9mIGl0cyB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbiNwYXJlbnQgcGFyZW50fSwgYGZhbHNlYCBvdGhlcndpc2UuCiAgICoKICAgKiBAcmVhZG9ubHkKICAgKiBAdHlwZSB7Qm9vbGVhbn0KICAgKi8KCgogIGdldCBpc0F0U3RhcnQoKSB7CiAgICByZXR1cm4gdGhpcy5vZmZzZXQgPT09IDA7CiAgfQogIC8qKgogICAqIElzIGB0cnVlYCBpZiBwb3NpdGlvbiBpcyBhdCB0aGUgZW5kIG9mIGl0cyB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbiNwYXJlbnQgcGFyZW50fSwgYGZhbHNlYCBvdGhlcndpc2UuCiAgICoKICAgKiBAcmVhZG9ubHkKICAgKiBAdHlwZSB7Qm9vbGVhbn0KICAgKi8KCgogIGdldCBpc0F0RW5kKCkgewogICAgcmV0dXJuIHRoaXMub2Zmc2V0ID09IHRoaXMucGFyZW50Lm1heE9mZnNldDsKICB9CiAgLyoqCiAgICogQ2hlY2tzIHdoZXRoZXIgdGhpcyBwb3NpdGlvbiBpcyBiZWZvcmUgb3IgYWZ0ZXIgZ2l2ZW4gcG9zaXRpb24uCiAgICoKICAgKiBUaGlzIG1ldGhvZCBpcyBzYWZlIHRvIHVzZSBpdCBvbiBub24tZXhpc3RpbmcgcG9zaXRpb25zIChmb3IgZXhhbXBsZSBkdXJpbmcgb3BlcmF0aW9uYWwgdHJhbnNmb3JtYXRpb24pLgogICAqCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufSBvdGhlclBvc2l0aW9uIFBvc2l0aW9uIHRvIGNvbXBhcmUgd2l0aC4KICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvblJlbGF0aW9ufQogICAqLwoKCiAgY29tcGFyZVdpdGgob3RoZXJQb3NpdGlvbikgewogICAgaWYgKHRoaXMucm9vdCAhPSBvdGhlclBvc2l0aW9uLnJvb3QpIHsKICAgICAgcmV0dXJuICdkaWZmZXJlbnQnOwogICAgfQoKICAgIGNvbnN0IHJlc3VsdCA9IGNvbXBhcmVBcnJheXModGhpcy5wYXRoLCBvdGhlclBvc2l0aW9uLnBhdGgpOwoKICAgIHN3aXRjaCAocmVzdWx0KSB7CiAgICAgIGNhc2UgJ3NhbWUnOgogICAgICAgIHJldHVybiAnc2FtZSc7CgogICAgICBjYXNlICdwcmVmaXgnOgogICAgICAgIHJldHVybiAnYmVmb3JlJzsKCiAgICAgIGNhc2UgJ2V4dGVuc2lvbic6CiAgICAgICAgcmV0dXJuICdhZnRlcic7CgogICAgICBkZWZhdWx0OgogICAgICAgIHJldHVybiB0aGlzLnBhdGhbcmVzdWx0XSA8IG90aGVyUG9zaXRpb24ucGF0aFtyZXN1bHRdID8gJ2JlZm9yZScgOiAnYWZ0ZXInOwogICAgfQogIH0KICAvKioKICAgKiBHZXRzIHRoZSBmYXJ0aGVzdCBwb3NpdGlvbiB3aGljaCBtYXRjaGVzIHRoZSBjYWxsYmFjayB1c2luZwogICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3RyZWV3YWxrZXJ+VHJlZVdhbGtlciBUcmVlV2Fsa2VyfS4KICAgKgogICAqIEZvciBleGFtcGxlOgogICAqCiAgICogCQlnZXRMYXN0TWF0Y2hpbmdQb3NpdGlvbiggdmFsdWUgPT4gdmFsdWUudHlwZSA9PSAndGV4dCcgKTsKICAgKiAJCS8vIDxwYXJhZ3JhcGg+W11mb288L3BhcmFncmFwaD4gLT4gPHBhcmFncmFwaD5mb29bXTwvcGFyYWdyYXBoPgogICAqCiAgICogCQlnZXRMYXN0TWF0Y2hpbmdQb3NpdGlvbiggdmFsdWUgPT4gdmFsdWUudHlwZSA9PSAndGV4dCcsIHsgZGlyZWN0aW9uOiAnYmFja3dhcmQnIH0gKTsKICAgKiAJCS8vIDxwYXJhZ3JhcGg+Zm9vW108L3BhcmFncmFwaD4gLT4gPHBhcmFncmFwaD5bXWZvbzwvcGFyYWdyYXBoPgogICAqCiAgICogCQlnZXRMYXN0TWF0Y2hpbmdQb3NpdGlvbiggdmFsdWUgPT4gZmFsc2UgKTsKICAgKiAJCS8vIERvIG5vdCBtb3ZlIHRoZSBwb3NpdGlvbi4KICAgKgogICAqIEBwYXJhbSB7RnVuY3Rpb259IHNraXAgQ2FsbGJhY2sgZnVuY3Rpb24uIEdldHMge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvdHJlZXdhbGtlcn5UcmVlV2Fsa2VyVmFsdWV9IGFuZCBzaG91bGQKICAgKiByZXR1cm4gYHRydWVgIGlmIHRoZSB2YWx1ZSBzaG91bGQgYmUgc2tpcHBlZCBvciBgZmFsc2VgIGlmIG5vdC4KICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPYmplY3Qgd2l0aCBjb25maWd1cmF0aW9uIG9wdGlvbnMuIFNlZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC90cmVld2Fsa2VyflRyZWVXYWxrZXJ9LgogICAqCiAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259IFRoZSBwb3NpdGlvbiBhZnRlciB0aGUgbGFzdCBpdGVtIHdoaWNoIG1hdGNoZXMgdGhlIGBza2lwYCBjYWxsYmFjayB0ZXN0LgogICAqLwoKCiAgZ2V0TGFzdE1hdGNoaW5nUG9zaXRpb24oc2tpcCwgb3B0aW9ucyA9IHt9KSB7CiAgICBvcHRpb25zLnN0YXJ0UG9zaXRpb24gPSB0aGlzOwogICAgY29uc3QgdHJlZVdhbGtlciA9IG5ldyBUcmVlV2Fsa2VyKG9wdGlvbnMpOwogICAgdHJlZVdhbGtlci5za2lwKHNraXApOwogICAgcmV0dXJuIHRyZWVXYWxrZXIucG9zaXRpb247CiAgfQogIC8qKgogICAqIFJldHVybnMgYSBwYXRoIHRvIHRoaXMgcG9zaXRpb24ncyBwYXJlbnQuIFBhcmVudCBwYXRoIGlzIGVxdWFsIHRvIHBvc2l0aW9uIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9uI3BhdGggcGF0aH0KICAgKiBidXQgd2l0aG91dCB0aGUgbGFzdCBpdGVtLgogICAqCiAgICogVGhpcyBtZXRob2QgaXMgc2FmZSB0byB1c2UgaXQgb24gbm9uLWV4aXN0aW5nIHBvc2l0aW9ucyAoZm9yIGV4YW1wbGUgZHVyaW5nIG9wZXJhdGlvbmFsIHRyYW5zZm9ybWF0aW9uKS4KICAgKgogICAqIEByZXR1cm5zIHtBcnJheS48TnVtYmVyPn0gUGF0aCB0byB0aGUgcGFyZW50LgogICAqLwoKCiAgZ2V0UGFyZW50UGF0aCgpIHsKICAgIHJldHVybiB0aGlzLnBhdGguc2xpY2UoMCwgLTEpOwogIH0KICAvKioKICAgKiBSZXR1cm5zIGFuY2VzdG9ycyBhcnJheSBvZiB0aGlzIHBvc2l0aW9uLCB0aGF0IGlzIHRoaXMgcG9zaXRpb24ncyBwYXJlbnQgYW5kIGl0cyBhbmNlc3RvcnMuCiAgICoKICAgKiBAcmV0dXJucyB7QXJyYXkuPG1vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtPn0gQXJyYXkgd2l0aCBhbmNlc3RvcnMuCiAgICovCgoKICBnZXRBbmNlc3RvcnMoKSB7CiAgICBpZiAodGhpcy5wYXJlbnQuaXMoJ2RvY3VtZW50RnJhZ21lbnQnKSkgewogICAgICByZXR1cm4gW3RoaXMucGFyZW50XTsKICAgIH0gZWxzZSB7CiAgICAgIHJldHVybiB0aGlzLnBhcmVudC5nZXRBbmNlc3RvcnMoewogICAgICAgIGluY2x1ZGVTZWxmOiB0cnVlCiAgICAgIH0pOwogICAgfQogIH0KICAvKioKICAgKiBSZXR1cm5zIHRoZSBzbGljZSBvZiB0d28gcG9zaXRpb24ge0BsaW5rICNwYXRoIHBhdGhzfSB3aGljaCBpcyBpZGVudGljYWwuIFRoZSB7QGxpbmsgI3Jvb3Qgcm9vdHN9CiAgICogb2YgdGhlc2UgdHdvIHBhdGhzIG11c3QgYmUgaWRlbnRpY2FsLgogICAqCiAgICogVGhpcyBtZXRob2QgaXMgc2FmZSB0byB1c2UgaXQgb24gbm9uLWV4aXN0aW5nIHBvc2l0aW9ucyAoZm9yIGV4YW1wbGUgZHVyaW5nIG9wZXJhdGlvbmFsIHRyYW5zZm9ybWF0aW9uKS4KICAgKgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0gcG9zaXRpb24gVGhlIHNlY29uZCBwb3NpdGlvbi4KICAgKiBAcmV0dXJucyB7QXJyYXkuPE51bWJlcj59IFRoZSBjb21tb24gcGF0aC4KICAgKi8KCgogIGdldENvbW1vblBhdGgocG9zaXRpb24pIHsKICAgIGlmICh0aGlzLnJvb3QgIT0gcG9zaXRpb24ucm9vdCkgewogICAgICByZXR1cm4gW107CiAgICB9IC8vIFdlIGZpbmQgb24gd2hpY2ggdHJlZS1sZXZlbCBzdGFydCBhbmQgZW5kIGhhdmUgdGhlIGxvd2VzdCBjb21tb24gYW5jZXN0b3IKCgogICAgY29uc3QgY21wID0gY29tcGFyZUFycmF5cyh0aGlzLnBhdGgsIHBvc2l0aW9uLnBhdGgpOyAvLyBJZiBjb21wYXJpc29uIHJldHVybmVkIHN0cmluZyBpdCBtZWFucyB0aGF0IGFycmF5cyBhcmUgc2FtZS4KCiAgICBjb25zdCBkaWZmQXQgPSB0eXBlb2YgY21wID09ICdzdHJpbmcnID8gTWF0aC5taW4odGhpcy5wYXRoLmxlbmd0aCwgcG9zaXRpb24ucGF0aC5sZW5ndGgpIDogY21wOwogICAgcmV0dXJuIHRoaXMucGF0aC5zbGljZSgwLCBkaWZmQXQpOwogIH0KICAvKioKICAgKiBSZXR1cm5zIGFuIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudH0gb3Ige0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50fQogICAqIHdoaWNoIGlzIGEgY29tbW9uIGFuY2VzdG9yIG9mIGJvdGggcG9zaXRpb25zLiBUaGUge0BsaW5rICNyb290IHJvb3RzfSBvZiB0aGVzZSB0d28gcG9zaXRpb25zIG11c3QgYmUgaWRlbnRpY2FsLgogICAqCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufSBwb3NpdGlvbiBUaGUgc2Vjb25kIHBvc2l0aW9uLgogICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudHxtb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudHxudWxsfQogICAqLwoKCiAgZ2V0Q29tbW9uQW5jZXN0b3IocG9zaXRpb24pIHsKICAgIGNvbnN0IGFuY2VzdG9yc0EgPSB0aGlzLmdldEFuY2VzdG9ycygpOwogICAgY29uc3QgYW5jZXN0b3JzQiA9IHBvc2l0aW9uLmdldEFuY2VzdG9ycygpOwogICAgbGV0IGkgPSAwOwoKICAgIHdoaWxlIChhbmNlc3RvcnNBW2ldID09IGFuY2VzdG9yc0JbaV0gJiYgYW5jZXN0b3JzQVtpXSkgewogICAgICBpKys7CiAgICB9CgogICAgcmV0dXJuIGkgPT09IDAgPyBudWxsIDogYW5jZXN0b3JzQVtpIC0gMV07CiAgfQogIC8qKgogICAqIFJldHVybnMgYSBuZXcgaW5zdGFuY2Ugb2YgYFBvc2l0aW9uYCwgdGhhdCBoYXMgc2FtZSB7QGxpbmsgI3BhcmVudCBwYXJlbnR9IGJ1dCBpdCdzIG9mZnNldAogICAqIGlzIHNoaWZ0ZWQgYnkgYHNoaWZ0YCB2YWx1ZSAoY2FuIGJlIGEgbmVnYXRpdmUgdmFsdWUpLgogICAqCiAgICogVGhpcyBtZXRob2QgaXMgc2FmZSB0byB1c2UgaXQgb24gbm9uLWV4aXN0aW5nIHBvc2l0aW9ucyAoZm9yIGV4YW1wbGUgZHVyaW5nIG9wZXJhdGlvbmFsIHRyYW5zZm9ybWF0aW9uKS4KICAgKgogICAqIEBwYXJhbSB7TnVtYmVyfSBzaGlmdCBPZmZzZXQgc2hpZnQuIENhbiBiZSBhIG5lZ2F0aXZlIHZhbHVlLgogICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufSBTaGlmdGVkIHBvc2l0aW9uLgogICAqLwoKCiAgZ2V0U2hpZnRlZEJ5KHNoaWZ0KSB7CiAgICBjb25zdCBzaGlmdGVkID0gdGhpcy5jbG9uZSgpOwogICAgY29uc3Qgb2Zmc2V0ID0gc2hpZnRlZC5vZmZzZXQgKyBzaGlmdDsKICAgIHNoaWZ0ZWQub2Zmc2V0ID0gb2Zmc2V0IDwgMCA/IDAgOiBvZmZzZXQ7CiAgICByZXR1cm4gc2hpZnRlZDsKICB9CiAgLyoqCiAgICogQ2hlY2tzIHdoZXRoZXIgdGhpcyBwb3NpdGlvbiBpcyBhZnRlciBnaXZlbiBwb3NpdGlvbi4KICAgKgogICAqIFRoaXMgbWV0aG9kIGlzIHNhZmUgdG8gdXNlIGl0IG9uIG5vbi1leGlzdGluZyBwb3NpdGlvbnMgKGZvciBleGFtcGxlIGR1cmluZyBvcGVyYXRpb25hbCB0cmFuc2Zvcm1hdGlvbikuCiAgICoKICAgKiBAc2VlIG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb24jaXNCZWZvcmUKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259IG90aGVyUG9zaXRpb24gUG9zaXRpb24gdG8gY29tcGFyZSB3aXRoLgogICAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoaXMgcG9zaXRpb24gaXMgYWZ0ZXIgZ2l2ZW4gcG9zaXRpb24uCiAgICovCgoKICBpc0FmdGVyKG90aGVyUG9zaXRpb24pIHsKICAgIHJldHVybiB0aGlzLmNvbXBhcmVXaXRoKG90aGVyUG9zaXRpb24pID09ICdhZnRlcic7CiAgfQogIC8qKgogICAqIENoZWNrcyB3aGV0aGVyIHRoaXMgcG9zaXRpb24gaXMgYmVmb3JlIGdpdmVuIHBvc2l0aW9uLgogICAqCiAgICogKipOb3RlOioqIHdhdGNoIG91dCB3aGVuIHVzaW5nIG5lZ2F0aW9uIG9mIHRoZSB2YWx1ZSByZXR1cm5lZCBieSB0aGlzIG1ldGhvZCwgYmVjYXVzZSB0aGUgbmVnYXRpb24gd2lsbCBhbHNvCiAgICogYmUgYHRydWVgIGlmIHBvc2l0aW9ucyBhcmUgaW4gZGlmZmVyZW50IHJvb3RzIGFuZCB5b3UgbWlnaHQgbm90IGV4cGVjdCB0aGlzLiBZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZQogICAqIGBhLmlzQWZ0ZXIoIGIgKSB8fCBhLmlzRXF1YWwoIGIgKWAgb3IgYCFhLmlzQmVmb3JlKCBwICkgJiYgYS5yb290ID09IGIucm9vdGAgaW4gbW9zdCBzY2VuYXJpb3MuIElmIHlvdXIKICAgKiBjb25kaXRpb24gdXNlcyBtdWx0aXBsZSBgaXNBZnRlcmAgYW5kIGBpc0JlZm9yZWAgY2hlY2tzLCBidWlsZCB0aGVtIHNvIHRoZXkgZG8gbm90IHVzZSBuZWdhdGVkIHZhbHVlcywgaS5lLjoKICAgKgogICAqCQlpZiAoIGEuaXNCZWZvcmUoIGIgKSAmJiBjLmlzQWZ0ZXIoIGQgKSApIHsKICAgKgkJCS8vIGRvIEEuCiAgICoJCX0gZWxzZSB7CiAgICoJCQkvLyBkbyBCLgogICAqCQl9CiAgICoKICAgKiBvciwgaWYgeW91IGhhdmUgb25seSBvbmUgaWYtYnJhbmNoOgogICAqCiAgICoJCWlmICggISggYS5pc0JlZm9yZSggYiApICYmIGMuaXNBZnRlciggZCApICkgewogICAqCQkJLy8gZG8gQi4KICAgKgkJfQogICAqCiAgICogcmF0aGVyIHRoYW46CiAgICoKICAgKgkJaWYgKCAhYS5pc0JlZm9yZSggYiApIHx8ICYmICFjLmlzQWZ0ZXIoIGQgKSApIHsKICAgKgkJCS8vIGRvIEIuCiAgICoJCX0gZWxzZSB7CiAgICoJCQkvLyBkbyBBLgogICAqCQl9CiAgICoKICAgKiBUaGlzIG1ldGhvZCBpcyBzYWZlIHRvIHVzZSBpdCBvbiBub24tZXhpc3RpbmcgcG9zaXRpb25zIChmb3IgZXhhbXBsZSBkdXJpbmcgb3BlcmF0aW9uYWwgdHJhbnNmb3JtYXRpb24pLgogICAqCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufSBvdGhlclBvc2l0aW9uIFBvc2l0aW9uIHRvIGNvbXBhcmUgd2l0aC4KICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGlzIHBvc2l0aW9uIGlzIGJlZm9yZSBnaXZlbiBwb3NpdGlvbi4KICAgKi8KCgogIGlzQmVmb3JlKG90aGVyUG9zaXRpb24pIHsKICAgIHJldHVybiB0aGlzLmNvbXBhcmVXaXRoKG90aGVyUG9zaXRpb24pID09ICdiZWZvcmUnOwogIH0KICAvKioKICAgKiBDaGVja3Mgd2hldGhlciB0aGlzIHBvc2l0aW9uIGlzIGVxdWFsIHRvIGdpdmVuIHBvc2l0aW9uLgogICAqCiAgICogVGhpcyBtZXRob2QgaXMgc2FmZSB0byB1c2UgaXQgb24gbm9uLWV4aXN0aW5nIHBvc2l0aW9ucyAoZm9yIGV4YW1wbGUgZHVyaW5nIG9wZXJhdGlvbmFsIHRyYW5zZm9ybWF0aW9uKS4KICAgKgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0gb3RoZXJQb3NpdGlvbiBQb3NpdGlvbiB0byBjb21wYXJlIHdpdGguCiAgICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgcG9zaXRpb25zIGFyZSBzYW1lLgogICAqLwoKCiAgaXNFcXVhbChvdGhlclBvc2l0aW9uKSB7CiAgICByZXR1cm4gdGhpcy5jb21wYXJlV2l0aChvdGhlclBvc2l0aW9uKSA9PSAnc2FtZSc7CiAgfQogIC8qKgogICAqIENoZWNrcyB3aGV0aGVyIHRoaXMgcG9zaXRpb24gaXMgdG91Y2hpbmcgZ2l2ZW4gcG9zaXRpb24uIFBvc2l0aW9ucyB0b3VjaCB3aGVuIHRoZXJlIGFyZSBubyB0ZXh0IG5vZGVzCiAgICogb3IgZW1wdHkgbm9kZXMgaW4gYSByYW5nZSBiZXR3ZWVuIHRoZW0uIFRlY2huaWNhbGx5LCB0aG9zZSBwb3NpdGlvbnMgYXJlIG5vdCBlcXVhbCBidXQgaW4gbWFueSBjYXNlcwogICAqIHRoZXkgYXJlIHZlcnkgc2ltaWxhciBvciBldmVuIGluZGlzdGluZ3Vpc2hhYmxlLgogICAqCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufSBvdGhlclBvc2l0aW9uIFBvc2l0aW9uIHRvIGNvbXBhcmUgd2l0aC4KICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiBwb3NpdGlvbnMgdG91Y2guCiAgICovCgoKICBpc1RvdWNoaW5nKG90aGVyUG9zaXRpb24pIHsKICAgIGxldCBsZWZ0ID0gbnVsbDsKICAgIGxldCByaWdodCA9IG51bGw7CiAgICBjb25zdCBjb21wYXJlID0gdGhpcy5jb21wYXJlV2l0aChvdGhlclBvc2l0aW9uKTsKCiAgICBzd2l0Y2ggKGNvbXBhcmUpIHsKICAgICAgY2FzZSAnc2FtZSc6CiAgICAgICAgcmV0dXJuIHRydWU7CgogICAgICBjYXNlICdiZWZvcmUnOgogICAgICAgIGxlZnQgPSBQb3NpdGlvbi5fY3JlYXRlQXQodGhpcyk7CiAgICAgICAgcmlnaHQgPSBQb3NpdGlvbi5fY3JlYXRlQXQob3RoZXJQb3NpdGlvbik7CiAgICAgICAgYnJlYWs7CgogICAgICBjYXNlICdhZnRlcic6CiAgICAgICAgbGVmdCA9IFBvc2l0aW9uLl9jcmVhdGVBdChvdGhlclBvc2l0aW9uKTsKICAgICAgICByaWdodCA9IFBvc2l0aW9uLl9jcmVhdGVBdCh0aGlzKTsKICAgICAgICBicmVhazsKCiAgICAgIGRlZmF1bHQ6CiAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgfSAvLyBDYWNoZWQgZm9yIG9wdGltaXphdGlvbiBwdXJwb3Nlcy4KCgogICAgbGV0IGxlZnRQYXJlbnQgPSBsZWZ0LnBhcmVudDsKCiAgICB3aGlsZSAobGVmdC5wYXRoLmxlbmd0aCArIHJpZ2h0LnBhdGgubGVuZ3RoKSB7CiAgICAgIGlmIChsZWZ0LmlzRXF1YWwocmlnaHQpKSB7CiAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgIH0KCiAgICAgIGlmIChsZWZ0LnBhdGgubGVuZ3RoID4gcmlnaHQucGF0aC5sZW5ndGgpIHsKICAgICAgICBpZiAobGVmdC5vZmZzZXQgIT09IGxlZnRQYXJlbnQubWF4T2Zmc2V0KSB7CiAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgfQoKICAgICAgICBsZWZ0LnBhdGggPSBsZWZ0LnBhdGguc2xpY2UoMCwgLTEpOwogICAgICAgIGxlZnRQYXJlbnQgPSBsZWZ0UGFyZW50LnBhcmVudDsKICAgICAgICBsZWZ0Lm9mZnNldCsrOwogICAgICB9IGVsc2UgewogICAgICAgIGlmIChyaWdodC5vZmZzZXQgIT09IDApIHsKICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICB9CgogICAgICAgIHJpZ2h0LnBhdGggPSByaWdodC5wYXRoLnNsaWNlKDAsIC0xKTsKICAgICAgfQogICAgfQogIH0KICAvKioKICAgKiBDaGVja3Mgd2hldGhlciB0aGlzIG9iamVjdCBpcyBvZiB0aGUgZ2l2ZW4uCiAgICoKICAgKgkJcG9zaXRpb24uaXMoICdwb3NpdGlvbicgKTsgLy8gLT4gdHJ1ZQogICAqCQlwb3NpdGlvbi5pcyggJ21vZGVsOnBvc2l0aW9uJyApOyAvLyAtPiB0cnVlCiAgICoKICAgKgkJcG9zaXRpb24uaXMoICd2aWV3OnBvc2l0aW9uJyApOyAvLyAtPiBmYWxzZQogICAqCQlwb3NpdGlvbi5pcyggJ2RvY3VtZW50U2VsZWN0aW9uJyApOyAvLyAtPiBmYWxzZQogICAqCiAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbm9kZX5Ob2RlI2lzIENoZWNrIHRoZSBlbnRpcmUgbGlzdCBvZiBtb2RlbCBvYmplY3RzfSB3aGljaCBpbXBsZW1lbnQgdGhlIGBpcygpYCBtZXRob2QuCiAgICoKICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZQogICAqIEByZXR1cm5zIHtCb29sZWFufQogICAqLwoKCiAgaXModHlwZSkgewogICAgcmV0dXJuIHR5cGUgPT0gJ3Bvc2l0aW9uJyB8fCB0eXBlID09ICdtb2RlbDpwb3NpdGlvbic7CiAgfQogIC8qKgogICAqIENoZWNrcyBpZiB0d28gcG9zaXRpb25zIGFyZSBpbiB0aGUgc2FtZSBwYXJlbnQuCiAgICoKICAgKiBUaGlzIG1ldGhvZCBpcyBzYWZlIHRvIHVzZSBpdCBvbiBub24tZXhpc3RpbmcgcG9zaXRpb25zIChmb3IgZXhhbXBsZSBkdXJpbmcgb3BlcmF0aW9uYWwgdHJhbnNmb3JtYXRpb24pLgogICAqCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufSBwb3NpdGlvbiBQb3NpdGlvbiB0byBjb21wYXJlIHdpdGguCiAgICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiBwb3NpdGlvbnMgaGF2ZSB0aGUgc2FtZSBwYXJlbnQsIGBmYWxzZWAgb3RoZXJ3aXNlLgogICAqLwoKCiAgaGFzU2FtZVBhcmVudEFzKHBvc2l0aW9uKSB7CiAgICBpZiAodGhpcy5yb290ICE9PSBwb3NpdGlvbi5yb290KSB7CiAgICAgIHJldHVybiBmYWxzZTsKICAgIH0KCiAgICBjb25zdCB0aGlzUGFyZW50UGF0aCA9IHRoaXMuZ2V0UGFyZW50UGF0aCgpOwogICAgY29uc3QgcG9zUGFyZW50UGF0aCA9IHBvc2l0aW9uLmdldFBhcmVudFBhdGgoKTsKICAgIHJldHVybiBjb21wYXJlQXJyYXlzKHRoaXNQYXJlbnRQYXRoLCBwb3NQYXJlbnRQYXRoKSA9PSAnc2FtZSc7CiAgfQogIC8qKgogICAqIFJldHVybnMgYSBjb3B5IG9mIHRoaXMgcG9zaXRpb24gdGhhdCBpcyB0cmFuc2Zvcm1lZCBieSBnaXZlbiBgb3BlcmF0aW9uYC4KICAgKgogICAqIFRoZSBuZXcgcG9zaXRpb24ncyBwYXJhbWV0ZXJzIGFyZSB1cGRhdGVkIGFjY29yZGluZ2x5IHRvIHRoZSBlZmZlY3Qgb2YgdGhlIGBvcGVyYXRpb25gLgogICAqCiAgICogRm9yIGV4YW1wbGUsIGlmIGBuYCBub2RlcyBhcmUgaW5zZXJ0ZWQgYmVmb3JlIHRoZSBwb3NpdGlvbiwgdGhlIHJldHVybmVkIHBvc2l0aW9uIHtAbGluayB+UG9zaXRpb24jb2Zmc2V0fSB3aWxsIGJlCiAgICogaW5jcmVhc2VkIGJ5IGBuYC4gSWYgdGhlIHBvc2l0aW9uIHdhcyBpbiBhIG1lcmdlZCBlbGVtZW50LCBpdCB3aWxsIGJlIGFjY29yZGluZ2x5IG1vdmVkIHRvIHRoZSBuZXcgZWxlbWVudCwgZXRjLgogICAqCiAgICogVGhpcyBtZXRob2QgaXMgc2FmZSB0byB1c2UgaXQgb24gbm9uLWV4aXN0aW5nIHBvc2l0aW9ucyAoZm9yIGV4YW1wbGUgZHVyaW5nIG9wZXJhdGlvbmFsIHRyYW5zZm9ybWF0aW9uKS4KICAgKgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9vcGVyYXRpb24vb3BlcmF0aW9ufk9wZXJhdGlvbn0gb3BlcmF0aW9uIE9wZXJhdGlvbiB0byB0cmFuc2Zvcm0gYnkuCiAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259IFRyYW5zZm9ybWVkIHBvc2l0aW9uLgogICAqLwoKCiAgZ2V0VHJhbnNmb3JtZWRCeU9wZXJhdGlvbihvcGVyYXRpb24pIHsKICAgIGxldCByZXN1bHQ7CgogICAgc3dpdGNoIChvcGVyYXRpb24udHlwZSkgewogICAgICBjYXNlICdpbnNlcnQnOgogICAgICAgIHJlc3VsdCA9IHRoaXMuX2dldFRyYW5zZm9ybWVkQnlJbnNlcnRPcGVyYXRpb24ob3BlcmF0aW9uKTsKICAgICAgICBicmVhazsKCiAgICAgIGNhc2UgJ21vdmUnOgogICAgICBjYXNlICdyZW1vdmUnOgogICAgICBjYXNlICdyZWluc2VydCc6CiAgICAgICAgcmVzdWx0ID0gdGhpcy5fZ2V0VHJhbnNmb3JtZWRCeU1vdmVPcGVyYXRpb24ob3BlcmF0aW9uKTsKICAgICAgICBicmVhazsKCiAgICAgIGNhc2UgJ3NwbGl0JzoKICAgICAgICByZXN1bHQgPSB0aGlzLl9nZXRUcmFuc2Zvcm1lZEJ5U3BsaXRPcGVyYXRpb24ob3BlcmF0aW9uKTsKICAgICAgICBicmVhazsKCiAgICAgIGNhc2UgJ21lcmdlJzoKICAgICAgICByZXN1bHQgPSB0aGlzLl9nZXRUcmFuc2Zvcm1lZEJ5TWVyZ2VPcGVyYXRpb24ob3BlcmF0aW9uKTsKICAgICAgICBicmVhazsKCiAgICAgIGRlZmF1bHQ6CiAgICAgICAgcmVzdWx0ID0gUG9zaXRpb24uX2NyZWF0ZUF0KHRoaXMpOwogICAgICAgIGJyZWFrOwogICAgfQoKICAgIHJldHVybiByZXN1bHQ7CiAgfQogIC8qKgogICAqIFJldHVybnMgYSBjb3B5IG9mIHRoaXMgcG9zaXRpb24gdHJhbnNmb3JtZWQgYnkgYW4gaW5zZXJ0IG9wZXJhdGlvbi4KICAgKgogICAqIEBwcm90ZWN0ZWQKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvb3BlcmF0aW9uL2luc2VydG9wZXJhdGlvbn5JbnNlcnRPcGVyYXRpb259IG9wZXJhdGlvbgogICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufQogICAqLwoKCiAgX2dldFRyYW5zZm9ybWVkQnlJbnNlcnRPcGVyYXRpb24ob3BlcmF0aW9uKSB7CiAgICByZXR1cm4gdGhpcy5fZ2V0VHJhbnNmb3JtZWRCeUluc2VydGlvbihvcGVyYXRpb24ucG9zaXRpb24sIG9wZXJhdGlvbi5ob3dNYW55KTsKICB9CiAgLyoqCiAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhpcyBwb3NpdGlvbiB0cmFuc2Zvcm1lZCBieSBhIG1vdmUgb3BlcmF0aW9uLgogICAqCiAgICogQHByb3RlY3RlZAogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9vcGVyYXRpb24vbW92ZW9wZXJhdGlvbn5Nb3ZlT3BlcmF0aW9ufSBvcGVyYXRpb24KICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0KICAgKi8KCgogIF9nZXRUcmFuc2Zvcm1lZEJ5TW92ZU9wZXJhdGlvbihvcGVyYXRpb24pIHsKICAgIHJldHVybiB0aGlzLl9nZXRUcmFuc2Zvcm1lZEJ5TW92ZShvcGVyYXRpb24uc291cmNlUG9zaXRpb24sIG9wZXJhdGlvbi50YXJnZXRQb3NpdGlvbiwgb3BlcmF0aW9uLmhvd01hbnkpOwogIH0KICAvKioKICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGlzIHBvc2l0aW9uIHRyYW5zZm9ybWVkIGJ5IGEgc3BsaXQgb3BlcmF0aW9uLgogICAqCiAgICogQHByb3RlY3RlZAogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9vcGVyYXRpb24vc3BsaXRvcGVyYXRpb25+U3BsaXRPcGVyYXRpb259IG9wZXJhdGlvbgogICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufQogICAqLwoKCiAgX2dldFRyYW5zZm9ybWVkQnlTcGxpdE9wZXJhdGlvbihvcGVyYXRpb24pIHsKICAgIGNvbnN0IG1vdmVkUmFuZ2UgPSBvcGVyYXRpb24ubW92ZWRSYW5nZTsKICAgIGNvbnN0IGlzQ29udGFpbmVkID0gbW92ZWRSYW5nZS5jb250YWluc1Bvc2l0aW9uKHRoaXMpIHx8IG1vdmVkUmFuZ2Uuc3RhcnQuaXNFcXVhbCh0aGlzKSAmJiB0aGlzLnN0aWNraW5lc3MgPT0gJ3RvTmV4dCc7CgogICAgaWYgKGlzQ29udGFpbmVkKSB7CiAgICAgIHJldHVybiB0aGlzLl9nZXRDb21iaW5lZChvcGVyYXRpb24uc3BsaXRQb3NpdGlvbiwgb3BlcmF0aW9uLm1vdmVUYXJnZXRQb3NpdGlvbik7CiAgICB9IGVsc2UgewogICAgICBpZiAob3BlcmF0aW9uLmdyYXZleWFyZFBvc2l0aW9uKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFRyYW5zZm9ybWVkQnlNb3ZlKG9wZXJhdGlvbi5ncmF2ZXlhcmRQb3NpdGlvbiwgb3BlcmF0aW9uLmluc2VydGlvblBvc2l0aW9uLCAxKTsKICAgICAgfSBlbHNlIHsKICAgICAgICByZXR1cm4gdGhpcy5fZ2V0VHJhbnNmb3JtZWRCeUluc2VydGlvbihvcGVyYXRpb24uaW5zZXJ0aW9uUG9zaXRpb24sIDEpOwogICAgICB9CiAgICB9CiAgfQogIC8qKgogICAqIFJldHVybnMgYSBjb3B5IG9mIHRoaXMgcG9zaXRpb24gdHJhbnNmb3JtZWQgYnkgbWVyZ2Ugb3BlcmF0aW9uLgogICAqCiAgICogQHByb3RlY3RlZAogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9vcGVyYXRpb24vbWVyZ2VvcGVyYXRpb25+TWVyZ2VPcGVyYXRpb259IG9wZXJhdGlvbgogICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufQogICAqLwoKCiAgX2dldFRyYW5zZm9ybWVkQnlNZXJnZU9wZXJhdGlvbihvcGVyYXRpb24pIHsKICAgIGNvbnN0IG1vdmVkUmFuZ2UgPSBvcGVyYXRpb24ubW92ZWRSYW5nZTsKICAgIGNvbnN0IGlzQ29udGFpbmVkID0gbW92ZWRSYW5nZS5jb250YWluc1Bvc2l0aW9uKHRoaXMpIHx8IG1vdmVkUmFuZ2Uuc3RhcnQuaXNFcXVhbCh0aGlzKTsKICAgIGxldCBwb3M7CgogICAgaWYgKGlzQ29udGFpbmVkKSB7CiAgICAgIHBvcyA9IHRoaXMuX2dldENvbWJpbmVkKG9wZXJhdGlvbi5zb3VyY2VQb3NpdGlvbiwgb3BlcmF0aW9uLnRhcmdldFBvc2l0aW9uKTsKCiAgICAgIGlmIChvcGVyYXRpb24uc291cmNlUG9zaXRpb24uaXNCZWZvcmUob3BlcmF0aW9uLnRhcmdldFBvc2l0aW9uKSkgewogICAgICAgIC8vIEFib3ZlIGhhcHBlbnMgZHVyaW5nIE9UIHdoZW4gdGhlIG1lcmdlZCBlbGVtZW50IGlzIG1vdmVkIGJlZm9yZSB0aGUgbWVyZ2VkLXRvIGVsZW1lbnQuCiAgICAgICAgcG9zID0gcG9zLl9nZXRUcmFuc2Zvcm1lZEJ5RGVsZXRpb24ob3BlcmF0aW9uLmRlbGV0aW9uUG9zaXRpb24sIDEpOwogICAgICB9CiAgICB9IGVsc2UgaWYgKHRoaXMuaXNFcXVhbChvcGVyYXRpb24uZGVsZXRpb25Qb3NpdGlvbikpIHsKICAgICAgcG9zID0gUG9zaXRpb24uX2NyZWF0ZUF0KG9wZXJhdGlvbi5kZWxldGlvblBvc2l0aW9uKTsKICAgIH0gZWxzZSB7CiAgICAgIHBvcyA9IHRoaXMuX2dldFRyYW5zZm9ybWVkQnlNb3ZlKG9wZXJhdGlvbi5kZWxldGlvblBvc2l0aW9uLCBvcGVyYXRpb24uZ3JhdmV5YXJkUG9zaXRpb24sIDEpOwogICAgfQoKICAgIHJldHVybiBwb3M7CiAgfQogIC8qKgogICAqIFJldHVybnMgYSBjb3B5IG9mIHRoaXMgcG9zaXRpb24gdGhhdCBpcyB1cGRhdGVkIGJ5IHJlbW92aW5nIGBob3dNYW55YCBub2RlcyBzdGFydGluZyBmcm9tIGBkZWxldGVQb3NpdGlvbmAuCiAgICogSXQgbWF5IGhhcHBlbiB0aGF0IHRoaXMgcG9zaXRpb24gaXMgaW4gYSByZW1vdmVkIG5vZGUuIElmIHRoYXQgaXMgdGhlIGNhc2UsIGBudWxsYCBpcyByZXR1cm5lZCBpbnN0ZWFkLgogICAqCiAgICogQHByb3RlY3RlZAogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0gZGVsZXRlUG9zaXRpb24gUG9zaXRpb24gYmVmb3JlIHRoZSBmaXJzdCByZW1vdmVkIG5vZGUuCiAgICogQHBhcmFtIHtOdW1iZXJ9IGhvd01hbnkgSG93IG1hbnkgbm9kZXMgYXJlIHJlbW92ZWQuCiAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb258bnVsbH0gVHJhbnNmb3JtZWQgcG9zaXRpb24gb3IgYG51bGxgLgogICAqLwoKCiAgX2dldFRyYW5zZm9ybWVkQnlEZWxldGlvbihkZWxldGVQb3NpdGlvbiwgaG93TWFueSkgewogICAgY29uc3QgdHJhbnNmb3JtZWQgPSBQb3NpdGlvbi5fY3JlYXRlQXQodGhpcyk7IC8vIFRoaXMgcG9zaXRpb24gY2FuJ3QgYmUgYWZmZWN0ZWQgaWYgZGVsZXRpb24gd2FzIGluIGEgZGlmZmVyZW50IHJvb3QuCgoKICAgIGlmICh0aGlzLnJvb3QgIT0gZGVsZXRlUG9zaXRpb24ucm9vdCkgewogICAgICByZXR1cm4gdHJhbnNmb3JtZWQ7CiAgICB9CgogICAgaWYgKGNvbXBhcmVBcnJheXMoZGVsZXRlUG9zaXRpb24uZ2V0UGFyZW50UGF0aCgpLCB0aGlzLmdldFBhcmVudFBhdGgoKSkgPT0gJ3NhbWUnKSB7CiAgICAgIC8vIElmIG5vZGVzIGFyZSByZW1vdmVkIGZyb20gdGhlIG5vZGUgdGhhdCBpcyBwb2ludGVkIGJ5IHRoaXMgcG9zaXRpb24uLi4KICAgICAgaWYgKGRlbGV0ZVBvc2l0aW9uLm9mZnNldCA8IHRoaXMub2Zmc2V0KSB7CiAgICAgICAgLy8gQW5kIGFyZSByZW1vdmVkIGZyb20gYmVmb3JlIGFuIG9mZnNldCBvZiB0aGF0IHBvc2l0aW9uLi4uCiAgICAgICAgaWYgKGRlbGV0ZVBvc2l0aW9uLm9mZnNldCArIGhvd01hbnkgPiB0aGlzLm9mZnNldCkgewogICAgICAgICAgLy8gUG9zaXRpb24gaXMgaW4gcmVtb3ZlZCByYW5nZSwgaXQncyBubyBsb25nZXIgaW4gdGhlIHRyZWUuCiAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgLy8gRGVjcmVtZW50IHRoZSBvZmZzZXQgYWNjb3JkaW5nbHkuCiAgICAgICAgICB0cmFuc2Zvcm1lZC5vZmZzZXQgLT0gaG93TWFueTsKICAgICAgICB9CiAgICAgIH0KICAgIH0gZWxzZSBpZiAoY29tcGFyZUFycmF5cyhkZWxldGVQb3NpdGlvbi5nZXRQYXJlbnRQYXRoKCksIHRoaXMuZ2V0UGFyZW50UGF0aCgpKSA9PSAncHJlZml4JykgewogICAgICAvLyBJZiBub2RlcyBhcmUgcmVtb3ZlZCBmcm9tIGEgbm9kZSB0aGF0IGlzIG9uIGEgcGF0aCB0byB0aGlzIHBvc2l0aW9uLi4uCiAgICAgIGNvbnN0IGkgPSBkZWxldGVQb3NpdGlvbi5wYXRoLmxlbmd0aCAtIDE7CgogICAgICBpZiAoZGVsZXRlUG9zaXRpb24ub2Zmc2V0IDw9IHRoaXMucGF0aFtpXSkgewogICAgICAgIC8vIEFuZCBhcmUgcmVtb3ZlZCBmcm9tIGJlZm9yZSBuZXh0IG5vZGUgb2YgdGhhdCBwYXRoLi4uCiAgICAgICAgaWYgKGRlbGV0ZVBvc2l0aW9uLm9mZnNldCArIGhvd01hbnkgPiB0aGlzLnBhdGhbaV0pIHsKICAgICAgICAgIC8vIElmIHRoZSBuZXh0IG5vZGUgb2YgdGhhdCBwYXRoIGlzIHJlbW92ZWQgcmV0dXJuIG51bGwKICAgICAgICAgIC8vIGJlY2F1c2UgdGhlIG5vZGUgY29udGFpbmluZyB0aGlzIHBvc2l0aW9uIGdvdCByZW1vdmVkLgogICAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIC8vIE90aGVyd2lzZSwgZGVjcmVtZW50IGluZGV4IG9uIHRoYXQgcGF0aC4KICAgICAgICAgIHRyYW5zZm9ybWVkLnBhdGhbaV0gLT0gaG93TWFueTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KCiAgICByZXR1cm4gdHJhbnNmb3JtZWQ7CiAgfQogIC8qKgogICAqIFJldHVybnMgYSBjb3B5IG9mIHRoaXMgcG9zaXRpb24gdGhhdCBpcyB1cGRhdGVkIGJ5IGluc2VydGluZyBgaG93TWFueWAgbm9kZXMgYXQgYGluc2VydFBvc2l0aW9uYC4KICAgKgogICAqIEBwcm90ZWN0ZWQKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259IGluc2VydFBvc2l0aW9uIFBvc2l0aW9uIHdoZXJlIG5vZGVzIGFyZSBpbnNlcnRlZC4KICAgKiBAcGFyYW0ge051bWJlcn0gaG93TWFueSBIb3cgbWFueSBub2RlcyBhcmUgaW5zZXJ0ZWQuCiAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259IFRyYW5zZm9ybWVkIHBvc2l0aW9uLgogICAqLwoKCiAgX2dldFRyYW5zZm9ybWVkQnlJbnNlcnRpb24oaW5zZXJ0UG9zaXRpb24sIGhvd01hbnkpIHsKICAgIGNvbnN0IHRyYW5zZm9ybWVkID0gUG9zaXRpb24uX2NyZWF0ZUF0KHRoaXMpOyAvLyBUaGlzIHBvc2l0aW9uIGNhbid0IGJlIGFmZmVjdGVkIGlmIGluc2VydGlvbiB3YXMgaW4gYSBkaWZmZXJlbnQgcm9vdC4KCgogICAgaWYgKHRoaXMucm9vdCAhPSBpbnNlcnRQb3NpdGlvbi5yb290KSB7CiAgICAgIHJldHVybiB0cmFuc2Zvcm1lZDsKICAgIH0KCiAgICBpZiAoY29tcGFyZUFycmF5cyhpbnNlcnRQb3NpdGlvbi5nZXRQYXJlbnRQYXRoKCksIHRoaXMuZ2V0UGFyZW50UGF0aCgpKSA9PSAnc2FtZScpIHsKICAgICAgLy8gSWYgbm9kZXMgYXJlIGluc2VydGVkIGluIHRoZSBub2RlIHRoYXQgaXMgcG9pbnRlZCBieSB0aGlzIHBvc2l0aW9uLi4uCiAgICAgIGlmIChpbnNlcnRQb3NpdGlvbi5vZmZzZXQgPCB0aGlzLm9mZnNldCB8fCBpbnNlcnRQb3NpdGlvbi5vZmZzZXQgPT0gdGhpcy5vZmZzZXQgJiYgdGhpcy5zdGlja2luZXNzICE9ICd0b1ByZXZpb3VzJykgewogICAgICAgIC8vIEFuZCBhcmUgaW5zZXJ0ZWQgYmVmb3JlIGFuIG9mZnNldCBvZiB0aGF0IHBvc2l0aW9uLi4uCiAgICAgICAgLy8gIlB1c2giIHRoaXMgcG9zaXRpb25zIG9mZnNldC4KICAgICAgICB0cmFuc2Zvcm1lZC5vZmZzZXQgKz0gaG93TWFueTsKICAgICAgfQogICAgfSBlbHNlIGlmIChjb21wYXJlQXJyYXlzKGluc2VydFBvc2l0aW9uLmdldFBhcmVudFBhdGgoKSwgdGhpcy5nZXRQYXJlbnRQYXRoKCkpID09ICdwcmVmaXgnKSB7CiAgICAgIC8vIElmIG5vZGVzIGFyZSBpbnNlcnRlZCBpbiBhIG5vZGUgdGhhdCBpcyBvbiBhIHBhdGggdG8gdGhpcyBwb3NpdGlvbi4uLgogICAgICBjb25zdCBpID0gaW5zZXJ0UG9zaXRpb24ucGF0aC5sZW5ndGggLSAxOwoKICAgICAgaWYgKGluc2VydFBvc2l0aW9uLm9mZnNldCA8PSB0aGlzLnBhdGhbaV0pIHsKICAgICAgICAvLyBBbmQgYXJlIGluc2VydGVkIGJlZm9yZSBuZXh0IG5vZGUgb2YgdGhhdCBwYXRoLi4uCiAgICAgICAgLy8gIlB1c2giIHRoZSBpbmRleCBvbiB0aGF0IHBhdGguCiAgICAgICAgdHJhbnNmb3JtZWQucGF0aFtpXSArPSBob3dNYW55OwogICAgICB9CiAgICB9CgogICAgcmV0dXJuIHRyYW5zZm9ybWVkOwogIH0KICAvKioKICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGlzIHBvc2l0aW9uIHRoYXQgaXMgdXBkYXRlZCBieSBtb3ZpbmcgYGhvd01hbnlgIG5vZGVzIGZyb20gYHNvdXJjZVBvc2l0aW9uYCB0byBgdGFyZ2V0UG9zaXRpb25gLgogICAqCiAgICogQHByb3RlY3RlZAogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0gc291cmNlUG9zaXRpb24gUG9zaXRpb24gYmVmb3JlIHRoZSBmaXJzdCBlbGVtZW50IHRvIG1vdmUuCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufSB0YXJnZXRQb3NpdGlvbiBQb3NpdGlvbiB3aGVyZSBtb3ZlZCBlbGVtZW50cyB3aWxsIGJlIGluc2VydGVkLgogICAqIEBwYXJhbSB7TnVtYmVyfSBob3dNYW55IEhvdyBtYW55IGNvbnNlY3V0aXZlIG5vZGVzIHRvIG1vdmUsIHN0YXJ0aW5nIGZyb20gYHNvdXJjZVBvc2l0aW9uYC4KICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0gVHJhbnNmb3JtZWQgcG9zaXRpb24uCiAgICovCgoKICBfZ2V0VHJhbnNmb3JtZWRCeU1vdmUoc291cmNlUG9zaXRpb24sIHRhcmdldFBvc2l0aW9uLCBob3dNYW55KSB7CiAgICAvLyBVcGRhdGUgdGFyZ2V0IHBvc2l0aW9uLCBhcyBpdCBjb3VsZCBiZSBhZmZlY3RlZCBieSBub2RlcyByZW1vdmFsLgogICAgdGFyZ2V0UG9zaXRpb24gPSB0YXJnZXRQb3NpdGlvbi5fZ2V0VHJhbnNmb3JtZWRCeURlbGV0aW9uKHNvdXJjZVBvc2l0aW9uLCBob3dNYW55KTsKCiAgICBpZiAoc291cmNlUG9zaXRpb24uaXNFcXVhbCh0YXJnZXRQb3NpdGlvbikpIHsKICAgICAgLy8gSWYgYHRhcmdldFBvc2l0aW9uYCBpcyBlcXVhbCB0byBgc291cmNlUG9zaXRpb25gIHRoaXMgaXNuJ3QgcmVhbGx5IGFueSBtb3ZlLiBKdXN0IHJldHVybiBwb3NpdGlvbiBhcyBpdCBpcy4KICAgICAgcmV0dXJuIFBvc2l0aW9uLl9jcmVhdGVBdCh0aGlzKTsKICAgIH0gLy8gTW92aW5nIGEgcmFuZ2UgcmVtb3ZlcyBub2RlcyBmcm9tIHRoZWlyIG9yaWdpbmFsIHBvc2l0aW9uLiBXZSBhY2tub3dsZWRnZSB0aGlzIGJ5IHByb3BlciB0cmFuc2Zvcm1hdGlvbi4KCgogICAgY29uc3QgdHJhbnNmb3JtZWQgPSB0aGlzLl9nZXRUcmFuc2Zvcm1lZEJ5RGVsZXRpb24oc291cmNlUG9zaXRpb24sIGhvd01hbnkpOwoKICAgIGNvbnN0IGlzTW92ZWQgPSB0cmFuc2Zvcm1lZCA9PT0gbnVsbCB8fCBzb3VyY2VQb3NpdGlvbi5pc0VxdWFsKHRoaXMpICYmIHRoaXMuc3RpY2tpbmVzcyA9PSAndG9OZXh0JyB8fCBzb3VyY2VQb3NpdGlvbi5nZXRTaGlmdGVkQnkoaG93TWFueSkuaXNFcXVhbCh0aGlzKSAmJiB0aGlzLnN0aWNraW5lc3MgPT0gJ3RvUHJldmlvdXMnOwoKICAgIGlmIChpc01vdmVkKSB7CiAgICAgIC8vIFRoaXMgcG9zaXRpb24gaXMgaW5zaWRlIG1vdmVkIHJhbmdlIChvciBzdGlja3MgdG8gaXQpLgogICAgICAvLyBJbiB0aGlzIGNhc2UsIHdlIGNhbGN1bGF0ZSBhIGNvbWJpbmF0aW9uIG9mIHRoaXMgcG9zaXRpb24sIG1vdmUgc291cmNlIHBvc2l0aW9uIGFuZCB0YXJnZXQgcG9zaXRpb24uCiAgICAgIHJldHVybiB0aGlzLl9nZXRDb21iaW5lZChzb3VyY2VQb3NpdGlvbiwgdGFyZ2V0UG9zaXRpb24pOwogICAgfSBlbHNlIHsKICAgICAgLy8gVGhpcyBwb3NpdGlvbiBpcyBub3QgaW5zaWRlIGEgcmVtb3ZlZCByYW5nZS4KICAgICAgLy8KICAgICAgLy8gSW4gbmV4dCBzdGVwLCB3ZSBzaW1wbHkgcmVmbGVjdCBpbnNlcnRpbmcgYGhvd01hbnlgIG5vZGVzLCB3aGljaCBtaWdodCBmdXJ0aGVyIGFmZmVjdCB0aGUgcG9zaXRpb24uCiAgICAgIHJldHVybiB0cmFuc2Zvcm1lZC5fZ2V0VHJhbnNmb3JtZWRCeUluc2VydGlvbih0YXJnZXRQb3NpdGlvbiwgaG93TWFueSk7CiAgICB9CiAgfQogIC8qKgogICAqIFJldHVybnMgYSBuZXcgcG9zaXRpb24gdGhhdCBpcyBhIGNvbWJpbmF0aW9uIG9mIHRoaXMgcG9zaXRpb24gYW5kIGdpdmVuIHBvc2l0aW9ucy4KICAgKgogICAqIFRoZSBjb21iaW5lZCBwb3NpdGlvbiBpcyBhIGNvcHkgb2YgdGhpcyBwb3NpdGlvbiB0cmFuc2Zvcm1lZCBieSBtb3ZpbmcgYSByYW5nZSBzdGFydGluZyBhdCBgc291cmNlYCBwb3NpdGlvbgogICAqIHRvIHRoZSBgdGFyZ2V0YCBwb3NpdGlvbi4gSXQgaXMgZXhwZWN0ZWQgdGhhdCB0aGlzIHBvc2l0aW9uIGlzIGluc2lkZSB0aGUgbW92ZWQgcmFuZ2UuCiAgICoKICAgKiBFeGFtcGxlOgogICAqCiAgICoJCWxldCBvcmlnaW5hbCA9IG1vZGVsLmNyZWF0ZVBvc2l0aW9uRnJvbVBhdGgoIHJvb3QsIFsgMiwgMywgMSBdICk7CiAgICoJCWxldCBzb3VyY2UgPSBtb2RlbC5jcmVhdGVQb3NpdGlvbkZyb21QYXRoKCByb290LCBbIDIsIDIgXSApOwogICAqCQlsZXQgdGFyZ2V0ID0gbW9kZWwuY3JlYXRlUG9zaXRpb25Gcm9tUGF0aCggb3RoZXJSb290LCBbIDEsIDEsIDMgXSApOwogICAqCQlvcmlnaW5hbC5fZ2V0Q29tYmluZWQoIHNvdXJjZSwgdGFyZ2V0ICk7IC8vIHBhdGggaXMgWyAxLCAxLCA0LCAxIF0sIHJvb3QgaXMgYG90aGVyUm9vdGAKICAgKgogICAqIEV4cGxhbmF0aW9uOgogICAqCiAgICogV2UgaGF2ZSBhIHBvc2l0aW9uIGBbIDIsIDMsIDEgXWAgYW5kIG1vdmUgc29tZSBub2RlcyBmcm9tIGBbIDIsIDIgXWAgdG8gYFsgMSwgMSwgMyBdYC4gVGhlIG9yaWdpbmFsIHBvc2l0aW9uCiAgICogd2FzIGluc2lkZSBtb3ZlZCBub2RlcyBhbmQgbm93IHNob3VsZCBwb2ludCB0byB0aGUgbmV3IHBsYWNlLiBUaGUgbW92ZWQgbm9kZXMgd2lsbCBiZSBhZnRlcgogICAqIHBvc2l0aW9ucyBgWyAxLCAxLCAzIF1gLCBgWyAxLCAxLCA0IF1gLCBgWyAxLCAxLCA1IF1gLiBTaW5jZSBvdXIgcG9zaXRpb24gd2FzIGluIHRoZSBzZWNvbmQgbW92ZWQgbm9kZSwKICAgKiB0aGUgdHJhbnNmb3JtZWQgcG9zaXRpb24gd2lsbCBiZSBpbiBhIHN1Yi10cmVlIG9mIGEgbm9kZSBhdCBgWyAxLCAxLCA0IF1gLiBMb29raW5nIGF0IG9yaWdpbmFsIHBhdGgsIHdlCiAgICogdG9vayBjYXJlIG9mIGBbIDIsIDMgXWAgcGFydCBvZiBpdC4gTm93IHdlIGhhdmUgdG8gYWRkIHRoZSByZXN0IG9mIHRoZSBvcmlnaW5hbCBwYXRoIHRvIHRoZSB0cmFuc2Zvcm1lZCBwYXRoLgogICAqIEZpbmFsbHksIHRoZSB0cmFuc2Zvcm1lZCBwb3NpdGlvbiB3aWxsIHBvaW50IHRvIGBbIDEsIDEsIDQsIDEgXWAuCiAgICoKICAgKiBAcHJvdGVjdGVkCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufSBzb3VyY2UgQmVnaW5uaW5nIG9mIHRoZSBtb3ZlZCByYW5nZS4KICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259IHRhcmdldCBQb3NpdGlvbiB3aGVyZSB0aGUgcmFuZ2UgaXMgbW92ZWQuCiAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259IENvbWJpbmVkIHBvc2l0aW9uLgogICAqLwoKCiAgX2dldENvbWJpbmVkKHNvdXJjZSwgdGFyZ2V0KSB7CiAgICBjb25zdCBpID0gc291cmNlLnBhdGgubGVuZ3RoIC0gMTsgLy8gVGhlIGZpcnN0IHBhcnQgb2YgYSBwYXRoIHRvIGNvbWJpbmVkIHBvc2l0aW9uIGlzIGEgcGF0aCB0byB0aGUgcGxhY2Ugd2hlcmUgbm9kZXMgd2VyZSBtb3ZlZC4KCiAgICBjb25zdCBjb21iaW5lZCA9IFBvc2l0aW9uLl9jcmVhdGVBdCh0YXJnZXQpOwoKICAgIGNvbWJpbmVkLnN0aWNraW5lc3MgPSB0aGlzLnN0aWNraW5lc3M7IC8vIFRoZW4gd2UgaGF2ZSB0byB1cGRhdGUgdGhlIHJlc3Qgb2YgdGhlIHBhdGguCiAgICAvLyBGaXggdGhlIG9mZnNldCBiZWNhdXNlIHRoaXMgcG9zaXRpb24gbWlnaHQgYmUgYWZ0ZXIgYGZyb21gIHBvc2l0aW9uIGFuZCB3ZSBoYXZlIHRvIHJlZmxlY3QgdGhhdC4KCiAgICBjb21iaW5lZC5vZmZzZXQgPSBjb21iaW5lZC5vZmZzZXQgKyB0aGlzLnBhdGhbaV0gLSBzb3VyY2Uub2Zmc2V0OyAvLyBUaGVuLCBhZGQgdGhlIHJlc3Qgb2YgdGhlIHBhdGguCiAgICAvLyBJZiB0aGlzIHBvc2l0aW9uIGlzIGF0IHRoZSBzYW1lIGxldmVsIGFzIGBmcm9tYCBwb3NpdGlvbiBub3RoaW5nIHdpbGwgZ2V0IGFkZGVkLgoKICAgIGNvbWJpbmVkLnBhdGggPSBjb21iaW5lZC5wYXRoLmNvbmNhdCh0aGlzLnBhdGguc2xpY2UoaSArIDEpKTsKICAgIHJldHVybiBjb21iaW5lZDsKICB9CiAgLyoqCiAgICogQGluaGVyaXREb2MKICAgKi8KCgogIHRvSlNPTigpIHsKICAgIHJldHVybiB7CiAgICAgIHJvb3Q6IHRoaXMucm9vdC50b0pTT04oKSwKICAgICAgcGF0aDogQXJyYXkuZnJvbSh0aGlzLnBhdGgpLAogICAgICBzdGlja2luZXNzOiB0aGlzLnN0aWNraW5lc3MKICAgIH07CiAgfQogIC8qKgogICAqIFJldHVybnMgYSBuZXcgcG9zaXRpb24gdGhhdCBpcyBlcXVhbCB0byBjdXJyZW50IHBvc2l0aW9uLgogICAqCiAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259CiAgICovCgoKICBjbG9uZSgpIHsKICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLnJvb3QsIHRoaXMucGF0aCwgdGhpcy5zdGlja2luZXNzKTsKICB9CiAgLyoqCiAgICogQ3JlYXRlcyBwb3NpdGlvbiBhdCB0aGUgZ2l2ZW4gbG9jYXRpb24uIFRoZSBsb2NhdGlvbiBjYW4gYmUgc3BlY2lmaWVkIGFzOgogICAqCiAgICogKiBhIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9uIHBvc2l0aW9ufSwKICAgKiAqIHBhcmVudCBlbGVtZW50IGFuZCBvZmZzZXQgKG9mZnNldCBkZWZhdWx0cyB0byBgMGApLAogICAqICogcGFyZW50IGVsZW1lbnQgYW5kIGAnZW5kJ2AgKHNldHMgcG9zaXRpb24gYXQgdGhlIGVuZCBvZiB0aGF0IGVsZW1lbnQpLAogICAqICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtIG1vZGVsIGl0ZW19IGFuZCBgJ2JlZm9yZSdgIG9yIGAnYWZ0ZXInYCAoc2V0cyBwb3NpdGlvbiBiZWZvcmUgb3IgYWZ0ZXIgZ2l2ZW4gbW9kZWwgaXRlbSkuCiAgICoKICAgKiBUaGlzIG1ldGhvZCBpcyBhIHNob3J0Y3V0IHRvIG90aGVyIGZhY3RvcnkgbWV0aG9kcyBzdWNoIGFzOgogICAqCiAgICogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbi5fY3JlYXRlQmVmb3JlfSwKICAgKiAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9uLl9jcmVhdGVBZnRlcn0uCiAgICoKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtfG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259IGl0ZW1PclBvc2l0aW9uCiAgICogQHBhcmFtIHtOdW1iZXJ8J2VuZCd8J2JlZm9yZSd8J2FmdGVyJ30gW29mZnNldF0gT2Zmc2V0IG9yIG9uZSBvZiB0aGUgZmxhZ3MuIFVzZWQgb25seSB3aGVuIHRoZQogICAqIGZpcnN0IHBhcmFtZXRlciBpcyBhIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbSBtb2RlbCBpdGVtfS4KICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb25TdGlja2luZXNzfSBbc3RpY2tpbmVzcz0ndG9Ob25lJ10gUG9zaXRpb24gc3RpY2tpbmVzcy4gVXNlZCBvbmx5IHdoZW4gdGhlCiAgICogZmlyc3QgcGFyYW1ldGVyIGlzIGEge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtIG1vZGVsIGl0ZW19LgogICAqIEBwcm90ZWN0ZWQKICAgKi8KCgogIHN0YXRpYyBfY3JlYXRlQXQoaXRlbU9yUG9zaXRpb24sIG9mZnNldCwgc3RpY2tpbmVzcyA9ICd0b05vbmUnKSB7CiAgICBpZiAoaXRlbU9yUG9zaXRpb24gaW5zdGFuY2VvZiBQb3NpdGlvbikgewogICAgICByZXR1cm4gbmV3IFBvc2l0aW9uKGl0ZW1PclBvc2l0aW9uLnJvb3QsIGl0ZW1PclBvc2l0aW9uLnBhdGgsIGl0ZW1PclBvc2l0aW9uLnN0aWNraW5lc3MpOwogICAgfSBlbHNlIHsKICAgICAgY29uc3Qgbm9kZSA9IGl0ZW1PclBvc2l0aW9uOwoKICAgICAgaWYgKG9mZnNldCA9PSAnZW5kJykgewogICAgICAgIG9mZnNldCA9IG5vZGUubWF4T2Zmc2V0OwogICAgICB9IGVsc2UgaWYgKG9mZnNldCA9PSAnYmVmb3JlJykgewogICAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVCZWZvcmUobm9kZSwgc3RpY2tpbmVzcyk7CiAgICAgIH0gZWxzZSBpZiAob2Zmc2V0ID09ICdhZnRlcicpIHsKICAgICAgICByZXR1cm4gdGhpcy5fY3JlYXRlQWZ0ZXIobm9kZSwgc3RpY2tpbmVzcyk7CiAgICAgIH0gZWxzZSBpZiAob2Zmc2V0ICE9PSAwICYmICFvZmZzZXQpIHsKICAgICAgICAvKioKICAgICAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9tb2RlbH5Nb2RlbCNjcmVhdGVQb3NpdGlvbkF0IGBNb2RlbCNjcmVhdGVQb3NpdGlvbkF0KClgfQogICAgICAgICAqIHJlcXVpcmVzIHRoZSBvZmZzZXQgdG8gYmUgc3BlY2lmaWVkIHdoZW4gdGhlIGZpcnN0IHBhcmFtZXRlciBpcyBhIG1vZGVsIGl0ZW0uCiAgICAgICAgICoKICAgICAgICAgKiBAZXJyb3IgbW9kZWwtY3JlYXRlUG9zaXRpb25BdC1vZmZzZXQtcmVxdWlyZWQKICAgICAgICAgKi8KICAgICAgICB0aHJvdyBuZXcgQ0tFZGl0b3JFcnJvcignbW9kZWwtY3JlYXRlUG9zaXRpb25BdC1vZmZzZXQtcmVxdWlyZWQ6ICcgKyAnTW9kZWwjY3JlYXRlUG9zaXRpb25BdCgpIHJlcXVpcmVzIHRoZSBvZmZzZXQgd2hlbiB0aGUgZmlyc3QgcGFyYW1ldGVyIGlzIGEgbW9kZWwgaXRlbS4nLCBbdGhpcywgaXRlbU9yUG9zaXRpb25dKTsKICAgICAgfQoKICAgICAgaWYgKCFub2RlLmlzKCdlbGVtZW50JykgJiYgIW5vZGUuaXMoJ2RvY3VtZW50RnJhZ21lbnQnKSkgewogICAgICAgIC8qKgogICAgICAgICAqIFBvc2l0aW9uIHBhcmVudCBoYXZlIHRvIGJlIGEgbW9kZWwgZWxlbWVudCBvciBtb2RlbCBkb2N1bWVudCBmcmFnbWVudC4KICAgICAgICAgKgogICAgICAgICAqIEBlcnJvciBtb2RlbC1wb3NpdGlvbi1wYXJlbnQtaW5jb3JyZWN0CiAgICAgICAgICovCiAgICAgICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ21vZGVsLXBvc2l0aW9uLXBhcmVudC1pbmNvcnJlY3Q6IFBvc2l0aW9uIHBhcmVudCBoYXZlIHRvIGJlIGEgZWxlbWVudCBvciBkb2N1bWVudCBmcmFnbWVudC4nLCBbdGhpcywgaXRlbU9yUG9zaXRpb25dKTsKICAgICAgfQoKICAgICAgY29uc3QgcGF0aCA9IG5vZGUuZ2V0UGF0aCgpOwogICAgICBwYXRoLnB1c2gob2Zmc2V0KTsKICAgICAgcmV0dXJuIG5ldyB0aGlzKG5vZGUucm9vdCwgcGF0aCwgc3RpY2tpbmVzcyk7CiAgICB9CiAgfQogIC8qKgogICAqIENyZWF0ZXMgYSBuZXcgcG9zaXRpb24sIGFmdGVyIGdpdmVuIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbSBtb2RlbCBpdGVtfS4KICAgKgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9pdGVtfkl0ZW19IGl0ZW0gSXRlbSBhZnRlciB3aGljaCB0aGUgcG9zaXRpb24gc2hvdWxkIGJlIHBsYWNlZC4KICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb25TdGlja2luZXNzfSBbc3RpY2tpbmVzcz0ndG9Ob25lJ10gUG9zaXRpb24gc3RpY2tpbmVzcy4KICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0KICAgKiBAcHJvdGVjdGVkCiAgICovCgoKICBzdGF0aWMgX2NyZWF0ZUFmdGVyKGl0ZW0sIHN0aWNraW5lc3MpIHsKICAgIGlmICghaXRlbS5wYXJlbnQpIHsKICAgICAgLyoqCiAgICAgICAqIFlvdSBjYW4gbm90IG1ha2UgYSBwb3NpdGlvbiBhZnRlciBhIHJvb3QgZWxlbWVudC4KICAgICAgICoKICAgICAgICogQGVycm9yIG1vZGVsLXBvc2l0aW9uLWFmdGVyLXJvb3QKICAgICAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbX0gcm9vdAogICAgICAgKi8KICAgICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ21vZGVsLXBvc2l0aW9uLWFmdGVyLXJvb3Q6IFlvdSBjYW5ub3QgbWFrZSBhIHBvc2l0aW9uIGFmdGVyIHJvb3QuJywgW3RoaXMsIGl0ZW1dLCB7CiAgICAgICAgcm9vdDogaXRlbQogICAgICB9KTsKICAgIH0KCiAgICByZXR1cm4gdGhpcy5fY3JlYXRlQXQoaXRlbS5wYXJlbnQsIGl0ZW0uZW5kT2Zmc2V0LCBzdGlja2luZXNzKTsKICB9CiAgLyoqCiAgICogQ3JlYXRlcyBhIG5ldyBwb3NpdGlvbiwgYmVmb3JlIHRoZSBnaXZlbiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9pdGVtfkl0ZW0gbW9kZWwgaXRlbX0uCiAgICoKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtfSBpdGVtIEl0ZW0gYmVmb3JlIHdoaWNoIHRoZSBwb3NpdGlvbiBzaG91bGQgYmUgcGxhY2VkLgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvblN0aWNraW5lc3N9IFtzdGlja2luZXNzPSd0b05vbmUnXSBQb3NpdGlvbiBzdGlja2luZXNzLgogICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufQogICAqIEBwcm90ZWN0ZWQKICAgKi8KCgogIHN0YXRpYyBfY3JlYXRlQmVmb3JlKGl0ZW0sIHN0aWNraW5lc3MpIHsKICAgIGlmICghaXRlbS5wYXJlbnQpIHsKICAgICAgLyoqCiAgICAgICAqIFlvdSBjYW4gbm90IG1ha2UgYSBwb3NpdGlvbiBiZWZvcmUgYSByb290IGVsZW1lbnQuCiAgICAgICAqCiAgICAgICAqIEBlcnJvciBtb2RlbC1wb3NpdGlvbi1iZWZvcmUtcm9vdAogICAgICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtfSByb290CiAgICAgICAqLwogICAgICB0aHJvdyBuZXcgQ0tFZGl0b3JFcnJvcignbW9kZWwtcG9zaXRpb24tYmVmb3JlLXJvb3Q6IFlvdSBjYW5ub3QgbWFrZSBhIHBvc2l0aW9uIGJlZm9yZSByb290LicsIGl0ZW0sIHsKICAgICAgICByb290OiBpdGVtCiAgICAgIH0pOwogICAgfQoKICAgIHJldHVybiB0aGlzLl9jcmVhdGVBdChpdGVtLnBhcmVudCwgaXRlbS5zdGFydE9mZnNldCwgc3RpY2tpbmVzcyk7CiAgfQogIC8qKgogICAqIENyZWF0ZXMgYSBgUG9zaXRpb25gIGluc3RhbmNlIGZyb20gZ2l2ZW4gcGxhaW4gb2JqZWN0IChpLmUuIHBhcnNlZCBKU09OIHN0cmluZykuCiAgICoKICAgKiBAcGFyYW0ge09iamVjdH0ganNvbiBQbGFpbiBvYmplY3QgdG8gYmUgY29udmVydGVkIHRvIGBQb3NpdGlvbmAuCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50fkRvY3VtZW50fSBkb2MgRG9jdW1lbnQgb2JqZWN0IHRoYXQgd2lsbCBiZSBwb3NpdGlvbiBvd25lci4KICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0gYFBvc2l0aW9uYCBpbnN0YW5jZSBjcmVhdGVkIHVzaW5nIGdpdmVuIHBsYWluIG9iamVjdC4KICAgKi8KCgogIHN0YXRpYyBmcm9tSlNPTihqc29uLCBkb2MpIHsKICAgIGlmIChqc29uLnJvb3QgPT09ICckZ3JhdmV5YXJkJykgewogICAgICBjb25zdCBwb3MgPSBuZXcgUG9zaXRpb24oZG9jLmdyYXZleWFyZCwganNvbi5wYXRoKTsKICAgICAgcG9zLnN0aWNraW5lc3MgPSBqc29uLnN0aWNraW5lc3M7CiAgICAgIHJldHVybiBwb3M7CiAgICB9CgogICAgaWYgKCFkb2MuZ2V0Um9vdChqc29uLnJvb3QpKSB7CiAgICAgIC8qKgogICAgICAgKiBDYW5ub3QgY3JlYXRlIHBvc2l0aW9uIGZvciBkb2N1bWVudC4gUm9vdCB3aXRoIHNwZWNpZmllZCBuYW1lIGRvZXMgbm90IGV4aXN0LgogICAgICAgKgogICAgICAgKiBAZXJyb3IgbW9kZWwtcG9zaXRpb24tZnJvbWpzb24tbm8tcm9vdAogICAgICAgKiBAcGFyYW0ge1N0cmluZ30gcm9vdE5hbWUKICAgICAgICovCiAgICAgIHRocm93IG5ldyBDS0VkaXRvckVycm9yKCdtb2RlbC1wb3NpdGlvbi1mcm9tanNvbi1uby1yb290OiBDYW5ub3QgY3JlYXRlIHBvc2l0aW9uIGZvciBkb2N1bWVudC4gUm9vdCB3aXRoIHNwZWNpZmllZCBuYW1lIGRvZXMgbm90IGV4aXN0LicsIGRvYywgewogICAgICAgIHJvb3ROYW1lOiBqc29uLnJvb3QKICAgICAgfSk7CiAgICB9CgogICAgcmV0dXJuIG5ldyBQb3NpdGlvbihkb2MuZ2V0Um9vdChqc29uLnJvb3QpLCBqc29uLnBhdGgsIGpzb24uc3RpY2tpbmVzcyk7CiAgfSAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vIHRvU3RyaW5nKCkgewogIC8vIEBpZiBDS19ERUJVR19FTkdJTkUgLy8gCXJldHVybiBgJHsgdGhpcy5yb290IH0gWyAkeyB0aGlzLnBhdGguam9pbiggJywgJyApIH0gXWA7CiAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLyB9CiAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLyBsb2coKSB7CiAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLyAJY29uc29sZS5sb2coICdNb2RlbFBvc2l0aW9uOiAnICsgdGhpcyApOwogIC8vIEBpZiBDS19ERUJVR19FTkdJTkUgLy8gfQoKCn0KLyoqCiAqIEEgZmxhZyBpbmRpY2F0aW5nIHdoZXRoZXIgdGhpcyBwb3NpdGlvbiBpcyBgJ2JlZm9yZSdgIG9yIGAnYWZ0ZXInYCBvciBgJ3NhbWUnYCBhcyBnaXZlbiBwb3NpdGlvbi4KICogSWYgcG9zaXRpb25zIGFyZSBpbiBkaWZmZXJlbnQgcm9vdHMgYCdkaWZmZXJlbnQnYCBmbGFnIGlzIHJldHVybmVkLgogKgogKiBAdHlwZWRlZiB7U3RyaW5nfSBtb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9uUmVsYXRpb24KICovCgovKioKICogUmVwcmVzZW50cyBob3cgcG9zaXRpb24gaXMgInN0aWNraW5nIiB3aXRoIG5laWdoYm91ciBub2Rlcy4gVXNlZCB0byBkZWZpbmUgaG93IHBvc2l0aW9uIHNob3VsZCBiZSB0cmFuc2Zvcm1lZCAobW92ZWQpCiAqIGluIGVkZ2UgY2FzZXMuIFBvc3NpYmxlIHZhbHVlczogYCd0b05vbmUnYCwgYCd0b05leHQnYCwgYCd0b1ByZXZpb3VzJ2AuCiAqCiAqIEV4YW1wbGVzOgogKgogKgkJSW5zZXJ0LiBQb3NpdGlvbiBpcyBhdCB8IGFuZCBub2RlcyBhcmUgaW5zZXJ0ZWQgYXQgdGhlIHNhbWUgcG9zaXRpb24sIG1hcmtlZCBhcyBeOgogKgogKgkJLSBzdGlja3MgdG8gbm9uZTogICAgICAgICAgIDxwPmZefG9vPC9wPiAgLT4gIDxwPmZiYXJ8b288L3A+CiAqCQktIHN0aWNrcyB0byBuZXh0IG5vZGU6ICAgICAgPHA+Zl58b288L3A+ICAtPiAgPHA+ZmJhcnxvbzwvcD4KICoJCS0gc3RpY2tzIHRvIHByZXZpb3VzIG5vZGU6ICA8cD5mfF5vbzwvcD4gIC0+ICA8cD5mfGJhcm9vPC9wPgogKgogKgogKgkJTW92ZS4gUG9zaXRpb24gaXMgYXQgfCBhbmQgcmFuZ2UgW29vXSBpcyBtb3ZlZCB0byBwb3NpdGlvbiBeOgogKgogKgkJLSBzdGlja3MgdG8gbm9uZTogICAgICAgICAgIDxwPmZ8W29vXTwvcD48cD5iXmFyPC9wPiAgLT4gIDxwPmZ8PC9wPjxwPmJvb2FyPC9wPgogKgkJLSBzdGlja3MgdG8gbm9uZTogICAgICAgICAgIDxwPmZbb29dfDwvcD48cD5iXmFyPC9wPiAgLT4gIDxwPmZ8PC9wPjxwPmJvb2FyPC9wPgogKgogKgkJLSBzdGlja3MgdG8gbmV4dCBub2RlOiAgICAgIDxwPmZ8W29vXTwvcD48cD5iXmFyPC9wPiAgLT4gIDxwPmY8L3A+PHA+Ynxvb2FyPC9wPgogKgkJLSBzdGlja3MgdG8gbmV4dCBub2RlOiAgICAgIDxwPmZbb29dfDwvcD48cD5iXmFyPC9wPiAgLT4gIDxwPmZ8PC9wPjxwPmJvb2FyPC9wPgogKgogKgkJLSBzdGlja3MgdG8gcHJldmlvdXMgbm9kZTogIDxwPmZ8W29vXTwvcD48cD5iXmFyPC9wPiAgLT4gIDxwPmZ8PC9wPjxwPmJvb2FyPC9wPgogKgkJLSBzdGlja3MgdG8gcHJldmlvdXMgbm9kZTogIDxwPmZbb29dfDwvcD48cD5iXmFyPC9wPiAgLT4gIDxwPmY8L3A+PHA+Ym9vfGFyPC9wPgogKgogKiBAdHlwZWRlZiB7U3RyaW5nfSBtb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9uU3RpY2tpbmVzcwogKi8="},{"version":3,"sources":["/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-engine/src/model/position.js"],"names":["TreeWalker","compareArrays","CKEditorError","Text","last","Position","constructor","root","path","stickiness","is","Array","length","getPath","concat","offset","newOffset","parent","i","getChild","offsetToIndex","position","index","textNode","node","startOffset","nodeAfter","nodeBefore","isAtStart","isAtEnd","maxOffset","compareWith","otherPosition","result","getLastMatchingPosition","skip","options","startPosition","treeWalker","getParentPath","slice","getAncestors","includeSelf","getCommonPath","cmp","diffAt","Math","min","getCommonAncestor","ancestorsA","ancestorsB","getShiftedBy","shift","shifted","clone","isAfter","isBefore","isEqual","isTouching","left","right","compare","_createAt","leftParent","type","hasSameParentAs","thisParentPath","posParentPath","getTransformedByOperation","operation","_getTransformedByInsertOperation","_getTransformedByMoveOperation","_getTransformedBySplitOperation","_getTransformedByMergeOperation","_getTransformedByInsertion","howMany","_getTransformedByMove","sourcePosition","targetPosition","movedRange","isContained","containsPosition","start","_getCombined","splitPosition","moveTargetPosition","graveyardPosition","insertionPosition","pos","_getTransformedByDeletion","deletionPosition","deletePosition","transformed","insertPosition","isMoved","source","target","combined","toJSON","from","itemOrPosition","_createBefore","_createAfter","push","item","endOffset","fromJSON","json","doc","graveyard","getRoot","rootName"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/position\n */\n\nimport TreeWalker from './treewalker';\nimport compareArrays from '@ckeditor/ckeditor5-utils/src/comparearrays';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport Text from './text';\nimport { last } from 'lodash-es';\n\n// To check if component is loaded more than once.\nimport '@ckeditor/ckeditor5-utils/src/version';\n\n/**\n * Represents a position in the model tree.\n *\n * A position is represented by its {@link module:engine/model/position~Position#root} and\n * a {@link module:engine/model/position~Position#path} in that root.\n *\n * You can create position instances via its constructor or the `createPosition*()` factory methods of\n * {@link module:engine/model/model~Model} and {@link module:engine/model/writer~Writer}.\n *\n * **Note:** Position is based on offsets, not indexes. This means that a position between two text nodes\n * `foo` and `bar` has offset `3`, not `1`. See {@link module:engine/model/position~Position#path} for more information.\n *\n * Since a position in the model is represented by a {@link module:engine/model/position~Position#root position root} and\n * {@link module:engine/model/position~Position#path position path} it is possible to create positions placed in non-existing places.\n * This requirement is important for operational transformation algorithms.\n *\n * Also, {@link module:engine/model/operation/operation~Operation operations}\n * kept in the {@link module:engine/model/document~Document#history document history}\n * are storing positions (and ranges) which were correct when those operations were applied, but may not be correct\n * after the document has changed.\n *\n * When changes are applied to the model, it may also happen that {@link module:engine/model/position~Position#parent position parent}\n * will change even if position path has not changed. Keep in mind, that if a position leads to non-existing element,\n * {@link module:engine/model/position~Position#parent} and some other properties and methods will throw errors.\n *\n * In most cases, position with wrong path is caused by an error in code, but it is sometimes needed, as described above.\n */\nexport default class Position {\n\t/**\n\t * Creates a position.\n\t *\n\t * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} root Root of the position.\n\t * @param {Array.<Number>} path Position path. See {@link module:engine/model/position~Position#path}.\n\t * @param {module:engine/model/position~PositionStickiness} [stickiness='toNone'] Position stickiness.\n\t * See {@link module:engine/model/position~PositionStickiness}.\n\t */\n\tconstructor( root, path, stickiness = 'toNone' ) {\n\t\tif ( !root.is( 'element' ) && !root.is( 'documentFragment' ) ) {\n\t\t\t/**\n\t\t\t * Position root is invalid.\n\t\t\t *\n\t\t\t * Positions can only be anchored in elements or document fragments.\n\t\t\t *\n\t\t\t * @error model-position-root-invalid\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'model-position-root-invalid: Position root invalid.',\n\t\t\t\troot\n\t\t\t);\n\t\t}\n\n\t\tif ( !( path instanceof Array ) || path.length === 0 ) {\n\t\t\t/**\n\t\t\t * Position path must be an array with at least one item.\n\t\t\t *\n\t\t\t * @error model-position-path-incorrect-format\n\t\t\t * @param path\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'model-position-path-incorrect-format: Position path must be an array with at least one item.',\n\t\t\t\troot,\n\t\t\t\t{ path }\n\t\t\t);\n\t\t}\n\n\t\t// Normalize the root and path (if element was passed).\n\t\tpath = root.getPath().concat( path );\n\t\troot = root.root;\n\n\t\t/**\n\t\t * Root of the position path.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment}\n\t\t * module:engine/model/position~Position#root\n\t\t */\n\t\tthis.root = root;\n\n\t\t/**\n\t\t * Position of the node in the tree. **Path contains offsets, not indexes.**\n\t\t *\n\t\t * Position can be placed before, after or in a {@link module:engine/model/node~Node node} if that node has\n\t\t * {@link module:engine/model/node~Node#offsetSize} greater than `1`. Items in position path are\n\t\t * {@link module:engine/model/node~Node#startOffset starting offsets} of position ancestors, starting from direct root children,\n\t\t * down to the position offset in it's parent.\n\t\t *\n\t\t *\t\t ROOT\n\t\t *\t\t  |- P            before: [ 0 ]         after: [ 1 ]\n\t\t *\t\t  |- UL           before: [ 1 ]         after: [ 2 ]\n\t\t *\t\t     |- LI        before: [ 1, 0 ]      after: [ 1, 1 ]\n\t\t *\t\t     |  |- foo    before: [ 1, 0, 0 ]   after: [ 1, 0, 3 ]\n\t\t *\t\t     |- LI        before: [ 1, 1 ]      after: [ 1, 2 ]\n\t\t *\t\t        |- bar    before: [ 1, 1, 0 ]   after: [ 1, 1, 3 ]\n\t\t *\n\t\t * `foo` and `bar` are representing {@link module:engine/model/text~Text text nodes}. Since text nodes has offset size\n\t\t * greater than `1` you can place position offset between their start and end:\n\t\t *\n\t\t *\t\t ROOT\n\t\t *\t\t  |- P\n\t\t *\t\t  |- UL\n\t\t *\t\t     |- LI\n\t\t *\t\t     |  |- f^o|o  ^ has path: [ 1, 0, 1 ]   | has path: [ 1, 0, 2 ]\n\t\t *\t\t     |- LI\n\t\t *\t\t        |- b^a|r  ^ has path: [ 1, 1, 1 ]   | has path: [ 1, 1, 2 ]\n\t\t *\n\t\t * @readonly\n\t\t * @member {Array.<Number>} module:engine/model/position~Position#path\n\t\t */\n\t\tthis.path = path;\n\n\t\t/**\n\t\t * Position stickiness. See {@link module:engine/model/position~PositionStickiness}.\n\t\t *\n\t\t * @member {module:engine/model/position~PositionStickiness} module:engine/model/position~Position#stickiness\n\t\t */\n\t\tthis.stickiness = stickiness;\n\t}\n\n\t/**\n\t * Offset at which this position is located in its {@link module:engine/model/position~Position#parent parent}. It is equal\n\t * to the last item in position {@link module:engine/model/position~Position#path path}.\n\t *\n\t * @type {Number}\n\t */\n\tget offset() {\n\t\treturn last( this.path );\n\t}\n\n\t/**\n\t * @param {Number} newOffset\n\t */\n\tset offset( newOffset ) {\n\t\tthis.path[ this.path.length - 1 ] = newOffset;\n\t}\n\n\t/**\n\t * Parent element of this position.\n\t *\n\t * Keep in mind that `parent` value is calculated when the property is accessed.\n\t * If {@link module:engine/model/position~Position#path position path}\n\t * leads to a non-existing element, `parent` property will throw error.\n\t *\n\t * Also it is a good idea to cache `parent` property if it is used frequently in an algorithm (i.e. in a long loop).\n\t *\n\t * @readonly\n\t * @type {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment}\n\t */\n\tget parent() {\n\t\tlet parent = this.root;\n\n\t\tfor ( let i = 0; i < this.path.length - 1; i++ ) {\n\t\t\tparent = parent.getChild( parent.offsetToIndex( this.path[ i ] ) );\n\n\t\t\tif ( !parent ) {\n\t\t\t\tthrow new CKEditorError( 'model-position-path-incorrect: The position\\'s path is incorrect.', this, { position: this } );\n\t\t\t}\n\t\t}\n\n\t\tif ( parent.is( 'text' ) ) {\n\t\t\t/**\n\t\t\t * The position's path is incorrect. This means that a position does not point to\n\t\t\t * a correct place in the tree and hence, some of its methods and getters cannot work correctly.\n\t\t\t *\n\t\t\t * **Note**: Unlike DOM and view positions, in the model, the\n\t\t\t * {@link module:engine/model/position~Position#parent position's parent} is always an element or a document fragment.\n\t\t\t * The last offset in the {@link module:engine/model/position~Position#path position's path} is the point in this element where\n\t\t\t * this position points.\n\t\t\t *\n\t\t\t * Read more about model positions and offsets in\n\t\t\t * the {@glink framework/guides/architecture/editing-engine#indexes-and-offsets Editing engine architecture guide}.\n\t\t\t *\n\t\t\t * @error position-incorrect-path\n\t\t\t * @param {module:engine/model/position~Position} position The incorrect position.\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'model-position-path-incorrect: The position\\'s path is incorrect.', this, { position: this } );\n\t\t}\n\n\t\treturn parent;\n\t}\n\n\t/**\n\t * Position {@link module:engine/model/position~Position#offset offset} converted to an index in position's parent node. It is\n\t * equal to the {@link module:engine/model/node~Node#index index} of a node after this position. If position is placed\n\t * in text node, position index is equal to the index of that text node.\n\t *\n\t * @readonly\n\t * @type {Number}\n\t */\n\tget index() {\n\t\treturn this.parent.offsetToIndex( this.offset );\n\t}\n\n\t/**\n\t * Returns {@link module:engine/model/text~Text text node} instance in which this position is placed or `null` if this\n\t * position is not in a text node.\n\t *\n\t * @readonly\n\t * @type {module:engine/model/text~Text|null}\n\t */\n\tget textNode() {\n\t\tconst node = this.parent.getChild( this.index );\n\n\t\treturn ( node instanceof Text && node.startOffset < this.offset ) ? node : null;\n\t}\n\n\t/**\n\t * Node directly after this position or `null` if this position is in text node.\n\t *\n\t * @readonly\n\t * @type {module:engine/model/node~Node|null}\n\t */\n\tget nodeAfter() {\n\t\treturn this.textNode === null ? this.parent.getChild( this.index ) : null;\n\t}\n\n\t/**\n\t * Node directly before this position or `null` if this position is in text node.\n\t *\n\t * @readonly\n\t * @type {Node}\n\t */\n\tget nodeBefore() {\n\t\treturn this.textNode === null ? this.parent.getChild( this.index - 1 ) : null;\n\t}\n\n\t/**\n\t * Is `true` if position is at the beginning of its {@link module:engine/model/position~Position#parent parent}, `false` otherwise.\n\t *\n\t * @readonly\n\t * @type {Boolean}\n\t */\n\tget isAtStart() {\n\t\treturn this.offset === 0;\n\t}\n\n\t/**\n\t * Is `true` if position is at the end of its {@link module:engine/model/position~Position#parent parent}, `false` otherwise.\n\t *\n\t * @readonly\n\t * @type {Boolean}\n\t */\n\tget isAtEnd() {\n\t\treturn this.offset == this.parent.maxOffset;\n\t}\n\n\t/**\n\t * Checks whether this position is before or after given position.\n\t *\n\t * This method is safe to use it on non-existing positions (for example during operational transformation).\n\t *\n\t * @param {module:engine/model/position~Position} otherPosition Position to compare with.\n\t * @returns {module:engine/model/position~PositionRelation}\n\t */\n\tcompareWith( otherPosition ) {\n\t\tif ( this.root != otherPosition.root ) {\n\t\t\treturn 'different';\n\t\t}\n\n\t\tconst result = compareArrays( this.path, otherPosition.path );\n\n\t\tswitch ( result ) {\n\t\t\tcase 'same':\n\t\t\t\treturn 'same';\n\n\t\t\tcase 'prefix':\n\t\t\t\treturn 'before';\n\n\t\t\tcase 'extension':\n\t\t\t\treturn 'after';\n\n\t\t\tdefault:\n\t\t\t\treturn this.path[ result ] < otherPosition.path[ result ] ? 'before' : 'after';\n\t\t}\n\t}\n\n\t/**\n\t * Gets the farthest position which matches the callback using\n\t * {@link module:engine/model/treewalker~TreeWalker TreeWalker}.\n\t *\n\t * For example:\n\t *\n\t * \t\tgetLastMatchingPosition( value => value.type == 'text' );\n\t * \t\t// <paragraph>[]foo</paragraph> -> <paragraph>foo[]</paragraph>\n\t *\n\t * \t\tgetLastMatchingPosition( value => value.type == 'text', { direction: 'backward' } );\n\t * \t\t// <paragraph>foo[]</paragraph> -> <paragraph>[]foo</paragraph>\n\t *\n\t * \t\tgetLastMatchingPosition( value => false );\n\t * \t\t// Do not move the position.\n\t *\n\t * @param {Function} skip Callback function. Gets {@link module:engine/model/treewalker~TreeWalkerValue} and should\n\t * return `true` if the value should be skipped or `false` if not.\n\t * @param {Object} options Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.\n\t *\n\t * @returns {module:engine/model/position~Position} The position after the last item which matches the `skip` callback test.\n\t */\n\tgetLastMatchingPosition( skip, options = {} ) {\n\t\toptions.startPosition = this;\n\n\t\tconst treeWalker = new TreeWalker( options );\n\t\ttreeWalker.skip( skip );\n\n\t\treturn treeWalker.position;\n\t}\n\n\t/**\n\t * Returns a path to this position's parent. Parent path is equal to position {@link module:engine/model/position~Position#path path}\n\t * but without the last item.\n\t *\n\t * This method is safe to use it on non-existing positions (for example during operational transformation).\n\t *\n\t * @returns {Array.<Number>} Path to the parent.\n\t */\n\tgetParentPath() {\n\t\treturn this.path.slice( 0, -1 );\n\t}\n\n\t/**\n\t * Returns ancestors array of this position, that is this position's parent and its ancestors.\n\t *\n\t * @returns {Array.<module:engine/model/item~Item>} Array with ancestors.\n\t */\n\tgetAncestors() {\n\t\tif ( this.parent.is( 'documentFragment' ) ) {\n\t\t\treturn [ this.parent ];\n\t\t} else {\n\t\t\treturn this.parent.getAncestors( { includeSelf: true } );\n\t\t}\n\t}\n\n\t/**\n\t * Returns the slice of two position {@link #path paths} which is identical. The {@link #root roots}\n\t * of these two paths must be identical.\n\t *\n\t * This method is safe to use it on non-existing positions (for example during operational transformation).\n\t *\n\t * @param {module:engine/model/position~Position} position The second position.\n\t * @returns {Array.<Number>} The common path.\n\t */\n\tgetCommonPath( position ) {\n\t\tif ( this.root != position.root ) {\n\t\t\treturn [];\n\t\t}\n\n\t\t// We find on which tree-level start and end have the lowest common ancestor\n\t\tconst cmp = compareArrays( this.path, position.path );\n\t\t// If comparison returned string it means that arrays are same.\n\t\tconst diffAt = ( typeof cmp == 'string' ) ? Math.min( this.path.length, position.path.length ) : cmp;\n\n\t\treturn this.path.slice( 0, diffAt );\n\t}\n\n\t/**\n\t * Returns an {@link module:engine/model/element~Element} or {@link module:engine/model/documentfragment~DocumentFragment}\n\t * which is a common ancestor of both positions. The {@link #root roots} of these two positions must be identical.\n\t *\n\t * @param {module:engine/model/position~Position} position The second position.\n\t * @returns {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment|null}\n\t */\n\tgetCommonAncestor( position ) {\n\t\tconst ancestorsA = this.getAncestors();\n\t\tconst ancestorsB = position.getAncestors();\n\n\t\tlet i = 0;\n\n\t\twhile ( ancestorsA[ i ] == ancestorsB[ i ] && ancestorsA[ i ] ) {\n\t\t\ti++;\n\t\t}\n\n\t\treturn i === 0 ? null : ancestorsA[ i - 1 ];\n\t}\n\n\t/**\n\t * Returns a new instance of `Position`, that has same {@link #parent parent} but it's offset\n\t * is shifted by `shift` value (can be a negative value).\n\t *\n\t * This method is safe to use it on non-existing positions (for example during operational transformation).\n\t *\n\t * @param {Number} shift Offset shift. Can be a negative value.\n\t * @returns {module:engine/model/position~Position} Shifted position.\n\t */\n\tgetShiftedBy( shift ) {\n\t\tconst shifted = this.clone();\n\n\t\tconst offset = shifted.offset + shift;\n\t\tshifted.offset = offset < 0 ? 0 : offset;\n\n\t\treturn shifted;\n\t}\n\n\t/**\n\t * Checks whether this position is after given position.\n\t *\n\t * This method is safe to use it on non-existing positions (for example during operational transformation).\n\t *\n\t * @see module:engine/model/position~Position#isBefore\n\t * @param {module:engine/model/position~Position} otherPosition Position to compare with.\n\t * @returns {Boolean} True if this position is after given position.\n\t */\n\tisAfter( otherPosition ) {\n\t\treturn this.compareWith( otherPosition ) == 'after';\n\t}\n\n\t/**\n\t * Checks whether this position is before given position.\n\t *\n\t * **Note:** watch out when using negation of the value returned by this method, because the negation will also\n\t * be `true` if positions are in different roots and you might not expect this. You should probably use\n\t * `a.isAfter( b ) || a.isEqual( b )` or `!a.isBefore( p ) && a.root == b.root` in most scenarios. If your\n\t * condition uses multiple `isAfter` and `isBefore` checks, build them so they do not use negated values, i.e.:\n\t *\n\t *\t\tif ( a.isBefore( b ) && c.isAfter( d ) ) {\n\t *\t\t\t// do A.\n\t *\t\t} else {\n\t *\t\t\t// do B.\n\t *\t\t}\n\t *\n\t * or, if you have only one if-branch:\n\t *\n\t *\t\tif ( !( a.isBefore( b ) && c.isAfter( d ) ) {\n\t *\t\t\t// do B.\n\t *\t\t}\n\t *\n\t * rather than:\n\t *\n\t *\t\tif ( !a.isBefore( b ) || && !c.isAfter( d ) ) {\n\t *\t\t\t// do B.\n\t *\t\t} else {\n\t *\t\t\t// do A.\n\t *\t\t}\n\t *\n\t * This method is safe to use it on non-existing positions (for example during operational transformation).\n\t *\n\t * @param {module:engine/model/position~Position} otherPosition Position to compare with.\n\t * @returns {Boolean} True if this position is before given position.\n\t */\n\tisBefore( otherPosition ) {\n\t\treturn this.compareWith( otherPosition ) == 'before';\n\t}\n\n\t/**\n\t * Checks whether this position is equal to given position.\n\t *\n\t * This method is safe to use it on non-existing positions (for example during operational transformation).\n\t *\n\t * @param {module:engine/model/position~Position} otherPosition Position to compare with.\n\t * @returns {Boolean} True if positions are same.\n\t */\n\tisEqual( otherPosition ) {\n\t\treturn this.compareWith( otherPosition ) == 'same';\n\t}\n\n\t/**\n\t * Checks whether this position is touching given position. Positions touch when there are no text nodes\n\t * or empty nodes in a range between them. Technically, those positions are not equal but in many cases\n\t * they are very similar or even indistinguishable.\n\t *\n\t * @param {module:engine/model/position~Position} otherPosition Position to compare with.\n\t * @returns {Boolean} True if positions touch.\n\t */\n\tisTouching( otherPosition ) {\n\t\tlet left = null;\n\t\tlet right = null;\n\t\tconst compare = this.compareWith( otherPosition );\n\n\t\tswitch ( compare ) {\n\t\t\tcase 'same':\n\t\t\t\treturn true;\n\n\t\t\tcase 'before':\n\t\t\t\tleft = Position._createAt( this );\n\t\t\t\tright = Position._createAt( otherPosition );\n\t\t\t\tbreak;\n\n\t\t\tcase 'after':\n\t\t\t\tleft = Position._createAt( otherPosition );\n\t\t\t\tright = Position._createAt( this );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t}\n\n\t\t// Cached for optimization purposes.\n\t\tlet leftParent = left.parent;\n\n\t\twhile ( left.path.length + right.path.length ) {\n\t\t\tif ( left.isEqual( right ) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif ( left.path.length > right.path.length ) {\n\t\t\t\tif ( left.offset !== leftParent.maxOffset ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tleft.path = left.path.slice( 0, -1 );\n\t\t\t\tleftParent = leftParent.parent;\n\t\t\t\tleft.offset++;\n\t\t\t} else {\n\t\t\t\tif ( right.offset !== 0 ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tright.path = right.path.slice( 0, -1 );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Checks whether this object is of the given.\n\t *\n\t *\t\tposition.is( 'position' ); // -> true\n\t *\t\tposition.is( 'model:position' ); // -> true\n\t *\n\t *\t\tposition.is( 'view:position' ); // -> false\n\t *\t\tposition.is( 'documentSelection' ); // -> false\n\t *\n\t * {@link module:engine/model/node~Node#is Check the entire list of model objects} which implement the `is()` method.\n\t *\n\t * @param {String} type\n\t * @returns {Boolean}\n\t */\n\tis( type ) {\n\t\treturn type == 'position' || type == 'model:position';\n\t}\n\n\t/**\n\t * Checks if two positions are in the same parent.\n\t *\n\t * This method is safe to use it on non-existing positions (for example during operational transformation).\n\t *\n\t * @param {module:engine/model/position~Position} position Position to compare with.\n\t * @returns {Boolean} `true` if positions have the same parent, `false` otherwise.\n\t */\n\thasSameParentAs( position ) {\n\t\tif ( this.root !== position.root ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst thisParentPath = this.getParentPath();\n\t\tconst posParentPath = position.getParentPath();\n\n\t\treturn compareArrays( thisParentPath, posParentPath ) == 'same';\n\t}\n\n\t/**\n\t * Returns a copy of this position that is transformed by given `operation`.\n\t *\n\t * The new position's parameters are updated accordingly to the effect of the `operation`.\n\t *\n\t * For example, if `n` nodes are inserted before the position, the returned position {@link ~Position#offset} will be\n\t * increased by `n`. If the position was in a merged element, it will be accordingly moved to the new element, etc.\n\t *\n\t * This method is safe to use it on non-existing positions (for example during operational transformation).\n\t *\n\t * @param {module:engine/model/operation/operation~Operation} operation Operation to transform by.\n\t * @returns {module:engine/model/position~Position} Transformed position.\n\t */\n\tgetTransformedByOperation( operation ) {\n\t\tlet result;\n\n\t\tswitch ( operation.type ) {\n\t\t\tcase 'insert':\n\t\t\t\tresult = this._getTransformedByInsertOperation( operation );\n\t\t\t\tbreak;\n\t\t\tcase 'move':\n\t\t\tcase 'remove':\n\t\t\tcase 'reinsert':\n\t\t\t\tresult = this._getTransformedByMoveOperation( operation );\n\t\t\t\tbreak;\n\t\t\tcase 'split':\n\t\t\t\tresult = this._getTransformedBySplitOperation( operation );\n\t\t\t\tbreak;\n\t\t\tcase 'merge':\n\t\t\t\tresult = this._getTransformedByMergeOperation( operation );\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tresult = Position._createAt( this );\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Returns a copy of this position transformed by an insert operation.\n\t *\n\t * @protected\n\t * @param {module:engine/model/operation/insertoperation~InsertOperation} operation\n\t * @returns {module:engine/model/position~Position}\n\t */\n\t_getTransformedByInsertOperation( operation ) {\n\t\treturn this._getTransformedByInsertion( operation.position, operation.howMany );\n\t}\n\n\t/**\n\t * Returns a copy of this position transformed by a move operation.\n\t *\n\t * @protected\n\t * @param {module:engine/model/operation/moveoperation~MoveOperation} operation\n\t * @returns {module:engine/model/position~Position}\n\t */\n\t_getTransformedByMoveOperation( operation ) {\n\t\treturn this._getTransformedByMove( operation.sourcePosition, operation.targetPosition, operation.howMany );\n\t}\n\n\t/**\n\t * Returns a copy of this position transformed by a split operation.\n\t *\n\t * @protected\n\t * @param {module:engine/model/operation/splitoperation~SplitOperation} operation\n\t * @returns {module:engine/model/position~Position}\n\t */\n\t_getTransformedBySplitOperation( operation ) {\n\t\tconst movedRange = operation.movedRange;\n\n\t\tconst isContained = movedRange.containsPosition( this ) ||\n\t\t\t( movedRange.start.isEqual( this ) && this.stickiness == 'toNext' );\n\n\t\tif ( isContained ) {\n\t\t\treturn this._getCombined( operation.splitPosition, operation.moveTargetPosition );\n\t\t} else {\n\t\t\tif ( operation.graveyardPosition ) {\n\t\t\t\treturn this._getTransformedByMove( operation.graveyardPosition, operation.insertionPosition, 1 );\n\t\t\t} else {\n\t\t\t\treturn this._getTransformedByInsertion( operation.insertionPosition, 1 );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Returns a copy of this position transformed by merge operation.\n\t *\n\t * @protected\n\t * @param {module:engine/model/operation/mergeoperation~MergeOperation} operation\n\t * @returns {module:engine/model/position~Position}\n\t */\n\t_getTransformedByMergeOperation( operation ) {\n\t\tconst movedRange = operation.movedRange;\n\t\tconst isContained = movedRange.containsPosition( this ) || movedRange.start.isEqual( this );\n\n\t\tlet pos;\n\n\t\tif ( isContained ) {\n\t\t\tpos = this._getCombined( operation.sourcePosition, operation.targetPosition );\n\n\t\t\tif ( operation.sourcePosition.isBefore( operation.targetPosition ) ) {\n\t\t\t\t// Above happens during OT when the merged element is moved before the merged-to element.\n\t\t\t\tpos = pos._getTransformedByDeletion( operation.deletionPosition, 1 );\n\t\t\t}\n\t\t} else if ( this.isEqual( operation.deletionPosition ) ) {\n\t\t\tpos = Position._createAt( operation.deletionPosition );\n\t\t} else {\n\t\t\tpos = this._getTransformedByMove( operation.deletionPosition, operation.graveyardPosition, 1 );\n\t\t}\n\n\t\treturn pos;\n\t}\n\n\t/**\n\t * Returns a copy of this position that is updated by removing `howMany` nodes starting from `deletePosition`.\n\t * It may happen that this position is in a removed node. If that is the case, `null` is returned instead.\n\t *\n\t * @protected\n\t * @param {module:engine/model/position~Position} deletePosition Position before the first removed node.\n\t * @param {Number} howMany How many nodes are removed.\n\t * @returns {module:engine/model/position~Position|null} Transformed position or `null`.\n\t */\n\t_getTransformedByDeletion( deletePosition, howMany ) {\n\t\tconst transformed = Position._createAt( this );\n\n\t\t// This position can't be affected if deletion was in a different root.\n\t\tif ( this.root != deletePosition.root ) {\n\t\t\treturn transformed;\n\t\t}\n\n\t\tif ( compareArrays( deletePosition.getParentPath(), this.getParentPath() ) == 'same' ) {\n\t\t\t// If nodes are removed from the node that is pointed by this position...\n\t\t\tif ( deletePosition.offset < this.offset ) {\n\t\t\t\t// And are removed from before an offset of that position...\n\t\t\t\tif ( deletePosition.offset + howMany > this.offset ) {\n\t\t\t\t\t// Position is in removed range, it's no longer in the tree.\n\t\t\t\t\treturn null;\n\t\t\t\t} else {\n\t\t\t\t\t// Decrement the offset accordingly.\n\t\t\t\t\ttransformed.offset -= howMany;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if ( compareArrays( deletePosition.getParentPath(), this.getParentPath() ) == 'prefix' ) {\n\t\t\t// If nodes are removed from a node that is on a path to this position...\n\t\t\tconst i = deletePosition.path.length - 1;\n\n\t\t\tif ( deletePosition.offset <= this.path[ i ] ) {\n\t\t\t\t// And are removed from before next node of that path...\n\t\t\t\tif ( deletePosition.offset + howMany > this.path[ i ] ) {\n\t\t\t\t\t// If the next node of that path is removed return null\n\t\t\t\t\t// because the node containing this position got removed.\n\t\t\t\t\treturn null;\n\t\t\t\t} else {\n\t\t\t\t\t// Otherwise, decrement index on that path.\n\t\t\t\t\ttransformed.path[ i ] -= howMany;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn transformed;\n\t}\n\n\t/**\n\t * Returns a copy of this position that is updated by inserting `howMany` nodes at `insertPosition`.\n\t *\n\t * @protected\n\t * @param {module:engine/model/position~Position} insertPosition Position where nodes are inserted.\n\t * @param {Number} howMany How many nodes are inserted.\n\t * @returns {module:engine/model/position~Position} Transformed position.\n\t */\n\t_getTransformedByInsertion( insertPosition, howMany ) {\n\t\tconst transformed = Position._createAt( this );\n\n\t\t// This position can't be affected if insertion was in a different root.\n\t\tif ( this.root != insertPosition.root ) {\n\t\t\treturn transformed;\n\t\t}\n\n\t\tif ( compareArrays( insertPosition.getParentPath(), this.getParentPath() ) == 'same' ) {\n\t\t\t// If nodes are inserted in the node that is pointed by this position...\n\t\t\tif ( insertPosition.offset < this.offset || ( insertPosition.offset == this.offset && this.stickiness != 'toPrevious' ) ) {\n\t\t\t\t// And are inserted before an offset of that position...\n\t\t\t\t// \"Push\" this positions offset.\n\t\t\t\ttransformed.offset += howMany;\n\t\t\t}\n\t\t} else if ( compareArrays( insertPosition.getParentPath(), this.getParentPath() ) == 'prefix' ) {\n\t\t\t// If nodes are inserted in a node that is on a path to this position...\n\t\t\tconst i = insertPosition.path.length - 1;\n\n\t\t\tif ( insertPosition.offset <= this.path[ i ] ) {\n\t\t\t\t// And are inserted before next node of that path...\n\t\t\t\t// \"Push\" the index on that path.\n\t\t\t\ttransformed.path[ i ] += howMany;\n\t\t\t}\n\t\t}\n\n\t\treturn transformed;\n\t}\n\n\t/**\n\t * Returns a copy of this position that is updated by moving `howMany` nodes from `sourcePosition` to `targetPosition`.\n\t *\n\t * @protected\n\t * @param {module:engine/model/position~Position} sourcePosition Position before the first element to move.\n\t * @param {module:engine/model/position~Position} targetPosition Position where moved elements will be inserted.\n\t * @param {Number} howMany How many consecutive nodes to move, starting from `sourcePosition`.\n\t * @returns {module:engine/model/position~Position} Transformed position.\n\t */\n\t_getTransformedByMove( sourcePosition, targetPosition, howMany ) {\n\t\t// Update target position, as it could be affected by nodes removal.\n\t\ttargetPosition = targetPosition._getTransformedByDeletion( sourcePosition, howMany );\n\n\t\tif ( sourcePosition.isEqual( targetPosition ) ) {\n\t\t\t// If `targetPosition` is equal to `sourcePosition` this isn't really any move. Just return position as it is.\n\t\t\treturn Position._createAt( this );\n\t\t}\n\n\t\t// Moving a range removes nodes from their original position. We acknowledge this by proper transformation.\n\t\tconst transformed = this._getTransformedByDeletion( sourcePosition, howMany );\n\n\t\tconst isMoved = transformed === null ||\n\t\t\t( sourcePosition.isEqual( this ) && this.stickiness == 'toNext' ) ||\n\t\t\t( sourcePosition.getShiftedBy( howMany ).isEqual( this ) && this.stickiness == 'toPrevious' );\n\n\t\tif ( isMoved ) {\n\t\t\t// This position is inside moved range (or sticks to it).\n\t\t\t// In this case, we calculate a combination of this position, move source position and target position.\n\t\t\treturn this._getCombined( sourcePosition, targetPosition );\n\t\t} else {\n\t\t\t// This position is not inside a removed range.\n\t\t\t//\n\t\t\t// In next step, we simply reflect inserting `howMany` nodes, which might further affect the position.\n\t\t\treturn transformed._getTransformedByInsertion( targetPosition, howMany );\n\t\t}\n\t}\n\n\t/**\n\t * Returns a new position that is a combination of this position and given positions.\n\t *\n\t * The combined position is a copy of this position transformed by moving a range starting at `source` position\n\t * to the `target` position. It is expected that this position is inside the moved range.\n\t *\n\t * Example:\n\t *\n\t *\t\tlet original = model.createPositionFromPath( root, [ 2, 3, 1 ] );\n\t *\t\tlet source = model.createPositionFromPath( root, [ 2, 2 ] );\n\t *\t\tlet target = model.createPositionFromPath( otherRoot, [ 1, 1, 3 ] );\n\t *\t\toriginal._getCombined( source, target ); // path is [ 1, 1, 4, 1 ], root is `otherRoot`\n\t *\n\t * Explanation:\n\t *\n\t * We have a position `[ 2, 3, 1 ]` and move some nodes from `[ 2, 2 ]` to `[ 1, 1, 3 ]`. The original position\n\t * was inside moved nodes and now should point to the new place. The moved nodes will be after\n\t * positions `[ 1, 1, 3 ]`, `[ 1, 1, 4 ]`, `[ 1, 1, 5 ]`. Since our position was in the second moved node,\n\t * the transformed position will be in a sub-tree of a node at `[ 1, 1, 4 ]`. Looking at original path, we\n\t * took care of `[ 2, 3 ]` part of it. Now we have to add the rest of the original path to the transformed path.\n\t * Finally, the transformed position will point to `[ 1, 1, 4, 1 ]`.\n\t *\n\t * @protected\n\t * @param {module:engine/model/position~Position} source Beginning of the moved range.\n\t * @param {module:engine/model/position~Position} target Position where the range is moved.\n\t * @returns {module:engine/model/position~Position} Combined position.\n\t */\n\t_getCombined( source, target ) {\n\t\tconst i = source.path.length - 1;\n\n\t\t// The first part of a path to combined position is a path to the place where nodes were moved.\n\t\tconst combined = Position._createAt( target );\n\t\tcombined.stickiness = this.stickiness;\n\n\t\t// Then we have to update the rest of the path.\n\n\t\t// Fix the offset because this position might be after `from` position and we have to reflect that.\n\t\tcombined.offset = combined.offset + this.path[ i ] - source.offset;\n\n\t\t// Then, add the rest of the path.\n\t\t// If this position is at the same level as `from` position nothing will get added.\n\t\tcombined.path = combined.path.concat( this.path.slice( i + 1 ) );\n\n\t\treturn combined;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\ttoJSON() {\n\t\treturn {\n\t\t\troot: this.root.toJSON(),\n\t\t\tpath: Array.from( this.path ),\n\t\t\tstickiness: this.stickiness\n\t\t};\n\t}\n\n\t/**\n\t * Returns a new position that is equal to current position.\n\t *\n\t * @returns {module:engine/model/position~Position}\n\t */\n\tclone() {\n\t\treturn new this.constructor( this.root, this.path, this.stickiness );\n\t}\n\n\t/**\n\t * Creates position at the given location. The location can be specified as:\n\t *\n\t * * a {@link module:engine/model/position~Position position},\n\t * * parent element and offset (offset defaults to `0`),\n\t * * parent element and `'end'` (sets position at the end of that element),\n\t * * {@link module:engine/model/item~Item model item} and `'before'` or `'after'` (sets position before or after given model item).\n\t *\n\t * This method is a shortcut to other factory methods such as:\n\t *\n\t * * {@link module:engine/model/position~Position._createBefore},\n\t * * {@link module:engine/model/position~Position._createAfter}.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n\t * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when the\n\t * first parameter is a {@link module:engine/model/item~Item model item}.\n\t * @param {module:engine/model/position~PositionStickiness} [stickiness='toNone'] Position stickiness. Used only when the\n\t * first parameter is a {@link module:engine/model/item~Item model item}.\n\t * @protected\n\t */\n\tstatic _createAt( itemOrPosition, offset, stickiness = 'toNone' ) {\n\t\tif ( itemOrPosition instanceof Position ) {\n\t\t\treturn new Position( itemOrPosition.root, itemOrPosition.path, itemOrPosition.stickiness );\n\t\t} else {\n\t\t\tconst node = itemOrPosition;\n\n\t\t\tif ( offset == 'end' ) {\n\t\t\t\toffset = node.maxOffset;\n\t\t\t} else if ( offset == 'before' ) {\n\t\t\t\treturn this._createBefore( node, stickiness );\n\t\t\t} else if ( offset == 'after' ) {\n\t\t\t\treturn this._createAfter( node, stickiness );\n\t\t\t} else if ( offset !== 0 && !offset ) {\n\t\t\t\t/**\n\t\t\t\t * {@link module:engine/model/model~Model#createPositionAt `Model#createPositionAt()`}\n\t\t\t\t * requires the offset to be specified when the first parameter is a model item.\n\t\t\t\t *\n\t\t\t\t * @error model-createPositionAt-offset-required\n\t\t\t\t */\n\t\t\t\tthrow new CKEditorError(\n\t\t\t\t\t'model-createPositionAt-offset-required: ' +\n\t\t\t\t\t'Model#createPositionAt() requires the offset when the first parameter is a model item.',\n\t\t\t\t\t[ this, itemOrPosition ]\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif ( !node.is( 'element' ) && !node.is( 'documentFragment' ) ) {\n\t\t\t\t/**\n\t\t\t\t * Position parent have to be a model element or model document fragment.\n\t\t\t\t *\n\t\t\t\t * @error model-position-parent-incorrect\n\t\t\t\t */\n\t\t\t\tthrow new CKEditorError(\n\t\t\t\t\t'model-position-parent-incorrect: Position parent have to be a element or document fragment.',\n\t\t\t\t\t[ this, itemOrPosition ]\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconst path = node.getPath();\n\n\t\t\tpath.push( offset );\n\n\t\t\treturn new this( node.root, path, stickiness );\n\t\t}\n\t}\n\n\t/**\n\t * Creates a new position, after given {@link module:engine/model/item~Item model item}.\n\t *\n\t * @param {module:engine/model/item~Item} item Item after which the position should be placed.\n\t * @param {module:engine/model/position~PositionStickiness} [stickiness='toNone'] Position stickiness.\n\t * @returns {module:engine/model/position~Position}\n\t * @protected\n\t */\n\tstatic _createAfter( item, stickiness ) {\n\t\tif ( !item.parent ) {\n\t\t\t/**\n\t\t\t * You can not make a position after a root element.\n\t\t\t *\n\t\t\t * @error model-position-after-root\n\t\t\t * @param {module:engine/model/item~Item} root\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'model-position-after-root: You cannot make a position after root.',\n\t\t\t\t[ this, item ],\n\t\t\t\t{ root: item }\n\t\t\t);\n\t\t}\n\n\t\treturn this._createAt( item.parent, item.endOffset, stickiness );\n\t}\n\n\t/**\n\t * Creates a new position, before the given {@link module:engine/model/item~Item model item}.\n\t *\n\t * @param {module:engine/model/item~Item} item Item before which the position should be placed.\n\t * @param {module:engine/model/position~PositionStickiness} [stickiness='toNone'] Position stickiness.\n\t * @returns {module:engine/model/position~Position}\n\t * @protected\n\t */\n\tstatic _createBefore( item, stickiness ) {\n\t\tif ( !item.parent ) {\n\t\t\t/**\n\t\t\t * You can not make a position before a root element.\n\t\t\t *\n\t\t\t * @error model-position-before-root\n\t\t\t * @param {module:engine/model/item~Item} root\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'model-position-before-root: You cannot make a position before root.',\n\t\t\t\titem,\n\t\t\t\t{ root: item }\n\t\t\t);\n\t\t}\n\n\t\treturn this._createAt( item.parent, item.startOffset, stickiness );\n\t}\n\n\t/**\n\t * Creates a `Position` instance from given plain object (i.e. parsed JSON string).\n\t *\n\t * @param {Object} json Plain object to be converted to `Position`.\n\t * @param {module:engine/model/document~Document} doc Document object that will be position owner.\n\t * @returns {module:engine/model/position~Position} `Position` instance created using given plain object.\n\t */\n\tstatic fromJSON( json, doc ) {\n\t\tif ( json.root === '$graveyard' ) {\n\t\t\tconst pos = new Position( doc.graveyard, json.path );\n\t\t\tpos.stickiness = json.stickiness;\n\n\t\t\treturn pos;\n\t\t}\n\n\t\tif ( !doc.getRoot( json.root ) ) {\n\t\t\t/**\n\t\t\t * Cannot create position for document. Root with specified name does not exist.\n\t\t\t *\n\t\t\t * @error model-position-fromjson-no-root\n\t\t\t * @param {String} rootName\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'model-position-fromjson-no-root: Cannot create position for document. Root with specified name does not exist.',\n\t\t\t\tdoc,\n\t\t\t\t{ rootName: json.root }\n\t\t\t);\n\t\t}\n\n\t\treturn new Position( doc.getRoot( json.root ), json.path, json.stickiness );\n\t}\n\n\t// @if CK_DEBUG_ENGINE // toString() {\n\t// @if CK_DEBUG_ENGINE // \treturn `${ this.root } [ ${ this.path.join( ', ' ) } ]`;\n\t// @if CK_DEBUG_ENGINE // }\n\n\t// @if CK_DEBUG_ENGINE // log() {\n\t// @if CK_DEBUG_ENGINE // \tconsole.log( 'ModelPosition: ' + this );\n\t// @if CK_DEBUG_ENGINE // }\n}\n\n/**\n * A flag indicating whether this position is `'before'` or `'after'` or `'same'` as given position.\n * If positions are in different roots `'different'` flag is returned.\n *\n * @typedef {String} module:engine/model/position~PositionRelation\n */\n\n/**\n * Represents how position is \"sticking\" with neighbour nodes. Used to define how position should be transformed (moved)\n * in edge cases. Possible values: `'toNone'`, `'toNext'`, `'toPrevious'`.\n *\n * Examples:\n *\n *\t\tInsert. Position is at | and nodes are inserted at the same position, marked as ^:\n *\n *\t\t- sticks to none:           <p>f^|oo</p>  ->  <p>fbar|oo</p>\n *\t\t- sticks to next node:      <p>f^|oo</p>  ->  <p>fbar|oo</p>\n *\t\t- sticks to previous node:  <p>f|^oo</p>  ->  <p>f|baroo</p>\n *\n *\n *\t\tMove. Position is at | and range [oo] is moved to position ^:\n *\n *\t\t- sticks to none:           <p>f|[oo]</p><p>b^ar</p>  ->  <p>f|</p><p>booar</p>\n *\t\t- sticks to none:           <p>f[oo]|</p><p>b^ar</p>  ->  <p>f|</p><p>booar</p>\n *\n *\t\t- sticks to next node:      <p>f|[oo]</p><p>b^ar</p>  ->  <p>f</p><p>b|ooar</p>\n *\t\t- sticks to next node:      <p>f[oo]|</p><p>b^ar</p>  ->  <p>f|</p><p>booar</p>\n *\n *\t\t- sticks to previous node:  <p>f|[oo]</p><p>b^ar</p>  ->  <p>f|</p><p>booar</p>\n *\t\t- sticks to previous node:  <p>f[oo]|</p><p>b^ar</p>  ->  <p>f</p><p>boo|ar</p>\n *\n * @typedef {String} module:engine/model/position~PositionStickiness\n */\n"]}]}