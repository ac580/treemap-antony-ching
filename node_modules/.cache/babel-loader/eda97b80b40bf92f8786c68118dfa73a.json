{"remainingRequest":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/babel-loader/lib/index.js!/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-engine/src/conversion/upcasthelpers.js","dependencies":[{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-engine/src/conversion/upcasthelpers.js","mtime":499162500000},{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js","mtime":499162500000},{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/babel-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:LyoqCiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDE5LCBDS1NvdXJjZSAtIEZyZWRlcmljbyBLbmFiYmVuLiBBbGwgcmlnaHRzIHJlc2VydmVkLgogKiBGb3IgbGljZW5zaW5nLCBzZWUgTElDRU5TRS5tZCBvciBodHRwczovL2NrZWRpdG9yLmNvbS9sZWdhbC9ja2VkaXRvci1vc3MtbGljZW5zZQogKi8KaW1wb3J0IE1hdGNoZXIgZnJvbSAnLi4vdmlldy9tYXRjaGVyJzsKaW1wb3J0IE1vZGVsUmFuZ2UgZnJvbSAnLi4vbW9kZWwvcmFuZ2UnOwppbXBvcnQgQ29udmVyc2lvbkhlbHBlcnMgZnJvbSAnLi9jb252ZXJzaW9uaGVscGVycyc7CmltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaC1lcyc7CmltcG9ydCBNb2RlbFNlbGVjdGlvbiBmcm9tICcuLi9tb2RlbC9zZWxlY3Rpb24nOwovKioKICogQ29udGFpbnMge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy92aWV3IHZpZXd9IHRvIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL21vZGVsIG1vZGVsfSBjb252ZXJ0ZXJzIGZvcgogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL3VwY2FzdGRpc3BhdGNoZXJ+VXBjYXN0RGlzcGF0Y2hlcn0uCiAqCiAqIEBtb2R1bGUgZW5naW5lL2NvbnZlcnNpb24vdXBjYXN0aGVscGVycwogKi8KCi8qKgogKiBVcGNhc3QgY29udmVyc2lvbiBoZWxwZXIgZnVuY3Rpb25zLgogKgogKiBAZXh0ZW5kcyBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vY29udmVyc2lvbmhlbHBlcnN+Q29udmVyc2lvbkhlbHBlcnMKICovCgpleHBvcnQgZGVmYXVsdCBjbGFzcyBVcGNhc3RIZWxwZXJzIGV4dGVuZHMgQ29udmVyc2lvbkhlbHBlcnMgewogIC8qKgogICAqIFZpZXcgZWxlbWVudCB0byBtb2RlbCBlbGVtZW50IGNvbnZlcnNpb24gaGVscGVyLgogICAqCiAgICogVGhpcyBjb252ZXJzaW9uIHJlc3VsdHMgaW4gY3JlYXRpbmcgYSBtb2RlbCBlbGVtZW50LiBGb3IgZXhhbXBsZSwKICAgKiB2aWV3IGA8cD5Gb288L3A+YCBiZWNvbWVzIGA8cGFyYWdyYXBoPkZvbzwvcGFyYWdyYXBoPmAgaW4gdGhlIG1vZGVsLgogICAqCiAgICogS2VlcCBpbiBtaW5kIHRoYXQgdGhlIGVsZW1lbnQgd2lsbCBiZSBpbnNlcnRlZCBvbmx5IGlmIGl0IGlzIGFsbG93ZWQKICAgKiBieSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hIHNjaGVtYX0gY29uZmlndXJhdGlvbi4KICAgKgogICAqCQllZGl0b3IuY29udmVyc2lvbi5mb3IoICd1cGNhc3QnICkuZWxlbWVudFRvRWxlbWVudCggewogICAqCQkJdmlldzogJ3AnLAogICAqCQkJbW9kZWw6ICdwYXJhZ3JhcGgnCiAgICoJCX0gKTsKICAgKgogICAqCQllZGl0b3IuY29udmVyc2lvbi5mb3IoICd1cGNhc3QnICkuZWxlbWVudFRvRWxlbWVudCggewogICAqCQkJdmlldzogJ3AnLAogICAqCQkJbW9kZWw6ICdwYXJhZ3JhcGgnLAogICAqCQkJY29udmVydGVyUHJpb3JpdHk6ICdoaWdoJwogICAqCQl9ICk7CiAgICoKICAgKgkJZWRpdG9yLmNvbnZlcnNpb24uZm9yKCAndXBjYXN0JyApLmVsZW1lbnRUb0VsZW1lbnQoIHsKICAgKgkJCXZpZXc6IHsKICAgKgkJCQluYW1lOiAncCcsCiAgICoJCQkJY2xhc3NlczogJ2ZhbmN5JwogICAqCQkJfSwKICAgKgkJCW1vZGVsOiAnZmFuY3lQYXJhZ3JhcGgnCiAgICoJCX0gKTsKICAgKgogICAqCQllZGl0b3IuY29udmVyc2lvbi5mb3IoICd1cGNhc3QnICkuZWxlbWVudFRvRWxlbWVudCggewogICAqIAkJCXZpZXc6IHsKICAgKgkJCQluYW1lOiAncCcsCiAgICoJCQkJY2xhc3NlczogJ2hlYWRpbmcnCiAgICogCQkJfSwKICAgKiAJCQltb2RlbDogKCB2aWV3RWxlbWVudCwgbW9kZWxXcml0ZXIgKSA9PiB7CiAgICogCQkJCXJldHVybiBtb2RlbFdyaXRlci5jcmVhdGVFbGVtZW50KCAnaGVhZGluZycsIHsgbGV2ZWw6IHZpZXdFbGVtZW50LmdldEF0dHJpYnV0ZSggJ2RhdGEtbGV2ZWwnICkgfSApOwogICAqIAkJCX0KICAgKiAJCX0gKTsKICAgKgogICAqIFNlZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL2NvbnZlcnNpb25+Q29udmVyc2lvbiNmb3IgYGNvbnZlcnNpb24uZm9yKClgfSB0byBsZWFybiBob3cgdG8gYWRkIGEgY29udmVydGVyCiAgICogdG8gdGhlIGNvbnZlcnNpb24gcHJvY2Vzcy4KICAgKgogICAqIEBtZXRob2QgI2VsZW1lbnRUb0VsZW1lbnQKICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIENvbnZlcnNpb24gY29uZmlndXJhdGlvbi4KICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9tYXRjaGVyfk1hdGNoZXJQYXR0ZXJufSBbY29uZmlnLnZpZXddIFBhdHRlcm4gbWF0Y2hpbmcgYWxsIHZpZXcgZWxlbWVudHMgd2hpY2ggc2hvdWxkIGJlIGNvbnZlcnRlZC4gSWYgbm90CiAgICogc2V0LCB0aGUgY29udmVydGVyIHdpbGwgZmlyZSBmb3IgZXZlcnkgdmlldyBlbGVtZW50LgogICAqIEBwYXJhbSB7U3RyaW5nfG1vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50fEZ1bmN0aW9ufSBjb25maWcubW9kZWwgTmFtZSBvZiB0aGUgbW9kZWwgZWxlbWVudCwgYSBtb2RlbCBlbGVtZW50CiAgICogaW5zdGFuY2Ugb3IgYSBmdW5jdGlvbiB0aGF0IHRha2VzIGEgdmlldyBlbGVtZW50IGFuZCByZXR1cm5zIGEgbW9kZWwgZWxlbWVudC4gVGhlIG1vZGVsIGVsZW1lbnQgd2lsbCBiZSBpbnNlcnRlZCBpbiB0aGUgbW9kZWwuCiAgICogQHBhcmFtIHttb2R1bGU6dXRpbHMvcHJpb3JpdGllc35Qcmlvcml0eVN0cmluZ30gW2NvbmZpZy5jb252ZXJ0ZXJQcmlvcml0eT0nbm9ybWFsJ10gQ29udmVydGVyIHByaW9yaXR5LgogICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vdXBjYXN0aGVscGVyc35VcGNhc3RIZWxwZXJzfQogICAqLwogIGVsZW1lbnRUb0VsZW1lbnQoY29uZmlnKSB7CiAgICByZXR1cm4gdGhpcy5hZGQodXBjYXN0RWxlbWVudFRvRWxlbWVudChjb25maWcpKTsKICB9CiAgLyoqCiAgICogVmlldyBlbGVtZW50IHRvIG1vZGVsIGF0dHJpYnV0ZSBjb252ZXJzaW9uIGhlbHBlci4KICAgKgogICAqIFRoaXMgY29udmVyc2lvbiByZXN1bHRzIGluIHNldHRpbmcgYW4gYXR0cmlidXRlIG9uIGEgbW9kZWwgbm9kZS4gRm9yIGV4YW1wbGUsIHZpZXcgYDxzdHJvbmc+Rm9vPC9zdHJvbmc+YCBiZWNvbWVzCiAgICogYEZvb2Age0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvdGV4dH5UZXh0IG1vZGVsIHRleHQgbm9kZX0gd2l0aCBgYm9sZGAgYXR0cmlidXRlIHNldCB0byBgdHJ1ZWAuCiAgICoKICAgKiBUaGlzIGhlbHBlciBpcyBtZWFudCB0byBzZXQgYSBtb2RlbCBhdHRyaWJ1dGUgb24gYWxsIHRoZSBlbGVtZW50cyB0aGF0IGFyZSBpbnNpZGUgdGhlIGNvbnZlcnRlZCBlbGVtZW50OgogICAqCiAgICoJCTxzdHJvbmc+Rm9vPC9zdHJvbmc+ICAgLS0+ICAgPHN0cm9uZz48cD5Gb288L3A+PC9zdHJvbmc+ICAgLS0+ICAgPHBhcmFncmFwaD48JHRleHQgYm9sZD0idHJ1ZSI+Rm9vPC8kdGV4dD48L3BhcmFncmFwaD4KICAgKgogICAqIEFib3ZlIGlzIGEgc2FtcGxlIG9mIEhUTUwgY29kZSwgdGhhdCBnb2VzIHRocm91Z2ggYXV0b3BhcmFncmFwaGluZyAoZmlyc3Qgc3RlcCkgYW5kIHRoZW4gaXMgY29udmVydGVkIChzZWNvbmQgc3RlcCkuCiAgICogRXZlbiB0aG91Z2ggYDxzdHJvbmc+YCBpcyBvdmVyIGA8cD5gIGVsZW1lbnQsIGBib2xkPSJ0cnVlImAgd2FzIGFkZGVkIHRvIHRoZSB0ZXh0LiBTZWUKICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL3VwY2FzdGhlbHBlcnN+VXBjYXN0SGVscGVycyNhdHRyaWJ1dGVUb0F0dHJpYnV0ZX0gZm9yIGNvbXBhcmlzb24uCiAgICoKICAgKiBLZWVwIGluIG1pbmQgdGhhdCB0aGUgYXR0cmlidXRlIHdpbGwgYmUgc2V0IG9ubHkgaWYgaXQgaXMgYWxsb3dlZCBieSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hIHNjaGVtYX0gY29uZmlndXJhdGlvbi4KICAgKgogICAqCQllZGl0b3IuY29udmVyc2lvbi5mb3IoICd1cGNhc3QnICkuZWxlbWVudFRvQXR0cmlidXRlKCB7CiAgICoJCQl2aWV3OiAnc3Ryb25nJywKICAgKgkJCW1vZGVsOiAnYm9sZCcKICAgKgkJfSApOwogICAqCiAgICoJCWVkaXRvci5jb252ZXJzaW9uLmZvciggJ3VwY2FzdCcgKS5lbGVtZW50VG9BdHRyaWJ1dGUoIHsKICAgKgkJCXZpZXc6ICdzdHJvbmcnLAogICAqCQkJbW9kZWw6ICdib2xkJywKICAgKgkJCWNvbnZlcnRlclByaW9yaXR5OiAnaGlnaCcKICAgKgkJfSApOwogICAqCiAgICoJCWVkaXRvci5jb252ZXJzaW9uLmZvciggJ3VwY2FzdCcgKS5lbGVtZW50VG9BdHRyaWJ1dGUoIHsKICAgKgkJCXZpZXc6IHsKICAgKgkJCQluYW1lOiAnc3BhbicsCiAgICoJCQkJY2xhc3NlczogJ2JvbGQnCiAgICoJCQl9LAogICAqCQkJbW9kZWw6ICdib2xkJwogICAqCQl9ICk7CiAgICoKICAgKgkJZWRpdG9yLmNvbnZlcnNpb24uZm9yKCAndXBjYXN0JyApLmVsZW1lbnRUb0F0dHJpYnV0ZSggewogICAqCQkJdmlldzogewogICAqCQkJCW5hbWU6ICdzcGFuJywKICAgKgkJCQljbGFzc2VzOiBbICdzdHlsZWQnLCAnc3R5bGVkLWRhcmsnIF0KICAgKgkJCX0sCiAgICoJCQltb2RlbDogewogICAqCQkJCWtleTogJ3N0eWxlZCcsCiAgICoJCQkJdmFsdWU6ICdkYXJrJwogICAqCQkJfQogICAqCQl9ICk7CiAgICoKICAgKiAJCWVkaXRvci5jb252ZXJzaW9uLmZvciggJ3VwY2FzdCcgKS5lbGVtZW50VG9BdHRyaWJ1dGUoIHsKICAgKgkJCXZpZXc6IHsKICAgKgkJCQluYW1lOiAnc3BhbicsCiAgICoJCQkJc3R5bGVzOiB7CiAgICoJCQkJCSdmb250LXNpemUnOiAvW1xzXFNdKy8KICAgKgkJCQl9CiAgICoJCQl9LAogICAqCQkJbW9kZWw6IHsKICAgKgkJCQlrZXk6ICdmb250U2l6ZScsCiAgICoJCQkJdmFsdWU6IHZpZXdFbGVtZW50ID0+IHsKICAgKgkJCQkJY29uc3QgZm9udFNpemUgPSB2aWV3RWxlbWVudC5nZXRTdHlsZSggJ2ZvbnQtc2l6ZScgKTsKICAgKgkJCQkJY29uc3QgdmFsdWUgPSBmb250U2l6ZS5zdWJzdHIoIDAsIGZvbnRTaXplLmxlbmd0aCAtIDIgKTsKICAgKgogICAqCQkJCQlpZiAoIHZhbHVlIDw9IDEwICkgewogICAqCQkJCQkJcmV0dXJuICdzbWFsbCc7CiAgICoJCQkJCX0gZWxzZSBpZiAoIHZhbHVlID4gMTIgKSB7CiAgICoJCQkJCQlyZXR1cm4gJ2JpZyc7CiAgICoJCQkJCX0KICAgKgogICAqCQkJCQlyZXR1cm4gbnVsbDsKICAgKgkJCQl9CiAgICoJCQl9CiAgICoJCX0gKTsKICAgKgogICAqIFNlZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL2NvbnZlcnNpb25+Q29udmVyc2lvbiNmb3IgYGNvbnZlcnNpb24uZm9yKClgfSB0byBsZWFybiBob3cgdG8gYWRkIGEgY29udmVydGVyCiAgICogdG8gdGhlIGNvbnZlcnNpb24gcHJvY2Vzcy4KICAgKgogICAqIEBtZXRob2QgI2VsZW1lbnRUb0F0dHJpYnV0ZQogICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgQ29udmVyc2lvbiBjb25maWd1cmF0aW9uLgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L21hdGNoZXJ+TWF0Y2hlclBhdHRlcm59IGNvbmZpZy52aWV3IFBhdHRlcm4gbWF0Y2hpbmcgYWxsIHZpZXcgZWxlbWVudHMgd2hpY2ggc2hvdWxkIGJlIGNvbnZlcnRlZC4KICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGNvbmZpZy5tb2RlbCBNb2RlbCBhdHRyaWJ1dGUga2V5IG9yIGFuIG9iamVjdCB3aXRoIGBrZXlgIGFuZCBgdmFsdWVgIHByb3BlcnRpZXMsIGRlc2NyaWJpbmcKICAgKiB0aGUgbW9kZWwgYXR0cmlidXRlLiBgdmFsdWVgIHByb3BlcnR5IG1heSBiZSBzZXQgYXMgYSBmdW5jdGlvbiB0aGF0IHRha2VzIGEgdmlldyBlbGVtZW50IGFuZCByZXR1cm5zIHRoZSB2YWx1ZS4KICAgKiBJZiBgU3RyaW5nYCBpcyBnaXZlbiwgdGhlIG1vZGVsIGF0dHJpYnV0ZSB2YWx1ZSB3aWxsIGJlIHNldCB0byBgdHJ1ZWAuCiAgICogQHBhcmFtIHttb2R1bGU6dXRpbHMvcHJpb3JpdGllc35Qcmlvcml0eVN0cmluZ30gW2NvbmZpZy5jb252ZXJ0ZXJQcmlvcml0eT0nbG93J10gQ29udmVydGVyIHByaW9yaXR5LgogICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vdXBjYXN0aGVscGVyc35VcGNhc3RIZWxwZXJzfQogICAqLwoKCiAgZWxlbWVudFRvQXR0cmlidXRlKGNvbmZpZykgewogICAgcmV0dXJuIHRoaXMuYWRkKHVwY2FzdEVsZW1lbnRUb0F0dHJpYnV0ZShjb25maWcpKTsKICB9CiAgLyoqCiAgICogVmlldyBhdHRyaWJ1dGUgdG8gbW9kZWwgYXR0cmlidXRlIGNvbnZlcnNpb24gaGVscGVyLgogICAqCiAgICogVGhpcyBjb252ZXJzaW9uIHJlc3VsdHMgaW4gc2V0dGluZyBhbiBhdHRyaWJ1dGUgb24gYSBtb2RlbCBub2RlLiBGb3IgZXhhbXBsZSwgdmlldyBgPGltZyBzcmM9ImZvby5qcGciPjwvaW1nPmAgYmVjb21lcwogICAqIGA8aW1hZ2Ugc291cmNlPSJmb28uanBnIj48L2ltYWdlPmAgaW4gdGhlIG1vZGVsLgogICAqCiAgICogVGhpcyBoZWxwZXIgaXMgbWVhbnQgdG8gY29udmVydCB2aWV3IGF0dHJpYnV0ZXMgZnJvbSB2aWV3IGVsZW1lbnRzIHdoaWNoIGdvdCBjb252ZXJ0ZWQgdG8gdGhlIG1vZGVsLCBzbyB0aGUgdmlldyBhdHRyaWJ1dGUKICAgKiBpcyBzZXQgb25seSBvbiB0aGUgY29ycmVzcG9uZGluZyBtb2RlbCBub2RlOgogICAqCiAgICoJCTxkaXYgY2xhc3M9ImRhcmsiPjxkaXY+Zm9vPC9kaXY+PC9kaXY+ICAgIC0tPiAgICA8ZGl2IGRhcms9InRydWUiPjxkaXY+Zm9vPC9kaXY+PC9kaXY+CiAgICoKICAgKiBBYm92ZSwgYGNsYXNzPSJkYXJrImAgYXR0cmlidXRlIGlzIGFkZGVkIG9ubHkgdG8gdGhlIGA8ZGl2PmAgZWxlbWVudHMgdGhhdCBoYXMgaXQuIFRoaXMgaXMgaW4gY29udHJhcnkgdG8KICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL3VwY2FzdGhlbHBlcnN+VXBjYXN0SGVscGVycyNlbGVtZW50VG9BdHRyaWJ1dGV9IHdoaWNoIHNldHMgYXR0cmlidXRlcyBmb3IKICAgKiBhbGwgdGhlIGNoaWxkcmVuIGluIHRoZSBtb2RlbDoKICAgKgogICAqCQk8c3Ryb25nPkZvbzwvc3Ryb25nPiAgIC0tPiAgIDxzdHJvbmc+PHA+Rm9vPC9wPjwvc3Ryb25nPiAgIC0tPiAgIDxwYXJhZ3JhcGg+PCR0ZXh0IGJvbGQ9InRydWUiPkZvbzwvJHRleHQ+PC9wYXJhZ3JhcGg+CiAgICoKICAgKiBBYm92ZSBpcyBhIHNhbXBsZSBvZiBIVE1MIGNvZGUsIHRoYXQgZ29lcyB0aHJvdWdoIGF1dG9wYXJhZ3JhcGhpbmcgKGZpcnN0IHN0ZXApIGFuZCB0aGVuIGlzIGNvbnZlcnRlZCAoc2Vjb25kIHN0ZXApLgogICAqIEV2ZW4gdGhvdWdoIGA8c3Ryb25nPmAgaXMgb3ZlciBgPHA+YCBlbGVtZW50LCBgYm9sZD0idHJ1ZSJgIHdhcyBhZGRlZCB0byB0aGUgdGV4dC4KICAgKgogICAqIEtlZXAgaW4gbWluZCB0aGF0IHRoZSBhdHRyaWJ1dGUgd2lsbCBiZSBzZXQgb25seSBpZiBpdCBpcyBhbGxvd2VkIGJ5IHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWEgc2NoZW1hfSBjb25maWd1cmF0aW9uLgogICAqCiAgICoJCWVkaXRvci5jb252ZXJzaW9uLmZvciggJ3VwY2FzdCcgKS5hdHRyaWJ1dGVUb0F0dHJpYnV0ZSggewogICAqCQkJdmlldzogJ3NyYycsCiAgICoJCQltb2RlbDogJ3NvdXJjZScKICAgKgkJfSApOwogICAqCiAgICoJCWVkaXRvci5jb252ZXJzaW9uLmZvciggJ3VwY2FzdCcgKS5hdHRyaWJ1dGVUb0F0dHJpYnV0ZSggewogICAqCQkJdmlldzogeyBrZXk6ICdzcmMnIH0sCiAgICoJCQltb2RlbDogJ3NvdXJjZScKICAgKgkJfSApOwogICAqCiAgICoJCWVkaXRvci5jb252ZXJzaW9uLmZvciggJ3VwY2FzdCcgKS5hdHRyaWJ1dGVUb0F0dHJpYnV0ZSggewogICAqCQkJdmlldzogeyBrZXk6ICdzcmMnIH0sCiAgICoJCQltb2RlbDogJ3NvdXJjZScsCiAgICoJCQljb252ZXJ0ZXJQcmlvcml0eTogJ25vcm1hbCcKICAgKgkJfSApOwogICAqCiAgICoJCWVkaXRvci5jb252ZXJzaW9uLmZvciggJ3VwY2FzdCcgKS5hdHRyaWJ1dGVUb0F0dHJpYnV0ZSggewogICAqCQkJdmlldzogewogICAqCQkJCWtleTogJ2RhdGEtc3R5bGUnLAogICAqCQkJCXZhbHVlOiAvW1xzXFNdKy8KICAgKgkJCX0sCiAgICoJCQltb2RlbDogJ3N0eWxlZCcKICAgKgkJfSApOwogICAqCiAgICoJCWVkaXRvci5jb252ZXJzaW9uLmZvciggJ3VwY2FzdCcgKS5hdHRyaWJ1dGVUb0F0dHJpYnV0ZSggewogICAqCQkJdmlldzogewogICAqCQkJCW5hbWU6ICdpbWcnLAogICAqCQkJCWtleTogJ2NsYXNzJywKICAgKgkJCQl2YWx1ZTogJ3N0eWxlZC1kYXJrJwogICAqCQkJfSwKICAgKgkJCW1vZGVsOiB7CiAgICoJCQkJa2V5OiAnc3R5bGVkJywKICAgKgkJCQl2YWx1ZTogJ2RhcmsnCiAgICoJCQl9CiAgICoJCX0gKTsKICAgKgogICAqCQllZGl0b3IuY29udmVyc2lvbi5mb3IoICd1cGNhc3QnICkuYXR0cmlidXRlVG9BdHRyaWJ1dGUoIHsKICAgKgkJCXZpZXc6IHsKICAgKgkJCQlrZXk6ICdjbGFzcycsCiAgICoJCQkJdmFsdWU6IC9zdHlsZWQtW1xTXSsvCiAgICoJCQl9LAogICAqCQkJbW9kZWw6IHsKICAgKgkJCQlrZXk6ICdzdHlsZWQnCiAgICoJCQkJdmFsdWU6IHZpZXdFbGVtZW50ID0+IHsKICAgKgkJCQkJY29uc3QgcmVnZXhwID0gL3N0eWxlZC0oW1xTXSspLzsKICAgKgkJCQkJY29uc3QgbWF0Y2ggPSB2aWV3RWxlbWVudC5nZXRBdHRyaWJ1dGUoICdjbGFzcycgKS5tYXRjaCggcmVnZXhwICk7CiAgICoKICAgKgkJCQkJcmV0dXJuIG1hdGNoWyAxIF07CiAgICoJCQkJfQogICAqCQkJfQogICAqCQl9ICk7CiAgICoKICAgKiBDb252ZXJ0aW5nIHN0eWxlcyB3b3JrcyBhIGJpdCBkaWZmZXJlbnRseSBhcyBpdCByZXF1aXJlcyBgdmlldy5zdHlsZXNgIHRvIGJlIGFuIG9iamVjdCBhbmQgYnkgZGVmYXVsdAogICAqIGEgbW9kZWwgYXR0cmlidXRlIHdpbGwgYmUgc2V0IHRvIGB0cnVlYCBieSBzdWNoIGEgY29udmVydGVyLiBZb3UgY2FuIHNldCB0aGUgbW9kZWwgYXR0cmlidXRlIHRvIGFueSB2YWx1ZSBieSBwcm92aWRpbmcgdGhlIGB2YWx1ZWAKICAgKiBjYWxsYmFjayB0aGF0IHJldHVybnMgdGhlIGRlc2lyZWQgdmFsdWUuCiAgICoKICAgKgkJLy8gRGVmYXVsdCBjb252ZXJzaW9uIG9mIGZvbnQtd2VpZ2h0IHN0eWxlIHdpbGwgcmVzdWx0IGluIHNldHRpbmcgYm9sZCBhdHRyaWJ1dGUgdG8gdHJ1ZS4KICAgKgkJZWRpdG9yLmNvbnZlcnNpb24uZm9yKCAndXBjYXN0JyApLmF0dHJpYnV0ZVRvQXR0cmlidXRlKCB7CiAgICoJCQl2aWV3OiB7CiAgICoJCQkJc3R5bGVzOiB7CiAgICoJCQkJCSdmb250LXdlaWdodCc6ICdib2xkJwogICAqCQkJCX0KICAgKgkJCX0sCiAgICoJCQltb2RlbDogJ2JvbGQnCiAgICoJCX0gKTsKICAgKgogICAqCQkvLyBUaGlzIGNvbnZlcnRlciB3aWxsIHBhc3MgYW55IHN0eWxlIHZhbHVlIHRvIHRoZSBgbGluZUhlaWdodGAgbW9kZWwgYXR0cmlidXRlLgogICAqCQllZGl0b3IuY29udmVyc2lvbi5mb3IoICd1cGNhc3QnICkuYXR0cmlidXRlVG9BdHRyaWJ1dGUoIHsKICAgKgkJCXZpZXc6IHsKICAgKgkJCQlzdHlsZXM6IHsKICAgKgkJCQkJJ2xpbmUtaGVpZ2h0JzogL1tcc1xTXSsvCiAgICoJCQkJfQogICAqCQkJfSwKICAgKgkJCW1vZGVsOiB7CiAgICoJCQkJa2V5OiAnbGluZUhlaWdodCcsCiAgICoJCQkJdmFsdWU6IHZpZXdFbGVtZW50ID0+IHZpZXdFbGVtZW50LmdldFN0eWxlKCAnbGluZS1oZWlnaHQnICkKICAgKgkJCX0KICAgKgkJfSApOwogICAqCiAgICogU2VlIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vY29udmVyc2lvbn5Db252ZXJzaW9uI2ZvciBgY29udmVyc2lvbi5mb3IoKWB9IHRvIGxlYXJuIGhvdyB0byBhZGQgYSBjb252ZXJ0ZXIKICAgKiB0byB0aGUgY29udmVyc2lvbiBwcm9jZXNzLgogICAqCiAgICogQG1ldGhvZCAjYXR0cmlidXRlVG9BdHRyaWJ1dGUKICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIENvbnZlcnNpb24gY29uZmlndXJhdGlvbi4KICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGNvbmZpZy52aWV3IFNwZWNpZmllcyB3aGljaCB2aWV3IGF0dHJpYnV0ZSB3aWxsIGJlIGNvbnZlcnRlZC4gSWYgYSBgU3RyaW5nYCBpcyBwYXNzZWQsCiAgICogYXR0cmlidXRlcyB3aXRoIGdpdmVuIGtleSB3aWxsIGJlIGNvbnZlcnRlZC4gSWYgYW4gYE9iamVjdGAgaXMgcGFzc2VkLCBpdCBtdXN0IGhhdmUgYSByZXF1aXJlZCBga2V5YCBwcm9wZXJ0eSwKICAgKiBzcGVjaWZ5aW5nIHZpZXcgYXR0cmlidXRlIGtleSwgYW5kIG1heSBoYXZlIGFuIG9wdGlvbmFsIGB2YWx1ZWAgcHJvcGVydHksIHNwZWNpZnlpbmcgdmlldyBhdHRyaWJ1dGUgdmFsdWUgYW5kIG9wdGlvbmFsIGBuYW1lYAogICAqIHByb3BlcnR5IHNwZWNpZnlpbmcgYSB2aWV3IGVsZW1lbnQgbmFtZSBmcm9tL29uIHdoaWNoIHRoZSBhdHRyaWJ1dGUgc2hvdWxkIGJlIGNvbnZlcnRlZC4gYHZhbHVlYCBjYW4gYmUgZ2l2ZW4gYXMgYSBgU3RyaW5nYCwKICAgKiBhIGBSZWdFeHBgIG9yIGEgZnVuY3Rpb24gY2FsbGJhY2ssIHRoYXQgdGFrZXMgdmlldyBhdHRyaWJ1dGUgdmFsdWUgYXMgdGhlIG9ubHkgcGFyYW1ldGVyIGFuZCByZXR1cm5zIGBCb29sZWFuYC4KICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGNvbmZpZy5tb2RlbCBNb2RlbCBhdHRyaWJ1dGUga2V5IG9yIGFuIG9iamVjdCB3aXRoIGBrZXlgIGFuZCBgdmFsdWVgIHByb3BlcnRpZXMsIGRlc2NyaWJpbmcKICAgKiB0aGUgbW9kZWwgYXR0cmlidXRlLiBgdmFsdWVgIHByb3BlcnR5IG1heSBiZSBzZXQgYXMgYSBmdW5jdGlvbiB0aGF0IHRha2VzIGEgdmlldyBlbGVtZW50IGFuZCByZXR1cm5zIHRoZSB2YWx1ZS4KICAgKiBJZiBgU3RyaW5nYCBpcyBnaXZlbiwgdGhlIG1vZGVsIGF0dHJpYnV0ZSB2YWx1ZSB3aWxsIGJlIHNhbWUgYXMgdmlldyBhdHRyaWJ1dGUgdmFsdWUuCiAgICogQHBhcmFtIHttb2R1bGU6dXRpbHMvcHJpb3JpdGllc35Qcmlvcml0eVN0cmluZ30gW2NvbmZpZy5jb252ZXJ0ZXJQcmlvcml0eT0nbG93J10gQ29udmVydGVyIHByaW9yaXR5LgogICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vdXBjYXN0aGVscGVyc35VcGNhc3RIZWxwZXJzfQogICAqLwoKCiAgYXR0cmlidXRlVG9BdHRyaWJ1dGUoY29uZmlnKSB7CiAgICByZXR1cm4gdGhpcy5hZGQodXBjYXN0QXR0cmlidXRlVG9BdHRyaWJ1dGUoY29uZmlnKSk7CiAgfQogIC8qKgogICAqIFZpZXcgZWxlbWVudCB0byBtb2RlbCBtYXJrZXIgY29udmVyc2lvbiBoZWxwZXIuCiAgICoKICAgKiBUaGlzIGNvbnZlcnNpb24gcmVzdWx0cyBpbiBjcmVhdGluZyBhIG1vZGVsIG1hcmtlci4gRm9yIGV4YW1wbGUsIGlmIHRoZSBtYXJrZXIgd2FzIHN0b3JlZCBpbiBhIHZpZXcgYXMgYW4gZWxlbWVudDoKICAgKiBgPHA+Rm88c3BhbiBkYXRhLW1hcmtlcj0iY29tbWVudCIgZGF0YS1jb21tZW50LWlkPSI3Ij48L3NwYW4+bzwvcD48cD5CPHNwYW4gZGF0YS1tYXJrZXI9ImNvbW1lbnQiIGRhdGEtY29tbWVudC1pZD0iNyI+PC9zcGFuPmFyPC9wPmAsCiAgICogYWZ0ZXIgdGhlIGNvbnZlcnNpb24gaXMgZG9uZSwgdGhlIG1hcmtlciB3aWxsIGJlIGF2YWlsYWJsZSBpbgogICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL21vZGVsfk1vZGVsI21hcmtlcnMgbW9kZWwgZG9jdW1lbnQgbWFya2Vyc30uCiAgICoKICAgKgkJZWRpdG9yLmNvbnZlcnNpb24uZm9yKCAndXBjYXN0JyApLmVsZW1lbnRUb01hcmtlciggewogICAqCQkJdmlldzogJ21hcmtlci1zZWFyY2gnLAogICAqCQkJbW9kZWw6ICdzZWFyY2gnCiAgICoJCX0gKTsKICAgKgogICAqCQllZGl0b3IuY29udmVyc2lvbi5mb3IoICd1cGNhc3QnICkuZWxlbWVudFRvTWFya2VyKCB7CiAgICoJCQl2aWV3OiAnbWFya2VyLXNlYXJjaCcsCiAgICoJCQltb2RlbDogJ3NlYXJjaCcsCiAgICoJCQljb252ZXJ0ZXJQcmlvcml0eTogJ2hpZ2gnCiAgICoJCX0gKTsKICAgKgogICAqCQllZGl0b3IuY29udmVyc2lvbi5mb3IoICd1cGNhc3QnICkuZWxlbWVudFRvTWFya2VyKCB7CiAgICoJCQl2aWV3OiAnbWFya2VyLXNlYXJjaCcsCiAgICoJCQltb2RlbDogdmlld0VsZW1lbnQgPT4gJ2NvbW1lbnQ6JyArIHZpZXdFbGVtZW50LmdldEF0dHJpYnV0ZSggJ2RhdGEtY29tbWVudC1pZCcgKQogICAqCQl9ICk7CiAgICoKICAgKgkJZWRpdG9yLmNvbnZlcnNpb24uZm9yKCAndXBjYXN0JyApLmVsZW1lbnRUb01hcmtlciggewogICAqCQkJdmlldzogewogICAqCQkJCW5hbWU6ICdzcGFuJywKICAgKgkJCQlhdHRyaWJ1dGVzOiB7CiAgICoJCQkJCSdkYXRhLW1hcmtlcic6ICdzZWFyY2gnCiAgICoJCQkJfQogICAqCQkJfSwKICAgKgkJCW1vZGVsOiAnc2VhcmNoJwogICAqCQl9ICk7CiAgICoKICAgKiBTZWUge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi9jb252ZXJzaW9ufkNvbnZlcnNpb24jZm9yIGBjb252ZXJzaW9uLmZvcigpYH0gdG8gbGVhcm4gaG93IHRvIGFkZCBhIGNvbnZlcnRlcgogICAqIHRvIHRoZSBjb252ZXJzaW9uIHByb2Nlc3MuCiAgICoKICAgKiBAbWV0aG9kICNlbGVtZW50VG9NYXJrZXIKICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIENvbnZlcnNpb24gY29uZmlndXJhdGlvbi4KICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9tYXRjaGVyfk1hdGNoZXJQYXR0ZXJufSBjb25maWcudmlldyBQYXR0ZXJuIG1hdGNoaW5nIGFsbCB2aWV3IGVsZW1lbnRzIHdoaWNoIHNob3VsZCBiZSBjb252ZXJ0ZWQuCiAgICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IGNvbmZpZy5tb2RlbCBOYW1lIG9mIHRoZSBtb2RlbCBtYXJrZXIsIG9yIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHZpZXcgZWxlbWVudCBhbmQgcmV0dXJucwogICAqIGEgbW9kZWwgbWFya2VyIG5hbWUuCiAgICogQHBhcmFtIHttb2R1bGU6dXRpbHMvcHJpb3JpdGllc35Qcmlvcml0eVN0cmluZ30gW2NvbmZpZy5jb252ZXJ0ZXJQcmlvcml0eT0nbm9ybWFsJ10gQ29udmVydGVyIHByaW9yaXR5LgogICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vdXBjYXN0aGVscGVyc35VcGNhc3RIZWxwZXJzfQogICAqLwoKCiAgZWxlbWVudFRvTWFya2VyKGNvbmZpZykgewogICAgcmV0dXJuIHRoaXMuYWRkKHVwY2FzdEVsZW1lbnRUb01hcmtlcihjb25maWcpKTsKICB9Cgp9Ci8qKgogKiBGdW5jdGlvbiBmYWN0b3J5LCBjcmVhdGVzIGEgY29udmVydGVyIHRoYXQgY29udmVydHMge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnQgdmlldyBkb2N1bWVudCBmcmFnbWVudH0KICogb3IgYWxsIGNoaWxkcmVuIG9mIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50fSBpbnRvCiAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudCBtb2RlbCBkb2N1bWVudCBmcmFnbWVudH0uCiAqIFRoaXMgaXMgdGhlICJlbnRyeS1wb2ludCIgY29udmVydGVyIGZvciB1cGNhc3QgKHZpZXcgdG8gbW9kZWwgY29udmVyc2lvbikuIFRoaXMgY29udmVydGVyIHN0YXJ0cyB0aGUgY29udmVyc2lvbiBvZiBhbGwgY2hpbGRyZW4KICogb2YgcGFzc2VkIHZpZXcgZG9jdW1lbnQgZnJhZ21lbnQuIFRob3NlIGNoaWxkcmVuIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvbm9kZX5Ob2RlIHZpZXcgbm9kZXN9IGFyZSB0aGVuIGhhbmRsZWQgYnkgb3RoZXIgY29udmVydGVycy4KICoKICogVGhpcyBhbHNvIGEgImRlZmF1bHQiLCBsYXN0IHJlc29ydCBjb252ZXJ0ZXIgZm9yIGFsbCB2aWV3IGVsZW1lbnRzIHRoYXQgaGFzIG5vdCBiZWVuIGNvbnZlcnRlZCBieSBvdGhlciBjb252ZXJ0ZXJzLgogKiBXaGVuIGEgdmlldyBlbGVtZW50IGlzIGJlaW5nIGNvbnZlcnRlZCB0byB0aGUgbW9kZWwgYnV0IGl0IGRvZXMgbm90IGhhdmUgY29udmVydGVyIHNwZWNpZmllZCwgdGhhdCB2aWV3IGVsZW1lbnQKICogd2lsbCBiZSBjb252ZXJ0ZWQgdG8ge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50IG1vZGVsIGRvY3VtZW50IGZyYWdtZW50fSBhbmQgcmV0dXJuZWQuCiAqCiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gVW5pdmVyc2FsIGNvbnZlcnRlciBmb3IgdmlldyB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudCBmcmFnbWVudHN9IGFuZAogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudCBlbGVtZW50c30gdGhhdCByZXR1cm5zCiAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudCBtb2RlbCBmcmFnbWVudH0gd2l0aCBjaGlsZHJlbiBvZiBjb252ZXJ0ZWQgdmlldyBpdGVtLgogKi8KCmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0VG9Nb2RlbEZyYWdtZW50KCkgewogIHJldHVybiAoZXZ0LCBkYXRhLCBjb252ZXJzaW9uQXBpKSA9PiB7CiAgICAvLyBTZWNvbmQgYXJndW1lbnQgaW4gYGNvbnN1bWFibGUuY29uc3VtZWAgaXMgZGlzY2FyZGVkIGZvciBWaWV3RG9jdW1lbnRGcmFnbWVudCBidXQgaXMgbmVlZGVkIGZvciBWaWV3RWxlbWVudC4KICAgIGlmICghZGF0YS5tb2RlbFJhbmdlICYmIGNvbnZlcnNpb25BcGkuY29uc3VtYWJsZS5jb25zdW1lKGRhdGEudmlld0l0ZW0sIHsKICAgICAgbmFtZTogdHJ1ZQogICAgfSkpIHsKICAgICAgY29uc3QgewogICAgICAgIG1vZGVsUmFuZ2UsCiAgICAgICAgbW9kZWxDdXJzb3IKICAgICAgfSA9IGNvbnZlcnNpb25BcGkuY29udmVydENoaWxkcmVuKGRhdGEudmlld0l0ZW0sIGRhdGEubW9kZWxDdXJzb3IpOwogICAgICBkYXRhLm1vZGVsUmFuZ2UgPSBtb2RlbFJhbmdlOwogICAgICBkYXRhLm1vZGVsQ3Vyc29yID0gbW9kZWxDdXJzb3I7CiAgICB9CiAgfTsKfQovKioKICogRnVuY3Rpb24gZmFjdG9yeSwgY3JlYXRlcyBhIGNvbnZlcnRlciB0aGF0IGNvbnZlcnRzIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdGV4dH5UZXh0fSB0byB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC90ZXh0flRleHR9LgogKgogKiBAcmV0dXJucyB7RnVuY3Rpb259IHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdGV4dH5UZXh0IFZpZXcgdGV4dH0gY29udmVydGVyLgogKi8KCmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0VGV4dCgpIHsKICByZXR1cm4gKGV2dCwgZGF0YSwgY29udmVyc2lvbkFwaSkgPT4gewogICAgaWYgKGNvbnZlcnNpb25BcGkuc2NoZW1hLmNoZWNrQ2hpbGQoZGF0YS5tb2RlbEN1cnNvciwgJyR0ZXh0JykpIHsKICAgICAgaWYgKGNvbnZlcnNpb25BcGkuY29uc3VtYWJsZS5jb25zdW1lKGRhdGEudmlld0l0ZW0pKSB7CiAgICAgICAgY29uc3QgdGV4dCA9IGNvbnZlcnNpb25BcGkud3JpdGVyLmNyZWF0ZVRleHQoZGF0YS52aWV3SXRlbS5kYXRhKTsKICAgICAgICBjb252ZXJzaW9uQXBpLndyaXRlci5pbnNlcnQodGV4dCwgZGF0YS5tb2RlbEN1cnNvcik7CiAgICAgICAgZGF0YS5tb2RlbFJhbmdlID0gTW9kZWxSYW5nZS5fY3JlYXRlRnJvbVBvc2l0aW9uQW5kU2hpZnQoZGF0YS5tb2RlbEN1cnNvciwgdGV4dC5vZmZzZXRTaXplKTsKICAgICAgICBkYXRhLm1vZGVsQ3Vyc29yID0gZGF0YS5tb2RlbFJhbmdlLmVuZDsKICAgICAgfQogICAgfQogIH07Cn0KLyoqCiAqIEZ1bmN0aW9uIGZhY3RvcnksIGNyZWF0ZXMgYSBjYWxsYmFjayBmdW5jdGlvbiB3aGljaCBjb252ZXJ0cyBhIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvc2VsZWN0aW9uflNlbGVjdGlvbgogKiB2aWV3IHNlbGVjdGlvbn0gdGFrZW4gZnJvbSB0aGUge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9kb2N1bWVudH5Eb2N1bWVudCNldmVudDpzZWxlY3Rpb25DaGFuZ2V9IGV2ZW50CiAqIGFuZCBzZXRzIGluIG9uIHRoZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudH5Eb2N1bWVudCNzZWxlY3Rpb24gbW9kZWx9LgogKgogKiAqKk5vdGUqKjogYmVjYXVzZSB0aGVyZSBpcyBubyB2aWV3IHNlbGVjdGlvbiBjaGFuZ2UgZGlzcGF0Y2hlciBub3IgYW55IG90aGVyIGFkdmFuY2VkIHZpZXcgc2VsZWN0aW9uIHRvIG1vZGVsCiAqIGNvbnZlcnNpb24gbWVjaGFuaXNtLCB0aGUgY2FsbGJhY2sgc2hvdWxkIGJlIHNldCBkaXJlY3RseSBvbiB2aWV3IGRvY3VtZW50LgogKgogKgkJdmlldy5kb2N1bWVudC5vbiggJ3NlbGVjdGlvbkNoYW5nZScsIGNvbnZlcnRTZWxlY3Rpb25DaGFuZ2UoIG1vZGVsRG9jdW1lbnQsIG1hcHBlciApICk7CiAqCiAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9tb2RlbH5Nb2RlbH0gbW9kZWwgRGF0YSBtb2RlbC4KICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vbWFwcGVyfk1hcHBlcn0gbWFwcGVyIENvbnZlcnNpb24gbWFwcGVyLgogKiBAcmV0dXJucyB7RnVuY3Rpb259IHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZG9jdW1lbnR+RG9jdW1lbnQjZXZlbnQ6c2VsZWN0aW9uQ2hhbmdlfSBjYWxsYmFjayBmdW5jdGlvbi4KICovCgpleHBvcnQgZnVuY3Rpb24gY29udmVydFNlbGVjdGlvbkNoYW5nZShtb2RlbCwgbWFwcGVyKSB7CiAgcmV0dXJuIChldnQsIGRhdGEpID0+IHsKICAgIGNvbnN0IHZpZXdTZWxlY3Rpb24gPSBkYXRhLm5ld1NlbGVjdGlvbjsKICAgIGNvbnN0IG1vZGVsU2VsZWN0aW9uID0gbmV3IE1vZGVsU2VsZWN0aW9uKCk7CiAgICBjb25zdCByYW5nZXMgPSBbXTsKCiAgICBmb3IgKGNvbnN0IHZpZXdSYW5nZSBvZiB2aWV3U2VsZWN0aW9uLmdldFJhbmdlcygpKSB7CiAgICAgIHJhbmdlcy5wdXNoKG1hcHBlci50b01vZGVsUmFuZ2Uodmlld1JhbmdlKSk7CiAgICB9CgogICAgbW9kZWxTZWxlY3Rpb24uc2V0VG8ocmFuZ2VzLCB7CiAgICAgIGJhY2t3YXJkOiB2aWV3U2VsZWN0aW9uLmlzQmFja3dhcmQKICAgIH0pOwoKICAgIGlmICghbW9kZWxTZWxlY3Rpb24uaXNFcXVhbChtb2RlbC5kb2N1bWVudC5zZWxlY3Rpb24pKSB7CiAgICAgIG1vZGVsLmNoYW5nZSh3cml0ZXIgPT4gewogICAgICAgIHdyaXRlci5zZXRTZWxlY3Rpb24obW9kZWxTZWxlY3Rpb24pOwogICAgICB9KTsKICAgIH0KICB9Owp9IC8vIFZpZXcgZWxlbWVudCB0byBtb2RlbCBlbGVtZW50IGNvbnZlcnNpb24gaGVscGVyLgovLwovLyBTZWUge0BsaW5rIH5VcGNhc3RIZWxwZXJzI2VsZW1lbnRUb0VsZW1lbnQgYC5lbGVtZW50VG9FbGVtZW50KClgIHVwY2FzdCBoZWxwZXJ9IGZvciBleGFtcGxlcy4KLy8KLy8gQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBDb252ZXJzaW9uIGNvbmZpZ3VyYXRpb24uCi8vIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L21hdGNoZXJ+TWF0Y2hlclBhdHRlcm59IFtjb25maWcudmlld10gUGF0dGVybiBtYXRjaGluZyBhbGwgdmlldyBlbGVtZW50cyB3aGljaCBzaG91bGQgYmUgY29udmVydGVkLiBJZiBub3QKLy8gc2V0LCB0aGUgY29udmVydGVyIHdpbGwgZmlyZSBmb3IgZXZlcnkgdmlldyBlbGVtZW50LgovLyBAcGFyYW0ge1N0cmluZ3xtb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudHxGdW5jdGlvbn0gY29uZmlnLm1vZGVsIE5hbWUgb2YgdGhlIG1vZGVsIGVsZW1lbnQsIGEgbW9kZWwgZWxlbWVudAovLyBpbnN0YW5jZSBvciBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSB2aWV3IGVsZW1lbnQgYW5kIHJldHVybnMgYSBtb2RlbCBlbGVtZW50LiBUaGUgbW9kZWwgZWxlbWVudCB3aWxsIGJlIGluc2VydGVkIGluIHRoZSBtb2RlbC4KLy8gQHBhcmFtIHttb2R1bGU6dXRpbHMvcHJpb3JpdGllc35Qcmlvcml0eVN0cmluZ30gW2NvbmZpZy5jb252ZXJ0ZXJQcmlvcml0eT0nbm9ybWFsJ10gQ29udmVydGVyIHByaW9yaXR5LgovLyBAcmV0dXJucyB7RnVuY3Rpb259IENvbnZlcnNpb24gaGVscGVyLgoKZnVuY3Rpb24gdXBjYXN0RWxlbWVudFRvRWxlbWVudChjb25maWcpIHsKICBjb25maWcgPSBjbG9uZURlZXAoY29uZmlnKTsKICBjb25zdCBjb252ZXJ0ZXIgPSBwcmVwYXJlVG9FbGVtZW50Q29udmVydGVyKGNvbmZpZyk7CiAgY29uc3QgZWxlbWVudE5hbWUgPSBnZXRWaWV3RWxlbWVudE5hbWVGcm9tQ29uZmlnKGNvbmZpZy52aWV3KTsKICBjb25zdCBldmVudE5hbWUgPSBlbGVtZW50TmFtZSA/ICdlbGVtZW50OicgKyBlbGVtZW50TmFtZSA6ICdlbGVtZW50JzsKICByZXR1cm4gZGlzcGF0Y2hlciA9PiB7CiAgICBkaXNwYXRjaGVyLm9uKGV2ZW50TmFtZSwgY29udmVydGVyLCB7CiAgICAgIHByaW9yaXR5OiBjb25maWcuY29udmVydGVyUHJpb3JpdHkgfHwgJ25vcm1hbCcKICAgIH0pOwogIH07Cn0gLy8gVmlldyBlbGVtZW50IHRvIG1vZGVsIGF0dHJpYnV0ZSBjb252ZXJzaW9uIGhlbHBlci4KLy8KLy8gU2VlIHtAbGluayB+VXBjYXN0SGVscGVycyNlbGVtZW50VG9BdHRyaWJ1dGUgYC5lbGVtZW50VG9BdHRyaWJ1dGUoKWAgdXBjYXN0IGhlbHBlcn0gZm9yIGV4YW1wbGVzLgovLwovLyBAcGFyYW0ge09iamVjdH0gY29uZmlnIENvbnZlcnNpb24gY29uZmlndXJhdGlvbi4KLy8gQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvbWF0Y2hlcn5NYXRjaGVyUGF0dGVybn0gY29uZmlnLnZpZXcgUGF0dGVybiBtYXRjaGluZyBhbGwgdmlldyBlbGVtZW50cyB3aGljaCBzaG91bGQgYmUgY29udmVydGVkLgovLyBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGNvbmZpZy5tb2RlbCBNb2RlbCBhdHRyaWJ1dGUga2V5IG9yIGFuIG9iamVjdCB3aXRoIGBrZXlgIGFuZCBgdmFsdWVgIHByb3BlcnRpZXMsIGRlc2NyaWJpbmcKLy8gdGhlIG1vZGVsIGF0dHJpYnV0ZS4gYHZhbHVlYCBwcm9wZXJ0eSBtYXkgYmUgc2V0IGFzIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHZpZXcgZWxlbWVudCBhbmQgcmV0dXJucyB0aGUgdmFsdWUuCi8vIElmIGBTdHJpbmdgIGlzIGdpdmVuLCB0aGUgbW9kZWwgYXR0cmlidXRlIHZhbHVlIHdpbGwgYmUgc2V0IHRvIGB0cnVlYC4KLy8gQHBhcmFtIHttb2R1bGU6dXRpbHMvcHJpb3JpdGllc35Qcmlvcml0eVN0cmluZ30gW2NvbmZpZy5jb252ZXJ0ZXJQcmlvcml0eT0nbG93J10gQ29udmVydGVyIHByaW9yaXR5LgovLyBAcmV0dXJucyB7RnVuY3Rpb259IENvbnZlcnNpb24gaGVscGVyLgoKCmZ1bmN0aW9uIHVwY2FzdEVsZW1lbnRUb0F0dHJpYnV0ZShjb25maWcpIHsKICBjb25maWcgPSBjbG9uZURlZXAoY29uZmlnKTsKICBub3JtYWxpemVNb2RlbEF0dHJpYnV0ZUNvbmZpZyhjb25maWcpOwogIGNvbnN0IGNvbnZlcnRlciA9IHByZXBhcmVUb0F0dHJpYnV0ZUNvbnZlcnRlcihjb25maWcsIGZhbHNlKTsKICBjb25zdCBlbGVtZW50TmFtZSA9IGdldFZpZXdFbGVtZW50TmFtZUZyb21Db25maWcoY29uZmlnLnZpZXcpOwogIGNvbnN0IGV2ZW50TmFtZSA9IGVsZW1lbnROYW1lID8gJ2VsZW1lbnQ6JyArIGVsZW1lbnROYW1lIDogJ2VsZW1lbnQnOwogIHJldHVybiBkaXNwYXRjaGVyID0+IHsKICAgIGRpc3BhdGNoZXIub24oZXZlbnROYW1lLCBjb252ZXJ0ZXIsIHsKICAgICAgcHJpb3JpdHk6IGNvbmZpZy5jb252ZXJ0ZXJQcmlvcml0eSB8fCAnbG93JwogICAgfSk7CiAgfTsKfSAvLyBWaWV3IGF0dHJpYnV0ZSB0byBtb2RlbCBhdHRyaWJ1dGUgY29udmVyc2lvbiBoZWxwZXIuCi8vCi8vIFNlZSB7QGxpbmsgflVwY2FzdEhlbHBlcnMjYXR0cmlidXRlVG9BdHRyaWJ1dGUgYC5hdHRyaWJ1dGVUb0F0dHJpYnV0ZSgpYCB1cGNhc3QgaGVscGVyfSBmb3IgZXhhbXBsZXMuCi8vCi8vIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgQ29udmVyc2lvbiBjb25maWd1cmF0aW9uLgovLyBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGNvbmZpZy52aWV3IFNwZWNpZmllcyB3aGljaCB2aWV3IGF0dHJpYnV0ZSB3aWxsIGJlIGNvbnZlcnRlZC4gSWYgYSBgU3RyaW5nYCBpcyBwYXNzZWQsCi8vIGF0dHJpYnV0ZXMgd2l0aCBnaXZlbiBrZXkgd2lsbCBiZSBjb252ZXJ0ZWQuIElmIGFuIGBPYmplY3RgIGlzIHBhc3NlZCwgaXQgbXVzdCBoYXZlIGEgcmVxdWlyZWQgYGtleWAgcHJvcGVydHksCi8vIHNwZWNpZnlpbmcgdmlldyBhdHRyaWJ1dGUga2V5LCBhbmQgbWF5IGhhdmUgYW4gb3B0aW9uYWwgYHZhbHVlYCBwcm9wZXJ0eSwgc3BlY2lmeWluZyB2aWV3IGF0dHJpYnV0ZSB2YWx1ZSBhbmQgb3B0aW9uYWwgYG5hbWVgCi8vIHByb3BlcnR5IHNwZWNpZnlpbmcgYSB2aWV3IGVsZW1lbnQgbmFtZSBmcm9tL29uIHdoaWNoIHRoZSBhdHRyaWJ1dGUgc2hvdWxkIGJlIGNvbnZlcnRlZC4gYHZhbHVlYCBjYW4gYmUgZ2l2ZW4gYXMgYSBgU3RyaW5nYCwKLy8gYSBgUmVnRXhwYCBvciBhIGZ1bmN0aW9uIGNhbGxiYWNrLCB0aGF0IHRha2VzIHZpZXcgYXR0cmlidXRlIHZhbHVlIGFzIHRoZSBvbmx5IHBhcmFtZXRlciBhbmQgcmV0dXJucyBgQm9vbGVhbmAuCi8vIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gY29uZmlnLm1vZGVsIE1vZGVsIGF0dHJpYnV0ZSBrZXkgb3IgYW4gb2JqZWN0IHdpdGggYGtleWAgYW5kIGB2YWx1ZWAgcHJvcGVydGllcywgZGVzY3JpYmluZwovLyB0aGUgbW9kZWwgYXR0cmlidXRlLiBgdmFsdWVgIHByb3BlcnR5IG1heSBiZSBzZXQgYXMgYSBmdW5jdGlvbiB0aGF0IHRha2VzIGEgdmlldyBlbGVtZW50IGFuZCByZXR1cm5zIHRoZSB2YWx1ZS4KLy8gSWYgYFN0cmluZ2AgaXMgZ2l2ZW4sIHRoZSBtb2RlbCBhdHRyaWJ1dGUgdmFsdWUgd2lsbCBiZSBzYW1lIGFzIHZpZXcgYXR0cmlidXRlIHZhbHVlLgovLyBAcGFyYW0ge21vZHVsZTp1dGlscy9wcmlvcml0aWVzflByaW9yaXR5U3RyaW5nfSBbY29uZmlnLmNvbnZlcnRlclByaW9yaXR5PSdsb3cnXSBDb252ZXJ0ZXIgcHJpb3JpdHkuCi8vIEByZXR1cm5zIHtGdW5jdGlvbn0gQ29udmVyc2lvbiBoZWxwZXIuCgoKZnVuY3Rpb24gdXBjYXN0QXR0cmlidXRlVG9BdHRyaWJ1dGUoY29uZmlnKSB7CiAgY29uZmlnID0gY2xvbmVEZWVwKGNvbmZpZyk7CiAgbGV0IHZpZXdLZXkgPSBudWxsOwoKICBpZiAodHlwZW9mIGNvbmZpZy52aWV3ID09ICdzdHJpbmcnIHx8IGNvbmZpZy52aWV3LmtleSkgewogICAgdmlld0tleSA9IG5vcm1hbGl6ZVZpZXdBdHRyaWJ1dGVLZXlWYWx1ZUNvbmZpZyhjb25maWcpOwogIH0KCiAgbm9ybWFsaXplTW9kZWxBdHRyaWJ1dGVDb25maWcoY29uZmlnLCB2aWV3S2V5KTsKICBjb25zdCBjb252ZXJ0ZXIgPSBwcmVwYXJlVG9BdHRyaWJ1dGVDb252ZXJ0ZXIoY29uZmlnLCB0cnVlKTsKICByZXR1cm4gZGlzcGF0Y2hlciA9PiB7CiAgICBkaXNwYXRjaGVyLm9uKCdlbGVtZW50JywgY29udmVydGVyLCB7CiAgICAgIHByaW9yaXR5OiBjb25maWcuY29udmVydGVyUHJpb3JpdHkgfHwgJ2xvdycKICAgIH0pOwogIH07Cn0gLy8gVmlldyBlbGVtZW50IHRvIG1vZGVsIG1hcmtlciBjb252ZXJzaW9uIGhlbHBlci4KLy8KLy8gU2VlIHtAbGluayB+VXBjYXN0SGVscGVycyNlbGVtZW50VG9NYXJrZXIgYC5lbGVtZW50VG9NYXJrZXIoKWAgdXBjYXN0IGhlbHBlcn0gZm9yIGV4YW1wbGVzLgovLwovLyBAcGFyYW0ge09iamVjdH0gY29uZmlnIENvbnZlcnNpb24gY29uZmlndXJhdGlvbi4KLy8gQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvbWF0Y2hlcn5NYXRjaGVyUGF0dGVybn0gY29uZmlnLnZpZXcgUGF0dGVybiBtYXRjaGluZyBhbGwgdmlldyBlbGVtZW50cyB3aGljaCBzaG91bGQgYmUgY29udmVydGVkLgovLyBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gY29uZmlnLm1vZGVsIE5hbWUgb2YgdGhlIG1vZGVsIG1hcmtlciwgb3IgYSBmdW5jdGlvbiB0aGF0IHRha2VzIGEgdmlldyBlbGVtZW50IGFuZCByZXR1cm5zCi8vIGEgbW9kZWwgbWFya2VyIG5hbWUuCi8vIEBwYXJhbSB7bW9kdWxlOnV0aWxzL3ByaW9yaXRpZXN+UHJpb3JpdHlTdHJpbmd9IFtjb25maWcuY29udmVydGVyUHJpb3JpdHk9J25vcm1hbCddIENvbnZlcnRlciBwcmlvcml0eS4KLy8gQHJldHVybnMge0Z1bmN0aW9ufSBDb252ZXJzaW9uIGhlbHBlci4KCgpmdW5jdGlvbiB1cGNhc3RFbGVtZW50VG9NYXJrZXIoY29uZmlnKSB7CiAgY29uZmlnID0gY2xvbmVEZWVwKGNvbmZpZyk7CiAgbm9ybWFsaXplVG9NYXJrZXJDb25maWcoY29uZmlnKTsKICByZXR1cm4gdXBjYXN0RWxlbWVudFRvRWxlbWVudChjb25maWcpOwp9IC8vIEhlbHBlciBmdW5jdGlvbiBmb3IgZnJvbS12aWV3LWVsZW1lbnQgY29udmVyc2lvbi4gQ2hlY2tzIGlmIGBjb25maWcudmlld2AgZGlyZWN0bHkgc3BlY2lmaWVzIGNvbnZlcnRlZCB2aWV3IGVsZW1lbnQncyBuYW1lCi8vIGFuZCBpZiBzbywgcmV0dXJucyBpdC4KLy8KLy8gQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBDb252ZXJzaW9uIHZpZXcgY29uZmlnLgovLyBAcmV0dXJucyB7U3RyaW5nfG51bGx9IFZpZXcgZWxlbWVudCBuYW1lIG9yIGBudWxsYCBpZiBuYW1lIGlzIG5vdCBkaXJlY3RseSBzZXQuCgoKZnVuY3Rpb24gZ2V0Vmlld0VsZW1lbnROYW1lRnJvbUNvbmZpZyh2aWV3Q29uZmlnKSB7CiAgaWYgKHR5cGVvZiB2aWV3Q29uZmlnID09ICdzdHJpbmcnKSB7CiAgICByZXR1cm4gdmlld0NvbmZpZzsKICB9CgogIGlmICh0eXBlb2Ygdmlld0NvbmZpZyA9PSAnb2JqZWN0JyAmJiB0eXBlb2Ygdmlld0NvbmZpZy5uYW1lID09ICdzdHJpbmcnKSB7CiAgICByZXR1cm4gdmlld0NvbmZpZy5uYW1lOwogIH0KCiAgcmV0dXJuIG51bGw7Cn0gLy8gSGVscGVyIGZvciB0by1tb2RlbC1lbGVtZW50IGNvbnZlcnNpb24uIFRha2VzIGEgY29uZmlnIG9iamVjdCBhbmQgcmV0dXJucyBhIHByb3BlciBjb252ZXJ0ZXIgZnVuY3Rpb24uCi8vCi8vIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgQ29udmVyc2lvbiBjb25maWd1cmF0aW9uLgovLyBAcmV0dXJucyB7RnVuY3Rpb259IFZpZXcgdG8gbW9kZWwgY29udmVydGVyLgoKCmZ1bmN0aW9uIHByZXBhcmVUb0VsZW1lbnRDb252ZXJ0ZXIoY29uZmlnKSB7CiAgY29uc3QgbWF0Y2hlciA9IGNvbmZpZy52aWV3ID8gbmV3IE1hdGNoZXIoY29uZmlnLnZpZXcpIDogbnVsbDsKICByZXR1cm4gKGV2dCwgZGF0YSwgY29udmVyc2lvbkFwaSkgPT4gewogICAgbGV0IG1hdGNoID0ge307IC8vIElmIGBjb25maWcudmlld2AgaGFzIG5vdCBiZWVuIHBhc3NlZCBkbyBub3QgdHJ5IG1hdGNoaW5nLiBJbiB0aGlzIGNhc2UsIHRoZSBjb252ZXJ0ZXIgc2hvdWxkIGZpcmUgZm9yIGFsbCBlbGVtZW50cy4KCiAgICBpZiAobWF0Y2hlcikgewogICAgICAvLyBUaGlzIHdpbGwgYmUgdXN1YWxseSBqdXN0IG9uZSBwYXR0ZXJuIGJ1dCB3ZSBzdXBwb3J0IG1hdGNoZXJzIHdpdGggbWFueSBwYXR0ZXJucyB0b28uCiAgICAgIGNvbnN0IG1hdGNoZXJSZXN1bHQgPSBtYXRjaGVyLm1hdGNoKGRhdGEudmlld0l0ZW0pOyAvLyBJZiB0aGVyZSBpcyBubyBtYXRjaCwgdGhpcyBjYWxsYmFjayBzaG91bGQgbm90IGRvIGFueXRoaW5nLgoKICAgICAgaWYgKCFtYXRjaGVyUmVzdWx0KSB7CiAgICAgICAgcmV0dXJuOwogICAgICB9CgogICAgICBtYXRjaCA9IG1hdGNoZXJSZXN1bHQubWF0Y2g7CiAgICB9IC8vIEZvcmNlIGNvbnN1bWluZyBlbGVtZW50J3MgbmFtZS4KCgogICAgbWF0Y2gubmFtZSA9IHRydWU7IC8vIENyZWF0ZSBtb2RlbCBlbGVtZW50IGJhc2luZyBvbiBjb25maWcuCgogICAgY29uc3QgbW9kZWxFbGVtZW50ID0gZ2V0TW9kZWxFbGVtZW50KGNvbmZpZy5tb2RlbCwgZGF0YS52aWV3SXRlbSwgY29udmVyc2lvbkFwaS53cml0ZXIpOyAvLyBEbyBub3QgY29udmVydCBpZiBlbGVtZW50IGJ1aWxkaW5nIGZ1bmN0aW9uIHJldHVybmVkIGZhbHN5IHZhbHVlLgoKICAgIGlmICghbW9kZWxFbGVtZW50KSB7CiAgICAgIHJldHVybjsKICAgIH0gLy8gV2hlbiBlbGVtZW50IHdhcyBhbHJlYWR5IGNvbnN1bWVkIHRoZW4gc2tpcCBpdC4KCgogICAgaWYgKCFjb252ZXJzaW9uQXBpLmNvbnN1bWFibGUudGVzdChkYXRhLnZpZXdJdGVtLCBtYXRjaCkpIHsKICAgICAgcmV0dXJuOwogICAgfSAvLyBGaW5kIGFsbG93ZWQgcGFyZW50IGZvciBlbGVtZW50IHRoYXQgd2UgYXJlIGdvaW5nIHRvIGluc2VydC4KICAgIC8vIElmIGN1cnJlbnQgcGFyZW50IGRvZXMgbm90IGFsbG93IHRvIGluc2VydCBlbGVtZW50IGJ1dCBvbmUgb2YgdGhlIGFuY2VzdG9ycyBkb2VzCiAgICAvLyB0aGVuIHNwbGl0IG5vZGVzIHRvIGFsbG93ZWQgcGFyZW50LgoKCiAgICBjb25zdCBzcGxpdFJlc3VsdCA9IGNvbnZlcnNpb25BcGkuc3BsaXRUb0FsbG93ZWRQYXJlbnQobW9kZWxFbGVtZW50LCBkYXRhLm1vZGVsQ3Vyc29yKTsgLy8gV2hlbiB0aGVyZSBpcyBubyBzcGxpdCByZXN1bHQgaXQgbWVhbnMgdGhhdCB3ZSBjYW4ndCBpbnNlcnQgZWxlbWVudCB0byBtb2RlbCB0cmVlLCBzbyBsZXQncyBza2lwIGl0LgoKICAgIGlmICghc3BsaXRSZXN1bHQpIHsKICAgICAgcmV0dXJuOwogICAgfSAvLyBJbnNlcnQgZWxlbWVudCBvbiBhbGxvd2VkIHBvc2l0aW9uLgoKCiAgICBjb252ZXJzaW9uQXBpLndyaXRlci5pbnNlcnQobW9kZWxFbGVtZW50LCBzcGxpdFJlc3VsdC5wb3NpdGlvbik7IC8vIENvbnZlcnQgY2hpbGRyZW4gYW5kIGluc2VydCB0byBlbGVtZW50LgoKICAgIGNvbnZlcnNpb25BcGkuY29udmVydENoaWxkcmVuKGRhdGEudmlld0l0ZW0sIGNvbnZlcnNpb25BcGkud3JpdGVyLmNyZWF0ZVBvc2l0aW9uQXQobW9kZWxFbGVtZW50LCAwKSk7IC8vIENvbnN1bWUgYXBwcm9wcmlhdGUgdmFsdWUgZnJvbSBjb25zdW1hYmxlIHZhbHVlcyBsaXN0LgoKICAgIGNvbnZlcnNpb25BcGkuY29uc3VtYWJsZS5jb25zdW1lKGRhdGEudmlld0l0ZW0sIG1hdGNoKTsKICAgIGNvbnN0IHBhcnRzID0gY29udmVyc2lvbkFwaS5nZXRTcGxpdFBhcnRzKG1vZGVsRWxlbWVudCk7IC8vIFNldCBjb252ZXJzaW9uIHJlc3VsdCByYW5nZS4KCiAgICBkYXRhLm1vZGVsUmFuZ2UgPSBuZXcgTW9kZWxSYW5nZShjb252ZXJzaW9uQXBpLndyaXRlci5jcmVhdGVQb3NpdGlvbkJlZm9yZShtb2RlbEVsZW1lbnQpLCBjb252ZXJzaW9uQXBpLndyaXRlci5jcmVhdGVQb3NpdGlvbkFmdGVyKHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdKSk7IC8vIE5vdyB3ZSBuZWVkIHRvIGNoZWNrIHdoZXJlIHRoZSBgbW9kZWxDdXJzb3JgIHNob3VsZCBiZS4KCiAgICBpZiAoc3BsaXRSZXN1bHQuY3Vyc29yUGFyZW50KSB7CiAgICAgIC8vIElmIHdlIHNwbGl0IHBhcmVudCB0byBpbnNlcnQgb3VyIGVsZW1lbnQgdGhlbiB3ZSB3YW50IHRvIGNvbnRpbnVlIGNvbnZlcnNpb24gaW4gdGhlIG5ldyBwYXJ0IG9mIHRoZSBzcGxpdCBwYXJlbnQuCiAgICAgIC8vCiAgICAgIC8vIGJlZm9yZTogPGFsbG93ZWQ+PG5vdEFsbG93ZWQ+Zm9vW108L25vdEFsbG93ZWQ+PC9hbGxvd2VkPgogICAgICAvLyBhZnRlcjogIDxhbGxvd2VkPjxub3RBbGxvd2VkPmZvbzwvbm90QWxsb3dlZD48Y29udmVydGVkPjwvY29udmVydGVkPjxub3RBbGxvd2VkPltdPC9ub3RBbGxvd2VkPjwvYWxsb3dlZD4KICAgICAgZGF0YS5tb2RlbEN1cnNvciA9IGNvbnZlcnNpb25BcGkud3JpdGVyLmNyZWF0ZVBvc2l0aW9uQXQoc3BsaXRSZXN1bHQuY3Vyc29yUGFyZW50LCAwKTsKICAgIH0gZWxzZSB7CiAgICAgIC8vIE90aGVyd2lzZSBqdXN0IGNvbnRpbnVlIGFmdGVyIGluc2VydGVkIGVsZW1lbnQuCiAgICAgIGRhdGEubW9kZWxDdXJzb3IgPSBkYXRhLm1vZGVsUmFuZ2UuZW5kOwogICAgfQogIH07Cn0gLy8gSGVscGVyIGZ1bmN0aW9uIGZvciB1cGNhc3RpbmctdG8tZWxlbWVudCBjb252ZXJ0ZXIuIFRha2VzIHRoZSBtb2RlbCBjb25maWd1cmF0aW9uLCB0aGUgY29udmVydGVkIHZpZXcgZWxlbWVudAovLyBhbmQgYSB3cml0ZXIgaW5zdGFuY2UgYW5kIHJldHVybnMgYSBtb2RlbCBlbGVtZW50IGluc3RhbmNlIHRvIGJlIGluc2VydGVkIGluIHRoZSBtb2RlbC4KLy8KLy8gQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb258bW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR9IG1vZGVsIE1vZGVsIGNvbnZlcnNpb24gY29uZmlndXJhdGlvbi4KLy8gQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvbm9kZX5Ob2RlfSBpbnB1dCBUaGUgY29udmVydGVkIHZpZXcgbm9kZS4KLy8gQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3dyaXRlcn5Xcml0ZXJ9IHdyaXRlciBBIHdyaXRlciBpbnN0YW5jZSB0byB1c2UgdG8gY3JlYXRlIHRoZSBtb2RlbCBlbGVtZW50LgoKCmZ1bmN0aW9uIGdldE1vZGVsRWxlbWVudChtb2RlbCwgaW5wdXQsIHdyaXRlcikgewogIGlmIChtb2RlbCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7CiAgICByZXR1cm4gbW9kZWwoaW5wdXQsIHdyaXRlcik7CiAgfSBlbHNlIHsKICAgIHJldHVybiB3cml0ZXIuY3JlYXRlRWxlbWVudChtb2RlbCk7CiAgfQp9IC8vIEhlbHBlciBmdW5jdGlvbiB2aWV3LWF0dHJpYnV0ZS10by1tb2RlbC1hdHRyaWJ1dGUgaGVscGVyLiBOb3JtYWxpemVzIGBjb25maWcudmlld2Agd2hpY2ggd2FzIHNldCBhcyBgU3RyaW5nYCBvcgovLyBhcyBhbiBgT2JqZWN0YCB3aXRoIGBrZXlgLCBgdmFsdWVgIGFuZCBgbmFtZWAgcHJvcGVydGllcy4gTm9ybWFsaXplZCBgY29uZmlnLnZpZXdgIGhhcyBpcyBjb21wYXRpYmxlIHdpdGgKLy8ge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9tYXRjaGVyfk1hdGNoZXJQYXR0ZXJufS4KLy8KLy8gQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBDb252ZXJzaW9uIGNvbmZpZy4KLy8gQHJldHVybnMge1N0cmluZ30gS2V5IG9mIHRoZSBjb252ZXJ0ZWQgdmlldyBhdHRyaWJ1dGUuCgoKZnVuY3Rpb24gbm9ybWFsaXplVmlld0F0dHJpYnV0ZUtleVZhbHVlQ29uZmlnKGNvbmZpZykgewogIGlmICh0eXBlb2YgY29uZmlnLnZpZXcgPT0gJ3N0cmluZycpIHsKICAgIGNvbmZpZy52aWV3ID0gewogICAgICBrZXk6IGNvbmZpZy52aWV3CiAgICB9OwogIH0KCiAgY29uc3Qga2V5ID0gY29uZmlnLnZpZXcua2V5OwogIGxldCBub3JtYWxpemVkOwoKICBpZiAoa2V5ID09ICdjbGFzcycgfHwga2V5ID09ICdzdHlsZScpIHsKICAgIGNvbnN0IGtleU5hbWUgPSBrZXkgPT0gJ2NsYXNzJyA/ICdjbGFzc2VzJyA6ICdzdHlsZXMnOwogICAgbm9ybWFsaXplZCA9IHsKICAgICAgW2tleU5hbWVdOiBjb25maWcudmlldy52YWx1ZQogICAgfTsKICB9IGVsc2UgewogICAgY29uc3QgdmFsdWUgPSB0eXBlb2YgY29uZmlnLnZpZXcudmFsdWUgPT0gJ3VuZGVmaW5lZCcgPyAvW1xzXFNdKi8gOiBjb25maWcudmlldy52YWx1ZTsKICAgIG5vcm1hbGl6ZWQgPSB7CiAgICAgIGF0dHJpYnV0ZXM6IHsKICAgICAgICBba2V5XTogdmFsdWUKICAgICAgfQogICAgfTsKICB9CgogIGlmIChjb25maWcudmlldy5uYW1lKSB7CiAgICBub3JtYWxpemVkLm5hbWUgPSBjb25maWcudmlldy5uYW1lOwogIH0KCiAgY29uZmlnLnZpZXcgPSBub3JtYWxpemVkOwogIHJldHVybiBrZXk7Cn0gLy8gSGVscGVyIGZ1bmN0aW9uIHRoYXQgbm9ybWFsaXplcyBgY29uZmlnLm1vZGVsYCBpbiBmcm9tLW1vZGVsLWF0dHJpYnV0ZSBjb252ZXJzaW9uLiBgY29uZmlnLm1vZGVsYCBjYW4gYmUgc2V0Ci8vIGFzIGEgYFN0cmluZ2AsIGFuIGBPYmplY3RgIHdpdGggb25seSBga2V5YCBwcm9wZXJ0eSBvciBhbiBgT2JqZWN0YCB3aXRoIGBrZXlgIGFuZCBgdmFsdWVgIHByb3BlcnRpZXMuIE5vcm1hbGl6ZWQKLy8gYGNvbmZpZy5tb2RlbGAgaXMgYW4gYE9iamVjdGAgd2l0aCBga2V5YCBhbmQgYHZhbHVlYCBwcm9wZXJ0aWVzLgovLwovLyBAcGFyYW0ge09iamVjdH0gY29uZmlnIENvbnZlcnNpb24gY29uZmlnLgovLyBAcGFyYW0ge1N0cmluZ30gdmlld0F0dHJpYnV0ZUtleVRvQ29weSBLZXkgb2YgdGhlIGNvbnZlcnRlZCB2aWV3IGF0dHJpYnV0ZS4gSWYgaXQgaXMgc2V0LCBtb2RlbCBhdHRyaWJ1dGUgdmFsdWUKLy8gd2lsbCBiZSBlcXVhbCB0byB2aWV3IGF0dHJpYnV0ZSB2YWx1ZS4KCgpmdW5jdGlvbiBub3JtYWxpemVNb2RlbEF0dHJpYnV0ZUNvbmZpZyhjb25maWcsIHZpZXdBdHRyaWJ1dGVLZXlUb0NvcHkgPSBudWxsKSB7CiAgY29uc3QgZGVmYXVsdE1vZGVsVmFsdWUgPSB2aWV3QXR0cmlidXRlS2V5VG9Db3B5ID09PSBudWxsID8gdHJ1ZSA6IHZpZXdFbGVtZW50ID0+IHZpZXdFbGVtZW50LmdldEF0dHJpYnV0ZSh2aWV3QXR0cmlidXRlS2V5VG9Db3B5KTsKICBjb25zdCBrZXkgPSB0eXBlb2YgY29uZmlnLm1vZGVsICE9ICdvYmplY3QnID8gY29uZmlnLm1vZGVsIDogY29uZmlnLm1vZGVsLmtleTsKICBjb25zdCB2YWx1ZSA9IHR5cGVvZiBjb25maWcubW9kZWwgIT0gJ29iamVjdCcgfHwgdHlwZW9mIGNvbmZpZy5tb2RlbC52YWx1ZSA9PSAndW5kZWZpbmVkJyA/IGRlZmF1bHRNb2RlbFZhbHVlIDogY29uZmlnLm1vZGVsLnZhbHVlOwogIGNvbmZpZy5tb2RlbCA9IHsKICAgIGtleSwKICAgIHZhbHVlCiAgfTsKfSAvLyBIZWxwZXIgZm9yIHRvLW1vZGVsLWF0dHJpYnV0ZSBjb252ZXJzaW9uLiBUYWtlcyB0aGUgbW9kZWwgYXR0cmlidXRlIG5hbWUgYW5kIGNvbnZlcnNpb24gY29uZmlndXJhdGlvbiBhbmQgcmV0dXJucwovLyBhIHByb3BlciBjb252ZXJ0ZXIgZnVuY3Rpb24uCi8vCi8vIEBwYXJhbSB7U3RyaW5nfSBtb2RlbEF0dHJpYnV0ZUtleSBUaGUga2V5IG9mIHRoZSBtb2RlbCBhdHRyaWJ1dGUgdG8gc2V0IG9uIGEgbW9kZWwgbm9kZS4KLy8gQHBhcmFtIHtPYmplY3R8QXJyYXkuPE9iamVjdD59IGNvbmZpZyBDb252ZXJzaW9uIGNvbmZpZ3VyYXRpb24uIEl0IGlzIHBvc3NpYmxlIHRvIHByb3ZpZGUgbXVsdGlwbGUgY29uZmlndXJhdGlvbnMgaW4gYW4gYXJyYXkuCi8vIEBwYXJhbSB7Qm9vbGVhbn0gc2hhbGxvdyBJZiBzZXQgdG8gYHRydWVgIHRoZSBhdHRyaWJ1dGUgd2lsbCBiZSBzZXQgb25seSBvbiB0b3AtbGV2ZWwgbm9kZXMuIE90aGVyd2lzZSwgaXQgd2lsbCBiZSBzZXQKLy8gb24gYWxsIGVsZW1lbnRzIGluIHRoZSByYW5nZS4KCgpmdW5jdGlvbiBwcmVwYXJlVG9BdHRyaWJ1dGVDb252ZXJ0ZXIoY29uZmlnLCBzaGFsbG93KSB7CiAgY29uc3QgbWF0Y2hlciA9IG5ldyBNYXRjaGVyKGNvbmZpZy52aWV3KTsKICByZXR1cm4gKGV2dCwgZGF0YSwgY29udmVyc2lvbkFwaSkgPT4gewogICAgY29uc3QgbWF0Y2ggPSBtYXRjaGVyLm1hdGNoKGRhdGEudmlld0l0ZW0pOyAvLyBJZiB0aGVyZSBpcyBubyBtYXRjaCwgdGhpcyBjYWxsYmFjayBzaG91bGQgbm90IGRvIGFueXRoaW5nLgoKICAgIGlmICghbWF0Y2gpIHsKICAgICAgcmV0dXJuOwogICAgfQoKICAgIGNvbnN0IG1vZGVsS2V5ID0gY29uZmlnLm1vZGVsLmtleTsKICAgIGNvbnN0IG1vZGVsVmFsdWUgPSB0eXBlb2YgY29uZmlnLm1vZGVsLnZhbHVlID09ICdmdW5jdGlvbicgPyBjb25maWcubW9kZWwudmFsdWUoZGF0YS52aWV3SXRlbSkgOiBjb25maWcubW9kZWwudmFsdWU7IC8vIERvIG5vdCBjb252ZXJ0IGlmIGF0dHJpYnV0ZSBidWlsZGluZyBmdW5jdGlvbiByZXR1cm5lZCBmYWxzeSB2YWx1ZS4KCiAgICBpZiAobW9kZWxWYWx1ZSA9PT0gbnVsbCkgewogICAgICByZXR1cm47CiAgICB9CgogICAgaWYgKG9ubHlWaWV3TmFtZUlzRGVmaW5lZChjb25maWcudmlldywgZGF0YS52aWV3SXRlbSkpIHsKICAgICAgbWF0Y2gubWF0Y2gubmFtZSA9IHRydWU7CiAgICB9IGVsc2UgewogICAgICAvLyBEbyBub3QgdGVzdCBvciBjb25zdW1lIGBuYW1lYCBjb25zdW1hYmxlLgogICAgICBkZWxldGUgbWF0Y2gubWF0Y2gubmFtZTsKICAgIH0gLy8gVHJ5IHRvIGNvbnN1bWUgYXBwcm9wcmlhdGUgdmFsdWVzIGZyb20gY29uc3VtYWJsZSB2YWx1ZXMgbGlzdC4KCgogICAgaWYgKCFjb252ZXJzaW9uQXBpLmNvbnN1bWFibGUudGVzdChkYXRhLnZpZXdJdGVtLCBtYXRjaC5tYXRjaCkpIHsKICAgICAgcmV0dXJuOwogICAgfSAvLyBTaW5jZSB3ZSBhcmUgY29udmVydGluZyB0byBhdHRyaWJ1dGUgd2UgbmVlZCBhbiByYW5nZSBvbiB3aGljaCB3ZSB3aWxsIHNldCB0aGUgYXR0cmlidXRlLgogICAgLy8gSWYgdGhlIHJhbmdlIGlzIG5vdCBjcmVhdGVkIHlldCwgd2Ugd2lsbCBjcmVhdGUgaXQuCgoKICAgIGlmICghZGF0YS5tb2RlbFJhbmdlKSB7CiAgICAgIC8vIENvbnZlcnQgY2hpbGRyZW4gYW5kIHNldCBjb252ZXJzaW9uIHJlc3VsdCBhcyBhIGN1cnJlbnQgZGF0YS4KICAgICAgZGF0YSA9IE9iamVjdC5hc3NpZ24oZGF0YSwgY29udmVyc2lvbkFwaS5jb252ZXJ0Q2hpbGRyZW4oZGF0YS52aWV3SXRlbSwgZGF0YS5tb2RlbEN1cnNvcikpOwogICAgfSAvLyBTZXQgYXR0cmlidXRlIG9uIGN1cnJlbnQgYG91dHB1dGAuIGBTY2hlbWFgIGlzIGNoZWNrZWQgaW5zaWRlIHRoaXMgaGVscGVyIGZ1bmN0aW9uLgoKCiAgICBjb25zdCBhdHRyaWJ1dGVXYXNTZXQgPSBzZXRBdHRyaWJ1dGVPbihkYXRhLm1vZGVsUmFuZ2UsIHsKICAgICAga2V5OiBtb2RlbEtleSwKICAgICAgdmFsdWU6IG1vZGVsVmFsdWUKICAgIH0sIHNoYWxsb3csIGNvbnZlcnNpb25BcGkpOwoKICAgIGlmIChhdHRyaWJ1dGVXYXNTZXQpIHsKICAgICAgY29udmVyc2lvbkFwaS5jb25zdW1hYmxlLmNvbnN1bWUoZGF0YS52aWV3SXRlbSwgbWF0Y2gubWF0Y2gpOwogICAgfQogIH07Cn0gLy8gSGVscGVyIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIGlmIGVsZW1lbnQgbmFtZSBzaG91bGQgYmUgY29uc3VtZWQgaW4gYXR0cmlidXRlIGNvbnZlcnRlcnMuCi8vCi8vIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgQ29udmVyc2lvbiB2aWV3IGNvbmZpZy4KLy8gQHJldHVybnMge0Jvb2xlYW59CgoKZnVuY3Rpb24gb25seVZpZXdOYW1lSXNEZWZpbmVkKHZpZXdDb25maWcsIHZpZXdJdGVtKSB7CiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NrZWRpdG9yL2NrZWRpdG9yNS1lbmdpbmUvaXNzdWVzLzE3ODYKICBjb25zdCBjb25maWdUb1Rlc3QgPSB0eXBlb2Ygdmlld0NvbmZpZyA9PSAnZnVuY3Rpb24nID8gdmlld0NvbmZpZyh2aWV3SXRlbSkgOiB2aWV3Q29uZmlnOwoKICBpZiAodHlwZW9mIGNvbmZpZ1RvVGVzdCA9PSAnb2JqZWN0JyAmJiAhZ2V0Vmlld0VsZW1lbnROYW1lRnJvbUNvbmZpZyhjb25maWdUb1Rlc3QpKSB7CiAgICByZXR1cm4gZmFsc2U7CiAgfQoKICByZXR1cm4gIWNvbmZpZ1RvVGVzdC5jbGFzc2VzICYmICFjb25maWdUb1Rlc3QuYXR0cmlidXRlcyAmJiAhY29uZmlnVG9UZXN0LnN0eWxlczsKfSAvLyBIZWxwZXIgZnVuY3Rpb24gZm9yIHRvLW1vZGVsLWF0dHJpYnV0ZSBjb252ZXJ0ZXIuIFNldHMgbW9kZWwgYXR0cmlidXRlIG9uIGdpdmVuIHJhbmdlLiBDaGVja3Mge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYX0KLy8gdG8gZW5zdXJlIHByb3BlciBtb2RlbCBzdHJ1Y3R1cmUuCi8vCi8vIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZX0gbW9kZWxSYW5nZSBNb2RlbCByYW5nZSBvbiB3aGljaCBhdHRyaWJ1dGUgc2hvdWxkIGJlIHNldC4KLy8gQHBhcmFtIHtPYmplY3R9IG1vZGVsQXR0cmlidXRlIE1vZGVsIGF0dHJpYnV0ZSB0byBzZXQuCi8vIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL3VwY2FzdGRpc3BhdGNoZXJ+VXBjYXN0Q29udmVyc2lvbkFwaX0gY29udmVyc2lvbkFwaSBDb252ZXJzaW9uIEFQSS4KLy8gQHBhcmFtIHtCb29sZWFufSBzaGFsbG93IElmIHNldCB0byBgdHJ1ZWAgdGhlIGF0dHJpYnV0ZSB3aWxsIGJlIHNldCBvbmx5IG9uIHRvcC1sZXZlbCBub2Rlcy4gT3RoZXJ3aXNlLCBpdCB3aWxsIGJlIHNldAovLyBvbiBhbGwgZWxlbWVudHMgaW4gdGhlIHJhbmdlLgovLyBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIGF0dHJpYnV0ZSB3YXMgc2V0IG9uIGF0IGxlYXN0IG9uZSBub2RlIGZyb20gZ2l2ZW4gYG1vZGVsUmFuZ2VgLgoKCmZ1bmN0aW9uIHNldEF0dHJpYnV0ZU9uKG1vZGVsUmFuZ2UsIG1vZGVsQXR0cmlidXRlLCBzaGFsbG93LCBjb252ZXJzaW9uQXBpKSB7CiAgbGV0IHJlc3VsdCA9IGZhbHNlOyAvLyBTZXQgYXR0cmlidXRlIG9uIGVhY2ggaXRlbSBpbiByYW5nZSBhY2NvcmRpbmcgdG8gU2NoZW1hLgoKICBmb3IgKGNvbnN0IG5vZGUgb2YgQXJyYXkuZnJvbShtb2RlbFJhbmdlLmdldEl0ZW1zKHsKICAgIHNoYWxsb3cKICB9KSkpIHsKICAgIGlmIChjb252ZXJzaW9uQXBpLnNjaGVtYS5jaGVja0F0dHJpYnV0ZShub2RlLCBtb2RlbEF0dHJpYnV0ZS5rZXkpKSB7CiAgICAgIGNvbnZlcnNpb25BcGkud3JpdGVyLnNldEF0dHJpYnV0ZShtb2RlbEF0dHJpYnV0ZS5rZXksIG1vZGVsQXR0cmlidXRlLnZhbHVlLCBub2RlKTsKICAgICAgcmVzdWx0ID0gdHJ1ZTsKICAgIH0KICB9CgogIHJldHVybiByZXN1bHQ7Cn0gLy8gSGVscGVyIGZ1bmN0aW9uIGZvciB1cGNhc3RpbmctdG8tbWFya2VyIGNvbnZlcnNpb24uIFRha2VzIHRoZSBjb25maWcgaW4gYSBmb3JtYXQgcmVxdWVzdGVkIGJ5IGB1cGNhc3RFbGVtZW50VG9NYXJrZXIoKWAKLy8gZnVuY3Rpb24gYW5kIGNvbnZlcnRzIGl0IHRvIGEgZm9ybWF0IHRoYXQgaXMgc3VwcG9ydGVkIGJ5IGBfdXBjYXN0RWxlbWVudFRvRWxlbWVudCgpYCBmdW5jdGlvbi4KLy8KLy8gQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBDb252ZXJzaW9uIGNvbmZpZ3VyYXRpb24uCgoKZnVuY3Rpb24gbm9ybWFsaXplVG9NYXJrZXJDb25maWcoY29uZmlnKSB7CiAgY29uc3Qgb2xkTW9kZWwgPSBjb25maWcubW9kZWw7CgogIGNvbmZpZy5tb2RlbCA9ICh2aWV3RWxlbWVudCwgbW9kZWxXcml0ZXIpID0+IHsKICAgIGNvbnN0IG1hcmtlck5hbWUgPSB0eXBlb2Ygb2xkTW9kZWwgPT0gJ3N0cmluZycgPyBvbGRNb2RlbCA6IG9sZE1vZGVsKHZpZXdFbGVtZW50KTsKICAgIHJldHVybiBtb2RlbFdyaXRlci5jcmVhdGVFbGVtZW50KCckbWFya2VyJywgewogICAgICAnZGF0YS1uYW1lJzogbWFya2VyTmFtZQogICAgfSk7CiAgfTsKfQ=="},{"version":3,"sources":["/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-engine/src/conversion/upcasthelpers.js"],"names":["Matcher","ModelRange","ConversionHelpers","cloneDeep","ModelSelection","UpcastHelpers","elementToElement","config","add","upcastElementToElement","elementToAttribute","upcastElementToAttribute","attributeToAttribute","upcastAttributeToAttribute","elementToMarker","upcastElementToMarker","convertToModelFragment","evt","data","conversionApi","modelRange","consumable","consume","viewItem","name","modelCursor","convertChildren","convertText","schema","checkChild","text","writer","createText","insert","_createFromPositionAndShift","offsetSize","end","convertSelectionChange","model","mapper","viewSelection","newSelection","modelSelection","ranges","viewRange","getRanges","push","toModelRange","setTo","backward","isBackward","isEqual","document","selection","change","setSelection","converter","prepareToElementConverter","elementName","getViewElementNameFromConfig","view","eventName","dispatcher","on","priority","converterPriority","normalizeModelAttributeConfig","prepareToAttributeConverter","viewKey","key","normalizeViewAttributeKeyValueConfig","normalizeToMarkerConfig","viewConfig","matcher","match","matcherResult","modelElement","getModelElement","test","splitResult","splitToAllowedParent","position","createPositionAt","parts","getSplitParts","createPositionBefore","createPositionAfter","length","cursorParent","input","Function","createElement","normalized","keyName","value","attributes","viewAttributeKeyToCopy","defaultModelValue","viewElement","getAttribute","shallow","modelKey","modelValue","onlyViewNameIsDefined","Object","assign","attributeWasSet","setAttributeOn","configToTest","classes","styles","modelAttribute","result","node","Array","from","getItems","checkAttribute","setAttribute","oldModel","modelWriter","markerName"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\nimport Matcher from '../view/matcher';\nimport ModelRange from '../model/range';\nimport ConversionHelpers from './conversionhelpers';\n\nimport { cloneDeep } from 'lodash-es';\nimport ModelSelection from '../model/selection';\n\n/**\n * Contains {@link module:engine/view/view view} to {@link module:engine/model/model model} converters for\n * {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher}.\n *\n * @module engine/conversion/upcasthelpers\n */\n\n/**\n * Upcast conversion helper functions.\n *\n * @extends module:engine/conversion/conversionhelpers~ConversionHelpers\n */\nexport default class UpcastHelpers extends ConversionHelpers {\n\t/**\n\t * View element to model element conversion helper.\n\t *\n\t * This conversion results in creating a model element. For example,\n\t * view `<p>Foo</p>` becomes `<paragraph>Foo</paragraph>` in the model.\n\t *\n\t * Keep in mind that the element will be inserted only if it is allowed\n\t * by {@link module:engine/model/schema~Schema schema} configuration.\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).elementToElement( {\n\t *\t\t\tview: 'p',\n\t *\t\t\tmodel: 'paragraph'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).elementToElement( {\n\t *\t\t\tview: 'p',\n\t *\t\t\tmodel: 'paragraph',\n\t *\t\t\tconverterPriority: 'high'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).elementToElement( {\n\t *\t\t\tview: {\n\t *\t\t\t\tname: 'p',\n\t *\t\t\t\tclasses: 'fancy'\n\t *\t\t\t},\n\t *\t\t\tmodel: 'fancyParagraph'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).elementToElement( {\n\t * \t\t\tview: {\n\t *\t\t\t\tname: 'p',\n\t *\t\t\t\tclasses: 'heading'\n\t * \t\t\t},\n\t * \t\t\tmodel: ( viewElement, modelWriter ) => {\n\t * \t\t\t\treturn modelWriter.createElement( 'heading', { level: viewElement.getAttribute( 'data-level' ) } );\n\t * \t\t\t}\n\t * \t\t} );\n\t *\n\t * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n\t * to the conversion process.\n\t *\n\t * @method #elementToElement\n\t * @param {Object} config Conversion configuration.\n\t * @param {module:engine/view/matcher~MatcherPattern} [config.view] Pattern matching all view elements which should be converted. If not\n\t * set, the converter will fire for every view element.\n\t * @param {String|module:engine/model/element~Element|Function} config.model Name of the model element, a model element\n\t * instance or a function that takes a view element and returns a model element. The model element will be inserted in the model.\n\t * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n\t * @returns {module:engine/conversion/upcasthelpers~UpcastHelpers}\n\t */\n\telementToElement( config ) {\n\t\treturn this.add( upcastElementToElement( config ) );\n\t}\n\n\t/**\n\t * View element to model attribute conversion helper.\n\t *\n\t * This conversion results in setting an attribute on a model node. For example, view `<strong>Foo</strong>` becomes\n\t * `Foo` {@link module:engine/model/text~Text model text node} with `bold` attribute set to `true`.\n\t *\n\t * This helper is meant to set a model attribute on all the elements that are inside the converted element:\n\t *\n\t *\t\t<strong>Foo</strong>   -->   <strong><p>Foo</p></strong>   -->   <paragraph><$text bold=\"true\">Foo</$text></paragraph>\n\t *\n\t * Above is a sample of HTML code, that goes through autoparagraphing (first step) and then is converted (second step).\n\t * Even though `<strong>` is over `<p>` element, `bold=\"true\"` was added to the text. See\n\t * {@link module:engine/conversion/upcasthelpers~UpcastHelpers#attributeToAttribute} for comparison.\n\t *\n\t * Keep in mind that the attribute will be set only if it is allowed by {@link module:engine/model/schema~Schema schema} configuration.\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).elementToAttribute( {\n\t *\t\t\tview: 'strong',\n\t *\t\t\tmodel: 'bold'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).elementToAttribute( {\n\t *\t\t\tview: 'strong',\n\t *\t\t\tmodel: 'bold',\n\t *\t\t\tconverterPriority: 'high'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).elementToAttribute( {\n\t *\t\t\tview: {\n\t *\t\t\t\tname: 'span',\n\t *\t\t\t\tclasses: 'bold'\n\t *\t\t\t},\n\t *\t\t\tmodel: 'bold'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).elementToAttribute( {\n\t *\t\t\tview: {\n\t *\t\t\t\tname: 'span',\n\t *\t\t\t\tclasses: [ 'styled', 'styled-dark' ]\n\t *\t\t\t},\n\t *\t\t\tmodel: {\n\t *\t\t\t\tkey: 'styled',\n\t *\t\t\t\tvalue: 'dark'\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * \t\teditor.conversion.for( 'upcast' ).elementToAttribute( {\n\t *\t\t\tview: {\n\t *\t\t\t\tname: 'span',\n\t *\t\t\t\tstyles: {\n\t *\t\t\t\t\t'font-size': /[\\s\\S]+/\n\t *\t\t\t\t}\n\t *\t\t\t},\n\t *\t\t\tmodel: {\n\t *\t\t\t\tkey: 'fontSize',\n\t *\t\t\t\tvalue: viewElement => {\n\t *\t\t\t\t\tconst fontSize = viewElement.getStyle( 'font-size' );\n\t *\t\t\t\t\tconst value = fontSize.substr( 0, fontSize.length - 2 );\n\t *\n\t *\t\t\t\t\tif ( value <= 10 ) {\n\t *\t\t\t\t\t\treturn 'small';\n\t *\t\t\t\t\t} else if ( value > 12 ) {\n\t *\t\t\t\t\t\treturn 'big';\n\t *\t\t\t\t\t}\n\t *\n\t *\t\t\t\t\treturn null;\n\t *\t\t\t\t}\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n\t * to the conversion process.\n\t *\n\t * @method #elementToAttribute\n\t * @param {Object} config Conversion configuration.\n\t * @param {module:engine/view/matcher~MatcherPattern} config.view Pattern matching all view elements which should be converted.\n\t * @param {String|Object} config.model Model attribute key or an object with `key` and `value` properties, describing\n\t * the model attribute. `value` property may be set as a function that takes a view element and returns the value.\n\t * If `String` is given, the model attribute value will be set to `true`.\n\t * @param {module:utils/priorities~PriorityString} [config.converterPriority='low'] Converter priority.\n\t * @returns {module:engine/conversion/upcasthelpers~UpcastHelpers}\n\t */\n\telementToAttribute( config ) {\n\t\treturn this.add( upcastElementToAttribute( config ) );\n\t}\n\n\t/**\n\t * View attribute to model attribute conversion helper.\n\t *\n\t * This conversion results in setting an attribute on a model node. For example, view `<img src=\"foo.jpg\"></img>` becomes\n\t * `<image source=\"foo.jpg\"></image>` in the model.\n\t *\n\t * This helper is meant to convert view attributes from view elements which got converted to the model, so the view attribute\n\t * is set only on the corresponding model node:\n\t *\n\t *\t\t<div class=\"dark\"><div>foo</div></div>    -->    <div dark=\"true\"><div>foo</div></div>\n\t *\n\t * Above, `class=\"dark\"` attribute is added only to the `<div>` elements that has it. This is in contrary to\n\t * {@link module:engine/conversion/upcasthelpers~UpcastHelpers#elementToAttribute} which sets attributes for\n\t * all the children in the model:\n\t *\n\t *\t\t<strong>Foo</strong>   -->   <strong><p>Foo</p></strong>   -->   <paragraph><$text bold=\"true\">Foo</$text></paragraph>\n\t *\n\t * Above is a sample of HTML code, that goes through autoparagraphing (first step) and then is converted (second step).\n\t * Even though `<strong>` is over `<p>` element, `bold=\"true\"` was added to the text.\n\t *\n\t * Keep in mind that the attribute will be set only if it is allowed by {@link module:engine/model/schema~Schema schema} configuration.\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n\t *\t\t\tview: 'src',\n\t *\t\t\tmodel: 'source'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n\t *\t\t\tview: { key: 'src' },\n\t *\t\t\tmodel: 'source'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n\t *\t\t\tview: { key: 'src' },\n\t *\t\t\tmodel: 'source',\n\t *\t\t\tconverterPriority: 'normal'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n\t *\t\t\tview: {\n\t *\t\t\t\tkey: 'data-style',\n\t *\t\t\t\tvalue: /[\\s\\S]+/\n\t *\t\t\t},\n\t *\t\t\tmodel: 'styled'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n\t *\t\t\tview: {\n\t *\t\t\t\tname: 'img',\n\t *\t\t\t\tkey: 'class',\n\t *\t\t\t\tvalue: 'styled-dark'\n\t *\t\t\t},\n\t *\t\t\tmodel: {\n\t *\t\t\t\tkey: 'styled',\n\t *\t\t\t\tvalue: 'dark'\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n\t *\t\t\tview: {\n\t *\t\t\t\tkey: 'class',\n\t *\t\t\t\tvalue: /styled-[\\S]+/\n\t *\t\t\t},\n\t *\t\t\tmodel: {\n\t *\t\t\t\tkey: 'styled'\n\t *\t\t\t\tvalue: viewElement => {\n\t *\t\t\t\t\tconst regexp = /styled-([\\S]+)/;\n\t *\t\t\t\t\tconst match = viewElement.getAttribute( 'class' ).match( regexp );\n\t *\n\t *\t\t\t\t\treturn match[ 1 ];\n\t *\t\t\t\t}\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * Converting styles works a bit differently as it requires `view.styles` to be an object and by default\n\t * a model attribute will be set to `true` by such a converter. You can set the model attribute to any value by providing the `value`\n\t * callback that returns the desired value.\n\t *\n\t *\t\t// Default conversion of font-weight style will result in setting bold attribute to true.\n\t *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n\t *\t\t\tview: {\n\t *\t\t\t\tstyles: {\n\t *\t\t\t\t\t'font-weight': 'bold'\n\t *\t\t\t\t}\n\t *\t\t\t},\n\t *\t\t\tmodel: 'bold'\n\t *\t\t} );\n\t *\n\t *\t\t// This converter will pass any style value to the `lineHeight` model attribute.\n\t *\t\teditor.conversion.for( 'upcast' ).attributeToAttribute( {\n\t *\t\t\tview: {\n\t *\t\t\t\tstyles: {\n\t *\t\t\t\t\t'line-height': /[\\s\\S]+/\n\t *\t\t\t\t}\n\t *\t\t\t},\n\t *\t\t\tmodel: {\n\t *\t\t\t\tkey: 'lineHeight',\n\t *\t\t\t\tvalue: viewElement => viewElement.getStyle( 'line-height' )\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n\t * to the conversion process.\n\t *\n\t * @method #attributeToAttribute\n\t * @param {Object} config Conversion configuration.\n\t * @param {String|Object} config.view Specifies which view attribute will be converted. If a `String` is passed,\n\t * attributes with given key will be converted. If an `Object` is passed, it must have a required `key` property,\n\t * specifying view attribute key, and may have an optional `value` property, specifying view attribute value and optional `name`\n\t * property specifying a view element name from/on which the attribute should be converted. `value` can be given as a `String`,\n\t * a `RegExp` or a function callback, that takes view attribute value as the only parameter and returns `Boolean`.\n\t * @param {String|Object} config.model Model attribute key or an object with `key` and `value` properties, describing\n\t * the model attribute. `value` property may be set as a function that takes a view element and returns the value.\n\t * If `String` is given, the model attribute value will be same as view attribute value.\n\t * @param {module:utils/priorities~PriorityString} [config.converterPriority='low'] Converter priority.\n\t * @returns {module:engine/conversion/upcasthelpers~UpcastHelpers}\n\t */\n\tattributeToAttribute( config ) {\n\t\treturn this.add( upcastAttributeToAttribute( config ) );\n\t}\n\n\t/**\n\t * View element to model marker conversion helper.\n\t *\n\t * This conversion results in creating a model marker. For example, if the marker was stored in a view as an element:\n\t * `<p>Fo<span data-marker=\"comment\" data-comment-id=\"7\"></span>o</p><p>B<span data-marker=\"comment\" data-comment-id=\"7\"></span>ar</p>`,\n\t * after the conversion is done, the marker will be available in\n\t * {@link module:engine/model/model~Model#markers model document markers}.\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).elementToMarker( {\n\t *\t\t\tview: 'marker-search',\n\t *\t\t\tmodel: 'search'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).elementToMarker( {\n\t *\t\t\tview: 'marker-search',\n\t *\t\t\tmodel: 'search',\n\t *\t\t\tconverterPriority: 'high'\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).elementToMarker( {\n\t *\t\t\tview: 'marker-search',\n\t *\t\t\tmodel: viewElement => 'comment:' + viewElement.getAttribute( 'data-comment-id' )\n\t *\t\t} );\n\t *\n\t *\t\teditor.conversion.for( 'upcast' ).elementToMarker( {\n\t *\t\t\tview: {\n\t *\t\t\t\tname: 'span',\n\t *\t\t\t\tattributes: {\n\t *\t\t\t\t\t'data-marker': 'search'\n\t *\t\t\t\t}\n\t *\t\t\t},\n\t *\t\t\tmodel: 'search'\n\t *\t\t} );\n\t *\n\t * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter\n\t * to the conversion process.\n\t *\n\t * @method #elementToMarker\n\t * @param {Object} config Conversion configuration.\n\t * @param {module:engine/view/matcher~MatcherPattern} config.view Pattern matching all view elements which should be converted.\n\t * @param {String|Function} config.model Name of the model marker, or a function that takes a view element and returns\n\t * a model marker name.\n\t * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n\t * @returns {module:engine/conversion/upcasthelpers~UpcastHelpers}\n\t */\n\telementToMarker( config ) {\n\t\treturn this.add( upcastElementToMarker( config ) );\n\t}\n}\n\n/**\n * Function factory, creates a converter that converts {@link module:engine/view/documentfragment~DocumentFragment view document fragment}\n * or all children of {@link module:engine/view/element~Element} into\n * {@link module:engine/model/documentfragment~DocumentFragment model document fragment}.\n * This is the \"entry-point\" converter for upcast (view to model conversion). This converter starts the conversion of all children\n * of passed view document fragment. Those children {@link module:engine/view/node~Node view nodes} are then handled by other converters.\n *\n * This also a \"default\", last resort converter for all view elements that has not been converted by other converters.\n * When a view element is being converted to the model but it does not have converter specified, that view element\n * will be converted to {@link module:engine/model/documentfragment~DocumentFragment model document fragment} and returned.\n *\n * @returns {Function} Universal converter for view {@link module:engine/view/documentfragment~DocumentFragment fragments} and\n * {@link module:engine/view/element~Element elements} that returns\n * {@link module:engine/model/documentfragment~DocumentFragment model fragment} with children of converted view item.\n */\nexport function convertToModelFragment() {\n\treturn ( evt, data, conversionApi ) => {\n\t\t// Second argument in `consumable.consume` is discarded for ViewDocumentFragment but is needed for ViewElement.\n\t\tif ( !data.modelRange && conversionApi.consumable.consume( data.viewItem, { name: true } ) ) {\n\t\t\tconst { modelRange, modelCursor } = conversionApi.convertChildren( data.viewItem, data.modelCursor );\n\n\t\t\tdata.modelRange = modelRange;\n\t\t\tdata.modelCursor = modelCursor;\n\t\t}\n\t};\n}\n\n/**\n * Function factory, creates a converter that converts {@link module:engine/view/text~Text} to {@link module:engine/model/text~Text}.\n *\n * @returns {Function} {@link module:engine/view/text~Text View text} converter.\n */\nexport function convertText() {\n\treturn ( evt, data, conversionApi ) => {\n\t\tif ( conversionApi.schema.checkChild( data.modelCursor, '$text' ) ) {\n\t\t\tif ( conversionApi.consumable.consume( data.viewItem ) ) {\n\t\t\t\tconst text = conversionApi.writer.createText( data.viewItem.data );\n\n\t\t\t\tconversionApi.writer.insert( text, data.modelCursor );\n\n\t\t\t\tdata.modelRange = ModelRange._createFromPositionAndShift( data.modelCursor, text.offsetSize );\n\t\t\t\tdata.modelCursor = data.modelRange.end;\n\t\t\t}\n\t\t}\n\t};\n}\n\n/**\n * Function factory, creates a callback function which converts a {@link module:engine/view/selection~Selection\n * view selection} taken from the {@link module:engine/view/document~Document#event:selectionChange} event\n * and sets in on the {@link module:engine/model/document~Document#selection model}.\n *\n * **Note**: because there is no view selection change dispatcher nor any other advanced view selection to model\n * conversion mechanism, the callback should be set directly on view document.\n *\n *\t\tview.document.on( 'selectionChange', convertSelectionChange( modelDocument, mapper ) );\n *\n * @param {module:engine/model/model~Model} model Data model.\n * @param {module:engine/conversion/mapper~Mapper} mapper Conversion mapper.\n * @returns {Function} {@link module:engine/view/document~Document#event:selectionChange} callback function.\n */\nexport function convertSelectionChange( model, mapper ) {\n\treturn ( evt, data ) => {\n\t\tconst viewSelection = data.newSelection;\n\t\tconst modelSelection = new ModelSelection();\n\n\t\tconst ranges = [];\n\n\t\tfor ( const viewRange of viewSelection.getRanges() ) {\n\t\t\tranges.push( mapper.toModelRange( viewRange ) );\n\t\t}\n\n\t\tmodelSelection.setTo( ranges, { backward: viewSelection.isBackward } );\n\n\t\tif ( !modelSelection.isEqual( model.document.selection ) ) {\n\t\t\tmodel.change( writer => {\n\t\t\t\twriter.setSelection( modelSelection );\n\t\t\t} );\n\t\t}\n\t};\n}\n\n// View element to model element conversion helper.\n//\n// See {@link ~UpcastHelpers#elementToElement `.elementToElement()` upcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {module:engine/view/matcher~MatcherPattern} [config.view] Pattern matching all view elements which should be converted. If not\n// set, the converter will fire for every view element.\n// @param {String|module:engine/model/element~Element|Function} config.model Name of the model element, a model element\n// instance or a function that takes a view element and returns a model element. The model element will be inserted in the model.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n// @returns {Function} Conversion helper.\nfunction upcastElementToElement( config ) {\n\tconfig = cloneDeep( config );\n\n\tconst converter = prepareToElementConverter( config );\n\n\tconst elementName = getViewElementNameFromConfig( config.view );\n\tconst eventName = elementName ? 'element:' + elementName : 'element';\n\n\treturn dispatcher => {\n\t\tdispatcher.on( eventName, converter, { priority: config.converterPriority || 'normal' } );\n\t};\n}\n\n// View element to model attribute conversion helper.\n//\n// See {@link ~UpcastHelpers#elementToAttribute `.elementToAttribute()` upcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {module:engine/view/matcher~MatcherPattern} config.view Pattern matching all view elements which should be converted.\n// @param {String|Object} config.model Model attribute key or an object with `key` and `value` properties, describing\n// the model attribute. `value` property may be set as a function that takes a view element and returns the value.\n// If `String` is given, the model attribute value will be set to `true`.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='low'] Converter priority.\n// @returns {Function} Conversion helper.\nfunction upcastElementToAttribute( config ) {\n\tconfig = cloneDeep( config );\n\n\tnormalizeModelAttributeConfig( config );\n\n\tconst converter = prepareToAttributeConverter( config, false );\n\n\tconst elementName = getViewElementNameFromConfig( config.view );\n\tconst eventName = elementName ? 'element:' + elementName : 'element';\n\n\treturn dispatcher => {\n\t\tdispatcher.on( eventName, converter, { priority: config.converterPriority || 'low' } );\n\t};\n}\n\n// View attribute to model attribute conversion helper.\n//\n// See {@link ~UpcastHelpers#attributeToAttribute `.attributeToAttribute()` upcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {String|Object} config.view Specifies which view attribute will be converted. If a `String` is passed,\n// attributes with given key will be converted. If an `Object` is passed, it must have a required `key` property,\n// specifying view attribute key, and may have an optional `value` property, specifying view attribute value and optional `name`\n// property specifying a view element name from/on which the attribute should be converted. `value` can be given as a `String`,\n// a `RegExp` or a function callback, that takes view attribute value as the only parameter and returns `Boolean`.\n// @param {String|Object} config.model Model attribute key or an object with `key` and `value` properties, describing\n// the model attribute. `value` property may be set as a function that takes a view element and returns the value.\n// If `String` is given, the model attribute value will be same as view attribute value.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='low'] Converter priority.\n// @returns {Function} Conversion helper.\nfunction upcastAttributeToAttribute( config ) {\n\tconfig = cloneDeep( config );\n\n\tlet viewKey = null;\n\n\tif ( typeof config.view == 'string' || config.view.key ) {\n\t\tviewKey = normalizeViewAttributeKeyValueConfig( config );\n\t}\n\n\tnormalizeModelAttributeConfig( config, viewKey );\n\n\tconst converter = prepareToAttributeConverter( config, true );\n\n\treturn dispatcher => {\n\t\tdispatcher.on( 'element', converter, { priority: config.converterPriority || 'low' } );\n\t};\n}\n\n// View element to model marker conversion helper.\n//\n// See {@link ~UpcastHelpers#elementToMarker `.elementToMarker()` upcast helper} for examples.\n//\n// @param {Object} config Conversion configuration.\n// @param {module:engine/view/matcher~MatcherPattern} config.view Pattern matching all view elements which should be converted.\n// @param {String|Function} config.model Name of the model marker, or a function that takes a view element and returns\n// a model marker name.\n// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.\n// @returns {Function} Conversion helper.\nfunction upcastElementToMarker( config ) {\n\tconfig = cloneDeep( config );\n\n\tnormalizeToMarkerConfig( config );\n\n\treturn upcastElementToElement( config );\n}\n\n// Helper function for from-view-element conversion. Checks if `config.view` directly specifies converted view element's name\n// and if so, returns it.\n//\n// @param {Object} config Conversion view config.\n// @returns {String|null} View element name or `null` if name is not directly set.\nfunction getViewElementNameFromConfig( viewConfig ) {\n\tif ( typeof viewConfig == 'string' ) {\n\t\treturn viewConfig;\n\t}\n\n\tif ( typeof viewConfig == 'object' && typeof viewConfig.name == 'string' ) {\n\t\treturn viewConfig.name;\n\t}\n\n\treturn null;\n}\n\n// Helper for to-model-element conversion. Takes a config object and returns a proper converter function.\n//\n// @param {Object} config Conversion configuration.\n// @returns {Function} View to model converter.\nfunction prepareToElementConverter( config ) {\n\tconst matcher = config.view ? new Matcher( config.view ) : null;\n\n\treturn ( evt, data, conversionApi ) => {\n\t\tlet match = {};\n\n\t\t// If `config.view` has not been passed do not try matching. In this case, the converter should fire for all elements.\n\t\tif ( matcher ) {\n\t\t\t// This will be usually just one pattern but we support matchers with many patterns too.\n\t\t\tconst matcherResult = matcher.match( data.viewItem );\n\n\t\t\t// If there is no match, this callback should not do anything.\n\t\t\tif ( !matcherResult ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tmatch = matcherResult.match;\n\t\t}\n\n\t\t// Force consuming element's name.\n\t\tmatch.name = true;\n\n\t\t// Create model element basing on config.\n\t\tconst modelElement = getModelElement( config.model, data.viewItem, conversionApi.writer );\n\n\t\t// Do not convert if element building function returned falsy value.\n\t\tif ( !modelElement ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// When element was already consumed then skip it.\n\t\tif ( !conversionApi.consumable.test( data.viewItem, match ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Find allowed parent for element that we are going to insert.\n\t\t// If current parent does not allow to insert element but one of the ancestors does\n\t\t// then split nodes to allowed parent.\n\t\tconst splitResult = conversionApi.splitToAllowedParent( modelElement, data.modelCursor );\n\n\t\t// When there is no split result it means that we can't insert element to model tree, so let's skip it.\n\t\tif ( !splitResult ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Insert element on allowed position.\n\t\tconversionApi.writer.insert( modelElement, splitResult.position );\n\n\t\t// Convert children and insert to element.\n\t\tconversionApi.convertChildren( data.viewItem, conversionApi.writer.createPositionAt( modelElement, 0 ) );\n\n\t\t// Consume appropriate value from consumable values list.\n\t\tconversionApi.consumable.consume( data.viewItem, match );\n\n\t\tconst parts = conversionApi.getSplitParts( modelElement );\n\n\t\t// Set conversion result range.\n\t\tdata.modelRange = new ModelRange(\n\t\t\tconversionApi.writer.createPositionBefore( modelElement ),\n\t\t\tconversionApi.writer.createPositionAfter( parts[ parts.length - 1 ] )\n\t\t);\n\n\t\t// Now we need to check where the `modelCursor` should be.\n\t\tif ( splitResult.cursorParent ) {\n\t\t\t// If we split parent to insert our element then we want to continue conversion in the new part of the split parent.\n\t\t\t//\n\t\t\t// before: <allowed><notAllowed>foo[]</notAllowed></allowed>\n\t\t\t// after:  <allowed><notAllowed>foo</notAllowed><converted></converted><notAllowed>[]</notAllowed></allowed>\n\n\t\t\tdata.modelCursor = conversionApi.writer.createPositionAt( splitResult.cursorParent, 0 );\n\t\t} else {\n\t\t\t// Otherwise just continue after inserted element.\n\n\t\t\tdata.modelCursor = data.modelRange.end;\n\t\t}\n\t};\n}\n\n// Helper function for upcasting-to-element converter. Takes the model configuration, the converted view element\n// and a writer instance and returns a model element instance to be inserted in the model.\n//\n// @param {String|Function|module:engine/model/element~Element} model Model conversion configuration.\n// @param {module:engine/view/node~Node} input The converted view node.\n// @param {module:engine/model/writer~Writer} writer A writer instance to use to create the model element.\nfunction getModelElement( model, input, writer ) {\n\tif ( model instanceof Function ) {\n\t\treturn model( input, writer );\n\t} else {\n\t\treturn writer.createElement( model );\n\t}\n}\n\n// Helper function view-attribute-to-model-attribute helper. Normalizes `config.view` which was set as `String` or\n// as an `Object` with `key`, `value` and `name` properties. Normalized `config.view` has is compatible with\n// {@link module:engine/view/matcher~MatcherPattern}.\n//\n// @param {Object} config Conversion config.\n// @returns {String} Key of the converted view attribute.\nfunction normalizeViewAttributeKeyValueConfig( config ) {\n\tif ( typeof config.view == 'string' ) {\n\t\tconfig.view = { key: config.view };\n\t}\n\n\tconst key = config.view.key;\n\tlet normalized;\n\n\tif ( key == 'class' || key == 'style' ) {\n\t\tconst keyName = key == 'class' ? 'classes' : 'styles';\n\n\t\tnormalized = {\n\t\t\t[ keyName ]: config.view.value\n\t\t};\n\t} else {\n\t\tconst value = typeof config.view.value == 'undefined' ? /[\\s\\S]*/ : config.view.value;\n\n\t\tnormalized = {\n\t\t\tattributes: {\n\t\t\t\t[ key ]: value\n\t\t\t}\n\t\t};\n\t}\n\n\tif ( config.view.name ) {\n\t\tnormalized.name = config.view.name;\n\t}\n\n\tconfig.view = normalized;\n\n\treturn key;\n}\n\n// Helper function that normalizes `config.model` in from-model-attribute conversion. `config.model` can be set\n// as a `String`, an `Object` with only `key` property or an `Object` with `key` and `value` properties. Normalized\n// `config.model` is an `Object` with `key` and `value` properties.\n//\n// @param {Object} config Conversion config.\n// @param {String} viewAttributeKeyToCopy Key of the converted view attribute. If it is set, model attribute value\n// will be equal to view attribute value.\nfunction normalizeModelAttributeConfig( config, viewAttributeKeyToCopy = null ) {\n\tconst defaultModelValue = viewAttributeKeyToCopy === null ? true : viewElement => viewElement.getAttribute( viewAttributeKeyToCopy );\n\n\tconst key = typeof config.model != 'object' ? config.model : config.model.key;\n\tconst value = typeof config.model != 'object' || typeof config.model.value == 'undefined' ? defaultModelValue : config.model.value;\n\n\tconfig.model = { key, value };\n}\n\n// Helper for to-model-attribute conversion. Takes the model attribute name and conversion configuration and returns\n// a proper converter function.\n//\n// @param {String} modelAttributeKey The key of the model attribute to set on a model node.\n// @param {Object|Array.<Object>} config Conversion configuration. It is possible to provide multiple configurations in an array.\n// @param {Boolean} shallow If set to `true` the attribute will be set only on top-level nodes. Otherwise, it will be set\n// on all elements in the range.\nfunction prepareToAttributeConverter( config, shallow ) {\n\tconst matcher = new Matcher( config.view );\n\n\treturn ( evt, data, conversionApi ) => {\n\t\tconst match = matcher.match( data.viewItem );\n\n\t\t// If there is no match, this callback should not do anything.\n\t\tif ( !match ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst modelKey = config.model.key;\n\t\tconst modelValue = typeof config.model.value == 'function' ? config.model.value( data.viewItem ) : config.model.value;\n\n\t\t// Do not convert if attribute building function returned falsy value.\n\t\tif ( modelValue === null ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( onlyViewNameIsDefined( config.view, data.viewItem ) ) {\n\t\t\tmatch.match.name = true;\n\t\t} else {\n\t\t\t// Do not test or consume `name` consumable.\n\t\t\tdelete match.match.name;\n\t\t}\n\n\t\t// Try to consume appropriate values from consumable values list.\n\t\tif ( !conversionApi.consumable.test( data.viewItem, match.match ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Since we are converting to attribute we need an range on which we will set the attribute.\n\t\t// If the range is not created yet, we will create it.\n\t\tif ( !data.modelRange ) {\n\t\t\t// Convert children and set conversion result as a current data.\n\t\t\tdata = Object.assign( data, conversionApi.convertChildren( data.viewItem, data.modelCursor ) );\n\t\t}\n\n\t\t// Set attribute on current `output`. `Schema` is checked inside this helper function.\n\t\tconst attributeWasSet = setAttributeOn( data.modelRange, { key: modelKey, value: modelValue }, shallow, conversionApi );\n\n\t\tif ( attributeWasSet ) {\n\t\t\tconversionApi.consumable.consume( data.viewItem, match.match );\n\t\t}\n\t};\n}\n\n// Helper function that checks if element name should be consumed in attribute converters.\n//\n// @param {Object} config Conversion view config.\n// @returns {Boolean}\nfunction onlyViewNameIsDefined( viewConfig, viewItem ) {\n\t// https://github.com/ckeditor/ckeditor5-engine/issues/1786\n\tconst configToTest = typeof viewConfig == 'function' ? viewConfig( viewItem ) : viewConfig;\n\n\tif ( typeof configToTest == 'object' && !getViewElementNameFromConfig( configToTest ) ) {\n\t\treturn false;\n\t}\n\n\treturn !configToTest.classes && !configToTest.attributes && !configToTest.styles;\n}\n\n// Helper function for to-model-attribute converter. Sets model attribute on given range. Checks {@link module:engine/model/schema~Schema}\n// to ensure proper model structure.\n//\n// @param {module:engine/model/range~Range} modelRange Model range on which attribute should be set.\n// @param {Object} modelAttribute Model attribute to set.\n// @param {module:engine/conversion/upcastdispatcher~UpcastConversionApi} conversionApi Conversion API.\n// @param {Boolean} shallow If set to `true` the attribute will be set only on top-level nodes. Otherwise, it will be set\n// on all elements in the range.\n// @returns {Boolean} `true` if attribute was set on at least one node from given `modelRange`.\nfunction setAttributeOn( modelRange, modelAttribute, shallow, conversionApi ) {\n\tlet result = false;\n\n\t// Set attribute on each item in range according to Schema.\n\tfor ( const node of Array.from( modelRange.getItems( { shallow } ) ) ) {\n\t\tif ( conversionApi.schema.checkAttribute( node, modelAttribute.key ) ) {\n\t\t\tconversionApi.writer.setAttribute( modelAttribute.key, modelAttribute.value, node );\n\n\t\t\tresult = true;\n\t\t}\n\t}\n\n\treturn result;\n}\n\n// Helper function for upcasting-to-marker conversion. Takes the config in a format requested by `upcastElementToMarker()`\n// function and converts it to a format that is supported by `_upcastElementToElement()` function.\n//\n// @param {Object} config Conversion configuration.\nfunction normalizeToMarkerConfig( config ) {\n\tconst oldModel = config.model;\n\n\tconfig.model = ( viewElement, modelWriter ) => {\n\t\tconst markerName = typeof oldModel == 'string' ? oldModel : oldModel( viewElement );\n\n\t\treturn modelWriter.createElement( '$marker', { 'data-name': markerName } );\n\t};\n}\n"]}]}