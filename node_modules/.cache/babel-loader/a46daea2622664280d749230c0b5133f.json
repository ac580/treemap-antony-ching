{"remainingRequest":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/babel-loader/lib/index.js!/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-table/src/tableutils.js","dependencies":[{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-table/src/tableutils.js","mtime":499162500000},{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js","mtime":499162500000},{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/babel-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:LyoqCiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDE5LCBDS1NvdXJjZSAtIEZyZWRlcmljbyBLbmFiYmVuLiBBbGwgcmlnaHRzIHJlc2VydmVkLgogKiBGb3IgbGljZW5zaW5nLCBzZWUgTElDRU5TRS5tZCBvciBodHRwczovL2NrZWRpdG9yLmNvbS9sZWdhbC9ja2VkaXRvci1vc3MtbGljZW5zZQogKi8KCi8qKgogKiBAbW9kdWxlIHRhYmxlL3RhYmxldXRpbHMKICovCmltcG9ydCBQbHVnaW4gZnJvbSAnQGNrZWRpdG9yL2NrZWRpdG9yNS1jb3JlL3NyYy9wbHVnaW4nOwppbXBvcnQgVGFibGVXYWxrZXIgZnJvbSAnLi90YWJsZXdhbGtlcic7CmltcG9ydCB7IGNyZWF0ZUVtcHR5VGFibGVDZWxsLCB1cGRhdGVOdW1lcmljQXR0cmlidXRlIH0gZnJvbSAnLi9jb21tYW5kcy91dGlscyc7Ci8qKgogKiBUaGUgdGFibGUgdXRpbGl0aWVzIHBsdWdpbi4KICoKICogQGV4dGVuZHMgbW9kdWxlOmNvcmUvcGx1Z2luflBsdWdpbgogKi8KCmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRhYmxlVXRpbHMgZXh0ZW5kcyBQbHVnaW4gewogIC8qKgogICAqIEBpbmhlcml0RG9jCiAgICovCiAgc3RhdGljIGdldCBwbHVnaW5OYW1lKCkgewogICAgcmV0dXJuICdUYWJsZVV0aWxzJzsKICB9CiAgLyoqCiAgICogUmV0dXJucyB0aGUgdGFibGUgY2VsbCBsb2NhdGlvbiBhcyBhbiBvYmplY3Qgd2l0aCB0YWJsZSByb3cgYW5kIHRhYmxlIGNvbHVtbiBpbmRleGVzLgogICAqCiAgICogRm9yIGluc3RhbmNlIGluIHRoZSB0YWJsZSBiZWxvdzoKICAgKgogICAqCQkgICAgMCAgIDEgICAyICAgMwogICAqCQkgICstLS0rLS0tKy0tLSstLS0rCiAgICoJCTAgfCBhICAgICB8IGIgfCBjIHwKICAgKgkJICArICAgICAgICsgICArLS0tKwogICAqCQkxIHwgICAgICAgfCAgIHwgZCB8CiAgICoJCSAgKy0tLSstLS0rICAgKy0tLSsKICAgKgkJMiB8IGUgICAgIHwgICB8IGYgfAogICAqCQkgICstLS0rLS0tKy0tLSstLS0rCiAgICoKICAgKiB0aGUgbWV0aG9kIHdpbGwgcmV0dXJuOgogICAqCiAgICoJCWNvbnN0IGNlbGxBID0gdGFibGUuZ2V0Tm9kZUJ5UGF0aCggWyAwLCAwIF0gKTsKICAgKgkJZWRpdG9yLnBsdWdpbnMuZ2V0KCAnVGFibGVVdGlscycgKS5nZXRDZWxsTG9jYXRpb24oIGNlbGxBICk7CiAgICoJCS8vIHdpbGwgcmV0dXJuIHsgcm93OiAwLCBjb2x1bW46IDAgfQogICAqCiAgICoJCWNvbnN0IGNlbGxEID0gdGFibGUuZ2V0Tm9kZUJ5UGF0aCggWyAxLCAwIF0gKTsKICAgKgkJZWRpdG9yLnBsdWdpbnMuZ2V0KCAnVGFibGVVdGlscycgKS5nZXRDZWxsTG9jYXRpb24oIGNlbGxEICk7CiAgICoJCS8vIHdpbGwgcmV0dXJuIHsgcm93OiAxLCBjb2x1bW46IDMgfQogICAqCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudH0gdGFibGVDZWxsCiAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBhIGB7cm93LCBjb2x1bW59YCBvYmplY3QuCiAgICovCgoKICBnZXRDZWxsTG9jYXRpb24odGFibGVDZWxsKSB7CiAgICBjb25zdCB0YWJsZVJvdyA9IHRhYmxlQ2VsbC5wYXJlbnQ7CiAgICBjb25zdCB0YWJsZSA9IHRhYmxlUm93LnBhcmVudDsKICAgIGNvbnN0IHJvd0luZGV4ID0gdGFibGUuZ2V0Q2hpbGRJbmRleCh0YWJsZVJvdyk7CiAgICBjb25zdCB0YWJsZVdhbGtlciA9IG5ldyBUYWJsZVdhbGtlcih0YWJsZSwgewogICAgICBzdGFydFJvdzogcm93SW5kZXgsCiAgICAgIGVuZFJvdzogcm93SW5kZXgKICAgIH0pOwoKICAgIGZvciAoY29uc3QgewogICAgICBjZWxsLAogICAgICByb3csCiAgICAgIGNvbHVtbgogICAgfSBvZiB0YWJsZVdhbGtlcikgewogICAgICBpZiAoY2VsbCA9PT0gdGFibGVDZWxsKSB7CiAgICAgICAgcmV0dXJuIHsKICAgICAgICAgIHJvdywKICAgICAgICAgIGNvbHVtbgogICAgICAgIH07CiAgICAgIH0KICAgIH0KICB9CiAgLyoqCiAgICogQ3JlYXRlcyBhbiBlbXB0eSB0YWJsZSB3aXRoIHByb3BlciBzdHJ1Y3R1cmUuIFRoZSB0YWJsZSBuZWVkcyB0byBiZSBpbnNlcnRlZCBpbnRvIHRoZSBtb2RlbCwKICAgKiBpZS4gdXNpbmcge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbW9kZWx+TW9kZWwjaW5zZXJ0Q29udGVudH0gZnVuY3Rpb24uCiAgICoKICAgKgkJbW9kZWwuY2hhbmdlKCAoIHdyaXRlciApID0+IHsKICAgKgkJCS8vIENyZWF0ZSBhIHRhYmxlIG9mIDIgcm93cyBhbmQgNyBjb2x1bW5zOgogICAqCQkJY29uc3QgdGFibGUgPSB0YWJsZVV0aWxzLmNyZWF0ZVRhYmxlKCB3cml0ZXIsIDIsIDcpOwogICAqCiAgICoJCQkvLyBJbnNlcnQgdGFibGUgdG8gdGhlIG1vZGVsIGF0IHRoZSBiZXN0IHBvc2l0aW9uIHRha2luZyBjdXJyZW50IHNlbGVjdGlvbjoKICAgKgkJCW1vZGVsLmluc2VydENvbnRlbnQoIHRhYmxlICk7CiAgICoJCX0KICAgKgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC93cml0ZXJ+V3JpdGVyfSB3cml0ZXIgVGhlIG1vZGVsIHdyaXRlci4KICAgKiBAcGFyYW0ge051bWJlcn0gcm93cyBUaGUgbnVtYmVyIG9mIHJvd3MgdG8gY3JlYXRlLgogICAqIEBwYXJhbSB7TnVtYmVyfSBjb2x1bW5zIFRoZSBudW1iZXIgb2YgY29sdW1ucyB0byBjcmVhdGUuCiAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50fSBUaGUgY3JlYXRlZCB0YWJsZSBlbGVtZW50LgogICAqLwoKCiAgY3JlYXRlVGFibGUod3JpdGVyLCByb3dzLCBjb2x1bW5zKSB7CiAgICBjb25zdCB0YWJsZSA9IHdyaXRlci5jcmVhdGVFbGVtZW50KCd0YWJsZScpOwogICAgY3JlYXRlRW1wdHlSb3dzKHdyaXRlciwgdGFibGUsIDAsIHJvd3MsIGNvbHVtbnMpOwogICAgcmV0dXJuIHRhYmxlOwogIH0KICAvKioKICAgKiBJbnNlcnRzIHJvd3MgaW50byBhIHRhYmxlLgogICAqCiAgICoJCWVkaXRvci5wbHVnaW5zLmdldCggJ1RhYmxlVXRpbHMnICkuaW5zZXJ0Um93cyggdGFibGUsIHsgYXQ6IDEsIHJvd3M6IDIgfSApOwogICAqCiAgICogQXNzdW1pbmcgdGhlIHRhYmxlIG9uIHRoZSBsZWZ0LCB0aGUgYWJvdmUgY29kZSB3aWxsIHRyYW5zZm9ybSBpdCB0byB0aGUgdGFibGUgb24gdGhlIHJpZ2h0OgogICAqCiAgICoJCXJvdyBpbmRleAogICAqCQkgIDAgKy0tLSstLS0rLS0tKyAgICAgICBgYXRgID0gMSwgICAgICArLS0tKy0tLSstLS0rIDAKICAgKgkJICAgIHwgYSB8IGIgfCBjIHwgICAgICAgYHJvd3NgID0gMiwgICAgfCBhIHwgYiB8IGMgfAogICAqCQkgIDEgKyAgICstLS0rLS0tKyAgIDwtLSBpbnNlcnQgaGVyZSAgICArICAgKy0tLSstLS0rIDEKICAgKgkJICAgIHwgICB8IGQgfCBlIHwgICAgICAgICAgICAgICAgICAgICAgfCAgIHwgICB8ICAgfAogICAqCQkgIDIgKyAgICstLS0rLS0tKyAgICAgICB3aWxsIGdpdmU6ICAgICArICAgKy0tLSstLS0rIDIKICAgKgkJICAgIHwgICB8IGYgfCBnIHwgICAgICAgICAgICAgICAgICAgICAgfCAgIHwgICB8ICAgfAogICAqCQkgIDMgKy0tLSstLS0rLS0tKyAgICAgICAgICAgICAgICAgICAgICArICAgKy0tLSstLS0rIDMKICAgKgkJICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgIHwgZCB8IGUgfAogICAqCQkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArLS0tKy0tLSstLS0rIDQKICAgKgkJICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyAgICsgZiB8IGcgfAogICAqCQkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArLS0tKy0tLSstLS0rIDUKICAgKgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR9IHRhYmxlIFRoZSB0YWJsZSBtb2RlbCBlbGVtZW50IHdoZXJlIHRoZSByb3dzIHdpbGwgYmUgaW5zZXJ0ZWQuCiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMKICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYXQ9MF0gUm93IGluZGV4IGF0IHdoaWNoIHRoZSByb3dzIHdpbGwgYmUgaW5zZXJ0ZWQuCiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJvd3M9MV0gVGhlIG51bWJlciBvZiByb3dzIHRvIGluc2VydC4KICAgKi8KCgogIGluc2VydFJvd3ModGFibGUsIG9wdGlvbnMgPSB7fSkgewogICAgY29uc3QgbW9kZWwgPSB0aGlzLmVkaXRvci5tb2RlbDsKICAgIGNvbnN0IGluc2VydEF0ID0gb3B0aW9ucy5hdCB8fCAwOwogICAgY29uc3Qgcm93c1RvSW5zZXJ0ID0gb3B0aW9ucy5yb3dzIHx8IDE7CiAgICBtb2RlbC5jaGFuZ2Uod3JpdGVyID0+IHsKICAgICAgY29uc3QgaGVhZGluZ1Jvd3MgPSB0YWJsZS5nZXRBdHRyaWJ1dGUoJ2hlYWRpbmdSb3dzJykgfHwgMDsgLy8gSW5zZXJ0aW5nIHJvd3MgaW5zaWRlIGhlYWRpbmcgc2VjdGlvbiByZXF1aXJlcyB0byB1cGRhdGUgYGhlYWRpbmdSb3dzYCBhdHRyaWJ1dGUgYXMgdGhlIGhlYWRpbmcgc2VjdGlvbiB3aWxsIGdyb3cuCgogICAgICBpZiAoaGVhZGluZ1Jvd3MgPiBpbnNlcnRBdCkgewogICAgICAgIHdyaXRlci5zZXRBdHRyaWJ1dGUoJ2hlYWRpbmdSb3dzJywgaGVhZGluZ1Jvd3MgKyByb3dzVG9JbnNlcnQsIHRhYmxlKTsKICAgICAgfSAvLyBJbnNlcnRpbmcgYXQgdGhlIGVuZCBhbmQgYXQgdGhlIGJlZ2lubmluZyBvZiBhIHRhYmxlIGRvZXNuJ3QgcmVxdWlyZSB0byBjYWxjdWxhdGUgYW55dGhpbmcgc3BlY2lhbC4KCgogICAgICBpZiAoaW5zZXJ0QXQgPT09IDAgfHwgaW5zZXJ0QXQgPT09IHRhYmxlLmNoaWxkQ291bnQpIHsKICAgICAgICBjcmVhdGVFbXB0eVJvd3Mod3JpdGVyLCB0YWJsZSwgaW5zZXJ0QXQsIHJvd3NUb0luc2VydCwgdGhpcy5nZXRDb2x1bW5zKHRhYmxlKSk7CiAgICAgICAgcmV0dXJuOwogICAgICB9IC8vIEl0ZXJhdGUgb3ZlciBhbGwgcm93cyBhYm92ZSBpbnNlcnRlZCByb3dzIGluIG9yZGVyIHRvIGNoZWNrIGZvciByb3dzcGFubmVkIGNlbGxzLgoKCiAgICAgIGNvbnN0IHRhYmxlSXRlcmF0b3IgPSBuZXcgVGFibGVXYWxrZXIodGFibGUsIHsKICAgICAgICBlbmRSb3c6IGluc2VydEF0CiAgICAgIH0pOyAvLyBXaWxsIGhvbGQgbnVtYmVyIG9mIGNlbGxzIG5lZWRlZCB0byBpbnNlcnQgaW4gY3JlYXRlZCByb3dzLgogICAgICAvLyBUaGUgbnVtYmVyIG1pZ2h0IGJlIGRpZmZlcmVudCB0aGVuIHRhYmxlIGNlbGwgd2lkdGggd2hlbiB0aGVyZSBhcmUgcm93c3Bhbm5lZCBjZWxscy4KCiAgICAgIGxldCBjZWxsc1RvSW5zZXJ0ID0gMDsKCiAgICAgIGZvciAoY29uc3QgewogICAgICAgIHJvdywKICAgICAgICByb3dzcGFuLAogICAgICAgIGNvbHNwYW4sCiAgICAgICAgY2VsbAogICAgICB9IG9mIHRhYmxlSXRlcmF0b3IpIHsKICAgICAgICBjb25zdCBpc0JlZm9yZUluc2VydGVkUm93ID0gcm93IDwgaW5zZXJ0QXQ7CiAgICAgICAgY29uc3Qgb3ZlcmxhcHNJbnNlcnRlZFJvdyA9IHJvdyArIHJvd3NwYW4gPiBpbnNlcnRBdDsKCiAgICAgICAgaWYgKGlzQmVmb3JlSW5zZXJ0ZWRSb3cgJiYgb3ZlcmxhcHNJbnNlcnRlZFJvdykgewogICAgICAgICAgLy8gVGhpcyBjZWxsIG92ZXJsYXBzIGluc2VydGVkIHJvd3Mgc28gd2UgbmVlZCB0byBleHBhbmQgaXQgZnVydGhlci4KICAgICAgICAgIHdyaXRlci5zZXRBdHRyaWJ1dGUoJ3Jvd3NwYW4nLCByb3dzcGFuICsgcm93c1RvSW5zZXJ0LCBjZWxsKTsKICAgICAgICB9IC8vIENhbGN1bGF0ZSBob3cgbWFueSBjZWxscyB0byBpbnNlcnQgYmFzZWQgb24gdGhlIHdpZHRoIG9mIGNlbGxzIGluIGEgcm93IGF0IGluc2VydCBwb3NpdGlvbi4KICAgICAgICAvLyBJdCBtaWdodCBiZSBsb3dlciB0aGVuIHRhYmxlIHdpZHRoIGFzIHNvbWUgY2VsbHMgbWlnaHQgb3ZlcmxhcHMgaW5zZXJ0ZWQgcm93LgogICAgICAgIC8vIEluIHRoZSB0YWJsZSBhYm92ZSB0aGUgY2VsbCAnYScgb3ZlcmxhcHMgaW5zZXJ0ZWQgcm93IHNvIG9ubHkgdHdvIGVtcHR5IGNlbGxzIGFyZSBuZWVkIHRvIGJlIGNyZWF0ZWQuCgoKICAgICAgICBpZiAocm93ID09PSBpbnNlcnRBdCkgewogICAgICAgICAgY2VsbHNUb0luc2VydCArPSBjb2xzcGFuOwogICAgICAgIH0KICAgICAgfQoKICAgICAgY3JlYXRlRW1wdHlSb3dzKHdyaXRlciwgdGFibGUsIGluc2VydEF0LCByb3dzVG9JbnNlcnQsIGNlbGxzVG9JbnNlcnQpOwogICAgfSk7CiAgfQogIC8qKgogICAqIEluc2VydHMgY29sdW1ucyBpbnRvIGEgdGFibGUuCiAgICoKICAgKgkJZWRpdG9yLnBsdWdpbnMuZ2V0KCAnVGFibGVVdGlscycgKS5pbnNlcnRDb2x1bW5zKCB0YWJsZSwgeyBhdDogMSwgY29sdW1uczogMiB9ICk7CiAgICoKICAgKiBBc3N1bWluZyB0aGUgdGFibGUgb24gdGhlIGxlZnQsIHRoZSBhYm92ZSBjb2RlIHdpbGwgdHJhbnNmb3JtIGl0IHRvIHRoZSB0YWJsZSBvbiB0aGUgcmlnaHQ6CiAgICoKICAgKgkJMCAgIDEgICAyICAgMyAgICAgICAgICAgICAgICAgICAwICAgMSAgIDIgICAzICAgNCAgIDUKICAgKgkJKy0tLSstLS0rLS0tKyAgICAgICAgICAgICAgICAgICArLS0tKy0tLSstLS0rLS0tKy0tLSsKICAgKgkJfCBhICAgICB8IGIgfCAgICAgICAgICAgICAgICAgICB8IGEgICAgICAgICAgICAgfCBiIHwKICAgKgkJKyAgICAgICArLS0tKyAgICAgICAgICAgICAgICAgICArICAgICAgICAgICAgICAgKy0tLSsKICAgKgkJfCAgICAgICB8IGMgfCAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgfCBjIHwKICAgKgkJKy0tLSstLS0rLS0tKyAgICAgd2lsbCBnaXZlOiAgICArLS0tKy0tLSstLS0rLS0tKy0tLSsKICAgKgkJfCBkIHwgZSB8IGYgfCAgICAgICAgICAgICAgICAgICB8IGQgfCAgIHwgICB8IGUgfCBmIHwKICAgKgkJKy0tLSsgICArLS0tKyAgICAgICAgICAgICAgICAgICArLS0tKy0tLSstLS0rICAgKy0tLSsKICAgKgkJfCBnIHwgICB8IGggfCAgICAgICAgICAgICAgICAgICB8IGcgfCAgIHwgICB8ICAgfCBoIHwKICAgKgkJKy0tLSstLS0rLS0tKyAgICAgICAgICAgICAgICAgICArLS0tKy0tLSstLS0rLS0tKy0tLSsKICAgKgkJfCBpICAgICAgICAgfCAgICAgICAgICAgICAgICAgICB8IGkgICAgICAgICAgICAgICAgIHwKICAgKgkJKy0tLSstLS0rLS0tKyAgICAgICAgICAgICAgICAgICArLS0tKy0tLSstLS0rLS0tKy0tLSsKICAgKgkJICAgIF4tLS0tIGluc2VydCBoZXJlLCBgYXRgID0gMSwgYGNvbHVtbnNgID0gMgogICAqCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudH0gdGFibGUgVGhlIHRhYmxlIG1vZGVsIGVsZW1lbnQgd2hlcmUgdGhlIGNvbHVtbnMgd2lsbCBiZSBpbnNlcnRlZC4KICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucwogICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5hdD0wXSBDb2x1bW4gaW5kZXggYXQgd2hpY2ggdGhlIGNvbHVtbnMgd2lsbCBiZSBpbnNlcnRlZC4KICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY29sdW1ucz0xXSBUaGUgbnVtYmVyIG9mIGNvbHVtbnMgdG8gaW5zZXJ0LgogICAqLwoKCiAgaW5zZXJ0Q29sdW1ucyh0YWJsZSwgb3B0aW9ucyA9IHt9KSB7CiAgICBjb25zdCBtb2RlbCA9IHRoaXMuZWRpdG9yLm1vZGVsOwogICAgY29uc3QgaW5zZXJ0QXQgPSBvcHRpb25zLmF0IHx8IDA7CiAgICBjb25zdCBjb2x1bW5zVG9JbnNlcnQgPSBvcHRpb25zLmNvbHVtbnMgfHwgMTsKICAgIG1vZGVsLmNoYW5nZSh3cml0ZXIgPT4gewogICAgICBjb25zdCBoZWFkaW5nQ29sdW1ucyA9IHRhYmxlLmdldEF0dHJpYnV0ZSgnaGVhZGluZ0NvbHVtbnMnKTsgLy8gSW5zZXJ0aW5nIGNvbHVtbnMgaW5zaWRlIGhlYWRpbmcgc2VjdGlvbiByZXF1aXJlcyB0byB1cGRhdGUgYGhlYWRpbmdDb2x1bW5zYCBhdHRyaWJ1dGUgYXMgdGhlIGhlYWRpbmcgc2VjdGlvbiB3aWxsIGdyb3cuCgogICAgICBpZiAoaW5zZXJ0QXQgPCBoZWFkaW5nQ29sdW1ucykgewogICAgICAgIHdyaXRlci5zZXRBdHRyaWJ1dGUoJ2hlYWRpbmdDb2x1bW5zJywgaGVhZGluZ0NvbHVtbnMgKyBjb2x1bW5zVG9JbnNlcnQsIHRhYmxlKTsKICAgICAgfQoKICAgICAgY29uc3QgdGFibGVDb2x1bW5zID0gdGhpcy5nZXRDb2x1bW5zKHRhYmxlKTsgLy8gSW5zZXJ0aW5nIGF0IHRoZSBlbmQgYW5kIGF0IHRoZSBiZWdpbm5pbmcgb2YgYSB0YWJsZSBkb2Vzbid0IHJlcXVpcmUgdG8gY2FsY3VsYXRlIGFueXRoaW5nIHNwZWNpYWwuCgogICAgICBpZiAoaW5zZXJ0QXQgPT09IDAgfHwgdGFibGVDb2x1bW5zID09PSBpbnNlcnRBdCkgewogICAgICAgIGZvciAoY29uc3QgdGFibGVSb3cgb2YgdGFibGUuZ2V0Q2hpbGRyZW4oKSkgewogICAgICAgICAgY3JlYXRlQ2VsbHMoY29sdW1uc1RvSW5zZXJ0LCB3cml0ZXIsIHdyaXRlci5jcmVhdGVQb3NpdGlvbkF0KHRhYmxlUm93LCBpbnNlcnRBdCA/ICdlbmQnIDogMCkpOwogICAgICAgIH0KCiAgICAgICAgcmV0dXJuOwogICAgICB9CgogICAgICBjb25zdCB0YWJsZVdhbGtlciA9IG5ldyBUYWJsZVdhbGtlcih0YWJsZSwgewogICAgICAgIGNvbHVtbjogaW5zZXJ0QXQsCiAgICAgICAgaW5jbHVkZVNwYW5uZWQ6IHRydWUKICAgICAgfSk7CgogICAgICBmb3IgKGNvbnN0IHsKICAgICAgICByb3csCiAgICAgICAgY2VsbCwKICAgICAgICBjZWxsSW5kZXgKICAgICAgfSBvZiB0YWJsZVdhbGtlcikgewogICAgICAgIC8vIFdoZW4gaXRlcmF0aW5nIG92ZXIgY29sdW1uIHRoZSB0YWJsZSB3YWxrZXIgb3V0cHV0cyBlaXRoZXI6CiAgICAgICAgLy8gLSBjZWxscyBhdCBnaXZlbiBjb2x1bW4gaW5kZXggKGNlbGwgImUiIGZyb20gbWV0aG9kIGRvY3MpLAogICAgICAgIC8vIC0gc3Bhbm5lZCBjb2x1bW5zIChzcGFubmVkIGNlbGwgZnJvbSByb3cgYmV0d2VlbiBjZWxscyAiZyIgYW5kICJoIiAtIHNwYW5uZWQgYnkgImUiLCBvbmx5IGlmIGBpbmNsdWRlU3Bhbm5lZDogdHJ1ZWApLAogICAgICAgIC8vIC0gb3IgYSBjZWxsIGZyb20gdGhlIHNhbWUgcm93IHdoaWNoIHNwYW5zIG92ZXIgdGhpcyBjb2x1bW4gKGNlbGwgImEiKS4KICAgICAgICBjb25zdCByb3dzcGFuID0gcGFyc2VJbnQoY2VsbC5nZXRBdHRyaWJ1dGUoJ3Jvd3NwYW4nKSB8fCAxKTsKICAgICAgICBjb25zdCBjb2xzcGFuID0gcGFyc2VJbnQoY2VsbC5nZXRBdHRyaWJ1dGUoJ2NvbHNwYW4nKSB8fCAxKTsKCiAgICAgICAgaWYgKGNlbGwuaW5kZXggIT09IGluc2VydEF0ICYmIGNvbHNwYW4gPiAxKSB7CiAgICAgICAgICAvLyBJZiBjb2x1bW4gaXMgZGlmZmVyZW50IHRoYW4gYGluc2VydEF0YCwgaXQgaXMgYSBjZWxsIHRoYXQgc3BhbnMgb3ZlciBhbiBpbnNlcnRlZCBjb2x1bW4gKGNlbGwgImEiICYgImkiKS4KICAgICAgICAgIC8vIEZvciBzdWNoIGNlbGxzIGV4cGFuZCB0aGVtIGJ5IGEgbnVtYmVyIG9mIGNvbHVtbnMgaW5zZXJ0ZWQuCiAgICAgICAgICB3cml0ZXIuc2V0QXR0cmlidXRlKCdjb2xzcGFuJywgY29sc3BhbiArIGNvbHVtbnNUb0luc2VydCwgY2VsbCk7IC8vIFRoZSBgaW5jbHVkZVNwYW5uZWRgIG9wdGlvbiB3aWxsIG91dHB1dCB0aGUgImVtcHR5Ii9zcGFubmVkIGNvbHVtbiBzbyBza2lwIHRoaXMgcm93IGFscmVhZHkuCgogICAgICAgICAgdGFibGVXYWxrZXIuc2tpcFJvdyhyb3cpOyAvLyBUaGlzIGNlbGwgd2lsbCBvdmVybGFwIGNlbGxzIGluIHJvd3MgYmVsb3cgc28gc2tpcCB0aGVtIGFsc28gKGJlY2F1c2Ugb2YgYGluY2x1ZGVTcGFubmVkYCBvcHRpb24pIC0gKGNlbGwgImEiKQoKICAgICAgICAgIGlmIChyb3dzcGFuID4gMSkgewogICAgICAgICAgICBmb3IgKGxldCBpID0gcm93ICsgMTsgaSA8IHJvdyArIHJvd3NwYW47IGkrKykgewogICAgICAgICAgICAgIHRhYmxlV2Fsa2VyLnNraXBSb3coaSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9IGVsc2UgewogICAgICAgICAgLy8gSXQncyBlaXRoZXIgY2VsbCBhdCB0aGlzIGNvbHVtbiBpbmRleCBvciBzcGFubmVkIGNlbGwgYnkgYSByb3dzcGFubmVkIGNlbGwgZnJvbSByb3cgYWJvdmUuCiAgICAgICAgICAvLyBJbiB0YWJsZSBhYm92ZSBpdCdzIGNlbGwgImUiIGFuZCBhIHNwYW5uZWQgcG9zaXRpb24gZnJvbSByb3cgYmVsb3cgKGVtcHR5IGNlbGwgYmV0d2VlbiBjZWxscyAiZyIgYW5kICJoIikKICAgICAgICAgIGNvbnN0IGluc2VydFBvc2l0aW9uID0gd3JpdGVyLmNyZWF0ZVBvc2l0aW9uQXQodGFibGUuZ2V0Q2hpbGQocm93KSwgY2VsbEluZGV4KTsKICAgICAgICAgIGNyZWF0ZUNlbGxzKGNvbHVtbnNUb0luc2VydCwgd3JpdGVyLCBpbnNlcnRQb3NpdGlvbik7CiAgICAgICAgfQogICAgICB9CiAgICB9KTsKICB9CiAgLyoqCiAgICogRGl2aWRlcyBhIHRhYmxlIGNlbGwgdmVydGljYWxseSBpbnRvIHNldmVyYWwgb25lcy4KICAgKgogICAqIFRoZSBjZWxsIHdpbGwgYmUgdmlzdWFsbHkgc3BsaXQgaW50byBtb3JlIGNlbGxzIGJ5IHVwZGF0aW5nIGNvbHNwYW5zIG9mIG90aGVyIGNlbGxzIGluIGEgY29sdW1uCiAgICogYW5kIGluc2VydGluZyBjZWxscyAoY29sdW1ucykgYWZ0ZXIgdGhhdCBjZWxsLgogICAqCiAgICogSW4gdGhlIHRhYmxlIGJlbG93LCBpZiBjZWxsICJhIiBpcyBzcGxpdCB0byAzIGNlbGxzOgogICAqCiAgICoJCSstLS0rLS0tKy0tLSsKICAgKgkJfCBhIHwgYiB8IGMgfAogICAqCQkrLS0tKy0tLSstLS0rCiAgICoJCXwgZCB8IGUgfCBmIHwKICAgKgkJKy0tLSstLS0rLS0tKwogICAqCiAgICogaXQgd2lsbCByZXN1bHQgaW4gdGhlIHRhYmxlIGJlbG93OgogICAqCiAgICoJCSstLS0rLS0tKy0tLSstLS0rLS0tKwogICAqCQl8IGEgfCAgIHwgICB8IGIgfCBjIHwKICAgKgkJKy0tLSstLS0rLS0tKy0tLSstLS0rCiAgICoJCXwgZCAgICAgICAgIHwgZSB8IGYgfAogICAqCQkrLS0tKy0tLSstLS0rLS0tKy0tLSsKICAgKgogICAqIFNvIGNlbGwgImQiIHdpbGwgZ2V0IGl0cyBgY29sc3BhbmAgdXBkYXRlZCB0byBgM2AgYW5kIDIgY2VsbHMgd2lsbCBiZSBhZGRlZCAoMiBjb2x1bW5zIHdpbGwgYmUgY3JlYXRlZCkuCiAgICoKICAgKiBTcGxpdHRpbmcgYSBjZWxsIHRoYXQgYWxyZWFkeSBoYXMgYSBgY29sc3BhbmAgYXR0cmlidXRlIHNldCB3aWxsIGRpc3RyaWJ1dGUgdGhlIGNlbGwgYGNvbHNwYW5gIGV2ZW5seSBhbmQgdGhlIHJlbWFpbmRlcgogICAqIHdpbGwgYmUgbGVmdCB0byB0aGUgb3JpZ2luYWwgY2VsbDoKICAgKgogICAqCQkrLS0tKy0tLSstLS0rCiAgICoJCXwgYSAgICAgICAgIHwKICAgKgkJKy0tLSstLS0rLS0tKwogICAqCQl8IGIgfCBjIHwgZCB8CiAgICoJCSstLS0rLS0tKy0tLSsKICAgKgogICAqIFNwbGl0dGluZyBjZWxsICJhIiB3aXRoIGBjb2xzcGFuPTNgIHRvIDIgY2VsbHMgd2lsbCBjcmVhdGUgMSBjZWxsIHdpdGggYSBgY29sc3Bhbj1hYCBhbmQgY2VsbCAiYSIgdGhhdCB3aWxsIGhhdmUgYGNvbHNwYW49MmA6CiAgICoKICAgKgkJKy0tLSstLS0rLS0tKwogICAqCQl8IGEgICAgIHwgICB8CiAgICoJCSstLS0rLS0tKy0tLSsKICAgKgkJfCBiIHwgYyB8IGQgfAogICAqCQkrLS0tKy0tLSstLS0rCiAgICoKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50fSB0YWJsZUNlbGwKICAgKiBAcGFyYW0ge051bWJlcn0gbnVtYmVyT2ZDZWxscwogICAqLwoKCiAgc3BsaXRDZWxsVmVydGljYWxseSh0YWJsZUNlbGwsIG51bWJlck9mQ2VsbHMgPSAyKSB7CiAgICBjb25zdCBtb2RlbCA9IHRoaXMuZWRpdG9yLm1vZGVsOwogICAgY29uc3QgdGFibGVSb3cgPSB0YWJsZUNlbGwucGFyZW50OwogICAgY29uc3QgdGFibGUgPSB0YWJsZVJvdy5wYXJlbnQ7CiAgICBjb25zdCByb3dzcGFuID0gcGFyc2VJbnQodGFibGVDZWxsLmdldEF0dHJpYnV0ZSgncm93c3BhbicpIHx8IDEpOwogICAgY29uc3QgY29sc3BhbiA9IHBhcnNlSW50KHRhYmxlQ2VsbC5nZXRBdHRyaWJ1dGUoJ2NvbHNwYW4nKSB8fCAxKTsKICAgIG1vZGVsLmNoYW5nZSh3cml0ZXIgPT4gewogICAgICAvLyBGaXJzdCBjaGVjayAtIHRoZSBjZWxsIHNwYW5zIG92ZXIgbXVsdGlwbGUgcm93cyBzbyBiZWZvcmUgZG9pbmcgYW55dGhpbmcgZWxzZSBqdXN0IHNwbGl0IHRoaXMgY2VsbC4KICAgICAgaWYgKGNvbHNwYW4gPiAxKSB7CiAgICAgICAgLy8gR2V0IHNwYW5zIG9mIG5ldyAoaW5zZXJ0ZWQpIGNlbGxzIGFuZCBzcGFuIHRvIHVwZGF0ZSBvZiBzcGxpdCBjZWxsLgogICAgICAgIGNvbnN0IHsKICAgICAgICAgIG5ld0NlbGxzU3BhbiwKICAgICAgICAgIHVwZGF0ZWRTcGFuCiAgICAgICAgfSA9IGJyZWFrU3BhbkV2ZW5seShjb2xzcGFuLCBudW1iZXJPZkNlbGxzKTsKICAgICAgICB1cGRhdGVOdW1lcmljQXR0cmlidXRlKCdjb2xzcGFuJywgdXBkYXRlZFNwYW4sIHRhYmxlQ2VsbCwgd3JpdGVyKTsgLy8gRWFjaCBpbnNlcnRlZCBjZWxsIHdpbGwgaGF2ZSB0aGUgc2FtZSBhdHRyaWJ1dGVzOgoKICAgICAgICBjb25zdCBuZXdDZWxsc0F0dHJpYnV0ZXMgPSB7fTsgLy8gRG8gbm90IHN0b3JlIGRlZmF1bHQgdmFsdWUgaW4gdGhlIG1vZGVsLgoKICAgICAgICBpZiAobmV3Q2VsbHNTcGFuID4gMSkgewogICAgICAgICAgbmV3Q2VsbHNBdHRyaWJ1dGVzLmNvbHNwYW4gPSBuZXdDZWxsc1NwYW47CiAgICAgICAgfSAvLyBDb3B5IHJvd3NwYW4gb2Ygc3BsaXQgY2VsbC4KCgogICAgICAgIGlmIChyb3dzcGFuID4gMSkgewogICAgICAgICAgbmV3Q2VsbHNBdHRyaWJ1dGVzLnJvd3NwYW4gPSByb3dzcGFuOwogICAgICAgIH0KCiAgICAgICAgY29uc3QgY2VsbHNUb0luc2VydCA9IGNvbHNwYW4gPiBudW1iZXJPZkNlbGxzID8gbnVtYmVyT2ZDZWxscyAtIDEgOiBjb2xzcGFuIC0gMTsKICAgICAgICBjcmVhdGVDZWxscyhjZWxsc1RvSW5zZXJ0LCB3cml0ZXIsIHdyaXRlci5jcmVhdGVQb3NpdGlvbkFmdGVyKHRhYmxlQ2VsbCksIG5ld0NlbGxzQXR0cmlidXRlcyk7CiAgICAgIH0gLy8gU2Vjb25kIGNoZWNrIC0gdGhlIGNlbGwgaGFzIGNvbHNwYW4gb2YgMSBvciB3ZSBuZWVkIHRvIGNyZWF0ZSBtb3JlIGNlbGxzIHRoZW4gdGhlIGN1cnJlbnRseSBvbmUgc3BhbnMgb3Zlci4KCgogICAgICBpZiAoY29sc3BhbiA8IG51bWJlck9mQ2VsbHMpIHsKICAgICAgICBjb25zdCBjZWxsc1RvSW5zZXJ0ID0gbnVtYmVyT2ZDZWxscyAtIGNvbHNwYW47IC8vIEZpcnN0IHN0ZXA6IGV4cGFuZCBjZWxscyBvbiB0aGUgc2FtZSBjb2x1bW4gYXMgc3BsaXQgY2VsbC4KCiAgICAgICAgY29uc3QgdGFibGVNYXAgPSBbLi4ubmV3IFRhYmxlV2Fsa2VyKHRhYmxlKV07IC8vIEdldCB0aGUgY29sdW1uIGluZGV4IG9mIHNwbGl0IGNlbGwuCgogICAgICAgIGNvbnN0IHsKICAgICAgICAgIGNvbHVtbjogc3BsaXRDZWxsQ29sdW1uCiAgICAgICAgfSA9IHRhYmxlTWFwLmZpbmQoKHsKICAgICAgICAgIGNlbGwKICAgICAgICB9KSA9PiBjZWxsID09PSB0YWJsZUNlbGwpOyAvLyBGaW5kIGNlbGxzIHdoaWNoIG5lZWRzIHRvIGJlIGV4cGFuZGVkIHZlcnRpY2FsbHkgLSB0aG9zZSBvbiB0aGUgc2FtZSBjb2x1bW4gb3IgdGhvc2UgdGhhdCBzcGFucyBvdmVyIHNwbGl0IGNlbGwncyBjb2x1bW4uCgogICAgICAgIGNvbnN0IGNlbGxzVG9VcGRhdGUgPSB0YWJsZU1hcC5maWx0ZXIoKHsKICAgICAgICAgIGNlbGwsCiAgICAgICAgICBjb2xzcGFuLAogICAgICAgICAgY29sdW1uCiAgICAgICAgfSkgPT4gewogICAgICAgICAgY29uc3QgaXNPblNhbWVDb2x1bW4gPSBjZWxsICE9PSB0YWJsZUNlbGwgJiYgY29sdW1uID09PSBzcGxpdENlbGxDb2x1bW47CiAgICAgICAgICBjb25zdCBzcGFuc092ZXJDb2x1bW4gPSBjb2x1bW4gPCBzcGxpdENlbGxDb2x1bW4gJiYgY29sdW1uICsgY29sc3BhbiA+IHNwbGl0Q2VsbENvbHVtbjsKICAgICAgICAgIHJldHVybiBpc09uU2FtZUNvbHVtbiB8fCBzcGFuc092ZXJDb2x1bW47CiAgICAgICAgfSk7IC8vIEV4cGFuZCBjZWxscyB2ZXJ0aWNhbGx5LgoKICAgICAgICBmb3IgKGNvbnN0IHsKICAgICAgICAgIGNlbGwsCiAgICAgICAgICBjb2xzcGFuCiAgICAgICAgfSBvZiBjZWxsc1RvVXBkYXRlKSB7CiAgICAgICAgICB3cml0ZXIuc2V0QXR0cmlidXRlKCdjb2xzcGFuJywgY29sc3BhbiArIGNlbGxzVG9JbnNlcnQsIGNlbGwpOwogICAgICAgIH0gLy8gU2Vjb25kIHN0ZXA6IGNyZWF0ZSBjb2x1bW5zIGFmdGVyIHNwbGl0IGNlbGwuCiAgICAgICAgLy8gRWFjaCBpbnNlcnRlZCBjZWxsIHdpbGwgaGF2ZSB0aGUgc2FtZSBhdHRyaWJ1dGVzOgoKCiAgICAgICAgY29uc3QgbmV3Q2VsbHNBdHRyaWJ1dGVzID0ge307IC8vIERvIG5vdCBzdG9yZSBkZWZhdWx0IHZhbHVlIGluIHRoZSBtb2RlbC4KICAgICAgICAvLyBDb3B5IHJvd3NwYW4gb2Ygc3BsaXQgY2VsbC4KCiAgICAgICAgaWYgKHJvd3NwYW4gPiAxKSB7CiAgICAgICAgICBuZXdDZWxsc0F0dHJpYnV0ZXMucm93c3BhbiA9IHJvd3NwYW47CiAgICAgICAgfQoKICAgICAgICBjcmVhdGVDZWxscyhjZWxsc1RvSW5zZXJ0LCB3cml0ZXIsIHdyaXRlci5jcmVhdGVQb3NpdGlvbkFmdGVyKHRhYmxlQ2VsbCksIG5ld0NlbGxzQXR0cmlidXRlcyk7CiAgICAgICAgY29uc3QgaGVhZGluZ0NvbHVtbnMgPSB0YWJsZS5nZXRBdHRyaWJ1dGUoJ2hlYWRpbmdDb2x1bW5zJykgfHwgMDsgLy8gVXBkYXRlIGhlYWRpbmcgc2VjdGlvbiBpZiBzcGxpdCBjZWxsIGlzIGluIGhlYWRpbmcgc2VjdGlvbi4KCiAgICAgICAgaWYgKGhlYWRpbmdDb2x1bW5zID4gc3BsaXRDZWxsQ29sdW1uKSB7CiAgICAgICAgICB1cGRhdGVOdW1lcmljQXR0cmlidXRlKCdoZWFkaW5nQ29sdW1ucycsIGhlYWRpbmdDb2x1bW5zICsgY2VsbHNUb0luc2VydCwgdGFibGUsIHdyaXRlcik7CiAgICAgICAgfQogICAgICB9CiAgICB9KTsKICB9CiAgLyoqCiAgICogRGl2aWRlcyBhIHRhYmxlIGNlbGwgaG9yaXpvbnRhbGx5IGludG8gc2V2ZXJhbCBvbmVzLgogICAqCiAgICogVGhlIGNlbGwgd2lsbCBiZSB2aXN1YWxseSBzcGxpdCBpbnRvIG1vcmUgY2VsbHMgYnkgdXBkYXRpbmcgcm93c3BhbnMgb2Ygb3RoZXIgY2VsbHMgaW4gdGhlIHJvdyBhbmQgaW5zZXJ0aW5nIHJvd3Mgd2l0aCBhIHNpbmdsZSBjZWxsCiAgICogYmVsb3cuCiAgICoKICAgKiBJZiBpbiB0aGUgdGFibGUgYmVsb3cgY2VsbCAiYiIgaXMgc3BsaXQgdG8gMyBjZWxsczoKICAgKgogICAqCQkrLS0tKy0tLSstLS0rCiAgICoJCXwgYSB8IGIgfCBjIHwKICAgKgkJKy0tLSstLS0rLS0tKwogICAqCQl8IGQgfCBlIHwgZiB8CiAgICoJCSstLS0rLS0tKy0tLSsKICAgKgogICAqIEl0IHdpbGwgcmVzdWx0IGluIHRoZSB0YWJsZSBiZWxvdzoKICAgKgogICAqCQkrLS0tKy0tLSstLS0rCiAgICoJCXwgYSB8IGIgfCBjIHwKICAgKgkJKyAgICstLS0rICAgKwogICAqCQl8ICAgfCAgIHwgICB8CiAgICoJCSsgICArLS0tKyAgICsKICAgKgkJfCAgIHwgICB8ICAgfAogICAqCQkrLS0tKy0tLSstLS0rCiAgICoJCXwgZCB8IGUgfCBmIHwKICAgKgkJKy0tLSstLS0rLS0tKwogICAqCiAgICogU28gY2VsbHMgImEiIGFuZCAiYiIgd2lsbCBnZXQgdGhlaXIgYHJvd3NwYW5gIHVwZGF0ZWQgdG8gYDNgIGFuZCAyIHJvd3Mgd2l0aCBhIHNpbmdsZSBjZWxsIHdpbGwgYmUgYWRkZWQuCiAgICoKICAgKiBTcGxpdHRpbmcgYSBjZWxsIHRoYXQgYWxyZWFkeSBoYXMgYSBgcm93c3BhbmAgYXR0cmlidXRlIHNldCB3aWxsIGRpc3RyaWJ1dGUgdGhlIGNlbGwgYHJvd3NwYW5gIGV2ZW5seSBhbmQgdGhlIHJlbWFpbmRlcgogICAqIHdpbGwgYmUgbGVmdCB0byB0aGUgb3JpZ2luYWwgY2VsbDoKICAgKgogICAqCQkrLS0tKy0tLSstLS0rCiAgICoJCXwgYSB8IGIgfCBjIHwKICAgKgkJKyAgICstLS0rLS0tKwogICAqCQl8ICAgfCBkIHwgZSB8CiAgICoJCSsgICArLS0tKy0tLSsKICAgKgkJfCAgIHwgZiB8IGcgfAogICAqCQkrICAgKy0tLSstLS0rCiAgICoJCXwgICB8IGggfCBpIHwKICAgKgkJKy0tLSstLS0rLS0tKwogICAqCiAgICogU3BsaXR0aW5nIGNlbGwgImEiIHdpdGggYHJvd3NwYW49NGAgdG8gMyBjZWxscyB3aWxsIGNyZWF0ZSAyIGNlbGxzIHdpdGggYSBgcm93c3Bhbj0xYCBhbmQgY2VsbCAiYSIgd2lsbCBoYXZlIGByb3dzcGFuPTJgOgogICAqCiAgICoJCSstLS0rLS0tKy0tLSsKICAgKgkJfCBhIHwgYiB8IGMgfAogICAqCQkrICAgKy0tLSstLS0rCiAgICoJCXwgICB8IGQgfCBlIHwKICAgKgkJKy0tLSstLS0rLS0tKwogICAqCQl8ICAgfCBmIHwgZyB8CiAgICoJCSstLS0rLS0tKy0tLSsKICAgKgkJfCAgIHwgaCB8IGkgfAogICAqCQkrLS0tKy0tLSstLS0rCiAgICoKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50fSB0YWJsZUNlbGwKICAgKiBAcGFyYW0ge051bWJlcn0gbnVtYmVyT2ZDZWxscwogICAqLwoKCiAgc3BsaXRDZWxsSG9yaXpvbnRhbGx5KHRhYmxlQ2VsbCwgbnVtYmVyT2ZDZWxscyA9IDIpIHsKICAgIGNvbnN0IG1vZGVsID0gdGhpcy5lZGl0b3IubW9kZWw7CiAgICBjb25zdCB0YWJsZVJvdyA9IHRhYmxlQ2VsbC5wYXJlbnQ7CiAgICBjb25zdCB0YWJsZSA9IHRhYmxlUm93LnBhcmVudDsKICAgIGNvbnN0IHNwbGl0Q2VsbFJvdyA9IHRhYmxlLmdldENoaWxkSW5kZXgodGFibGVSb3cpOwogICAgY29uc3Qgcm93c3BhbiA9IHBhcnNlSW50KHRhYmxlQ2VsbC5nZXRBdHRyaWJ1dGUoJ3Jvd3NwYW4nKSB8fCAxKTsKICAgIGNvbnN0IGNvbHNwYW4gPSBwYXJzZUludCh0YWJsZUNlbGwuZ2V0QXR0cmlidXRlKCdjb2xzcGFuJykgfHwgMSk7CiAgICBtb2RlbC5jaGFuZ2Uod3JpdGVyID0+IHsKICAgICAgLy8gRmlyc3QgY2hlY2sgLSB0aGUgY2VsbCBzcGFucyBvdmVyIG11bHRpcGxlIHJvd3Mgc28gYmVmb3JlIGRvaW5nIGFueXRoaW5nIGVsc2UganVzdCBzcGxpdCB0aGlzIGNlbGwuCiAgICAgIGlmIChyb3dzcGFuID4gMSkgewogICAgICAgIC8vIENhY2hlIHRhYmxlIG1hcCBiZWZvcmUgdXBkYXRpbmcgdGFibGUuCiAgICAgICAgY29uc3QgdGFibGVNYXAgPSBbLi4ubmV3IFRhYmxlV2Fsa2VyKHRhYmxlLCB7CiAgICAgICAgICBzdGFydFJvdzogc3BsaXRDZWxsUm93LAogICAgICAgICAgZW5kUm93OiBzcGxpdENlbGxSb3cgKyByb3dzcGFuIC0gMSwKICAgICAgICAgIGluY2x1ZGVTcGFubmVkOiB0cnVlCiAgICAgICAgfSldOyAvLyBHZXQgc3BhbnMgb2YgbmV3IChpbnNlcnRlZCkgY2VsbHMgYW5kIHNwYW4gdG8gdXBkYXRlIG9mIHNwbGl0IGNlbGwuCgogICAgICAgIGNvbnN0IHsKICAgICAgICAgIG5ld0NlbGxzU3BhbiwKICAgICAgICAgIHVwZGF0ZWRTcGFuCiAgICAgICAgfSA9IGJyZWFrU3BhbkV2ZW5seShyb3dzcGFuLCBudW1iZXJPZkNlbGxzKTsKICAgICAgICB1cGRhdGVOdW1lcmljQXR0cmlidXRlKCdyb3dzcGFuJywgdXBkYXRlZFNwYW4sIHRhYmxlQ2VsbCwgd3JpdGVyKTsKICAgICAgICBjb25zdCB7CiAgICAgICAgICBjb2x1bW46IGNlbGxDb2x1bW4KICAgICAgICB9ID0gdGFibGVNYXAuZmluZCgoewogICAgICAgICAgY2VsbAogICAgICAgIH0pID0+IGNlbGwgPT09IHRhYmxlQ2VsbCk7IC8vIEVhY2ggaW5zZXJ0ZWQgY2VsbCB3aWxsIGhhdmUgdGhlIHNhbWUgYXR0cmlidXRlczoKCiAgICAgICAgY29uc3QgbmV3Q2VsbHNBdHRyaWJ1dGVzID0ge307IC8vIERvIG5vdCBzdG9yZSBkZWZhdWx0IHZhbHVlIGluIHRoZSBtb2RlbC4KCiAgICAgICAgaWYgKG5ld0NlbGxzU3BhbiA+IDEpIHsKICAgICAgICAgIG5ld0NlbGxzQXR0cmlidXRlcy5yb3dzcGFuID0gbmV3Q2VsbHNTcGFuOwogICAgICAgIH0gLy8gQ29weSBjb2xzcGFuIG9mIHNwbGl0IGNlbGwuCgoKICAgICAgICBpZiAoY29sc3BhbiA+IDEpIHsKICAgICAgICAgIG5ld0NlbGxzQXR0cmlidXRlcy5jb2xzcGFuID0gY29sc3BhbjsKICAgICAgICB9CgogICAgICAgIGZvciAoY29uc3QgewogICAgICAgICAgY29sdW1uLAogICAgICAgICAgcm93LAogICAgICAgICAgY2VsbEluZGV4CiAgICAgICAgfSBvZiB0YWJsZU1hcCkgewogICAgICAgICAgLy8gQXMgYm90aCBuZXdseSBjcmVhdGVkIGNlbGxzIGFuZCB0aGUgc3BsaXQgY2VsbCBtaWdodCBoYXZlIHJvd3NwYW4sCiAgICAgICAgICAvLyB0aGUgaW5zZXJ0aW9uIG9mIG5ldyBjZWxscyBtdXN0IGdvIHRvIGFwcHJvcHJpYXRlIHJvd3M6CiAgICAgICAgICAvLwogICAgICAgICAgLy8gMS4gSXQncyBhIHJvdyBhZnRlciBzcGxpdCBjZWxsICsgaXQncyBoZWlnaHQuCiAgICAgICAgICBjb25zdCBpc0FmdGVyU3BsaXRDZWxsID0gcm93ID49IHNwbGl0Q2VsbFJvdyArIHVwZGF0ZWRTcGFuOyAvLyAyLiBJcyBvbiB0aGUgc2FtZSBjb2x1bW4uCgogICAgICAgICAgY29uc3QgaXNPblNhbWVDb2x1bW4gPSBjb2x1bW4gPT09IGNlbGxDb2x1bW47IC8vIDMuIEFuZCBpdCdzIHJvdyBpbmRleCBpcyBhZnRlciBwcmV2aW91cyBjZWxsIGhlaWdodC4KCiAgICAgICAgICBjb25zdCBpc0luRXZlbmx5U3BsaXRSb3cgPSAocm93ICsgc3BsaXRDZWxsUm93ICsgdXBkYXRlZFNwYW4pICUgbmV3Q2VsbHNTcGFuID09PSAwOwoKICAgICAgICAgIGlmIChpc0FmdGVyU3BsaXRDZWxsICYmIGlzT25TYW1lQ29sdW1uICYmIGlzSW5FdmVubHlTcGxpdFJvdykgewogICAgICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHdyaXRlci5jcmVhdGVQb3NpdGlvbkF0KHRhYmxlLmdldENoaWxkKHJvdyksIGNlbGxJbmRleCk7CiAgICAgICAgICAgIGNyZWF0ZUNlbGxzKDEsIHdyaXRlciwgcG9zaXRpb24sIG5ld0NlbGxzQXR0cmlidXRlcyk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9IC8vIFNlY29uZCBjaGVjayAtIHRoZSBjZWxsIGhhcyByb3dzcGFuIG9mIDEgb3Igd2UgbmVlZCB0byBjcmVhdGUgbW9yZSBjZWxscyB0aGFuIHRoZSBjdXJyZW50IGNlbGwgc3BhbnMgb3Zlci4KCgogICAgICBpZiAocm93c3BhbiA8IG51bWJlck9mQ2VsbHMpIHsKICAgICAgICAvLyBXZSBhbHJlYWR5IHNwbGl0IHRoZSBjZWxsIGluIGNoZWNrIG9uZSBzbyBoZXJlIHdlIHNwbGl0IHRvIHRoZSByZW1haW5pbmcgbnVtYmVyIG9mIGNlbGxzIG9ubHkuCiAgICAgICAgY29uc3QgY2VsbHNUb0luc2VydCA9IG51bWJlck9mQ2VsbHMgLSByb3dzcGFuOyAvLyBUaGlzIGNoZWNrIGlzIG5lZWRlZCBzaW5jZSB3ZSBuZWVkIHRvIGNoZWNrIGlmIHRoZXJlIGFyZSBhbnkgY2VsbHMgZnJvbSBwcmV2aW91cyByb3dzIHRoYW4gc3BhbnMgb3ZlciB0aGlzIGNlbGwncyByb3cuCgogICAgICAgIGNvbnN0IHRhYmxlTWFwID0gWy4uLm5ldyBUYWJsZVdhbGtlcih0YWJsZSwgewogICAgICAgICAgc3RhcnRSb3c6IDAsCiAgICAgICAgICBlbmRSb3c6IHNwbGl0Q2VsbFJvdwogICAgICAgIH0pXTsgLy8gRmlyc3Qgc3RlcDogZXhwYW5kIGNlbGxzLgoKICAgICAgICBmb3IgKGNvbnN0IHsKICAgICAgICAgIGNlbGwsCiAgICAgICAgICByb3dzcGFuLAogICAgICAgICAgcm93CiAgICAgICAgfSBvZiB0YWJsZU1hcCkgewogICAgICAgICAgLy8gRXhwYW5kIHJvd3NwYW4gb2YgY2VsbHMgdGhhdCBhcmUgZWl0aGVyOgogICAgICAgICAgLy8gLSBvbiB0aGUgc2FtZSByb3cgYXMgY3VycmVudCBjZWxsLAogICAgICAgICAgLy8gLSBvciBhcmUgYmVsb3cgc3BsaXQgY2VsbCByb3cgYW5kIG92ZXJsYXBzIHRoYXQgcm93LgogICAgICAgICAgaWYgKGNlbGwgIT09IHRhYmxlQ2VsbCAmJiByb3cgKyByb3dzcGFuID4gc3BsaXRDZWxsUm93KSB7CiAgICAgICAgICAgIGNvbnN0IHJvd3NwYW5Ub1NldCA9IHJvd3NwYW4gKyBjZWxsc1RvSW5zZXJ0OwogICAgICAgICAgICB3cml0ZXIuc2V0QXR0cmlidXRlKCdyb3dzcGFuJywgcm93c3BhblRvU2V0LCBjZWxsKTsKICAgICAgICAgIH0KICAgICAgICB9IC8vIFNlY29uZCBzdGVwOiBjcmVhdGUgcm93cyB3aXRoIHNpbmdsZSBjZWxsIGJlbG93IHNwbGl0IGNlbGwuCgoKICAgICAgICBjb25zdCBuZXdDZWxsc0F0dHJpYnV0ZXMgPSB7fTsgLy8gQ29weSBjb2xzcGFuIG9mIHNwbGl0IGNlbGwuCgogICAgICAgIGlmIChjb2xzcGFuID4gMSkgewogICAgICAgICAgbmV3Q2VsbHNBdHRyaWJ1dGVzLmNvbHNwYW4gPSBjb2xzcGFuOwogICAgICAgIH0KCiAgICAgICAgY3JlYXRlRW1wdHlSb3dzKHdyaXRlciwgdGFibGUsIHNwbGl0Q2VsbFJvdyArIDEsIGNlbGxzVG9JbnNlcnQsIDEsIG5ld0NlbGxzQXR0cmlidXRlcyk7IC8vIFVwZGF0ZSBoZWFkaW5nIHNlY3Rpb24gaWYgc3BsaXQgY2VsbCBpcyBpbiBoZWFkaW5nIHNlY3Rpb24uCgogICAgICAgIGNvbnN0IGhlYWRpbmdSb3dzID0gdGFibGUuZ2V0QXR0cmlidXRlKCdoZWFkaW5nUm93cycpIHx8IDA7CgogICAgICAgIGlmIChoZWFkaW5nUm93cyA+IHNwbGl0Q2VsbFJvdykgewogICAgICAgICAgdXBkYXRlTnVtZXJpY0F0dHJpYnV0ZSgnaGVhZGluZ1Jvd3MnLCBoZWFkaW5nUm93cyArIGNlbGxzVG9JbnNlcnQsIHRhYmxlLCB3cml0ZXIpOwogICAgICAgIH0KICAgICAgfQogICAgfSk7CiAgfQogIC8qKgogICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBjb2x1bW5zIGZvciBhIGdpdmVuIHRhYmxlLgogICAqCiAgICoJCWVkaXRvci5wbHVnaW5zLmdldCggJ1RhYmxlVXRpbHMnICkuZ2V0Q29sdW1ucyggdGFibGUgKTsKICAgKgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR9IHRhYmxlIFRoZSB0YWJsZSB0byBhbmFseXplLgogICAqIEByZXR1cm5zIHtOdW1iZXJ9CiAgICovCgoKICBnZXRDb2x1bW5zKHRhYmxlKSB7CiAgICAvLyBBbmFseXplIGZpcnN0IHJvdyBvbmx5IGFzIGFsbCB0aGUgcm93cyBzaG91bGQgaGF2ZSB0aGUgc2FtZSB3aWR0aC4KICAgIGNvbnN0IHJvdyA9IHRhYmxlLmdldENoaWxkKDApOwogICAgcmV0dXJuIFsuLi5yb3cuZ2V0Q2hpbGRyZW4oKV0ucmVkdWNlKChjb2x1bW5zLCByb3cpID0+IHsKICAgICAgY29uc3QgY29sdW1uV2lkdGggPSBwYXJzZUludChyb3cuZ2V0QXR0cmlidXRlKCdjb2xzcGFuJykgfHwgMSk7CiAgICAgIHJldHVybiBjb2x1bW5zICsgY29sdW1uV2lkdGg7CiAgICB9LCAwKTsKICB9Cgp9IC8vIENyZWF0ZXMgZW1wdHkgcm93cyBhdCB0aGUgZ2l2ZW4gaW5kZXggaW4gYW4gZXhpc3RpbmcgdGFibGUuCi8vCi8vIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC93cml0ZXJ+V3JpdGVyfSB3cml0ZXIKLy8gQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudH0gdGFibGUKLy8gQHBhcmFtIHtOdW1iZXJ9IGluc2VydEF0IFJvdyBpbmRleCBvZiByb3cgaW5zZXJ0aW9uLgovLyBAcGFyYW0ge051bWJlcn0gcm93cyBOdW1iZXIgb2Ygcm93cyB0byBjcmVhdGUuCi8vIEBwYXJhbSB7TnVtYmVyfSB0YWJsZUNlbGxUb0luc2VydCBOdW1iZXIgb2YgY2VsbHMgdG8gaW5zZXJ0IGluIGVhY2ggcm93LgoKZnVuY3Rpb24gY3JlYXRlRW1wdHlSb3dzKHdyaXRlciwgdGFibGUsIGluc2VydEF0LCByb3dzLCB0YWJsZUNlbGxUb0luc2VydCwgYXR0cmlidXRlcyA9IHt9KSB7CiAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dzOyBpKyspIHsKICAgIGNvbnN0IHRhYmxlUm93ID0gd3JpdGVyLmNyZWF0ZUVsZW1lbnQoJ3RhYmxlUm93Jyk7CiAgICB3cml0ZXIuaW5zZXJ0KHRhYmxlUm93LCB0YWJsZSwgaW5zZXJ0QXQpOwogICAgY3JlYXRlQ2VsbHModGFibGVDZWxsVG9JbnNlcnQsIHdyaXRlciwgd3JpdGVyLmNyZWF0ZVBvc2l0aW9uQXQodGFibGVSb3csICdlbmQnKSwgYXR0cmlidXRlcyk7CiAgfQp9IC8vIENyZWF0ZXMgY2VsbHMgYXQgYSBnaXZlbiBwb3NpdGlvbi4KLy8KLy8gQHBhcmFtIHtOdW1iZXJ9IGNvbHVtbnMgTnVtYmVyIG9mIGNvbHVtbnMgdG8gY3JlYXRlCi8vIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC93cml0ZXJ+V3JpdGVyfSB3cml0ZXIKLy8gQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufSBpbnNlcnRQb3NpdGlvbgoKCmZ1bmN0aW9uIGNyZWF0ZUNlbGxzKGNlbGxzLCB3cml0ZXIsIGluc2VydFBvc2l0aW9uLCBhdHRyaWJ1dGVzID0ge30pIHsKICBmb3IgKGxldCBpID0gMDsgaSA8IGNlbGxzOyBpKyspIHsKICAgIGNyZWF0ZUVtcHR5VGFibGVDZWxsKHdyaXRlciwgaW5zZXJ0UG9zaXRpb24sIGF0dHJpYnV0ZXMpOwogIH0KfSAvLyBFdmVubHkgZGlzdHJpYnV0ZXMgdGhlIHNwYW4gb2YgYSBjZWxsIHRvIGEgbnVtYmVyIG9mIHByb3ZpZGVkIGNlbGxzLgovLyBUaGUgcmVzdWx0aW5nIHNwYW5zIHdpbGwgYWx3YXlzIGJlIGludGVnZXIgdmFsdWVzLgovLwovLyBGb3IgaW5zdGFuY2UgYnJlYWtpbmcgYSBzcGFuIG9mIDcgaW50byAzIGNlbGxzIHdpbGwgcmV0dXJuOgovLwovLwkJeyBuZXdDZWxsc1NwYW46IDIsIHVwZGF0ZWRTcGFuOiAzIH0KLy8KLy8gYXMgdHdvIGNlbGxzIHdpbGwgaGF2ZSBhIHNwYW4gb2YgMiBhbmQgdGhlIHJlbWFpbmRlciB3aWxsIGdvIHRoZSBmaXJzdCBjZWxsIHNvIGl0cyBzcGFuIHdpbGwgY2hhbmdlIHRvIDMuCi8vCi8vIEBwYXJhbSB7TnVtYmVyfSBzcGFuIFNwYW4gdmFsdWUgZG8gYnJlYWsuCi8vIEBwYXJhbSB7TnVtYmVyfSBudW1iZXJPZkNlbGxzIE51bWJlciBvZiByZXN1bHRpbmcgc3BhbnMuCi8vIEByZXR1cm5zIHt7bmV3Q2VsbHNTcGFuOiBOdW1iZXIsIHVwZGF0ZWRTcGFuOiBOdW1iZXJ9fQoKCmZ1bmN0aW9uIGJyZWFrU3BhbkV2ZW5seShzcGFuLCBudW1iZXJPZkNlbGxzKSB7CiAgaWYgKHNwYW4gPCBudW1iZXJPZkNlbGxzKSB7CiAgICByZXR1cm4gewogICAgICBuZXdDZWxsc1NwYW46IDEsCiAgICAgIHVwZGF0ZWRTcGFuOiAxCiAgICB9OwogIH0KCiAgY29uc3QgbmV3Q2VsbHNTcGFuID0gTWF0aC5mbG9vcihzcGFuIC8gbnVtYmVyT2ZDZWxscyk7CiAgY29uc3QgdXBkYXRlZFNwYW4gPSBzcGFuIC0gbmV3Q2VsbHNTcGFuICogbnVtYmVyT2ZDZWxscyArIG5ld0NlbGxzU3BhbjsKICByZXR1cm4gewogICAgbmV3Q2VsbHNTcGFuLAogICAgdXBkYXRlZFNwYW4KICB9Owp9"},{"version":3,"sources":["/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-table/src/tableutils.js"],"names":["Plugin","TableWalker","createEmptyTableCell","updateNumericAttribute","TableUtils","pluginName","getCellLocation","tableCell","tableRow","parent","table","rowIndex","getChildIndex","tableWalker","startRow","endRow","cell","row","column","createTable","writer","rows","columns","createElement","createEmptyRows","insertRows","options","model","editor","insertAt","at","rowsToInsert","change","headingRows","getAttribute","setAttribute","childCount","getColumns","tableIterator","cellsToInsert","rowspan","colspan","isBeforeInsertedRow","overlapsInsertedRow","insertColumns","columnsToInsert","headingColumns","tableColumns","getChildren","createCells","createPositionAt","includeSpanned","cellIndex","parseInt","index","skipRow","i","insertPosition","getChild","splitCellVertically","numberOfCells","newCellsSpan","updatedSpan","breakSpanEvenly","newCellsAttributes","createPositionAfter","tableMap","splitCellColumn","find","cellsToUpdate","filter","isOnSameColumn","spansOverColumn","splitCellHorizontally","splitCellRow","cellColumn","isAfterSplitCell","isInEvenlySplitRow","position","rowspanToSet","reduce","columnWidth","tableCellToInsert","attributes","insert","cells","span","Math","floor"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module table/tableutils\n */\n\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';\n\nimport TableWalker from './tablewalker';\nimport { createEmptyTableCell, updateNumericAttribute } from './commands/utils';\n\n/**\n * The table utilities plugin.\n *\n * @extends module:core/plugin~Plugin\n */\nexport default class TableUtils extends Plugin {\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get pluginName() {\n\t\treturn 'TableUtils';\n\t}\n\n\t/**\n\t * Returns the table cell location as an object with table row and table column indexes.\n\t *\n\t * For instance in the table below:\n\t *\n\t *\t\t    0   1   2   3\n\t *\t\t  +---+---+---+---+\n\t *\t\t0 | a     | b | c |\n\t *\t\t  +       +   +---+\n\t *\t\t1 |       |   | d |\n\t *\t\t  +---+---+   +---+\n\t *\t\t2 | e     |   | f |\n\t *\t\t  +---+---+---+---+\n\t *\n\t * the method will return:\n\t *\n\t *\t\tconst cellA = table.getNodeByPath( [ 0, 0 ] );\n\t *\t\teditor.plugins.get( 'TableUtils' ).getCellLocation( cellA );\n\t *\t\t// will return { row: 0, column: 0 }\n\t *\n\t *\t\tconst cellD = table.getNodeByPath( [ 1, 0 ] );\n\t *\t\teditor.plugins.get( 'TableUtils' ).getCellLocation( cellD );\n\t *\t\t// will return { row: 1, column: 3 }\n\t *\n\t * @param {module:engine/model/element~Element} tableCell\n\t * @returns {Object} Returns a `{row, column}` object.\n\t */\n\tgetCellLocation( tableCell ) {\n\t\tconst tableRow = tableCell.parent;\n\t\tconst table = tableRow.parent;\n\n\t\tconst rowIndex = table.getChildIndex( tableRow );\n\n\t\tconst tableWalker = new TableWalker( table, { startRow: rowIndex, endRow: rowIndex } );\n\n\t\tfor ( const { cell, row, column } of tableWalker ) {\n\t\t\tif ( cell === tableCell ) {\n\t\t\t\treturn { row, column };\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Creates an empty table with proper structure. The table needs to be inserted into the model,\n\t * ie. using {@link module:engine/model/model~Model#insertContent} function.\n\t *\n\t *\t\tmodel.change( ( writer ) => {\n\t *\t\t\t// Create a table of 2 rows and 7 columns:\n\t *\t\t\tconst table = tableUtils.createTable( writer, 2, 7);\n\t *\n\t *\t\t\t// Insert table to the model at the best position taking current selection:\n\t *\t\t\tmodel.insertContent( table );\n\t *\t\t}\n\t *\n\t * @param {module:engine/model/writer~Writer} writer The model writer.\n\t * @param {Number} rows The number of rows to create.\n\t * @param {Number} columns The number of columns to create.\n\t * @returns {module:engine/model/element~Element} The created table element.\n\t */\n\tcreateTable( writer, rows, columns ) {\n\t\tconst table = writer.createElement( 'table' );\n\n\t\tcreateEmptyRows( writer, table, 0, rows, columns );\n\n\t\treturn table;\n\t}\n\n\t/**\n\t * Inserts rows into a table.\n\t *\n\t *\t\teditor.plugins.get( 'TableUtils' ).insertRows( table, { at: 1, rows: 2 } );\n\t *\n\t * Assuming the table on the left, the above code will transform it to the table on the right:\n\t *\n\t *\t\trow index\n\t *\t\t  0 +---+---+---+       `at` = 1,      +---+---+---+ 0\n\t *\t\t    | a | b | c |       `rows` = 2,    | a | b | c |\n\t *\t\t  1 +   +---+---+   <-- insert here    +   +---+---+ 1\n\t *\t\t    |   | d | e |                      |   |   |   |\n\t *\t\t  2 +   +---+---+       will give:     +   +---+---+ 2\n\t *\t\t    |   | f | g |                      |   |   |   |\n\t *\t\t  3 +---+---+---+                      +   +---+---+ 3\n\t *\t\t                                       |   | d | e |\n\t *\t\t                                       +---+---+---+ 4\n\t *\t\t                                       +   + f | g |\n\t *\t\t                                       +---+---+---+ 5\n\t *\n\t * @param {module:engine/model/element~Element} table The table model element where the rows will be inserted.\n\t * @param {Object} options\n\t * @param {Number} [options.at=0] Row index at which the rows will be inserted.\n\t * @param {Number} [options.rows=1] The number of rows to insert.\n\t */\n\tinsertRows( table, options = {} ) {\n\t\tconst model = this.editor.model;\n\n\t\tconst insertAt = options.at || 0;\n\t\tconst rowsToInsert = options.rows || 1;\n\n\t\tmodel.change( writer => {\n\t\t\tconst headingRows = table.getAttribute( 'headingRows' ) || 0;\n\n\t\t\t// Inserting rows inside heading section requires to update `headingRows` attribute as the heading section will grow.\n\t\t\tif ( headingRows > insertAt ) {\n\t\t\t\twriter.setAttribute( 'headingRows', headingRows + rowsToInsert, table );\n\t\t\t}\n\n\t\t\t// Inserting at the end and at the beginning of a table doesn't require to calculate anything special.\n\t\t\tif ( insertAt === 0 || insertAt === table.childCount ) {\n\t\t\t\tcreateEmptyRows( writer, table, insertAt, rowsToInsert, this.getColumns( table ) );\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Iterate over all rows above inserted rows in order to check for rowspanned cells.\n\t\t\tconst tableIterator = new TableWalker( table, { endRow: insertAt } );\n\n\t\t\t// Will hold number of cells needed to insert in created rows.\n\t\t\t// The number might be different then table cell width when there are rowspanned cells.\n\t\t\tlet cellsToInsert = 0;\n\n\t\t\tfor ( const { row, rowspan, colspan, cell } of tableIterator ) {\n\t\t\t\tconst isBeforeInsertedRow = row < insertAt;\n\t\t\t\tconst overlapsInsertedRow = row + rowspan > insertAt;\n\n\t\t\t\tif ( isBeforeInsertedRow && overlapsInsertedRow ) {\n\t\t\t\t\t// This cell overlaps inserted rows so we need to expand it further.\n\t\t\t\t\twriter.setAttribute( 'rowspan', rowspan + rowsToInsert, cell );\n\t\t\t\t}\n\n\t\t\t\t// Calculate how many cells to insert based on the width of cells in a row at insert position.\n\t\t\t\t// It might be lower then table width as some cells might overlaps inserted row.\n\t\t\t\t// In the table above the cell 'a' overlaps inserted row so only two empty cells are need to be created.\n\t\t\t\tif ( row === insertAt ) {\n\t\t\t\t\tcellsToInsert += colspan;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcreateEmptyRows( writer, table, insertAt, rowsToInsert, cellsToInsert );\n\t\t} );\n\t}\n\n\t/**\n\t * Inserts columns into a table.\n\t *\n\t *\t\teditor.plugins.get( 'TableUtils' ).insertColumns( table, { at: 1, columns: 2 } );\n\t *\n\t * Assuming the table on the left, the above code will transform it to the table on the right:\n\t *\n\t *\t\t0   1   2   3                   0   1   2   3   4   5\n\t *\t\t+---+---+---+                   +---+---+---+---+---+\n\t *\t\t| a     | b |                   | a             | b |\n\t *\t\t+       +---+                   +               +---+\n\t *\t\t|       | c |                   |               | c |\n\t *\t\t+---+---+---+     will give:    +---+---+---+---+---+\n\t *\t\t| d | e | f |                   | d |   |   | e | f |\n\t *\t\t+---+   +---+                   +---+---+---+   +---+\n\t *\t\t| g |   | h |                   | g |   |   |   | h |\n\t *\t\t+---+---+---+                   +---+---+---+---+---+\n\t *\t\t| i         |                   | i                 |\n\t *\t\t+---+---+---+                   +---+---+---+---+---+\n\t *\t\t    ^---- insert here, `at` = 1, `columns` = 2\n\t *\n\t * @param {module:engine/model/element~Element} table The table model element where the columns will be inserted.\n\t * @param {Object} options\n\t * @param {Number} [options.at=0] Column index at which the columns will be inserted.\n\t * @param {Number} [options.columns=1] The number of columns to insert.\n\t */\n\tinsertColumns( table, options = {} ) {\n\t\tconst model = this.editor.model;\n\n\t\tconst insertAt = options.at || 0;\n\t\tconst columnsToInsert = options.columns || 1;\n\n\t\tmodel.change( writer => {\n\t\t\tconst headingColumns = table.getAttribute( 'headingColumns' );\n\n\t\t\t// Inserting columns inside heading section requires to update `headingColumns` attribute as the heading section will grow.\n\t\t\tif ( insertAt < headingColumns ) {\n\t\t\t\twriter.setAttribute( 'headingColumns', headingColumns + columnsToInsert, table );\n\t\t\t}\n\n\t\t\tconst tableColumns = this.getColumns( table );\n\n\t\t\t// Inserting at the end and at the beginning of a table doesn't require to calculate anything special.\n\t\t\tif ( insertAt === 0 || tableColumns === insertAt ) {\n\t\t\t\tfor ( const tableRow of table.getChildren() ) {\n\t\t\t\t\tcreateCells( columnsToInsert, writer, writer.createPositionAt( tableRow, insertAt ? 'end' : 0 ) );\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst tableWalker = new TableWalker( table, { column: insertAt, includeSpanned: true } );\n\n\t\t\tfor ( const { row, cell, cellIndex } of tableWalker ) {\n\t\t\t\t// When iterating over column the table walker outputs either:\n\t\t\t\t// - cells at given column index (cell \"e\" from method docs),\n\t\t\t\t// - spanned columns (spanned cell from row between cells \"g\" and \"h\" - spanned by \"e\", only if `includeSpanned: true`),\n\t\t\t\t// - or a cell from the same row which spans over this column (cell \"a\").\n\n\t\t\t\tconst rowspan = parseInt( cell.getAttribute( 'rowspan' ) || 1 );\n\t\t\t\tconst colspan = parseInt( cell.getAttribute( 'colspan' ) || 1 );\n\n\t\t\t\tif ( cell.index !== insertAt && colspan > 1 ) {\n\t\t\t\t\t// If column is different than `insertAt`, it is a cell that spans over an inserted column (cell \"a\" & \"i\").\n\t\t\t\t\t// For such cells expand them by a number of columns inserted.\n\t\t\t\t\twriter.setAttribute( 'colspan', colspan + columnsToInsert, cell );\n\n\t\t\t\t\t// The `includeSpanned` option will output the \"empty\"/spanned column so skip this row already.\n\t\t\t\t\ttableWalker.skipRow( row );\n\n\t\t\t\t\t// This cell will overlap cells in rows below so skip them also (because of `includeSpanned` option) - (cell \"a\")\n\t\t\t\t\tif ( rowspan > 1 ) {\n\t\t\t\t\t\tfor ( let i = row + 1; i < row + rowspan; i++ ) {\n\t\t\t\t\t\t\ttableWalker.skipRow( i );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// It's either cell at this column index or spanned cell by a rowspanned cell from row above.\n\t\t\t\t\t// In table above it's cell \"e\" and a spanned position from row below (empty cell between cells \"g\" and \"h\")\n\t\t\t\t\tconst insertPosition = writer.createPositionAt( table.getChild( row ), cellIndex );\n\n\t\t\t\t\tcreateCells( columnsToInsert, writer, insertPosition );\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t}\n\n\t/**\n\t * Divides a table cell vertically into several ones.\n\t *\n\t * The cell will be visually split into more cells by updating colspans of other cells in a column\n\t * and inserting cells (columns) after that cell.\n\t *\n\t * In the table below, if cell \"a\" is split to 3 cells:\n\t *\n\t *\t\t+---+---+---+\n\t *\t\t| a | b | c |\n\t *\t\t+---+---+---+\n\t *\t\t| d | e | f |\n\t *\t\t+---+---+---+\n\t *\n\t * it will result in the table below:\n\t *\n\t *\t\t+---+---+---+---+---+\n\t *\t\t| a |   |   | b | c |\n\t *\t\t+---+---+---+---+---+\n\t *\t\t| d         | e | f |\n\t *\t\t+---+---+---+---+---+\n\t *\n\t * So cell \"d\" will get its `colspan` updated to `3` and 2 cells will be added (2 columns will be created).\n\t *\n\t * Splitting a cell that already has a `colspan` attribute set will distribute the cell `colspan` evenly and the remainder\n\t * will be left to the original cell:\n\t *\n\t *\t\t+---+---+---+\n\t *\t\t| a         |\n\t *\t\t+---+---+---+\n\t *\t\t| b | c | d |\n\t *\t\t+---+---+---+\n\t *\n\t * Splitting cell \"a\" with `colspan=3` to 2 cells will create 1 cell with a `colspan=a` and cell \"a\" that will have `colspan=2`:\n\t *\n\t *\t\t+---+---+---+\n\t *\t\t| a     |   |\n\t *\t\t+---+---+---+\n\t *\t\t| b | c | d |\n\t *\t\t+---+---+---+\n\t *\n\t * @param {module:engine/model/element~Element} tableCell\n\t * @param {Number} numberOfCells\n\t */\n\tsplitCellVertically( tableCell, numberOfCells = 2 ) {\n\t\tconst model = this.editor.model;\n\t\tconst tableRow = tableCell.parent;\n\t\tconst table = tableRow.parent;\n\n\t\tconst rowspan = parseInt( tableCell.getAttribute( 'rowspan' ) || 1 );\n\t\tconst colspan = parseInt( tableCell.getAttribute( 'colspan' ) || 1 );\n\n\t\tmodel.change( writer => {\n\t\t\t// First check - the cell spans over multiple rows so before doing anything else just split this cell.\n\t\t\tif ( colspan > 1 ) {\n\t\t\t\t// Get spans of new (inserted) cells and span to update of split cell.\n\t\t\t\tconst { newCellsSpan, updatedSpan } = breakSpanEvenly( colspan, numberOfCells );\n\n\t\t\t\tupdateNumericAttribute( 'colspan', updatedSpan, tableCell, writer );\n\n\t\t\t\t// Each inserted cell will have the same attributes:\n\t\t\t\tconst newCellsAttributes = {};\n\n\t\t\t\t// Do not store default value in the model.\n\t\t\t\tif ( newCellsSpan > 1 ) {\n\t\t\t\t\tnewCellsAttributes.colspan = newCellsSpan;\n\t\t\t\t}\n\n\t\t\t\t// Copy rowspan of split cell.\n\t\t\t\tif ( rowspan > 1 ) {\n\t\t\t\t\tnewCellsAttributes.rowspan = rowspan;\n\t\t\t\t}\n\n\t\t\t\tconst cellsToInsert = colspan > numberOfCells ? numberOfCells - 1 : colspan - 1;\n\t\t\t\tcreateCells( cellsToInsert, writer, writer.createPositionAfter( tableCell ), newCellsAttributes );\n\t\t\t}\n\n\t\t\t// Second check - the cell has colspan of 1 or we need to create more cells then the currently one spans over.\n\t\t\tif ( colspan < numberOfCells ) {\n\t\t\t\tconst cellsToInsert = numberOfCells - colspan;\n\n\t\t\t\t// First step: expand cells on the same column as split cell.\n\t\t\t\tconst tableMap = [ ...new TableWalker( table ) ];\n\n\t\t\t\t// Get the column index of split cell.\n\t\t\t\tconst { column: splitCellColumn } = tableMap.find( ( { cell } ) => cell === tableCell );\n\n\t\t\t\t// Find cells which needs to be expanded vertically - those on the same column or those that spans over split cell's column.\n\t\t\t\tconst cellsToUpdate = tableMap.filter( ( { cell, colspan, column } ) => {\n\t\t\t\t\tconst isOnSameColumn = cell !== tableCell && column === splitCellColumn;\n\t\t\t\t\tconst spansOverColumn = ( column < splitCellColumn && column + colspan > splitCellColumn );\n\n\t\t\t\t\treturn isOnSameColumn || spansOverColumn;\n\t\t\t\t} );\n\n\t\t\t\t// Expand cells vertically.\n\t\t\t\tfor ( const { cell, colspan } of cellsToUpdate ) {\n\t\t\t\t\twriter.setAttribute( 'colspan', colspan + cellsToInsert, cell );\n\t\t\t\t}\n\n\t\t\t\t// Second step: create columns after split cell.\n\n\t\t\t\t// Each inserted cell will have the same attributes:\n\t\t\t\tconst newCellsAttributes = {};\n\n\t\t\t\t// Do not store default value in the model.\n\n\t\t\t\t// Copy rowspan of split cell.\n\t\t\t\tif ( rowspan > 1 ) {\n\t\t\t\t\tnewCellsAttributes.rowspan = rowspan;\n\t\t\t\t}\n\n\t\t\t\tcreateCells( cellsToInsert, writer, writer.createPositionAfter( tableCell ), newCellsAttributes );\n\n\t\t\t\tconst headingColumns = table.getAttribute( 'headingColumns' ) || 0;\n\n\t\t\t\t// Update heading section if split cell is in heading section.\n\t\t\t\tif ( headingColumns > splitCellColumn ) {\n\t\t\t\t\tupdateNumericAttribute( 'headingColumns', headingColumns + cellsToInsert, table, writer );\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t}\n\n\t/**\n\t * Divides a table cell horizontally into several ones.\n\t *\n\t * The cell will be visually split into more cells by updating rowspans of other cells in the row and inserting rows with a single cell\n\t * below.\n\t *\n\t * If in the table below cell \"b\" is split to 3 cells:\n\t *\n\t *\t\t+---+---+---+\n\t *\t\t| a | b | c |\n\t *\t\t+---+---+---+\n\t *\t\t| d | e | f |\n\t *\t\t+---+---+---+\n\t *\n\t * It will result in the table below:\n\t *\n\t *\t\t+---+---+---+\n\t *\t\t| a | b | c |\n\t *\t\t+   +---+   +\n\t *\t\t|   |   |   |\n\t *\t\t+   +---+   +\n\t *\t\t|   |   |   |\n\t *\t\t+---+---+---+\n\t *\t\t| d | e | f |\n\t *\t\t+---+---+---+\n\t *\n\t * So cells \"a\" and \"b\" will get their `rowspan` updated to `3` and 2 rows with a single cell will be added.\n\t *\n\t * Splitting a cell that already has a `rowspan` attribute set will distribute the cell `rowspan` evenly and the remainder\n\t * will be left to the original cell:\n\t *\n\t *\t\t+---+---+---+\n\t *\t\t| a | b | c |\n\t *\t\t+   +---+---+\n\t *\t\t|   | d | e |\n\t *\t\t+   +---+---+\n\t *\t\t|   | f | g |\n\t *\t\t+   +---+---+\n\t *\t\t|   | h | i |\n\t *\t\t+---+---+---+\n\t *\n\t * Splitting cell \"a\" with `rowspan=4` to 3 cells will create 2 cells with a `rowspan=1` and cell \"a\" will have `rowspan=2`:\n\t *\n\t *\t\t+---+---+---+\n\t *\t\t| a | b | c |\n\t *\t\t+   +---+---+\n\t *\t\t|   | d | e |\n\t *\t\t+---+---+---+\n\t *\t\t|   | f | g |\n\t *\t\t+---+---+---+\n\t *\t\t|   | h | i |\n\t *\t\t+---+---+---+\n\t *\n\t * @param {module:engine/model/element~Element} tableCell\n\t * @param {Number} numberOfCells\n\t */\n\tsplitCellHorizontally( tableCell, numberOfCells = 2 ) {\n\t\tconst model = this.editor.model;\n\n\t\tconst tableRow = tableCell.parent;\n\t\tconst table = tableRow.parent;\n\t\tconst splitCellRow = table.getChildIndex( tableRow );\n\n\t\tconst rowspan = parseInt( tableCell.getAttribute( 'rowspan' ) || 1 );\n\t\tconst colspan = parseInt( tableCell.getAttribute( 'colspan' ) || 1 );\n\n\t\tmodel.change( writer => {\n\t\t\t// First check - the cell spans over multiple rows so before doing anything else just split this cell.\n\t\t\tif ( rowspan > 1 ) {\n\t\t\t\t// Cache table map before updating table.\n\t\t\t\tconst tableMap = [ ...new TableWalker( table, {\n\t\t\t\t\tstartRow: splitCellRow,\n\t\t\t\t\tendRow: splitCellRow + rowspan - 1,\n\t\t\t\t\tincludeSpanned: true\n\t\t\t\t} ) ];\n\n\t\t\t\t// Get spans of new (inserted) cells and span to update of split cell.\n\t\t\t\tconst { newCellsSpan, updatedSpan } = breakSpanEvenly( rowspan, numberOfCells );\n\n\t\t\t\tupdateNumericAttribute( 'rowspan', updatedSpan, tableCell, writer );\n\n\t\t\t\tconst { column: cellColumn } = tableMap.find( ( { cell } ) => cell === tableCell );\n\n\t\t\t\t// Each inserted cell will have the same attributes:\n\t\t\t\tconst newCellsAttributes = {};\n\n\t\t\t\t// Do not store default value in the model.\n\t\t\t\tif ( newCellsSpan > 1 ) {\n\t\t\t\t\tnewCellsAttributes.rowspan = newCellsSpan;\n\t\t\t\t}\n\n\t\t\t\t// Copy colspan of split cell.\n\t\t\t\tif ( colspan > 1 ) {\n\t\t\t\t\tnewCellsAttributes.colspan = colspan;\n\t\t\t\t}\n\n\t\t\t\tfor ( const { column, row, cellIndex } of tableMap ) {\n\t\t\t\t\t// As both newly created cells and the split cell might have rowspan,\n\t\t\t\t\t// the insertion of new cells must go to appropriate rows:\n\t\t\t\t\t//\n\t\t\t\t\t// 1. It's a row after split cell + it's height.\n\t\t\t\t\tconst isAfterSplitCell = row >= splitCellRow + updatedSpan;\n\t\t\t\t\t// 2. Is on the same column.\n\t\t\t\t\tconst isOnSameColumn = column === cellColumn;\n\t\t\t\t\t// 3. And it's row index is after previous cell height.\n\t\t\t\t\tconst isInEvenlySplitRow = ( row + splitCellRow + updatedSpan ) % newCellsSpan === 0;\n\n\t\t\t\t\tif ( isAfterSplitCell && isOnSameColumn && isInEvenlySplitRow ) {\n\t\t\t\t\t\tconst position = writer.createPositionAt( table.getChild( row ), cellIndex );\n\n\t\t\t\t\t\tcreateCells( 1, writer, position, newCellsAttributes );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Second check - the cell has rowspan of 1 or we need to create more cells than the current cell spans over.\n\t\t\tif ( rowspan < numberOfCells ) {\n\t\t\t\t// We already split the cell in check one so here we split to the remaining number of cells only.\n\t\t\t\tconst cellsToInsert = numberOfCells - rowspan;\n\n\t\t\t\t// This check is needed since we need to check if there are any cells from previous rows than spans over this cell's row.\n\t\t\t\tconst tableMap = [ ...new TableWalker( table, { startRow: 0, endRow: splitCellRow } ) ];\n\n\t\t\t\t// First step: expand cells.\n\t\t\t\tfor ( const { cell, rowspan, row } of tableMap ) {\n\t\t\t\t\t// Expand rowspan of cells that are either:\n\t\t\t\t\t// - on the same row as current cell,\n\t\t\t\t\t// - or are below split cell row and overlaps that row.\n\t\t\t\t\tif ( cell !== tableCell && row + rowspan > splitCellRow ) {\n\t\t\t\t\t\tconst rowspanToSet = rowspan + cellsToInsert;\n\n\t\t\t\t\t\twriter.setAttribute( 'rowspan', rowspanToSet, cell );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Second step: create rows with single cell below split cell.\n\t\t\t\tconst newCellsAttributes = {};\n\n\t\t\t\t// Copy colspan of split cell.\n\t\t\t\tif ( colspan > 1 ) {\n\t\t\t\t\tnewCellsAttributes.colspan = colspan;\n\t\t\t\t}\n\n\t\t\t\tcreateEmptyRows( writer, table, splitCellRow + 1, cellsToInsert, 1, newCellsAttributes );\n\n\t\t\t\t// Update heading section if split cell is in heading section.\n\t\t\t\tconst headingRows = table.getAttribute( 'headingRows' ) || 0;\n\n\t\t\t\tif ( headingRows > splitCellRow ) {\n\t\t\t\t\tupdateNumericAttribute( 'headingRows', headingRows + cellsToInsert, table, writer );\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t}\n\n\t/**\n\t * Returns the number of columns for a given table.\n\t *\n\t *\t\teditor.plugins.get( 'TableUtils' ).getColumns( table );\n\t *\n\t * @param {module:engine/model/element~Element} table The table to analyze.\n\t * @returns {Number}\n\t */\n\tgetColumns( table ) {\n\t\t// Analyze first row only as all the rows should have the same width.\n\t\tconst row = table.getChild( 0 );\n\n\t\treturn [ ...row.getChildren() ].reduce( ( columns, row ) => {\n\t\t\tconst columnWidth = parseInt( row.getAttribute( 'colspan' ) || 1 );\n\n\t\t\treturn columns + columnWidth;\n\t\t}, 0 );\n\t}\n}\n\n// Creates empty rows at the given index in an existing table.\n//\n// @param {module:engine/model/writer~Writer} writer\n// @param {module:engine/model/element~Element} table\n// @param {Number} insertAt Row index of row insertion.\n// @param {Number} rows Number of rows to create.\n// @param {Number} tableCellToInsert Number of cells to insert in each row.\nfunction createEmptyRows( writer, table, insertAt, rows, tableCellToInsert, attributes = {} ) {\n\tfor ( let i = 0; i < rows; i++ ) {\n\t\tconst tableRow = writer.createElement( 'tableRow' );\n\n\t\twriter.insert( tableRow, table, insertAt );\n\n\t\tcreateCells( tableCellToInsert, writer, writer.createPositionAt( tableRow, 'end' ), attributes );\n\t}\n}\n\n// Creates cells at a given position.\n//\n// @param {Number} columns Number of columns to create\n// @param {module:engine/model/writer~Writer} writer\n// @param {module:engine/model/position~Position} insertPosition\nfunction createCells( cells, writer, insertPosition, attributes = {} ) {\n\tfor ( let i = 0; i < cells; i++ ) {\n\t\tcreateEmptyTableCell( writer, insertPosition, attributes );\n\t}\n}\n\n// Evenly distributes the span of a cell to a number of provided cells.\n// The resulting spans will always be integer values.\n//\n// For instance breaking a span of 7 into 3 cells will return:\n//\n//\t\t{ newCellsSpan: 2, updatedSpan: 3 }\n//\n// as two cells will have a span of 2 and the remainder will go the first cell so its span will change to 3.\n//\n// @param {Number} span Span value do break.\n// @param {Number} numberOfCells Number of resulting spans.\n// @returns {{newCellsSpan: Number, updatedSpan: Number}}\nfunction breakSpanEvenly( span, numberOfCells ) {\n\tif ( span < numberOfCells ) {\n\t\treturn { newCellsSpan: 1, updatedSpan: 1 };\n\t}\n\n\tconst newCellsSpan = Math.floor( span / numberOfCells );\n\tconst updatedSpan = ( span - newCellsSpan * numberOfCells ) + newCellsSpan;\n\n\treturn { newCellsSpan, updatedSpan };\n}\n"]}]}