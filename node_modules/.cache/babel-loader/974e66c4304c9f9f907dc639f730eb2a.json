{"remainingRequest":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/babel-loader/lib/index.js!/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-autoformat/src/inlineautoformatediting.js","dependencies":[{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-autoformat/src/inlineautoformatediting.js","mtime":499162500000},{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js","mtime":499162500000},{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/babel-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:LyoqCiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDE5LCBDS1NvdXJjZSAtIEZyZWRlcmljbyBLbmFiYmVuLiBBbGwgcmlnaHRzIHJlc2VydmVkLgogKiBGb3IgbGljZW5zaW5nLCBzZWUgTElDRU5TRS5tZCBvciBodHRwczovL2NrZWRpdG9yLmNvbS9sZWdhbC9ja2VkaXRvci1vc3MtbGljZW5zZQogKi8KCi8qKgogKiBAbW9kdWxlIGF1dG9mb3JtYXQvaW5saW5lYXV0b2Zvcm1hdGVkaXRpbmcKICovCmltcG9ydCBnZXRMYXN0VGV4dExpbmUgZnJvbSAnQGNrZWRpdG9yL2NrZWRpdG9yNS10eXBpbmcvc3JjL3V0aWxzL2dldGxhc3R0ZXh0bGluZSc7Ci8qKgogKiBUaGUgaW5saW5lIGF1dG9mb3JtYXR0aW5nIGVuZ2luZS4gSXQgYWxsb3dzIHRvIGZvcm1hdCB2YXJpb3VzIGlubGluZSBwYXR0ZXJucy4gRm9yIGV4YW1wbGUsCiAqIGl0IGNhbiBiZSBjb25maWd1cmVkIHRvIG1ha2UgImZvbyIgYm9sZCB3aGVuIHR5cGVkIGAqKmZvbyoqYCAodGhlIGAqKmAgbWFya2VycyB3aWxsIGJlIHJlbW92ZWQpLgogKgogKiBUaGUgYXV0b2Zvcm1hdHRpbmcgb3BlcmF0aW9uIGlzIGludGVncmF0ZWQgd2l0aCB0aGUgdW5kbyBtYW5hZ2VyLAogKiBzbyB0aGUgYXV0b2Zvcm1hdHRpbmcgc3RlcCBjYW4gYmUgdW5kb25lIGlmIHRoZSB1c2VyJ3MgaW50ZW50aW9uIHdhcyBub3QgdG8gZm9ybWF0IHRoZSB0ZXh0LgogKgogKiBTZWUgdGhlIGNvbnN0cnVjdG9ycyBkb2N1bWVudGF0aW9uIHRvIGxlYXJuIGhvdyB0byBjcmVhdGUgY3VzdG9tIGlubGluZSBhdXRvZm9ybWF0dGVycy4gWW91IGNhbiBhbHNvIHVzZQogKiB0aGUge0BsaW5rIG1vZHVsZTphdXRvZm9ybWF0L2F1dG9mb3JtYXR+QXV0b2Zvcm1hdH0gZmVhdHVyZSB3aGljaCBlbmFibGVzIGEgc2V0IG9mIGRlZmF1bHQgYXV0b2Zvcm1hdHRlcnMKICogKGxpc3RzLCBoZWFkaW5ncywgYm9sZCBhbmQgaXRhbGljKS4KICovCgpleHBvcnQgZGVmYXVsdCBjbGFzcyBJbmxpbmVBdXRvZm9ybWF0RWRpdGluZyB7CiAgLyoqCiAgICogQGluaGVyaXREb2MKICAgKi8KICBzdGF0aWMgZ2V0IHBsdWdpbk5hbWUoKSB7CiAgICByZXR1cm4gJ0lubGluZUF1dG9mb3JtYXRFZGl0aW5nJzsKICB9CiAgLyoqCiAgICogRW5hYmxlcyBhdXRvZm9ybWF0dGluZyBtZWNoYW5pc20gZm9yIGEgZ2l2ZW4ge0BsaW5rIG1vZHVsZTpjb3JlL2VkaXRvci9lZGl0b3J+RWRpdG9yfS4KICAgKgogICAqIEl0IGZvcm1hdHMgdGhlIG1hdGNoZWQgdGV4dCBieSBhcHBseWluZyB0aGUgZ2l2ZW4gbW9kZWwgYXR0cmlidXRlIG9yIGJ5IHJ1bm5pbmcgdGhlIHByb3ZpZGVkIGZvcm1hdHRpbmcgY2FsbGJhY2suCiAgICogT24gZXZlcnkgY2hhbmdlIGFwcGxpZWQgdG8gdGhlIG1vZGVsIHRoZSBhdXRvZm9ybWF0dGluZyBlbmdpbmUgY2hlY2tzIHRoZSB0ZXh0IG9uIHRoZSBsZWZ0IG9mIHRoZSBzZWxlY3Rpb24KICAgKiBhbmQgZXhlY3V0ZXMgdGhlIHByb3ZpZGVkIGFjdGlvbiBpZiB0aGUgdGV4dCBtYXRjaGVzIGdpdmVuIGNyaXRlcmlhIChyZWd1bGFyIGV4cHJlc3Npb24gb3IgY2FsbGJhY2spLgogICAqCiAgICogQHBhcmFtIHttb2R1bGU6Y29yZS9lZGl0b3IvZWRpdG9yfkVkaXRvcn0gZWRpdG9yIFRoZSBlZGl0b3IgaW5zdGFuY2UuCiAgICogQHBhcmFtIHtGdW5jdGlvbnxSZWdFeHB9IHRlc3RSZWdleHBPckNhbGxiYWNrIFRoZSByZWd1bGFyIGV4cHJlc3Npb24gb3IgY2FsbGJhY2sgdG8gZXhlY3V0ZSBvbiB0ZXh0LgogICAqIFByb3ZpZGVkIHJlZ3VsYXIgZXhwcmVzc2lvbiAqbXVzdCogaGF2ZSB0aHJlZSBjYXB0dXJlIGdyb3Vwcy4gVGhlIGZpcnN0IGFuZCB0aGUgdGhpcmQgY2FwdHVyZSBncm91cAogICAqIHNob3VsZCBtYXRjaCBvcGVuaW5nIGFuZCBjbG9zaW5nIGRlbGltaXRlcnMuIFRoZSBzZWNvbmQgY2FwdHVyZSBncm91cCBzaG91bGQgbWF0Y2ggdGhlIHRleHQgdG8gZm9ybWF0LgogICAqCiAgICoJCS8vIE1hdGNoZXMgdGhlIGAqKmJvbGQgdGV4dCoqYCBwYXR0ZXJuLgogICAqCQkvLyBUaGVyZSBhcmUgdGhyZWUgY2FwdHVyaW5nIGdyb3VwczoKICAgKgkJLy8gLSBUaGUgZmlyc3QgdG8gbWF0Y2ggdGhlIHN0YXJ0aW5nIGAqKmAgZGVsaW1pdGVyLgogICAqCQkvLyAtIFRoZSBzZWNvbmQgdG8gbWF0Y2ggdGhlIHRleHQgdG8gZm9ybWF0LgogICAqCQkvLyAtIFRoZSB0aGlyZCB0byBtYXRjaCB0aGUgZW5kaW5nIGAqKmAgZGVsaW1pdGVyLgogICAqCQluZXcgSW5saW5lQXV0b2Zvcm1hdEVkaXRpbmcoIGVkaXRvciwgLyhcKlwqKShbXlwqXSs/KShcKlwqKSQvZywgJ2JvbGQnICk7CiAgICoKICAgKiBXaGVuIGEgZnVuY3Rpb24gaXMgcHJvdmlkZWQgaW5zdGVhZCBvZiB0aGUgcmVndWxhciBleHByZXNzaW9uLCBpdCB3aWxsIGJlIGV4ZWN1dGVkIHdpdGggdGhlIHRleHQgdG8gbWF0Y2ggYXMgYSBwYXJhbWV0ZXIuCiAgICogVGhlIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gcHJvcGVyICJyYW5nZXMiIHRvIGRlbGV0ZSBhbmQgZm9ybWF0LgogICAqCiAgICoJCXsKICAgKgkJCXJlbW92ZTogWwogICAqCQkJCVsgMCwgMSBdLAkvLyBSZW1vdmUgdGhlIGZpcnN0IGxldHRlciBmcm9tIHRoZSBnaXZlbiB0ZXh0LgogICAqCQkJCVsgNSwgNiBdCS8vIFJlbW92ZSB0aGUgNnRoIGxldHRlciBmcm9tIHRoZSBnaXZlbiB0ZXh0LgogICAqCQkJXSwKICAgKgkJCWZvcm1hdDogWwogICAqCQkJCVsgMSwgNSBdCS8vIEZvcm1hdCBhbGwgbGV0dGVycyBmcm9tIDJuZCB0byA1dGguCiAgICoJCQldCiAgICoJCX0KICAgKgogICAqIEBwYXJhbSB7RnVuY3Rpb258U3RyaW5nfSBhdHRyaWJ1dGVPckNhbGxiYWNrIFRoZSBuYW1lIG9mIGF0dHJpYnV0ZSB0byBhcHBseSBvbiBtYXRjaGluZyB0ZXh0IG9yIGEgY2FsbGJhY2sgZm9yIG1hbnVhbAogICAqIGZvcm1hdHRpbmcuIElmIGNhbGxiYWNrIGlzIHBhc3NlZCBpdCBzaG91bGQgcmV0dXJuIGBmYWxzZWAgaWYgY2hhbmdlcyBzaG91bGQgbm90IGJlIGFwcGxpZWQgKGUuZy4gaWYgYSBjb21tYW5kIGlzIGRpc2FibGVkKS4KICAgKgogICAqCQkvLyBVc2UgYXR0cmlidXRlIG5hbWU6CiAgICoJCW5ldyBJbmxpbmVBdXRvZm9ybWF0RWRpdGluZyggZWRpdG9yLCAvKFwqXCopKFteXCpdKz8pKFwqXCopJC9nLCAnYm9sZCcgKTsKICAgKgogICAqCQkvLyBVc2UgZm9ybWF0dGluZyBjYWxsYmFjazoKICAgKgkJbmV3IElubGluZUF1dG9mb3JtYXRFZGl0aW5nKCBlZGl0b3IsIC8oXCpcKikoW15cKl0rPykoXCpcKikkL2csICggd3JpdGVyLCByYW5nZXNUb0Zvcm1hdCApID0+IHsKICAgKgkJCWNvbnN0IGNvbW1hbmQgPSBlZGl0b3IuY29tbWFuZHMuZ2V0KCAnYm9sZCcgKTsKICAgKgogICAqCQkJaWYgKCAhY29tbWFuZC5pc0VuYWJsZWQgKSB7CiAgICoJCQkJcmV0dXJuIGZhbHNlOwogICAqCQkJfQogICAqCiAgICoJCQljb25zdCB2YWxpZFJhbmdlcyA9IGVkaXRvci5tb2RlbC5zY2hlbWEuZ2V0VmFsaWRSYW5nZXMoIHJhbmdlc1RvRm9ybWF0LCAnYm9sZCcgKTsKICAgKgogICAqCQkJZm9yICggbGV0IHJhbmdlIG9mIHZhbGlkUmFuZ2VzICkgewogICAqCQkJCXdyaXRlci5zZXRBdHRyaWJ1dGUoICdib2xkJywgdHJ1ZSwgcmFuZ2UgKTsKICAgKgkJCX0KICAgKgkJfSApOwogICAqLwoKCiAgY29uc3RydWN0b3IoZWRpdG9yLCB0ZXN0UmVnZXhwT3JDYWxsYmFjaywgYXR0cmlidXRlT3JDYWxsYmFjaykgewogICAgbGV0IHJlZ0V4cDsKICAgIGxldCBhdHRyaWJ1dGVLZXk7CiAgICBsZXQgdGVzdENhbGxiYWNrOwogICAgbGV0IGZvcm1hdENhbGxiYWNrOwoKICAgIGlmICh0ZXN0UmVnZXhwT3JDYWxsYmFjayBpbnN0YW5jZW9mIFJlZ0V4cCkgewogICAgICByZWdFeHAgPSB0ZXN0UmVnZXhwT3JDYWxsYmFjazsKICAgIH0gZWxzZSB7CiAgICAgIHRlc3RDYWxsYmFjayA9IHRlc3RSZWdleHBPckNhbGxiYWNrOwogICAgfQoKICAgIGlmICh0eXBlb2YgYXR0cmlidXRlT3JDYWxsYmFjayA9PSAnc3RyaW5nJykgewogICAgICBhdHRyaWJ1dGVLZXkgPSBhdHRyaWJ1dGVPckNhbGxiYWNrOwogICAgfSBlbHNlIHsKICAgICAgZm9ybWF0Q2FsbGJhY2sgPSBhdHRyaWJ1dGVPckNhbGxiYWNrOwogICAgfSAvLyBBIHRlc3QgY2FsbGJhY2sgcnVuIG9uIGNoYW5nZWQgdGV4dC4KCgogICAgdGVzdENhbGxiYWNrID0gdGVzdENhbGxiYWNrIHx8ICh0ZXh0ID0+IHsKICAgICAgbGV0IHJlc3VsdDsKICAgICAgY29uc3QgcmVtb3ZlID0gW107CiAgICAgIGNvbnN0IGZvcm1hdCA9IFtdOwoKICAgICAgd2hpbGUgKChyZXN1bHQgPSByZWdFeHAuZXhlYyh0ZXh0KSkgIT09IG51bGwpIHsKICAgICAgICAvLyBUaGVyZSBzaG91bGQgYmUgZnVsbCBtYXRjaCBhbmQgMyBjYXB0dXJlIGdyb3Vwcy4KICAgICAgICBpZiAocmVzdWx0ICYmIHJlc3VsdC5sZW5ndGggPCA0KSB7CiAgICAgICAgICBicmVhazsKICAgICAgICB9CgogICAgICAgIGxldCB7CiAgICAgICAgICBpbmRleCwKICAgICAgICAgICcxJzogbGVmdERlbCwKICAgICAgICAgICcyJzogY29udGVudCwKICAgICAgICAgICczJzogcmlnaHREZWwKICAgICAgICB9ID0gcmVzdWx0OyAvLyBSZWFsIG1hdGNoZWQgc3RyaW5nIC0gdGhlcmUgbWlnaHQgYmUgc29tZSBub24tY2FwdHVyaW5nIGdyb3VwcyBzbyB3ZSBuZWVkIHRvIHJlY2FsY3VsYXRlIHN0YXJ0aW5nIGluZGV4LgoKICAgICAgICBjb25zdCBmb3VuZCA9IGxlZnREZWwgKyBjb250ZW50ICsgcmlnaHREZWw7CiAgICAgICAgaW5kZXggKz0gcmVzdWx0WzBdLmxlbmd0aCAtIGZvdW5kLmxlbmd0aDsgLy8gU3RhcnQgYW5kIEVuZCBvZmZzZXRzIG9mIGRlbGltaXRlcnMgdG8gcmVtb3ZlLgoKICAgICAgICBjb25zdCBkZWxTdGFydCA9IFtpbmRleCwgaW5kZXggKyBsZWZ0RGVsLmxlbmd0aF07CiAgICAgICAgY29uc3QgZGVsRW5kID0gW2luZGV4ICsgbGVmdERlbC5sZW5ndGggKyBjb250ZW50Lmxlbmd0aCwgaW5kZXggKyBsZWZ0RGVsLmxlbmd0aCArIGNvbnRlbnQubGVuZ3RoICsgcmlnaHREZWwubGVuZ3RoXTsKICAgICAgICByZW1vdmUucHVzaChkZWxTdGFydCk7CiAgICAgICAgcmVtb3ZlLnB1c2goZGVsRW5kKTsKICAgICAgICBmb3JtYXQucHVzaChbaW5kZXggKyBsZWZ0RGVsLmxlbmd0aCwgaW5kZXggKyBsZWZ0RGVsLmxlbmd0aCArIGNvbnRlbnQubGVuZ3RoXSk7CiAgICAgIH0KCiAgICAgIHJldHVybiB7CiAgICAgICAgcmVtb3ZlLAogICAgICAgIGZvcm1hdAogICAgICB9OwogICAgfSk7IC8vIEEgZm9ybWF0IGNhbGxiYWNrIHJ1biBvbiBtYXRjaGVkIHRleHQuCgoKICAgIGZvcm1hdENhbGxiYWNrID0gZm9ybWF0Q2FsbGJhY2sgfHwgKCh3cml0ZXIsIHJhbmdlc1RvRm9ybWF0KSA9PiB7CiAgICAgIGNvbnN0IHZhbGlkUmFuZ2VzID0gZWRpdG9yLm1vZGVsLnNjaGVtYS5nZXRWYWxpZFJhbmdlcyhyYW5nZXNUb0Zvcm1hdCwgYXR0cmlidXRlS2V5KTsKCiAgICAgIGZvciAoY29uc3QgcmFuZ2Ugb2YgdmFsaWRSYW5nZXMpIHsKICAgICAgICB3cml0ZXIuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZUtleSwgdHJ1ZSwgcmFuZ2UpOwogICAgICB9IC8vIEFmdGVyIGFwcGx5aW5nIGF0dHJpYnV0ZSB0byB0aGUgdGV4dCwgcmVtb3ZlIGdpdmVuIGF0dHJpYnV0ZSBmcm9tIHRoZSBzZWxlY3Rpb24uCiAgICAgIC8vIFRoaXMgd2F5IHVzZXIgaXMgYWJsZSB0byB0eXBlIGEgdGV4dCB3aXRob3V0IGF0dHJpYnV0ZSB1c2VkIGJ5IGF1dG8gZm9ybWF0dGVyLgoKCiAgICAgIHdyaXRlci5yZW1vdmVTZWxlY3Rpb25BdHRyaWJ1dGUoYXR0cmlidXRlS2V5KTsKICAgIH0pOwoKICAgIGVkaXRvci5tb2RlbC5kb2N1bWVudC5vbignY2hhbmdlJywgKGV2dCwgYmF0Y2gpID0+IHsKICAgICAgaWYgKGJhdGNoLnR5cGUgPT0gJ3RyYW5zcGFyZW50JykgewogICAgICAgIHJldHVybjsKICAgICAgfQoKICAgICAgY29uc3QgbW9kZWwgPSBlZGl0b3IubW9kZWw7CiAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IG1vZGVsLmRvY3VtZW50LnNlbGVjdGlvbjsgLy8gRG8gbm90aGluZyBpZiBzZWxlY3Rpb24gaXMgbm90IGNvbGxhcHNlZC4KCiAgICAgIGlmICghc2VsZWN0aW9uLmlzQ29sbGFwc2VkKSB7CiAgICAgICAgcmV0dXJuOwogICAgICB9CgogICAgICBjb25zdCBjaGFuZ2VzID0gQXJyYXkuZnJvbShtb2RlbC5kb2N1bWVudC5kaWZmZXIuZ2V0Q2hhbmdlcygpKTsKICAgICAgY29uc3QgZW50cnkgPSBjaGFuZ2VzWzBdOyAvLyBUeXBpbmcgaXMgcmVwcmVzZW50ZWQgYnkgb25seSBhIHNpbmdsZSBjaGFuZ2UuCgogICAgICBpZiAoY2hhbmdlcy5sZW5ndGggIT0gMSB8fCBlbnRyeS50eXBlICE9PSAnaW5zZXJ0JyB8fCBlbnRyeS5uYW1lICE9ICckdGV4dCcgfHwgZW50cnkubGVuZ3RoICE9IDEpIHsKICAgICAgICByZXR1cm47CiAgICAgIH0KCiAgICAgIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzOwogICAgICBjb25zdCBibG9jayA9IGZvY3VzLnBhcmVudDsKICAgICAgY29uc3QgewogICAgICAgIHRleHQsCiAgICAgICAgcmFuZ2UKICAgICAgfSA9IGdldExhc3RUZXh0TGluZShtb2RlbC5jcmVhdGVSYW5nZShtb2RlbC5jcmVhdGVQb3NpdGlvbkF0KGJsb2NrLCAwKSwgZm9jdXMpLCBtb2RlbCk7CiAgICAgIGNvbnN0IHRlc3RPdXRwdXQgPSB0ZXN0Q2FsbGJhY2sodGV4dCk7CiAgICAgIGNvbnN0IHJhbmdlc1RvRm9ybWF0ID0gdGVzdE91dHB1dFRvUmFuZ2VzKHJhbmdlLnN0YXJ0LCB0ZXN0T3V0cHV0LmZvcm1hdCwgbW9kZWwpOwogICAgICBjb25zdCByYW5nZXNUb1JlbW92ZSA9IHRlc3RPdXRwdXRUb1JhbmdlcyhyYW5nZS5zdGFydCwgdGVzdE91dHB1dC5yZW1vdmUsIG1vZGVsKTsKCiAgICAgIGlmICghKHJhbmdlc1RvRm9ybWF0Lmxlbmd0aCAmJiByYW5nZXNUb1JlbW92ZS5sZW5ndGgpKSB7CiAgICAgICAgcmV0dXJuOwogICAgICB9IC8vIFVzZSBlbnF1ZXVlQ2hhbmdlIHRvIGNyZWF0ZSBuZXcgYmF0Y2ggdG8gc2VwYXJhdGUgdHlwaW5nIGJhdGNoIGZyb20gdGhlIGF1dG8tZm9ybWF0IGNoYW5nZXMuCgoKICAgICAgbW9kZWwuZW5xdWV1ZUNoYW5nZSh3cml0ZXIgPT4gewogICAgICAgIC8vIEFwcGx5IGZvcm1hdC4KICAgICAgICBjb25zdCBoYXNDaGFuZ2VkID0gZm9ybWF0Q2FsbGJhY2sod3JpdGVyLCByYW5nZXNUb0Zvcm1hdCk7IC8vIFN0cmljdCBjaGVjayBvbiBgZmFsc2VgIHRvIGhhdmUgYmFja3dhcmQgY29tcGF0aWJpbGl0eSAod2hlbiBjYWxsYmFja3Mgd2VyZSByZXR1cm5pbmcgYHVuZGVmaW5lZGApLgoKICAgICAgICBpZiAoaGFzQ2hhbmdlZCA9PT0gZmFsc2UpIHsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9IC8vIFJlbW92ZSBkZWxpbWl0ZXJzIC0gdXNlIHJldmVyc2VkIG9yZGVyIHRvIG5vdCBtaXggdGhlIG9mZnNldHMgd2hpbGUgcmVtb3ZpbmcuCgoKICAgICAgICBmb3IgKGNvbnN0IHJhbmdlIG9mIHJhbmdlc1RvUmVtb3ZlLnJldmVyc2UoKSkgewogICAgICAgICAgd3JpdGVyLnJlbW92ZShyYW5nZSk7CiAgICAgICAgfQogICAgICB9KTsKICAgIH0pOwogIH0KCn0gLy8gQ29udmVydHMgb3V0cHV0IG9mIHRoZSB0ZXN0IGZ1bmN0aW9uIHByb3ZpZGVkIHRvIHRoZSBJbmxpbmVBdXRvZm9ybWF0RWRpdGluZyBhbmQgY29udmVydHMgaXQgdG8gdGhlIG1vZGVsIHJhbmdlcwovLyBpbnNpZGUgcHJvdmlkZWQgYmxvY2suCi8vCi8vIEBwcml2YXRlCi8vIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0gc3RhcnQKLy8gQHBhcmFtIHtBcnJheS48QXJyYXk+fSBhcnJheXMKLy8gQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL21vZGVsfk1vZGVsfSBtb2RlbAoKZnVuY3Rpb24gdGVzdE91dHB1dFRvUmFuZ2VzKHN0YXJ0LCBhcnJheXMsIG1vZGVsKSB7CiAgcmV0dXJuIGFycmF5cy5maWx0ZXIoYXJyYXkgPT4gYXJyYXlbMF0gIT09IHVuZGVmaW5lZCAmJiBhcnJheVsxXSAhPT0gdW5kZWZpbmVkKS5tYXAoYXJyYXkgPT4gewogICAgcmV0dXJuIG1vZGVsLmNyZWF0ZVJhbmdlKHN0YXJ0LmdldFNoaWZ0ZWRCeShhcnJheVswXSksIHN0YXJ0LmdldFNoaWZ0ZWRCeShhcnJheVsxXSkpOwogIH0pOwp9"},{"version":3,"sources":["/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-autoformat/src/inlineautoformatediting.js"],"names":["getLastTextLine","InlineAutoformatEditing","pluginName","constructor","editor","testRegexpOrCallback","attributeOrCallback","regExp","attributeKey","testCallback","formatCallback","RegExp","text","result","remove","format","exec","length","index","leftDel","content","rightDel","found","delStart","delEnd","push","writer","rangesToFormat","validRanges","model","schema","getValidRanges","range","setAttribute","removeSelectionAttribute","document","on","evt","batch","type","selection","isCollapsed","changes","Array","from","differ","getChanges","entry","name","focus","block","parent","createRange","createPositionAt","testOutput","testOutputToRanges","start","rangesToRemove","enqueueChange","hasChanged","reverse","arrays","filter","array","undefined","map","getShiftedBy"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module autoformat/inlineautoformatediting\n */\n\nimport getLastTextLine from '@ckeditor/ckeditor5-typing/src/utils/getlasttextline';\n\n/**\n * The inline autoformatting engine. It allows to format various inline patterns. For example,\n * it can be configured to make \"foo\" bold when typed `**foo**` (the `**` markers will be removed).\n *\n * The autoformatting operation is integrated with the undo manager,\n * so the autoformatting step can be undone if the user's intention was not to format the text.\n *\n * See the constructors documentation to learn how to create custom inline autoformatters. You can also use\n * the {@link module:autoformat/autoformat~Autoformat} feature which enables a set of default autoformatters\n * (lists, headings, bold and italic).\n */\nexport default class InlineAutoformatEditing {\n\t/**\n\t * @inheritDoc\n\t */\n\tstatic get pluginName() {\n\t\treturn 'InlineAutoformatEditing';\n\t}\n\n\t/**\n\t * Enables autoformatting mechanism for a given {@link module:core/editor/editor~Editor}.\n\t *\n\t * It formats the matched text by applying the given model attribute or by running the provided formatting callback.\n\t * On every change applied to the model the autoformatting engine checks the text on the left of the selection\n\t * and executes the provided action if the text matches given criteria (regular expression or callback).\n\t *\n\t * @param {module:core/editor/editor~Editor} editor The editor instance.\n\t * @param {Function|RegExp} testRegexpOrCallback The regular expression or callback to execute on text.\n\t * Provided regular expression *must* have three capture groups. The first and the third capture group\n\t * should match opening and closing delimiters. The second capture group should match the text to format.\n\t *\n\t *\t\t// Matches the `**bold text**` pattern.\n\t *\t\t// There are three capturing groups:\n\t *\t\t// - The first to match the starting `**` delimiter.\n\t *\t\t// - The second to match the text to format.\n\t *\t\t// - The third to match the ending `**` delimiter.\n\t *\t\tnew InlineAutoformatEditing( editor, /(\\*\\*)([^\\*]+?)(\\*\\*)$/g, 'bold' );\n\t *\n\t * When a function is provided instead of the regular expression, it will be executed with the text to match as a parameter.\n\t * The function should return proper \"ranges\" to delete and format.\n\t *\n\t *\t\t{\n\t *\t\t\tremove: [\n\t *\t\t\t\t[ 0, 1 ],\t// Remove the first letter from the given text.\n\t *\t\t\t\t[ 5, 6 ]\t// Remove the 6th letter from the given text.\n\t *\t\t\t],\n\t *\t\t\tformat: [\n\t *\t\t\t\t[ 1, 5 ]\t// Format all letters from 2nd to 5th.\n\t *\t\t\t]\n\t *\t\t}\n\t *\n\t * @param {Function|String} attributeOrCallback The name of attribute to apply on matching text or a callback for manual\n\t * formatting. If callback is passed it should return `false` if changes should not be applied (e.g. if a command is disabled).\n\t *\n\t *\t\t// Use attribute name:\n\t *\t\tnew InlineAutoformatEditing( editor, /(\\*\\*)([^\\*]+?)(\\*\\*)$/g, 'bold' );\n\t *\n\t *\t\t// Use formatting callback:\n\t *\t\tnew InlineAutoformatEditing( editor, /(\\*\\*)([^\\*]+?)(\\*\\*)$/g, ( writer, rangesToFormat ) => {\n\t *\t\t\tconst command = editor.commands.get( 'bold' );\n\t *\n\t *\t\t\tif ( !command.isEnabled ) {\n\t *\t\t\t\treturn false;\n\t *\t\t\t}\n\t *\n\t *\t\t\tconst validRanges = editor.model.schema.getValidRanges( rangesToFormat, 'bold' );\n\t *\n\t *\t\t\tfor ( let range of validRanges ) {\n\t *\t\t\t\twriter.setAttribute( 'bold', true, range );\n\t *\t\t\t}\n\t *\t\t} );\n\t */\n\tconstructor( editor, testRegexpOrCallback, attributeOrCallback ) {\n\t\tlet regExp;\n\t\tlet attributeKey;\n\t\tlet testCallback;\n\t\tlet formatCallback;\n\n\t\tif ( testRegexpOrCallback instanceof RegExp ) {\n\t\t\tregExp = testRegexpOrCallback;\n\t\t} else {\n\t\t\ttestCallback = testRegexpOrCallback;\n\t\t}\n\n\t\tif ( typeof attributeOrCallback == 'string' ) {\n\t\t\tattributeKey = attributeOrCallback;\n\t\t} else {\n\t\t\tformatCallback = attributeOrCallback;\n\t\t}\n\n\t\t// A test callback run on changed text.\n\t\ttestCallback = testCallback || ( text => {\n\t\t\tlet result;\n\t\t\tconst remove = [];\n\t\t\tconst format = [];\n\n\t\t\twhile ( ( result = regExp.exec( text ) ) !== null ) {\n\t\t\t\t// There should be full match and 3 capture groups.\n\t\t\t\tif ( result && result.length < 4 ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tlet {\n\t\t\t\t\tindex,\n\t\t\t\t\t'1': leftDel,\n\t\t\t\t\t'2': content,\n\t\t\t\t\t'3': rightDel\n\t\t\t\t} = result;\n\n\t\t\t\t// Real matched string - there might be some non-capturing groups so we need to recalculate starting index.\n\t\t\t\tconst found = leftDel + content + rightDel;\n\t\t\t\tindex += result[ 0 ].length - found.length;\n\n\t\t\t\t// Start and End offsets of delimiters to remove.\n\t\t\t\tconst delStart = [\n\t\t\t\t\tindex,\n\t\t\t\t\tindex + leftDel.length\n\t\t\t\t];\n\t\t\t\tconst delEnd = [\n\t\t\t\t\tindex + leftDel.length + content.length,\n\t\t\t\t\tindex + leftDel.length + content.length + rightDel.length\n\t\t\t\t];\n\n\t\t\t\tremove.push( delStart );\n\t\t\t\tremove.push( delEnd );\n\n\t\t\t\tformat.push( [ index + leftDel.length, index + leftDel.length + content.length ] );\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tremove,\n\t\t\t\tformat\n\t\t\t};\n\t\t} );\n\n\t\t// A format callback run on matched text.\n\t\tformatCallback = formatCallback || ( ( writer, rangesToFormat ) => {\n\t\t\tconst validRanges = editor.model.schema.getValidRanges( rangesToFormat, attributeKey );\n\n\t\t\tfor ( const range of validRanges ) {\n\t\t\t\twriter.setAttribute( attributeKey, true, range );\n\t\t\t}\n\n\t\t\t// After applying attribute to the text, remove given attribute from the selection.\n\t\t\t// This way user is able to type a text without attribute used by auto formatter.\n\t\t\twriter.removeSelectionAttribute( attributeKey );\n\t\t} );\n\n\t\teditor.model.document.on( 'change', ( evt, batch ) => {\n\t\t\tif ( batch.type == 'transparent' ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst model = editor.model;\n\t\t\tconst selection = model.document.selection;\n\n\t\t\t// Do nothing if selection is not collapsed.\n\t\t\tif ( !selection.isCollapsed ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst changes = Array.from( model.document.differ.getChanges() );\n\t\t\tconst entry = changes[ 0 ];\n\n\t\t\t// Typing is represented by only a single change.\n\t\t\tif ( changes.length != 1 || entry.type !== 'insert' || entry.name != '$text' || entry.length != 1 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst focus = selection.focus;\n\t\t\tconst block = focus.parent;\n\t\t\tconst { text, range } = getLastTextLine( model.createRange( model.createPositionAt( block, 0 ), focus ), model );\n\t\t\tconst testOutput = testCallback( text );\n\t\t\tconst rangesToFormat = testOutputToRanges( range.start, testOutput.format, model );\n\t\t\tconst rangesToRemove = testOutputToRanges( range.start, testOutput.remove, model );\n\n\t\t\tif ( !( rangesToFormat.length && rangesToRemove.length ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Use enqueueChange to create new batch to separate typing batch from the auto-format changes.\n\t\t\tmodel.enqueueChange( writer => {\n\t\t\t\t// Apply format.\n\t\t\t\tconst hasChanged = formatCallback( writer, rangesToFormat );\n\n\t\t\t\t// Strict check on `false` to have backward compatibility (when callbacks were returning `undefined`).\n\t\t\t\tif ( hasChanged === false ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Remove delimiters - use reversed order to not mix the offsets while removing.\n\t\t\t\tfor ( const range of rangesToRemove.reverse() ) {\n\t\t\t\t\twriter.remove( range );\n\t\t\t\t}\n\t\t\t} );\n\t\t} );\n\t}\n}\n\n// Converts output of the test function provided to the InlineAutoformatEditing and converts it to the model ranges\n// inside provided block.\n//\n// @private\n// @param {module:engine/model/position~Position} start\n// @param {Array.<Array>} arrays\n// @param {module:engine/model/model~Model} model\nfunction testOutputToRanges( start, arrays, model ) {\n\treturn arrays\n\t\t.filter( array => ( array[ 0 ] !== undefined && array[ 1 ] !== undefined ) )\n\t\t.map( array => {\n\t\t\treturn model.createRange( start.getShiftedBy( array[ 0 ] ), start.getShiftedBy( array[ 1 ] ) );\n\t\t} );\n}\n"]}]}