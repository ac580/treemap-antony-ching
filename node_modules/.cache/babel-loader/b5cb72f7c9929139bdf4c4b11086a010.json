{"remainingRequest":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/babel-loader/lib/index.js!/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-engine/src/model/schema.js","dependencies":[{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-engine/src/model/schema.js","mtime":499162500000},{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js","mtime":499162500000},{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/babel-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:LyoqCiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDE5LCBDS1NvdXJjZSAtIEZyZWRlcmljbyBLbmFiYmVuLiBBbGwgcmlnaHRzIHJlc2VydmVkLgogKiBGb3IgbGljZW5zaW5nLCBzZWUgTElDRU5TRS5tZCBvciBodHRwczovL2NrZWRpdG9yLmNvbS9sZWdhbC9ja2VkaXRvci1vc3MtbGljZW5zZQogKi8KCi8qKgogKiBAbW9kdWxlIGVuZ2luZS9tb2RlbC9zY2hlbWEKICovCmltcG9ydCBDS0VkaXRvckVycm9yIGZyb20gJ0Bja2VkaXRvci9ja2VkaXRvcjUtdXRpbHMvc3JjL2NrZWRpdG9yZXJyb3InOwppbXBvcnQgT2JzZXJ2YWJsZU1peGluIGZyb20gJ0Bja2VkaXRvci9ja2VkaXRvcjUtdXRpbHMvc3JjL29ic2VydmFibGVtaXhpbic7CmltcG9ydCBtaXggZnJvbSAnQGNrZWRpdG9yL2NrZWRpdG9yNS11dGlscy9zcmMvbWl4JzsKaW1wb3J0IFJhbmdlIGZyb20gJy4vcmFuZ2UnOwppbXBvcnQgUG9zaXRpb24gZnJvbSAnLi9wb3NpdGlvbic7CmltcG9ydCBFbGVtZW50IGZyb20gJy4vZWxlbWVudCc7CmltcG9ydCBUZXh0IGZyb20gJy4vdGV4dCc7CmltcG9ydCBUcmVlV2Fsa2VyIGZyb20gJy4vdHJlZXdhbGtlcic7Ci8qKgogKiBUaGUgbW9kZWwncyBzY2hlbWEuIEl0IGRlZmluZXMgYWxsb3dlZCBhbmQgZGlzYWxsb3dlZCBzdHJ1Y3R1cmVzIG9mIG5vZGVzIGFzIHdlbGwgYXMgbm9kZXMnIGF0dHJpYnV0ZXMuCiAqIFRoZSBzY2hlbWEgaXMgdXN1YWxseSBkZWZpbmVkIGJ5IGZlYXR1cmVzIGFuZCBiYXNlZCBvbiB0aGVtIHRoZSBlZGl0aW5nIGZyYW1ld29yayBhbmQgZmVhdHVyZXMKICogbWFrZSBkZWNpc2lvbnMgaG93IHRvIGNoYW5nZSBhbmQgcHJvY2VzcyB0aGUgbW9kZWwuCiAqCiAqIFRoZSBpbnN0YW5jZSBvZiBzY2hlbWEgaXMgYXZhaWxhYmxlIGluIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL21vZGVsfk1vZGVsI3NjaGVtYSBgZWRpdG9yLm1vZGVsLnNjaGVtYWB9LgogKgogKiBSZWFkIG1vcmUgYWJvdXQgdGhlIHNjaGVtYSBpbjoKICoKICogKiB7QGdsaW5rIGZyYW1ld29yay9ndWlkZXMvYXJjaGl0ZWN0dXJlL2VkaXRpbmctZW5naW5lI3NjaGVtYSAiU2NoZW1hIn0gc2VjdGlvbiBvZiB0aGUKICoge0BnbGluayBmcmFtZXdvcmsvZ3VpZGVzL2FyY2hpdGVjdHVyZS9lZGl0aW5nLWVuZ2luZSBJbnRyb2R1Y3Rpb24gdG8gdGhlICJFZGl0aW5nIGVuZ2luZSBhcmNoaXRlY3R1cmUifS4KICogKiB7QGdsaW5rIGZyYW1ld29yay9ndWlkZXMvZGVlcC1kaXZlL3NjaGVtYSAiU2NoZW1hIiBkZWVwIGRpdmV9IGd1aWRlLgogKgogKiBAbWl4ZXMgbW9kdWxlOnV0aWxzL29ic2VydmFibGVtaXhpbn5PYnNlcnZhYmxlTWl4aW4KICovCgpleHBvcnQgZGVmYXVsdCBjbGFzcyBTY2hlbWEgewogIC8qKgogICAqIENyZWF0ZXMgc2NoZW1hIGluc3RhbmNlLgogICAqLwogIGNvbnN0cnVjdG9yKCkgewogICAgdGhpcy5fc291cmNlRGVmaW5pdGlvbnMgPSB7fTsKICAgIC8qKgogICAgICogQSBkaWN0aW9uYXJ5IGNvbnRhaW5pbmcgYXR0cmlidXRlIHByb3BlcnRpZXMuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEBtZW1iZXIge09iamVjdC48U3RyaW5nLFN0cmluZz59CiAgICAgKi8KCiAgICB0aGlzLl9hdHRyaWJ1dGVQcm9wZXJ0aWVzID0ge307CiAgICB0aGlzLmRlY29yYXRlKCdjaGVja0NoaWxkJyk7CiAgICB0aGlzLmRlY29yYXRlKCdjaGVja0F0dHJpYnV0ZScpOwogICAgdGhpcy5vbignY2hlY2tBdHRyaWJ1dGUnLCAoZXZ0LCBhcmdzKSA9PiB7CiAgICAgIGFyZ3NbMF0gPSBuZXcgU2NoZW1hQ29udGV4dChhcmdzWzBdKTsKICAgIH0sIHsKICAgICAgcHJpb3JpdHk6ICdoaWdoZXN0JwogICAgfSk7CiAgICB0aGlzLm9uKCdjaGVja0NoaWxkJywgKGV2dCwgYXJncykgPT4gewogICAgICBhcmdzWzBdID0gbmV3IFNjaGVtYUNvbnRleHQoYXJnc1swXSk7CiAgICAgIGFyZ3NbMV0gPSB0aGlzLmdldERlZmluaXRpb24oYXJnc1sxXSk7CiAgICB9LCB7CiAgICAgIHByaW9yaXR5OiAnaGlnaGVzdCcKICAgIH0pOwogIH0KICAvKioKICAgKiBSZWdpc3RlcnMgc2NoZW1hIGl0ZW0uIENhbiBvbmx5IGJlIGNhbGxlZCBvbmNlIGZvciBldmVyeSBpdGVtIG5hbWUuCiAgICoKICAgKgkJc2NoZW1hLnJlZ2lzdGVyKCAncGFyYWdyYXBoJywgewogICAqCQkJaW5oZXJpdEFsbEZyb206ICckYmxvY2snCiAgICoJCX0gKTsKICAgKgogICAqIEBwYXJhbSB7U3RyaW5nfSBpdGVtTmFtZQogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hSXRlbURlZmluaXRpb259IGRlZmluaXRpb24KICAgKi8KCgogIHJlZ2lzdGVyKGl0ZW1OYW1lLCBkZWZpbml0aW9uKSB7CiAgICBpZiAodGhpcy5fc291cmNlRGVmaW5pdGlvbnNbaXRlbU5hbWVdKSB7CiAgICAgIC8qKgogICAgICAgKiBBIHNpbmdsZSBpdGVtIGNhbm5vdCBiZSByZWdpc3RlcmVkIHR3aWNlIGluIHRoZSBzY2hlbWEuCiAgICAgICAqCiAgICAgICAqIFRoaXMgc2l0dWF0aW9uIG1heSBoYXBwZW4gd2hlbjoKICAgICAgICoKICAgICAgICogKiBUd28gb3IgbW9yZSBwbHVnaW5zIGNhbGxlZCB7QGxpbmsgI3JlZ2lzdGVyIGByZWdpc3RlcigpYH0gd2l0aCB0aGUgc2FtZSBuYW1lLiBUaGlzIHdpbGwgdXN1YWxseSBtZWFuIHRoYXQKICAgICAgICogdGhlcmUgaXMgYSBjb2xsaXNpb24gYmV0d2VlbiBwbHVnaW5zIHdoaWNoIHRyeSB0byB1c2UgdGhlIHNhbWUgZWxlbWVudCBpbiB0aGUgbW9kZWwuIFVuZm9ydHVuYXRlbHksCiAgICAgICAqIHRoZSBvbmx5IHdheSB0byBzb2x2ZSB0aGlzIGlzIGJ5IG1vZGlmeWluZyBvbmUgb2YgdGhlc2UgcGx1Z2lucyB0byB1c2UgYSB1bmlxdWUgbW9kZWwgZWxlbWVudCBuYW1lLgogICAgICAgKiAqIEEgc2luZ2xlIHBsdWdpbiB3YXMgbG9hZGVkIHR3aWNlLiBUaGlzIGhhcHBlbnMgd2hlbiBpdCBpcyBpbnN0YWxsZWQgYnkgbnBtL3lhcm4gaW4gdHdvIHZlcnNpb25zCiAgICAgICAqIGFuZCB1c3VhbGx5IG1lYW5zIG9uZSBvciBtb3JlIG9mIHRoZSBmb2xsb3dpbmcgaXNzdWVzOgogICAgICAgKiAgICAgKiBhIHZlcnNpb24gbWlzbWF0Y2ggKHR3byBvZiB5b3VyIGRlcGVuZGVuY2llcyByZXF1aXJlIHR3byBkaWZmZXJlbnQgdmVyc2lvbnMgb2YgdGhpcyBwbHVnaW4pLAogICAgICAgKiAgICAgKiBpbmNvcnJlY3QgaW1wb3J0cyAodGhpcyBwbHVnaW4gaXMgc29tZWhvdyBpbXBvcnRlZCB0d2ljZSBpbiBhIHdheSB3aGljaCBjb25mdXNlcyB3ZWJwYWNrKSwKICAgICAgICogICAgICogbWVzcyBpbiBgbm9kZV9tb2R1bGVzL2AgKGBybSAtcmYgbm9kZV9tb2R1bGVzL2AgbWF5IGhlbHApLgogICAgICAgKgogICAgICAgKiAqKk5vdGU6KiogQ2hlY2sgdGhlIGxvZ2dlZCBgaXRlbU5hbWVgIHRvIGJldHRlciB1bmRlcnN0YW5kIHdoaWNoIHBsdWdpbiB3YXMgZHVwbGljYXRlZC9jb25mbGljdGluZy4KICAgICAgICoKICAgICAgICogQHBhcmFtIGl0ZW1OYW1lIFRoZSBuYW1lIG9mIHRoZSBtb2RlbCBlbGVtZW50IHRoYXQgaXMgYmVpbmcgcmVnaXN0ZXJlZCB0d2ljZS4KICAgICAgICogQGVycm9yIHNjaGVtYS1jYW5ub3QtcmVnaXN0ZXItaXRlbS10d2ljZQogICAgICAgKi8KICAgICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ3NjaGVtYS1jYW5ub3QtcmVnaXN0ZXItaXRlbS10d2ljZTogQSBzaW5nbGUgaXRlbSBjYW5ub3QgYmUgcmVnaXN0ZXJlZCB0d2ljZSBpbiB0aGUgc2NoZW1hLicsIHRoaXMsIHsKICAgICAgICBpdGVtTmFtZQogICAgICB9KTsKICAgIH0KCiAgICB0aGlzLl9zb3VyY2VEZWZpbml0aW9uc1tpdGVtTmFtZV0gPSBbT2JqZWN0LmFzc2lnbih7fSwgZGVmaW5pdGlvbildOwoKICAgIHRoaXMuX2NsZWFyQ2FjaGUoKTsKICB9CiAgLyoqCiAgICogRXh0ZW5kcyBhIHtAbGluayAjcmVnaXN0ZXIgcmVnaXN0ZXJlZH0gaXRlbSdzIGRlZmluaXRpb24uCiAgICoKICAgKiBFeHRlbmRpbmcgcHJvcGVydGllcyBzdWNoIGFzIGBhbGxvd0luYCB3aWxsIGFkZCBtb3JlIGl0ZW1zIHRvIHRoZSBleGlzdGluZyBwcm9wZXJ0aWVzLAogICAqIHdoaWxlIHJlZGVmaW5pbmcgcHJvcGVydGllcyBzdWNoIGFzIGBpc0Jsb2NrYCB3aWxsIG92ZXJyaWRlIHRoZSBwcmV2aW91c2x5IGRlZmluZWQgb25lcy4KICAgKgogICAqCQlzY2hlbWEucmVnaXN0ZXIoICdmb28nLCB7CiAgICoJCQlhbGxvd0luOiAnJHJvb3QnLAogICAqCQkJaXNCbG9jazogdHJ1ZTsKICAgKgkJfSApOwogICAqCQlzY2hlbWEuZXh0ZW5kKCAnZm9vJywgewogICAqCQkJYWxsb3dJbjogJ2Jsb2NrUXVvdGUnLAogICAqCQkJaXNCbG9jazogZmFsc2UKICAgKgkJfSApOwogICAqCiAgICoJCXNjaGVtYS5nZXREZWZpbml0aW9uKCAnZm9vJyApOwogICAqCQkvLwl7CiAgICoJCS8vCQlhbGxvd0luOiBbICckcm9vdCcsICdibG9ja1F1b3RlJyBdLAogICAqCQkvLyAJCWlzQmxvY2s6IGZhbHNlCiAgICoJCS8vCX0KICAgKgogICAqIEBwYXJhbSB7U3RyaW5nfSBpdGVtTmFtZQogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hSXRlbURlZmluaXRpb259IGRlZmluaXRpb24KICAgKi8KCgogIGV4dGVuZChpdGVtTmFtZSwgZGVmaW5pdGlvbikgewogICAgaWYgKCF0aGlzLl9zb3VyY2VEZWZpbml0aW9uc1tpdGVtTmFtZV0pIHsKICAgICAgLyoqCiAgICAgICAqIENhbm5vdCBleHRlbmQgYW4gaXRlbSB3aGljaCB3YXMgbm90IHJlZ2lzdGVyZWQgeWV0LgogICAgICAgKgogICAgICAgKiBUaGlzIGVycm9yIGhhcHBlbnMgd2hlbiBhIHBsdWdpbiB0cmllcyB0byBleHRlbmQgdGhlIHNjaGVtYSBkZWZpbml0aW9uIG9mIGFuIGl0ZW0gd2hpY2ggd2FzIG5vdAogICAgICAgKiB7QGxpbmsgI3JlZ2lzdGVyIHJlZ2lzdGVyZWR9IHlldC4KICAgICAgICoKICAgICAgICogQHBhcmFtIGl0ZW1OYW1lIFRoZSBuYW1lIG9mIHRoZSBtb2RlbCBlbGVtZW50IHdoaWNoIGlzIGJlaW5nIGV4dGVuZGVkLgogICAgICAgKiBAZXJyb3Igc2NoZW1hLWNhbm5vdC1leHRlbmQtbWlzc2luZy1pdGVtCiAgICAgICAqLwogICAgICB0aHJvdyBuZXcgQ0tFZGl0b3JFcnJvcignc2NoZW1hLWNhbm5vdC1leHRlbmQtbWlzc2luZy1pdGVtOiBDYW5ub3QgZXh0ZW5kIGFuIGl0ZW0gd2hpY2ggd2FzIG5vdCByZWdpc3RlcmVkIHlldC4nLCB0aGlzLCB7CiAgICAgICAgaXRlbU5hbWUKICAgICAgfSk7CiAgICB9CgogICAgdGhpcy5fc291cmNlRGVmaW5pdGlvbnNbaXRlbU5hbWVdLnB1c2goT2JqZWN0LmFzc2lnbih7fSwgZGVmaW5pdGlvbikpOwoKICAgIHRoaXMuX2NsZWFyQ2FjaGUoKTsKICB9CiAgLyoqCiAgICogUmV0dXJucyBhbGwgcmVnaXN0ZXJlZCBpdGVtcy4KICAgKgogICAqIEByZXR1cm5zIHtPYmplY3QuPFN0cmluZyxtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWFDb21waWxlZEl0ZW1EZWZpbml0aW9uPn0KICAgKi8KCgogIGdldERlZmluaXRpb25zKCkgewogICAgaWYgKCF0aGlzLl9jb21waWxlZERlZmluaXRpb25zKSB7CiAgICAgIHRoaXMuX2NvbXBpbGUoKTsKICAgIH0KCiAgICByZXR1cm4gdGhpcy5fY29tcGlsZWREZWZpbml0aW9uczsKICB9CiAgLyoqCiAgICogUmV0dXJucyBhIGRlZmluaXRpb24gb2YgdGhlIGdpdmVuIGl0ZW0gb3IgYHVuZGVmaW5lZGAgaWYgaXRlbSBpcyBub3QgcmVnaXN0ZXJlZC4KICAgKgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9pdGVtfkl0ZW18bW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hQ29udGV4dEl0ZW18U3RyaW5nfSBpdGVtCiAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYUNvbXBpbGVkSXRlbURlZmluaXRpb259CiAgICovCgoKICBnZXREZWZpbml0aW9uKGl0ZW0pIHsKICAgIGxldCBpdGVtTmFtZTsKCiAgICBpZiAodHlwZW9mIGl0ZW0gPT0gJ3N0cmluZycpIHsKICAgICAgaXRlbU5hbWUgPSBpdGVtOwogICAgfSBlbHNlIGlmIChpdGVtLmlzICYmIChpdGVtLmlzKCd0ZXh0JykgfHwgaXRlbS5pcygndGV4dFByb3h5JykpKSB7CiAgICAgIGl0ZW1OYW1lID0gJyR0ZXh0JzsKICAgIH0gLy8gRWxlbWVudCBvciBtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWFDb250ZXh0SXRlbS4KICAgIGVsc2UgewogICAgICAgIGl0ZW1OYW1lID0gaXRlbS5uYW1lOwogICAgICB9CgogICAgcmV0dXJuIHRoaXMuZ2V0RGVmaW5pdGlvbnMoKVtpdGVtTmFtZV07CiAgfQogIC8qKgogICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBpdGVtIGlzIHJlZ2lzdGVyZWQgaW4gdGhlIHNjaGVtYS4KICAgKgogICAqCQlzY2hlbWEuaXNSZWdpc3RlcmVkKCAncGFyYWdyYXBoJyApOyAvLyAtPiB0cnVlCiAgICoJCXNjaGVtYS5pc1JlZ2lzdGVyZWQoIGVkaXRvci5tb2RlbC5kb2N1bWVudC5nZXRSb290KCkgKTsgLy8gLT4gdHJ1ZQogICAqCQlzY2hlbWEuaXNSZWdpc3RlcmVkKCAnZm9vJyApOyAvLyAtPiBmYWxzZQogICAqCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbXxtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWFDb250ZXh0SXRlbXxTdHJpbmd9IGl0ZW0KICAgKi8KCgogIGlzUmVnaXN0ZXJlZChpdGVtKSB7CiAgICByZXR1cm4gISF0aGlzLmdldERlZmluaXRpb24oaXRlbSk7CiAgfQogIC8qKgogICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBpdGVtIGlzIGRlZmluZWQgdG8gYmUKICAgKiBhIGJsb2NrIGJ5IHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWFJdGVtRGVmaW5pdGlvbn0ncyBgaXNCbG9ja2AgcHJvcGVydHkuCiAgICoKICAgKgkJc2NoZW1hLmlzQmxvY2soICdwYXJhZ3JhcGgnICk7IC8vIC0+IHRydWUKICAgKgkJc2NoZW1hLmlzQmxvY2soICckcm9vdCcgKTsgLy8gLT4gZmFsc2UKICAgKgogICAqCQljb25zdCBwYXJhZ3JhcGhFbGVtZW50ID0gd3JpdGVyLmNyZWF0ZUVsZW1lbnQoICdwYXJhZ3JhcGgnICk7CiAgICoJCXNjaGVtYS5pc0Jsb2NrKCBwYXJhZ3JhcGhFbGVtZW50ICk7IC8vIC0+IHRydWUKICAgKgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9pdGVtfkl0ZW18bW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hQ29udGV4dEl0ZW18U3RyaW5nfSBpdGVtCiAgICovCgoKICBpc0Jsb2NrKGl0ZW0pIHsKICAgIGNvbnN0IGRlZiA9IHRoaXMuZ2V0RGVmaW5pdGlvbihpdGVtKTsKICAgIHJldHVybiAhIShkZWYgJiYgZGVmLmlzQmxvY2spOwogIH0KICAvKioKICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gaXRlbSBpcyBkZWZpbmVkIHRvIGJlCiAgICogYSBsaW1pdCBlbGVtZW50IGJ5IHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWFJdGVtRGVmaW5pdGlvbn0ncyBgaXNMaW1pdGAgb3IgYGlzT2JqZWN0YCBwcm9wZXJ0eQogICAqIChhbGwgb2JqZWN0cyBhcmUgYWxzbyBsaW1pdHMpLgogICAqCiAgICoJCXNjaGVtYS5pc0xpbWl0KCAncGFyYWdyYXBoJyApOyAvLyAtPiBmYWxzZQogICAqCQlzY2hlbWEuaXNMaW1pdCggJyRyb290JyApOyAvLyAtPiB0cnVlCiAgICoJCXNjaGVtYS5pc0xpbWl0KCBlZGl0b3IubW9kZWwuZG9jdW1lbnQuZ2V0Um9vdCgpICk7IC8vIC0+IHRydWUKICAgKgkJc2NoZW1hLmlzTGltaXQoICdpbWFnZScgKTsgLy8gLT4gdHJ1ZQogICAqCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbXxtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWFDb250ZXh0SXRlbXxTdHJpbmd9IGl0ZW0KICAgKi8KCgogIGlzTGltaXQoaXRlbSkgewogICAgY29uc3QgZGVmID0gdGhpcy5nZXREZWZpbml0aW9uKGl0ZW0pOwoKICAgIGlmICghZGVmKSB7CiAgICAgIHJldHVybiBmYWxzZTsKICAgIH0KCiAgICByZXR1cm4gISEoZGVmLmlzTGltaXQgfHwgZGVmLmlzT2JqZWN0KTsKICB9CiAgLyoqCiAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIGl0ZW0gaXMgZGVmaW5lZCB0byBiZQogICAqIGFuIG9iamVjdCBlbGVtZW50IGJ5IHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWFJdGVtRGVmaW5pdGlvbn0ncyBgaXNPYmplY3RgIHByb3BlcnR5LgogICAqCiAgICoJCXNjaGVtYS5pc09iamVjdCggJ3BhcmFncmFwaCcgKTsgLy8gLT4gZmFsc2UKICAgKgkJc2NoZW1hLmlzT2JqZWN0KCAnaW1hZ2UnICk7IC8vIC0+IHRydWUKICAgKgogICAqCQljb25zdCBpbWFnZUVsZW1lbnQgPSB3cml0ZXIuY3JlYXRlRWxlbWVudCggJ2ltYWdlJyApOwogICAqCQlzY2hlbWEuaXNPYmplY3QoIGltYWdlRWxlbWVudCApOyAvLyAtPiB0cnVlCiAgICoKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtfG1vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYUNvbnRleHRJdGVtfFN0cmluZ30gaXRlbQogICAqLwoKCiAgaXNPYmplY3QoaXRlbSkgewogICAgY29uc3QgZGVmID0gdGhpcy5nZXREZWZpbml0aW9uKGl0ZW0pOwogICAgcmV0dXJuICEhKGRlZiAmJiBkZWYuaXNPYmplY3QpOwogIH0KICAvKioKICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gaXRlbSBpcyBkZWZpbmVkIHRvIGJlCiAgICogYW4gaW5saW5lIGVsZW1lbnQgYnkge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYUl0ZW1EZWZpbml0aW9ufSdzIGBpc0lubGluZWAgcHJvcGVydHkuCiAgICoKICAgKgkJc2NoZW1hLmlzSW5saW5lKCAncGFyYWdyYXBoJyApOyAvLyAtPiBmYWxzZQogICAqCQlzY2hlbWEuaXNJbmxpbmUoICdzb2Z0QnJlYWsnICk7IC8vIC0+IHRydWUKICAgKgogICAqCQljb25zdCB0ZXh0ID0gd3JpdGVyLmNyZWF0ZVRleHQoJ2ZvbycgKTsKICAgKgkJc2NoZW1hLmlzSW5saW5lKCB0ZXh0ICk7IC8vIC0+IHRydWUKICAgKgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9pdGVtfkl0ZW18bW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hQ29udGV4dEl0ZW18U3RyaW5nfSBpdGVtCiAgICovCgoKICBpc0lubGluZShpdGVtKSB7CiAgICBjb25zdCBkZWYgPSB0aGlzLmdldERlZmluaXRpb24oaXRlbSk7CiAgICByZXR1cm4gISEoZGVmICYmIGRlZi5pc0lubGluZSk7CiAgfQogIC8qKgogICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBub2RlIChgY2hpbGRgKSBjYW4gYmUgYSBjaGlsZCBvZiB0aGUgZ2l2ZW4gY29udGV4dC4KICAgKgogICAqCQlzY2hlbWEuY2hlY2tDaGlsZCggbW9kZWwuZG9jdW1lbnQuZ2V0Um9vdCgpLCBwYXJhZ3JhcGggKTsgLy8gLT4gZmFsc2UKICAgKgogICAqCQlzY2hlbWEucmVnaXN0ZXIoICdwYXJhZ3JhcGgnLCB7CiAgICoJCQlhbGxvd0luOiAnJHJvb3QnCiAgICoJCX0gKTsKICAgKgkJc2NoZW1hLmNoZWNrQ2hpbGQoIG1vZGVsLmRvY3VtZW50LmdldFJvb3QoKSwgcGFyYWdyYXBoICk7IC8vIC0+IHRydWUKICAgKgogICAqIE5vdGU6IFdoZW4gdmVyaWZ5aW5nIHdoZXRoZXIgdGhlIGdpdmVuIG5vZGUgY2FuIGJlIGEgY2hpbGQgb2YgdGhlIGdpdmVuIGNvbnRleHQsIHRoZQogICAqIHNjaGVtYSBhbHNvIHZlcmlmaWVzIHRoZSBlbnRpcmUgY29udGV4dCAmbWRhc2g7IGZyb20gaXRzIHJvb3QgdG8gaXRzIGxhc3QgZWxlbWVudC4gVGhlcmVmb3JlLCBpdCBpcyBwb3NzaWJsZQogICAqIGZvciBgY2hlY2tDaGlsZCgpYCB0byByZXR1cm4gYGZhbHNlYCBldmVuIHRob3VnaCB0aGUgY29udGV4dCdzIGxhc3QgZWxlbWVudCBjYW4gY29udGFpbiB0aGUgY2hlY2tlZCBjaGlsZC4KICAgKiBJdCBoYXBwZW5zIGlmIG9uZSBvZiB0aGUgY29udGV4dCdzIGVsZW1lbnRzIGRvZXMgbm90IGFsbG93IGl0cyBjaGlsZC4KICAgKgogICAqIEBmaXJlcyBjaGVja0NoaWxkCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWFDb250ZXh0RGVmaW5pdGlvbn0gY29udGV4dCBUaGUgY29udGV4dCBpbiB3aGljaCB0aGUgY2hpbGQgd2lsbCBiZSBjaGVja2VkLgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9ub2Rlfk5vZGV8U3RyaW5nfSBkZWYgVGhlIGNoaWxkIHRvIGNoZWNrLgogICAqLwoKCiAgY2hlY2tDaGlsZChjb250ZXh0LCBkZWYpIHsKICAgIC8vIE5vdGU6IGNvbnRleHQgYW5kIGNoaWxkIGFyZSBhbHJlYWR5IG5vcm1hbGl6ZWQgaGVyZSB0byBhIFNjaGVtYUNvbnRleHQgYW5kIFNjaGVtYUNvbXBpbGVkSXRlbURlZmluaXRpb24uCiAgICBpZiAoIWRlZikgewogICAgICByZXR1cm4gZmFsc2U7CiAgICB9CgogICAgcmV0dXJuIHRoaXMuX2NoZWNrQ29udGV4dE1hdGNoKGRlZiwgY29udGV4dCk7CiAgfQogIC8qKgogICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBhdHRyaWJ1dGUgY2FuIGJlIGFwcGxpZWQgaW4gdGhlIGdpdmVuIGNvbnRleHQgKG9uIHRoZSBsYXN0CiAgICogaXRlbSBvZiB0aGUgY29udGV4dCkuCiAgICoKICAgKgkJc2NoZW1hLmNoZWNrQXR0cmlidXRlKCB0ZXh0Tm9kZSwgJ2JvbGQnICk7IC8vIC0+IGZhbHNlCiAgICoKICAgKgkJc2NoZW1hLmV4dGVuZCggJyR0ZXh0JywgewogICAqCQkJYWxsb3dBdHRyaWJ1dGVzOiAnYm9sZCcKICAgKgkJfSApOwogICAqCQlzY2hlbWEuY2hlY2tBdHRyaWJ1dGUoIHRleHROb2RlLCAnYm9sZCcgKTsgLy8gLT4gdHJ1ZQogICAqCiAgICogQGZpcmVzIGNoZWNrQXR0cmlidXRlCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWFDb250ZXh0RGVmaW5pdGlvbn0gY29udGV4dCBUaGUgY29udGV4dCBpbiB3aGljaCB0aGUgYXR0cmlidXRlIHdpbGwgYmUgY2hlY2tlZC4KICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0cmlidXRlTmFtZQogICAqLwoKCiAgY2hlY2tBdHRyaWJ1dGUoY29udGV4dCwgYXR0cmlidXRlTmFtZSkgewogICAgY29uc3QgZGVmID0gdGhpcy5nZXREZWZpbml0aW9uKGNvbnRleHQubGFzdCk7CgogICAgaWYgKCFkZWYpIHsKICAgICAgcmV0dXJuIGZhbHNlOwogICAgfQoKICAgIHJldHVybiBkZWYuYWxsb3dBdHRyaWJ1dGVzLmluY2x1ZGVzKGF0dHJpYnV0ZU5hbWUpOwogIH0KICAvKioKICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gZWxlbWVudCAoYGVsZW1lbnRUb01lcmdlYCkgY2FuIGJlIG1lcmdlZCB3aXRoIHRoZSBzcGVjaWZpZWQgYmFzZSBlbGVtZW50IChgcG9zaXRpb25PckJhc2VFbGVtZW50YCkuCiAgICoKICAgKiBJbiBvdGhlciB3b3JkcyAmbWRhc2g7IHdoZXRoZXIgYGVsZW1lbnRUb01lcmdlYCdzIGNoaWxkcmVuIHtAbGluayAjY2hlY2tDaGlsZCBhcmUgYWxsb3dlZH0gaW4gdGhlIGBwb3NpdGlvbk9yQmFzZUVsZW1lbnRgLgogICAqCiAgICogVGhpcyBjaGVjayBlbnN1cmVzIHRoYXQgZWxlbWVudHMgbWVyZ2VkIHdpdGgge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvd3JpdGVyfldyaXRlciNtZXJnZSBgV3JpdGVyI21lcmdlKClgfQogICAqIHdpbGwgYmUgdmFsaWQuCiAgICoKICAgKiBJbnN0ZWFkIG9mIGVsZW1lbnRzLCB5b3UgY2FuIHBhc3MgdGhlIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0gY2xhc3MgYXMgdGhlCiAgICogYHBvc2l0aW9uT3JCYXNlRWxlbWVudGAuIEl0IG1lYW5zIHRoYXQgdGhlIGVsZW1lbnRzIGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIHBvc2l0aW9uIHdpbGwgYmUgY2hlY2tlZCB3aGV0aGVyIHRoZXkgY2FuIGJlIG1lcmdlZC4KICAgKgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbnxtb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudH0gcG9zaXRpb25PckJhc2VFbGVtZW50IFRoZSBwb3NpdGlvbiBvciBiYXNlCiAgICogZWxlbWVudCB0byB3aGljaCB0aGUgYGVsZW1lbnRUb01lcmdlYCB3aWxsIGJlIG1lcmdlZC4KICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50fSBlbGVtZW50VG9NZXJnZSBUaGUgZWxlbWVudCB0byBtZXJnZS4gUmVxdWlyZWQgaWYgYHBvc2l0aW9uT3JCYXNlRWxlbWVudGAgaXMgYW4gZWxlbWVudC4KICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0KICAgKi8KCgogIGNoZWNrTWVyZ2UocG9zaXRpb25PckJhc2VFbGVtZW50LCBlbGVtZW50VG9NZXJnZSA9IG51bGwpIHsKICAgIGlmIChwb3NpdGlvbk9yQmFzZUVsZW1lbnQgaW5zdGFuY2VvZiBQb3NpdGlvbikgewogICAgICBjb25zdCBub2RlQmVmb3JlID0gcG9zaXRpb25PckJhc2VFbGVtZW50Lm5vZGVCZWZvcmU7CiAgICAgIGNvbnN0IG5vZGVBZnRlciA9IHBvc2l0aW9uT3JCYXNlRWxlbWVudC5ub2RlQWZ0ZXI7CgogICAgICBpZiAoIShub2RlQmVmb3JlIGluc3RhbmNlb2YgRWxlbWVudCkpIHsKICAgICAgICAvKioKICAgICAgICAgKiBUaGUgbm9kZSBiZWZvcmUgdGhlIG1lcmdlIHBvc2l0aW9uIG11c3QgYmUgYW4gZWxlbWVudC4KICAgICAgICAgKgogICAgICAgICAqIEBlcnJvciBzY2hlbWEtY2hlY2stbWVyZ2Utbm8tZWxlbWVudC1iZWZvcmUKICAgICAgICAgKi8KICAgICAgICB0aHJvdyBuZXcgQ0tFZGl0b3JFcnJvcignc2NoZW1hLWNoZWNrLW1lcmdlLW5vLWVsZW1lbnQtYmVmb3JlOiBUaGUgbm9kZSBiZWZvcmUgdGhlIG1lcmdlIHBvc2l0aW9uIG11c3QgYmUgYW4gZWxlbWVudC4nLCB0aGlzKTsKICAgICAgfQoKICAgICAgaWYgKCEobm9kZUFmdGVyIGluc3RhbmNlb2YgRWxlbWVudCkpIHsKICAgICAgICAvKioKICAgICAgICAgKiBUaGUgbm9kZSBhZnRlciB0aGUgbWVyZ2UgcG9zaXRpb24gbXVzdCBiZSBhbiBlbGVtZW50LgogICAgICAgICAqCiAgICAgICAgICogQGVycm9yIHNjaGVtYS1jaGVjay1tZXJnZS1uby1lbGVtZW50LWFmdGVyCiAgICAgICAgICovCiAgICAgICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ3NjaGVtYS1jaGVjay1tZXJnZS1uby1lbGVtZW50LWFmdGVyOiBUaGUgbm9kZSBhZnRlciB0aGUgbWVyZ2UgcG9zaXRpb24gbXVzdCBiZSBhbiBlbGVtZW50LicsIHRoaXMpOwogICAgICB9CgogICAgICByZXR1cm4gdGhpcy5jaGVja01lcmdlKG5vZGVCZWZvcmUsIG5vZGVBZnRlcik7CiAgICB9CgogICAgZm9yIChjb25zdCBjaGlsZCBvZiBlbGVtZW50VG9NZXJnZS5nZXRDaGlsZHJlbigpKSB7CiAgICAgIGlmICghdGhpcy5jaGVja0NoaWxkKHBvc2l0aW9uT3JCYXNlRWxlbWVudCwgY2hpbGQpKSB7CiAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICB9CiAgICB9CgogICAgcmV0dXJuIHRydWU7CiAgfQogIC8qKgogICAqIEFsbG93cyByZWdpc3RlcmluZyBhIGNhbGxiYWNrIHRvIHRoZSB7QGxpbmsgI2NoZWNrQ2hpbGR9IG1ldGhvZCBjYWxscy4KICAgKgogICAqIENhbGxiYWNrcyBhbGxvdyB5b3UgdG8gaW1wbGVtZW50IHJ1bGVzIHdoaWNoIGFyZSBub3Qgb3RoZXJ3aXNlIHBvc3NpYmxlIHRvIGFjaGlldmUKICAgKiBieSB1c2luZyB0aGUgZGVjbGFyYXRpdmUgQVBJIG9mIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWFJdGVtRGVmaW5pdGlvbn0uCiAgICogRm9yIGV4YW1wbGUsIGJ5IHVzaW5nIHRoaXMgbWV0aG9kIHlvdSBjYW4gZGlzYWxsb3cgZWxlbWVudHMgaW4gc3BlY2lmaWMgY29udGV4dHMuCiAgICoKICAgKiBUaGlzIG1ldGhvZCBpcyBhIHNob3J0aGFuZCBmb3IgdXNpbmcgdGhlIHtAbGluayAjZXZlbnQ6Y2hlY2tDaGlsZH0gZXZlbnQuIEZvciBldmVuIGJldHRlciBjb250cm9sLAogICAqIHlvdSBjYW4gdXNlIHRoYXQgZXZlbnQgaW5zdGVhZC4KICAgKgogICAqIEV4YW1wbGU6CiAgICoKICAgKgkJLy8gRGlzYWxsb3cgaGVhZGluZzEgZGlyZWN0bHkgaW5zaWRlIGEgYmxvY2tRdW90ZS4KICAgKgkJc2NoZW1hLmFkZENoaWxkQ2hlY2soICggY29udGV4dCwgY2hpbGREZWZpbml0aW9uICkgPT4gewogICAqCQkJaWYgKCBjb250ZXh0LmVuZHNXaXRoKCAnYmxvY2tRdW90ZScgKSAmJiBjaGlsZERlZmluaXRpb24ubmFtZSA9PSAnaGVhZGluZzEnICkgewogICAqCQkJCXJldHVybiBmYWxzZTsKICAgKgkJCX0KICAgKgkJfSApOwogICAqCiAgICogV2hpY2ggdHJhbnNsYXRlcyB0bzoKICAgKgogICAqCQlzY2hlbWEub24oICdjaGVja0NoaWxkJywgKCBldnQsIGFyZ3MgKSA9PiB7CiAgICoJCQljb25zdCBjb250ZXh0ID0gYXJnc1sgMCBdOwogICAqCQkJY29uc3QgY2hpbGREZWZpbml0aW9uID0gYXJnc1sgMSBdOwogICAqCiAgICoJCQlpZiAoIGNvbnRleHQuZW5kc1dpdGgoICdibG9ja1F1b3RlJyApICYmIGNoaWxkRGVmaW5pdGlvbiAmJiBjaGlsZERlZmluaXRpb24ubmFtZSA9PSAnaGVhZGluZzEnICkgewogICAqCQkJCS8vIFByZXZlbnQgbmV4dCBsaXN0ZW5lcnMgZnJvbSBiZWluZyBjYWxsZWQuCiAgICoJCQkJZXZ0LnN0b3AoKTsKICAgKgkJCQkvLyBTZXQgdGhlIGNoZWNrQ2hpbGQoKSdzIHJldHVybiB2YWx1ZS4KICAgKgkJCQlldnQucmV0dXJuID0gZmFsc2U7CiAgICoJCQl9CiAgICoJCX0sIHsgcHJpb3JpdHk6ICdoaWdoJyB9ICk7CiAgICoKICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgY2FsbGJhY2sgdG8gYmUgY2FsbGVkLiBJdCBpcyBjYWxsZWQgd2l0aCB0d28gcGFyYW1ldGVyczoKICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hQ29udGV4dH0gKGNvbnRleHQpIGluc3RhbmNlIGFuZAogICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWFDb21waWxlZEl0ZW1EZWZpbml0aW9ufSAoY2hpbGQtdG8tY2hlY2sgZGVmaW5pdGlvbikuCiAgICogVGhlIGNhbGxiYWNrIG1heSByZXR1cm4gYHRydWUvZmFsc2VgIHRvIG92ZXJyaWRlIGBjaGVja0NoaWxkKClgJ3MgcmV0dXJuIHZhbHVlLiBJZiBpdCBkb2VzIG5vdCByZXR1cm4KICAgKiBhIGJvb2xlYW4gdmFsdWUsIHRoZSBkZWZhdWx0IGFsZ29yaXRobSAob3Igb3RoZXIgY2FsbGJhY2tzKSB3aWxsIGRlZmluZSBgY2hlY2tDaGlsZCgpYCdzIHJldHVybiB2YWx1ZS4KICAgKi8KCgogIGFkZENoaWxkQ2hlY2soY2FsbGJhY2spIHsKICAgIHRoaXMub24oJ2NoZWNrQ2hpbGQnLCAoZXZ0LCBbY3R4LCBjaGlsZERlZl0pID0+IHsKICAgICAgLy8gY2hlY2tDaGlsZCgpIHdhcyBjYWxsZWQgd2l0aCBhIG5vbi1yZWdpc3RlcmVkIGNoaWxkLgogICAgICAvLyBJbiA5OSUgY2FzZXMgc3VjaCBjaGVjayBzaG91bGQgcmV0dXJuIGZhbHNlLCBzbyBub3QgdG8gb3ZlcmNvbXBsaWNhdGUgYWxsIGNhbGxiYWNrcwogICAgICAvLyBkb24ndCBldmVuIGV4ZWN1dGUgdGhlbS4KICAgICAgaWYgKCFjaGlsZERlZikgewogICAgICAgIHJldHVybjsKICAgICAgfQoKICAgICAgY29uc3QgcmV0VmFsdWUgPSBjYWxsYmFjayhjdHgsIGNoaWxkRGVmKTsKCiAgICAgIGlmICh0eXBlb2YgcmV0VmFsdWUgPT0gJ2Jvb2xlYW4nKSB7CiAgICAgICAgZXZ0LnN0b3AoKTsKICAgICAgICBldnQucmV0dXJuID0gcmV0VmFsdWU7CiAgICAgIH0KICAgIH0sIHsKICAgICAgcHJpb3JpdHk6ICdoaWdoJwogICAgfSk7CiAgfQogIC8qKgogICAqIEFsbG93cyByZWdpc3RlcmluZyBhIGNhbGxiYWNrIHRvIHRoZSB7QGxpbmsgI2NoZWNrQXR0cmlidXRlfSBtZXRob2QgY2FsbHMuCiAgICoKICAgKiBDYWxsYmFja3MgYWxsb3cgeW91IHRvIGltcGxlbWVudCBydWxlcyB3aGljaCBhcmUgbm90IG90aGVyd2lzZSBwb3NzaWJsZSB0byBhY2hpZXZlCiAgICogYnkgdXNpbmcgdGhlIGRlY2xhcmF0aXZlIEFQSSBvZiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hSXRlbURlZmluaXRpb259LgogICAqIEZvciBleGFtcGxlLCBieSB1c2luZyB0aGlzIG1ldGhvZCB5b3UgY2FuIGRpc2FsbG93IGF0dHJpYnV0ZSBpZiBub2RlIHRvIHdoaWNoIGl0IGlzIGFwcGxpZWQKICAgKiBpcyBjb250YWluZWQgd2l0aGluIHNvbWUgb3RoZXIgZWxlbWVudCAoZS5nLiB5b3Ugd2FudCB0byBkaXNhbGxvdyBgYm9sZGAgb24gYCR0ZXh0YCB3aXRoaW4gYGhlYWRpbmcxYCkuCiAgICoKICAgKiBUaGlzIG1ldGhvZCBpcyBhIHNob3J0aGFuZCBmb3IgdXNpbmcgdGhlIHtAbGluayAjZXZlbnQ6Y2hlY2tBdHRyaWJ1dGV9IGV2ZW50LiBGb3IgZXZlbiBiZXR0ZXIgY29udHJvbCwKICAgKiB5b3UgY2FuIHVzZSB0aGF0IGV2ZW50IGluc3RlYWQuCiAgICoKICAgKiBFeGFtcGxlOgogICAqCiAgICoJCS8vIERpc2FsbG93IGJvbGQgb24gJHRleHQgaW5zaWRlIGhlYWRpbmcxLgogICAqCQlzY2hlbWEuYWRkQXR0cmlidXRlQ2hlY2soICggY29udGV4dCwgYXR0cmlidXRlTmFtZSApID0+IHsKICAgKgkJCWlmICggY29udGV4dC5lbmRzV2l0aCggJ2hlYWRpbmcxICR0ZXh0JyApICYmIGF0dHJpYnV0ZU5hbWUgPT0gJ2JvbGQnICkgewogICAqCQkJCXJldHVybiBmYWxzZTsKICAgKgkJCX0KICAgKgkJfSApOwogICAqCiAgICogV2hpY2ggdHJhbnNsYXRlcyB0bzoKICAgKgogICAqCQlzY2hlbWEub24oICdjaGVja0F0dHJpYnV0ZScsICggZXZ0LCBhcmdzICkgPT4gewogICAqCQkJY29uc3QgY29udGV4dCA9IGFyZ3NbIDAgXTsKICAgKgkJCWNvbnN0IGF0dHJpYnV0ZU5hbWUgPSBhcmdzWyAxIF07CiAgICoKICAgKgkJCWlmICggY29udGV4dC5lbmRzV2l0aCggJ2hlYWRpbmcxICR0ZXh0JyApICYmIGF0dHJpYnV0ZU5hbWUgPT0gJ2JvbGQnICkgewogICAqCQkJCS8vIFByZXZlbnQgbmV4dCBsaXN0ZW5lcnMgZnJvbSBiZWluZyBjYWxsZWQuCiAgICoJCQkJZXZ0LnN0b3AoKTsKICAgKgkJCQkvLyBTZXQgdGhlIGNoZWNrQXR0cmlidXRlKCkncyByZXR1cm4gdmFsdWUuCiAgICoJCQkJZXZ0LnJldHVybiA9IGZhbHNlOwogICAqCQkJfQogICAqCQl9LCB7IHByaW9yaXR5OiAnaGlnaCcgfSApOwogICAqCiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZC4gSXQgaXMgY2FsbGVkIHdpdGggdHdvIHBhcmFtZXRlcnM6CiAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYUNvbnRleHR9IChjb250ZXh0KSBpbnN0YW5jZSBhbmQgYXR0cmlidXRlIG5hbWUuCiAgICogVGhlIGNhbGxiYWNrIG1heSByZXR1cm4gYHRydWUvZmFsc2VgIHRvIG92ZXJyaWRlIGBjaGVja0F0dHJpYnV0ZSgpYCdzIHJldHVybiB2YWx1ZS4gSWYgaXQgZG9lcyBub3QgcmV0dXJuCiAgICogYSBib29sZWFuIHZhbHVlLCB0aGUgZGVmYXVsdCBhbGdvcml0aG0gKG9yIG90aGVyIGNhbGxiYWNrcykgd2lsbCBkZWZpbmUgYGNoZWNrQXR0cmlidXRlKClgJ3MgcmV0dXJuIHZhbHVlLgogICAqLwoKCiAgYWRkQXR0cmlidXRlQ2hlY2soY2FsbGJhY2spIHsKICAgIHRoaXMub24oJ2NoZWNrQXR0cmlidXRlJywgKGV2dCwgW2N0eCwgYXR0cmlidXRlTmFtZV0pID0+IHsKICAgICAgY29uc3QgcmV0VmFsdWUgPSBjYWxsYmFjayhjdHgsIGF0dHJpYnV0ZU5hbWUpOwoKICAgICAgaWYgKHR5cGVvZiByZXRWYWx1ZSA9PSAnYm9vbGVhbicpIHsKICAgICAgICBldnQuc3RvcCgpOwogICAgICAgIGV2dC5yZXR1cm4gPSByZXRWYWx1ZTsKICAgICAgfQogICAgfSwgewogICAgICBwcmlvcml0eTogJ2hpZ2gnCiAgICB9KTsKICB9CiAgLyoqCiAgICogVGhpcyBtZXRob2QgYWxsb3dzIGFzc2lnbmluZyBhZGRpdGlvbmFsIG1ldGFkYXRhIHRvIHRoZSBtb2RlbCBhdHRyaWJ1dGVzLiBGb3IgZXhhbXBsZSwKICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+QXR0cmlidXRlUHJvcGVydGllcyBgQXR0cmlidXRlUHJvcGVydGllcyNpc0Zvcm1hdHRpbmdgIHByb3BlcnR5fSBpcwogICAqIHVzZWQgdG8gbWFyayBmb3JtYXR0aW5nIGF0dHJpYnV0ZXMgKGxpa2UgYGJvbGRgIG9yIGBpdGFsaWNgKS4KICAgKgogICAqCQkvLyBNYXJrIGJvbGQgYXMgYSBmb3JtYXR0aW5nIGF0dHJpYnV0ZS4KICAgKgkJc2NoZW1hLnNldEF0dHJpYnV0ZVByb3BlcnRpZXMoICdib2xkJywgewogICAqCQkJaXNGb3JtYXR0aW5nOiB0cnVlCiAgICoJCX0gKTsKICAgKgogICAqCQkvLyBPdmVycmlkZSBjb2RlIG5vdCB0byBiZSBjb25zaWRlcmVkIGEgZm9ybWF0dGluZyBtYXJrdXAuCiAgICoJCXNjaGVtYS5zZXRBdHRyaWJ1dGVQcm9wZXJ0aWVzKCAnY29kZScsIHsKICAgKgkJCWlzRm9ybWF0dGluZzogZmFsc2UKICAgKgkJfSApOwogICAqCiAgICogUHJvcGVydGllcyBhcmUgbm90IGxpbWl0ZWQgdG8gbWVtYmVycyBkZWZpbmVkIGluIHRoZQogICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5BdHRyaWJ1dGVQcm9wZXJ0aWVzIGBBdHRyaWJ1dGVQcm9wZXJ0aWVzYCB0eXBlfSBhbmQgeW91IGNhbiBhbHNvIHVzZSBjdXN0b20gcHJvcGVydGllczoKICAgKgogICAqCQlzY2hlbWEuc2V0QXR0cmlidXRlUHJvcGVydGllcyggJ2Jsb2NrUXVvdGUnLCB7CiAgICoJCQljdXN0b21Qcm9wZXJ0eTogJ3ZhbHVlJwogICAqCQl9ICk7CiAgICoKICAgKiBTdWJzZXF1ZW50IGNhbGxzIHdpdGggdGhlIHNhbWUgYXR0cmlidXRlIHdpbGwgZXh0ZW5kIGl0cyBjdXN0b20gcHJvcGVydGllczoKICAgKgogICAqCQlzY2hlbWEuc2V0QXR0cmlidXRlUHJvcGVydGllcyggJ2Jsb2NrUXVvdGUnLCB7CiAgICoJCQlvbmU6IDEKICAgKgkJfSApOwogICAqCiAgICoJCXNjaGVtYS5zZXRBdHRyaWJ1dGVQcm9wZXJ0aWVzKCAnYmxvY2tRdW90ZScsIHsKICAgKgkJCXR3bzogMgogICAqCQl9ICk7CiAgICoKICAgKgkJY29uc29sZS5sb2coIHNjaGVtYS5nZXRBdHRyaWJ1dGVQcm9wZXJ0aWVzKCAnYmxvY2tRdW90ZScgKSApOwogICAqCQkvLyBMb2dzOiB7IG9uZTogMSwgdHdvOiAyIH0KICAgKgogICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyaWJ1dGVOYW1lIEEgbmFtZSBvZiB0aGUgYXR0cmlidXRlIHRvIHJlY2VpdmUgdGhlIHByb3BlcnRpZXMuCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5BdHRyaWJ1dGVQcm9wZXJ0aWVzfSBwcm9wZXJ0aWVzIEEgZGljdGlvbmFyeSBvZiBwcm9wZXJ0aWVzLgogICAqLwoKCiAgc2V0QXR0cmlidXRlUHJvcGVydGllcyhhdHRyaWJ1dGVOYW1lLCBwcm9wZXJ0aWVzKSB7CiAgICB0aGlzLl9hdHRyaWJ1dGVQcm9wZXJ0aWVzW2F0dHJpYnV0ZU5hbWVdID0gT2JqZWN0LmFzc2lnbih0aGlzLmdldEF0dHJpYnV0ZVByb3BlcnRpZXMoYXR0cmlidXRlTmFtZSksIHByb3BlcnRpZXMpOwogIH0KICAvKioKICAgKiBSZXR1cm5zIHByb3BlcnRpZXMgYXNzb2NpYXRlZCB3aXRoIGEgZ2l2ZW4gbW9kZWwgYXR0cmlidXRlLiBTZWUge0BsaW5rICNzZXRBdHRyaWJ1dGVQcm9wZXJ0aWVzIGBzZXRBdHRyaWJ1dGVQcm9wZXJ0aWVzKClgfS4KICAgKgogICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyaWJ1dGVOYW1lIEEgbmFtZSBvZiB0aGUgYXR0cmlidXRlLgogICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5BdHRyaWJ1dGVQcm9wZXJ0aWVzfQogICAqLwoKCiAgZ2V0QXR0cmlidXRlUHJvcGVydGllcyhhdHRyaWJ1dGVOYW1lKSB7CiAgICByZXR1cm4gdGhpcy5fYXR0cmlidXRlUHJvcGVydGllc1thdHRyaWJ1dGVOYW1lXSB8fCB7fTsKICB9CiAgLyoqCiAgICogUmV0dXJucyB0aGUgbG93ZXN0IHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWEjaXNMaW1pdCBsaW1pdCBlbGVtZW50fSBjb250YWluaW5nIHRoZSBlbnRpcmUKICAgKiBzZWxlY3Rpb24vcmFuZ2UvcG9zaXRpb24gb3IgdGhlIHJvb3Qgb3RoZXJ3aXNlLgogICAqCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3NlbGVjdGlvbn5TZWxlY3Rpb258bW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudHNlbGVjdGlvbn5Eb2N1bWVudFNlbGVjdGlvbnwKICAgKiBtb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlfG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259IHNlbGVjdGlvbk9yUmFuZ2VPclBvc2l0aW9uCiAgICogVGhlIHNlbGVjdGlvbi9yYW5nZS9wb3NpdGlvbiB0byBjaGVjay4KICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR9IFRoZSBsb3dlc3QgbGltaXQgZWxlbWVudCBjb250YWluaW5nCiAgICogdGhlIGVudGlyZSBgc2VsZWN0aW9uT3JSYW5nZU9yUG9zaXRpb25gLgogICAqLwoKCiAgZ2V0TGltaXRFbGVtZW50KHNlbGVjdGlvbk9yUmFuZ2VPclBvc2l0aW9uKSB7CiAgICBsZXQgZWxlbWVudDsKCiAgICBpZiAoc2VsZWN0aW9uT3JSYW5nZU9yUG9zaXRpb24gaW5zdGFuY2VvZiBQb3NpdGlvbikgewogICAgICBlbGVtZW50ID0gc2VsZWN0aW9uT3JSYW5nZU9yUG9zaXRpb24ucGFyZW50OwogICAgfSBlbHNlIHsKICAgICAgY29uc3QgcmFuZ2VzID0gc2VsZWN0aW9uT3JSYW5nZU9yUG9zaXRpb24gaW5zdGFuY2VvZiBSYW5nZSA/IFtzZWxlY3Rpb25PclJhbmdlT3JQb3NpdGlvbl0gOiBBcnJheS5mcm9tKHNlbGVjdGlvbk9yUmFuZ2VPclBvc2l0aW9uLmdldFJhbmdlcygpKTsgLy8gRmluZCB0aGUgY29tbW9uIGFuY2VzdG9yIGZvciBhbGwgc2VsZWN0aW9uJ3MgcmFuZ2VzLgoKICAgICAgZWxlbWVudCA9IHJhbmdlcy5yZWR1Y2UoKGVsZW1lbnQsIHJhbmdlKSA9PiB7CiAgICAgICAgY29uc3QgcmFuZ2VDb21tb25BbmNlc3RvciA9IHJhbmdlLmdldENvbW1vbkFuY2VzdG9yKCk7CgogICAgICAgIGlmICghZWxlbWVudCkgewogICAgICAgICAgcmV0dXJuIHJhbmdlQ29tbW9uQW5jZXN0b3I7CiAgICAgICAgfQoKICAgICAgICByZXR1cm4gZWxlbWVudC5nZXRDb21tb25BbmNlc3RvcihyYW5nZUNvbW1vbkFuY2VzdG9yLCB7CiAgICAgICAgICBpbmNsdWRlU2VsZjogdHJ1ZQogICAgICAgIH0pOwogICAgICB9LCBudWxsKTsKICAgIH0KCiAgICB3aGlsZSAoIXRoaXMuaXNMaW1pdChlbGVtZW50KSkgewogICAgICBpZiAoZWxlbWVudC5wYXJlbnQpIHsKICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnQ7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgYnJlYWs7CiAgICAgIH0KICAgIH0KCiAgICByZXR1cm4gZWxlbWVudDsKICB9CiAgLyoqCiAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGF0dHJpYnV0ZSBpcyBhbGxvd2VkIGluIHNlbGVjdGlvbjoKICAgKgogICAqICogaWYgdGhlIHNlbGVjdGlvbiBpcyBub3QgY29sbGFwc2VkLCB0aGVuIGNoZWNrcyBpZiB0aGUgYXR0cmlidXRlIGlzIGFsbG93ZWQgb24gYW55IG9mIG5vZGVzIGluIHRoYXQgcmFuZ2UsCiAgICogKiBpZiB0aGUgc2VsZWN0aW9uIGlzIGNvbGxhcHNlZCwgdGhlbiBjaGVja3MgaWYgb24gdGhlIHNlbGVjdGlvbiBwb3NpdGlvbiB0aGVyZSdzIGEgdGV4dCB3aXRoIHRoZQogICAqIHNwZWNpZmllZCBhdHRyaWJ1dGUgYWxsb3dlZC4KICAgKgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9zZWxlY3Rpb25+U2VsZWN0aW9ufG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnRzZWxlY3Rpb25+RG9jdW1lbnRTZWxlY3Rpb259IHNlbGVjdGlvbgogICAqIFNlbGVjdGlvbiB3aGljaCB3aWxsIGJlIGNoZWNrZWQuCiAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHJpYnV0ZSBUaGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlIHRvIGNoZWNrLgogICAqIEByZXR1cm5zIHtCb29sZWFufQogICAqLwoKCiAgY2hlY2tBdHRyaWJ1dGVJblNlbGVjdGlvbihzZWxlY3Rpb24sIGF0dHJpYnV0ZSkgewogICAgaWYgKHNlbGVjdGlvbi5pc0NvbGxhcHNlZCkgewogICAgICBjb25zdCBmaXJzdFBvc2l0aW9uID0gc2VsZWN0aW9uLmdldEZpcnN0UG9zaXRpb24oKTsKICAgICAgY29uc3QgY29udGV4dCA9IFsuLi5maXJzdFBvc2l0aW9uLmdldEFuY2VzdG9ycygpLCBuZXcgVGV4dCgnJywgc2VsZWN0aW9uLmdldEF0dHJpYnV0ZXMoKSldOyAvLyBDaGVjayB3aGV0aGVyIHNjaGVtYSBhbGxvd3MgZm9yIGEgdGV4dCB3aXRoIHRoZSBhdHRyaWJ1dGUgaW4gdGhlIHNlbGVjdGlvbi4KCiAgICAgIHJldHVybiB0aGlzLmNoZWNrQXR0cmlidXRlKGNvbnRleHQsIGF0dHJpYnV0ZSk7CiAgICB9IGVsc2UgewogICAgICBjb25zdCByYW5nZXMgPSBzZWxlY3Rpb24uZ2V0UmFuZ2VzKCk7IC8vIEZvciBhbGwgcmFuZ2VzLCBjaGVjayBub2RlcyBpbiB0aGVtIHVudGlsIHlvdSBmaW5kIGEgbm9kZSB0aGF0IGlzIGFsbG93ZWQgdG8gaGF2ZSB0aGUgYXR0cmlidXRlLgoKICAgICAgZm9yIChjb25zdCByYW5nZSBvZiByYW5nZXMpIHsKICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHJhbmdlKSB7CiAgICAgICAgICBpZiAodGhpcy5jaGVja0F0dHJpYnV0ZSh2YWx1ZS5pdGVtLCBhdHRyaWJ1dGUpKSB7CiAgICAgICAgICAgIC8vIElmIHdlIGZvdW5kIGEgbm9kZSB0aGF0IGlzIGFsbG93ZWQgdG8gaGF2ZSB0aGUgYXR0cmlidXRlLCByZXR1cm4gdHJ1ZS4KICAgICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICB9IC8vIElmIHdlIGhhdmVuJ3QgZm91bmQgc3VjaCBub2RlLCByZXR1cm4gZmFsc2UuCgoKICAgIHJldHVybiBmYWxzZTsKICB9CiAgLyoqCiAgICogVHJhbnNmb3JtcyB0aGUgZ2l2ZW4gc2V0IG9mIHJhbmdlcyBpbnRvIGEgc2V0IG9mIHJhbmdlcyB3aGVyZSB0aGUgZ2l2ZW4gYXR0cmlidXRlIGlzIGFsbG93ZWQgKGFuZCBjYW4gYmUgYXBwbGllZCkuCiAgICoKICAgKiBAcGFyYW0ge0FycmF5Ljxtb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlPn0gcmFuZ2VzIFJhbmdlcyB0byBiZSB2YWxpZGF0ZWQuCiAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHJpYnV0ZSBUaGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlIHRvIGNoZWNrLgogICAqIEByZXR1cm5zIHtJdGVyYWJsZS48bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZT59IFJhbmdlcyBpbiB3aGljaCB0aGUgYXR0cmlidXRlIGlzIGFsbG93ZWQuCiAgICovCgoKICAqZ2V0VmFsaWRSYW5nZXMocmFuZ2VzLCBhdHRyaWJ1dGUpIHsKICAgIHJhbmdlcyA9IGNvbnZlcnRUb01pbmltYWxGbGF0UmFuZ2VzKHJhbmdlcyk7CgogICAgZm9yIChjb25zdCByYW5nZSBvZiByYW5nZXMpIHsKICAgICAgeWllbGQqIHRoaXMuX2dldFZhbGlkUmFuZ2VzRm9yUmFuZ2UocmFuZ2UsIGF0dHJpYnV0ZSk7CiAgICB9CiAgfQogIC8qKgogICAqIEJhc2luZyBvbiBnaXZlbiBgcG9zaXRpb25gLCBmaW5kcyBhbmQgcmV0dXJucyBhIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlIHJhbmdlfSB3aGljaCBpcwogICAqIG5lYXJlc3QgdG8gdGhhdCBgcG9zaXRpb25gIGFuZCBpcyBhIGNvcnJlY3QgcmFuZ2UgZm9yIHNlbGVjdGlvbi4KICAgKgogICAqIFRoZSBjb3JyZWN0IHNlbGVjdGlvbiByYW5nZSBtaWdodCBiZSBjb2xsYXBzZWQgd2hlbiBpdCBpcyBsb2NhdGVkIGluIGEgcG9zaXRpb24gd2hlcmUgdGhlIHRleHQgbm9kZSBjYW4gYmUgcGxhY2VkLgogICAqIE5vbi1jb2xsYXBzZWQgcmFuZ2UgaXMgcmV0dXJuZWQgd2hlbiBzZWxlY3Rpb24gY2FuIGJlIHBsYWNlZCBhcm91bmQgZWxlbWVudCBtYXJrZWQgYXMgYW4gIm9iamVjdCIgaW4KICAgKiB0aGUge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYSBzY2hlbWF9LgogICAqCiAgICogRGlyZWN0aW9uIG9mIHNlYXJjaGluZyBmb3IgdGhlIG5lYXJlc3QgY29ycmVjdCBzZWxlY3Rpb24gcmFuZ2UgY2FuIGJlIHNwZWNpZmllZCBhczoKICAgKgogICAqICogYGJvdGhgIC0gc2VhcmNoaW5nIHdpbGwgYmUgcGVyZm9ybWVkIGluIGJvdGggd2F5cywKICAgKiAqIGBmb3J3YXJkYCAtIHNlYXJjaGluZyB3aWxsIGJlIHBlcmZvcm1lZCBvbmx5IGZvcndhcmQsCiAgICogKiBgYmFja3dhcmRgIC0gc2VhcmNoaW5nIHdpbGwgYmUgcGVyZm9ybWVkIG9ubHkgYmFja3dhcmQuCiAgICoKICAgKiBXaGVuIHZhbGlkIHNlbGVjdGlvbiByYW5nZSBjYW5ub3QgYmUgZm91bmQsIGBudWxsYCBpcyByZXR1cm5lZC4KICAgKgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0gcG9zaXRpb24gUmVmZXJlbmNlIHBvc2l0aW9uIHdoZXJlIG5ldyBzZWxlY3Rpb24gcmFuZ2Ugc2hvdWxkIGJlIGxvb2tlZCBmb3IuCiAgICogQHBhcmFtIHsnYm90aCd8J2ZvcndhcmQnfCdiYWNrd2FyZCd9IFtkaXJlY3Rpb249J2JvdGgnXSBTZWFyY2ggZGlyZWN0aW9uLgogICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlfG51bGx9IE5lYXJlc3Qgc2VsZWN0aW9uIHJhbmdlIG9yIGBudWxsYCBpZiBvbmUgY2Fubm90IGJlIGZvdW5kLgogICAqLwoKCiAgZ2V0TmVhcmVzdFNlbGVjdGlvblJhbmdlKHBvc2l0aW9uLCBkaXJlY3Rpb24gPSAnYm90aCcpIHsKICAgIC8vIFJldHVybiBjb2xsYXBzZWQgcmFuZ2UgaWYgcHJvdmlkZWQgcG9zaXRpb24gaXMgdmFsaWQuCiAgICBpZiAodGhpcy5jaGVja0NoaWxkKHBvc2l0aW9uLCAnJHRleHQnKSkgewogICAgICByZXR1cm4gbmV3IFJhbmdlKHBvc2l0aW9uKTsKICAgIH0KCiAgICBsZXQgYmFja3dhcmRXYWxrZXIsIGZvcndhcmRXYWxrZXI7CgogICAgaWYgKGRpcmVjdGlvbiA9PSAnYm90aCcgfHwgZGlyZWN0aW9uID09ICdiYWNrd2FyZCcpIHsKICAgICAgYmFja3dhcmRXYWxrZXIgPSBuZXcgVHJlZVdhbGtlcih7CiAgICAgICAgc3RhcnRQb3NpdGlvbjogcG9zaXRpb24sCiAgICAgICAgZGlyZWN0aW9uOiAnYmFja3dhcmQnCiAgICAgIH0pOwogICAgfQoKICAgIGlmIChkaXJlY3Rpb24gPT0gJ2JvdGgnIHx8IGRpcmVjdGlvbiA9PSAnZm9yd2FyZCcpIHsKICAgICAgZm9yd2FyZFdhbGtlciA9IG5ldyBUcmVlV2Fsa2VyKHsKICAgICAgICBzdGFydFBvc2l0aW9uOiBwb3NpdGlvbgogICAgICB9KTsKICAgIH0KCiAgICBmb3IgKGNvbnN0IGRhdGEgb2YgY29tYmluZVdhbGtlcnMoYmFja3dhcmRXYWxrZXIsIGZvcndhcmRXYWxrZXIpKSB7CiAgICAgIGNvbnN0IHR5cGUgPSBkYXRhLndhbGtlciA9PSBiYWNrd2FyZFdhbGtlciA/ICdlbGVtZW50RW5kJyA6ICdlbGVtZW50U3RhcnQnOwogICAgICBjb25zdCB2YWx1ZSA9IGRhdGEudmFsdWU7CgogICAgICBpZiAodmFsdWUudHlwZSA9PSB0eXBlICYmIHRoaXMuaXNPYmplY3QodmFsdWUuaXRlbSkpIHsKICAgICAgICByZXR1cm4gUmFuZ2UuX2NyZWF0ZU9uKHZhbHVlLml0ZW0pOwogICAgICB9CgogICAgICBpZiAodGhpcy5jaGVja0NoaWxkKHZhbHVlLm5leHRQb3NpdGlvbiwgJyR0ZXh0JykpIHsKICAgICAgICByZXR1cm4gbmV3IFJhbmdlKHZhbHVlLm5leHRQb3NpdGlvbik7CiAgICAgIH0KICAgIH0KCiAgICByZXR1cm4gbnVsbDsKICB9CiAgLyoqCiAgICogVHJpZXMgdG8gZmluZCBwb3NpdGlvbiBhbmNlc3RvcnMgdGhhdCBhbGxvd3MgdG8gaW5zZXJ0IGdpdmVuIG5vZGUuCiAgICogSXQgc3RhcnRzIHNlYXJjaGluZyBmcm9tIHRoZSBnaXZlbiBwb3NpdGlvbiBhbmQgZ29lcyBub2RlIGJ5IG5vZGUgdG8gdGhlIHRvcCBvZiB0aGUgbW9kZWwgdHJlZQogICAqIGFzIGxvbmcgYXMge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYSNpc0xpbWl0IGxpbWl0IGVsZW1lbnR9LAogICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWEjaXNPYmplY3Qgb2JqZWN0IGVsZW1lbnR9IG9yIHRvcC1tb3N0IGFuY2VzdG9yIHdvbid0IGJlIHJlYWNoZWQuCiAgICoKICAgKiBAcGFyYW1zIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufSBwb3NpdGlvbiBQb3NpdGlvbiBmcm9tIHNlYXJjaGluZyB3aWxsIHN0YXJ0LgogICAqIEBwYXJhbXMge21vZHVsZTplbmdpbmUvbW9kZWwvbm9kZX5Ob2RlfFN0cmluZ30gbm9kZSBOb2RlIGZvciB3aGljaCBhbGxvd2VkIHBhcmVudCBzaG91bGQgYmUgZm91bmQgb3IgaXRzIG5hbWUuCiAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50fG51bGx9IGVsZW1lbnQgQWxsb3dlZCBwYXJlbnQgb3IgbnVsbCBpZiBub3RoaW5nIHdhcyBmb3VuZC4KICAgKi8KCgogIGZpbmRBbGxvd2VkUGFyZW50KHBvc2l0aW9uLCBub2RlKSB7CiAgICBsZXQgcGFyZW50ID0gcG9zaXRpb24ucGFyZW50OwoKICAgIHdoaWxlIChwYXJlbnQpIHsKICAgICAgaWYgKHRoaXMuY2hlY2tDaGlsZChwYXJlbnQsIG5vZGUpKSB7CiAgICAgICAgcmV0dXJuIHBhcmVudDsKICAgICAgfSAvLyBEbyBub3Qgc3BsaXQgbGltaXQgZWxlbWVudHMuCgoKICAgICAgaWYgKHRoaXMuaXNMaW1pdChwYXJlbnQpKSB7CiAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgIH0KCiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7CiAgICB9CgogICAgcmV0dXJuIG51bGw7CiAgfQogIC8qKgogICAqIFJlbW92ZXMgYXR0cmlidXRlcyBkaXNhbGxvd2VkIGJ5IHRoZSBzY2hlbWEuCiAgICoKICAgKiBAcGFyYW0ge0l0ZXJhYmxlLjxtb2R1bGU6ZW5naW5lL21vZGVsL25vZGV+Tm9kZT59IG5vZGVzIE5vZGVzIHRoYXQgd2lsbCBiZSBmaWx0ZXJlZC4KICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvd3JpdGVyfldyaXRlcn0gd3JpdGVyCiAgICovCgoKICByZW1vdmVEaXNhbGxvd2VkQXR0cmlidXRlcyhub2Rlcywgd3JpdGVyKSB7CiAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMpIHsKICAgICAgLy8gV2hlbiBub2RlIGlzIGEgYFRleHRgIGl0IGhhcyBubyBjaGlsZHJlbiwgc28ganVzdCBmaWx0ZXIgaXQgb3V0LgogICAgICBpZiAobm9kZS5pcygndGV4dCcpKSB7CiAgICAgICAgcmVtb3ZlRGlzYWxsb3dlZEF0dHJpYnV0ZUZyb21Ob2RlKHRoaXMsIG5vZGUsIHdyaXRlcik7CiAgICAgIH0gLy8gSW4gYSBjYXNlIG9mIGBFbGVtZW50YCBpdGVyYXRlcyB0aHJvdWdoIHBvc2l0aW9ucyBiZXR3ZWVuIG5vZGVzIGluc2lkZSB0aGlzIGVsZW1lbnQKICAgICAgLy8gYW5kIGZpbHRlciBvdXQgbm9kZSBiZWZvcmUgdGhlIGN1cnJlbnQgcG9zaXRpb24sIG9yIHBvc2l0aW9uIHBhcmVudCB3aGVuIHBvc2l0aW9uCiAgICAgIC8vIGlzIGF0IHN0YXJ0IG9mIGFuIGVsZW1lbnQuIFVzaW5nIHBvc2l0aW9ucyBwcmV2ZW50IGZyb20gb21pdHRpbmcgbWVyZ2VkIG5vZGVzCiAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2tlZGl0b3IvY2tlZGl0b3I1LWVuZ2luZS9pc3N1ZXMvMTc4OS4KICAgICAgZWxzZSB7CiAgICAgICAgICBjb25zdCByYW5nZUluTm9kZSA9IFJhbmdlLl9jcmVhdGVJbihub2RlKTsKCiAgICAgICAgICBjb25zdCBwb3NpdGlvbnNJblJhbmdlID0gcmFuZ2VJbk5vZGUuZ2V0UG9zaXRpb25zKCk7CgogICAgICAgICAgZm9yIChjb25zdCBwb3NpdGlvbiBvZiBwb3NpdGlvbnNJblJhbmdlKSB7CiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBwb3NpdGlvbi5ub2RlQmVmb3JlIHx8IHBvc2l0aW9uLnBhcmVudDsKICAgICAgICAgICAgcmVtb3ZlRGlzYWxsb3dlZEF0dHJpYnV0ZUZyb21Ob2RlKHRoaXMsIGl0ZW0sIHdyaXRlcik7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgfQogIH0KICAvKioKICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoZSBzY2hlbWEgY29udGV4dC4KICAgKgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hQ29udGV4dERlZmluaXRpb259IGNvbnRleHQKICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hQ29udGV4dH0KICAgKi8KCgogIGNyZWF0ZUNvbnRleHQoY29udGV4dCkgewogICAgcmV0dXJuIG5ldyBTY2hlbWFDb250ZXh0KGNvbnRleHQpOwogIH0KICAvKioKICAgKiBAcHJpdmF0ZQogICAqLwoKCiAgX2NsZWFyQ2FjaGUoKSB7CiAgICB0aGlzLl9jb21waWxlZERlZmluaXRpb25zID0gbnVsbDsKICB9CiAgLyoqCiAgICogQHByaXZhdGUKICAgKi8KCgogIF9jb21waWxlKCkgewogICAgY29uc3QgY29tcGlsZWREZWZpbml0aW9ucyA9IHt9OwogICAgY29uc3Qgc291cmNlUnVsZXMgPSB0aGlzLl9zb3VyY2VEZWZpbml0aW9uczsKICAgIGNvbnN0IGl0ZW1OYW1lcyA9IE9iamVjdC5rZXlzKHNvdXJjZVJ1bGVzKTsKCiAgICBmb3IgKGNvbnN0IGl0ZW1OYW1lIG9mIGl0ZW1OYW1lcykgewogICAgICBjb21waWxlZERlZmluaXRpb25zW2l0ZW1OYW1lXSA9IGNvbXBpbGVCYXNlSXRlbVJ1bGUoc291cmNlUnVsZXNbaXRlbU5hbWVdLCBpdGVtTmFtZSk7CiAgICB9CgogICAgZm9yIChjb25zdCBpdGVtTmFtZSBvZiBpdGVtTmFtZXMpIHsKICAgICAgY29tcGlsZUFsbG93Q29udGVudE9mKGNvbXBpbGVkRGVmaW5pdGlvbnMsIGl0ZW1OYW1lKTsKICAgIH0KCiAgICBmb3IgKGNvbnN0IGl0ZW1OYW1lIG9mIGl0ZW1OYW1lcykgewogICAgICBjb21waWxlQWxsb3dXaGVyZShjb21waWxlZERlZmluaXRpb25zLCBpdGVtTmFtZSk7CiAgICB9CgogICAgZm9yIChjb25zdCBpdGVtTmFtZSBvZiBpdGVtTmFtZXMpIHsKICAgICAgY29tcGlsZUFsbG93QXR0cmlidXRlc09mKGNvbXBpbGVkRGVmaW5pdGlvbnMsIGl0ZW1OYW1lKTsKICAgICAgY29tcGlsZUluaGVyaXRQcm9wZXJ0aWVzRnJvbShjb21waWxlZERlZmluaXRpb25zLCBpdGVtTmFtZSk7CiAgICB9CgogICAgZm9yIChjb25zdCBpdGVtTmFtZSBvZiBpdGVtTmFtZXMpIHsKICAgICAgY2xlYW5VcEFsbG93SW4oY29tcGlsZWREZWZpbml0aW9ucywgaXRlbU5hbWUpOwogICAgICBjbGVhblVwQWxsb3dBdHRyaWJ1dGVzKGNvbXBpbGVkRGVmaW5pdGlvbnMsIGl0ZW1OYW1lKTsKICAgIH0KCiAgICB0aGlzLl9jb21waWxlZERlZmluaXRpb25zID0gY29tcGlsZWREZWZpbml0aW9uczsKICB9CiAgLyoqCiAgICogQHByaXZhdGUKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYUNvbXBpbGVkSXRlbURlZmluaXRpb259IGRlZgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hQ29udGV4dH0gY29udGV4dAogICAqIEBwYXJhbSB7TnVtYmVyfSBjb250ZXh0SXRlbUluZGV4CiAgICovCgoKICBfY2hlY2tDb250ZXh0TWF0Y2goZGVmLCBjb250ZXh0LCBjb250ZXh0SXRlbUluZGV4ID0gY29udGV4dC5sZW5ndGggLSAxKSB7CiAgICBjb25zdCBjb250ZXh0SXRlbSA9IGNvbnRleHQuZ2V0SXRlbShjb250ZXh0SXRlbUluZGV4KTsKCiAgICBpZiAoZGVmLmFsbG93SW4uaW5jbHVkZXMoY29udGV4dEl0ZW0ubmFtZSkpIHsKICAgICAgaWYgKGNvbnRleHRJdGVtSW5kZXggPT0gMCkgewogICAgICAgIHJldHVybiB0cnVlOwogICAgICB9IGVsc2UgewogICAgICAgIGNvbnN0IHBhcmVudFJ1bGUgPSB0aGlzLmdldERlZmluaXRpb24oY29udGV4dEl0ZW0pOwogICAgICAgIHJldHVybiB0aGlzLl9jaGVja0NvbnRleHRNYXRjaChwYXJlbnRSdWxlLCBjb250ZXh0LCBjb250ZXh0SXRlbUluZGV4IC0gMSk7CiAgICAgIH0KICAgIH0gZWxzZSB7CiAgICAgIHJldHVybiBmYWxzZTsKICAgIH0KICB9CiAgLyoqCiAgICogVGFrZXMgYSBmbGF0IHJhbmdlIGFuZCBhbiBhdHRyaWJ1dGUgbmFtZS4gVHJhdmVyc2VzIHRoZSByYW5nZSByZWN1cnNpdmVseSBhbmQgZGVlcGx5IHRvIGZpbmQgYW5kIHJldHVybiBhbGwgcmFuZ2VzCiAgICogaW5zaWRlIHRoZSBnaXZlbiByYW5nZSBvbiB3aGljaCB0aGUgYXR0cmlidXRlIGNhbiBiZSBhcHBsaWVkLgogICAqCiAgICogVGhpcyBpcyBhIGhlbHBlciBmdW5jdGlvbiBmb3Ige0BsaW5rIH5TY2hlbWEjZ2V0VmFsaWRSYW5nZXN9LgogICAqCiAgICogQHByaXZhdGUKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2V9IHJhbmdlIFJhbmdlIHRvIHByb2Nlc3MuCiAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHJpYnV0ZSBUaGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlIHRvIGNoZWNrLgogICAqIEByZXR1cm5zIHtJdGVyYWJsZS48bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZT59IFJhbmdlcyBpbiB3aGljaCB0aGUgYXR0cmlidXRlIGlzIGFsbG93ZWQuCiAgICovCgoKICAqX2dldFZhbGlkUmFuZ2VzRm9yUmFuZ2UocmFuZ2UsIGF0dHJpYnV0ZSkgewogICAgbGV0IHN0YXJ0ID0gcmFuZ2Uuc3RhcnQ7CiAgICBsZXQgZW5kID0gcmFuZ2Uuc3RhcnQ7CgogICAgZm9yIChjb25zdCBpdGVtIG9mIHJhbmdlLmdldEl0ZW1zKHsKICAgICAgc2hhbGxvdzogdHJ1ZQogICAgfSkpIHsKICAgICAgaWYgKGl0ZW0uaXMoJ2VsZW1lbnQnKSkgewogICAgICAgIHlpZWxkKiB0aGlzLl9nZXRWYWxpZFJhbmdlc0ZvclJhbmdlKFJhbmdlLl9jcmVhdGVJbihpdGVtKSwgYXR0cmlidXRlKTsKICAgICAgfQoKICAgICAgaWYgKCF0aGlzLmNoZWNrQXR0cmlidXRlKGl0ZW0sIGF0dHJpYnV0ZSkpIHsKICAgICAgICBpZiAoIXN0YXJ0LmlzRXF1YWwoZW5kKSkgewogICAgICAgICAgeWllbGQgbmV3IFJhbmdlKHN0YXJ0LCBlbmQpOwogICAgICAgIH0KCiAgICAgICAgc3RhcnQgPSBQb3NpdGlvbi5fY3JlYXRlQWZ0ZXIoaXRlbSk7CiAgICAgIH0KCiAgICAgIGVuZCA9IFBvc2l0aW9uLl9jcmVhdGVBZnRlcihpdGVtKTsKICAgIH0KCiAgICBpZiAoIXN0YXJ0LmlzRXF1YWwoZW5kKSkgewogICAgICB5aWVsZCBuZXcgUmFuZ2Uoc3RhcnQsIGVuZCk7CiAgICB9CiAgfQoKfQptaXgoU2NoZW1hLCBPYnNlcnZhYmxlTWl4aW4pOwovKioKICogRXZlbnQgZmlyZWQgd2hlbiB0aGUge0BsaW5rICNjaGVja0NoaWxkfSBtZXRob2QgaXMgY2FsbGVkLiBJdCBhbGxvd3MgcGx1Z2dpbmcgaW4KICogYWRkaXRpb25hbCBiZWhhdmlvciDigJMgZS5nLiBpbXBsZW1lbnRpbmcgcnVsZXMgd2hpY2ggY2Fubm90IGJlIGRlZmluZWQgdXNpbmcgdGhlIGRlY2xhcmF0aXZlCiAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWFJdGVtRGVmaW5pdGlvbn0gaW50ZXJmYWNlLgogKgogKiAqKk5vdGU6KiogVGhlIHtAbGluayAjYWRkQ2hpbGRDaGVja30gbWV0aG9kIGlzIGEgbW9yZSBoYW5keSB3YXkgdG8gcmVnaXN0ZXIgY2FsbGJhY2tzLiBJbnRlcm5hbGx5LAogKiBpdCByZWdpc3RlcnMgYSBsaXN0ZW5lciB0byB0aGlzIGV2ZW50IGJ1dCBjb21lcyB3aXRoIGEgc2ltcGxlciBBUEkgYW5kIGl0IGlzIHRoZSByZWNvbW1lbmRlZCBjaG9pY2UKICogaW4gbW9zdCBvZiB0aGUgY2FzZXMuCiAqCiAqIFRoZSB7QGxpbmsgI2NoZWNrQ2hpbGR9IG1ldGhvZCBmaXJlcyBhbiBldmVudCBiZWNhdXNlIGl0IGlzCiAqIHtAbGluayBtb2R1bGU6dXRpbHMvb2JzZXJ2YWJsZW1peGlufk9ic2VydmFibGVNaXhpbiNkZWNvcmF0ZSBkZWNvcmF0ZWR9IHdpdGggaXQuIFRoYW5rcyB0byB0aGF0IHlvdSBjYW4KICogdXNlIHRoaXMgZXZlbnQgaW4gYSB2YXJpb3VzIHdheSwgYnV0IHRoZSBtb3N0IGltcG9ydGFudCB1c2UgY2FzZSBpcyBvdmVycmlkaW5nIHN0YW5kYXJkIGJlaGF2aW91ciBvZiB0aGUKICogYGNoZWNrQ2hpbGQoKWAgbWV0aG9kLiBMZXQncyBzZWUgYSB0eXBpY2FsIGxpc3RlbmVyIHRlbXBsYXRlOgogKgogKgkJc2NoZW1hLm9uKCAnY2hlY2tDaGlsZCcsICggZXZ0LCBhcmdzICkgPT4gewogKgkJCWNvbnN0IGNvbnRleHQgPSBhcmdzWyAwIF07CiAqCQkJY29uc3QgY2hpbGREZWZpbml0aW9uID0gYXJnc1sgMSBdOwogKgkJfSwgeyBwcmlvcml0eTogJ2hpZ2gnIH0gKTsKICoKICogVGhlIGxpc3RlbmVyIGlzIGFkZGVkIHdpdGggYSBgaGlnaGAgcHJpb3JpdHkgdG8gYmUgZXhlY3V0ZWQgYmVmb3JlIHRoZSBkZWZhdWx0IG1ldGhvZCBpcyByZWFsbHkgY2FsbGVkLiBUaGUgYGFyZ3NgIGNhbGxiYWNrCiAqIHBhcmFtZXRlciBjb250YWlucyBhcmd1bWVudHMgcGFzc2VkIHRvIGBjaGVja0NoaWxkKCBjb250ZXh0LCBjaGlsZCApYC4gSG93ZXZlciwgdGhlIGBjb250ZXh0YCBwYXJhbWV0ZXIgaXMgYWxyZWFkeQogKiBub3JtYWxpemVkIHRvIGEge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYUNvbnRleHR9IGluc3RhbmNlIGFuZCBgY2hpbGRgIHRvIGEKICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYUNvbXBpbGVkSXRlbURlZmluaXRpb259IGluc3RhbmNlLCBzbyB5b3UgZG9uJ3QgaGF2ZSB0byB3b3JyeSBhYm91dAogKiB0aGUgdmFyaW91cyB3YXlzIGhvdyBgY29udGV4dGAgYW5kIGBjaGlsZGAgbWF5IGJlIHBhc3NlZCB0byBgY2hlY2tDaGlsZCgpYC4KICoKICogKipOb3RlOioqIGBjaGlsZERlZmluaXRpb25gIG1heSBiZSBgdW5kZWZpbmVkYCBpZiBgY2hlY2tDaGlsZCgpYCB3YXMgY2FsbGVkIHdpdGggYSBub24tcmVnaXN0ZXJlZCBlbGVtZW50LgogKgogKiBTbywgaW4gb3JkZXIgdG8gaW1wbGVtZW50IGEgcnVsZSAiZGlzYWxsb3cgYGhlYWRpbmcxYCBpbiBgYmxvY2tRdW90ZWAiIHlvdSBjYW4gYWRkIHN1Y2ggYSBsaXN0ZW5lcjoKICoKICoJCXNjaGVtYS5vbiggJ2NoZWNrQ2hpbGQnLCAoIGV2dCwgYXJncyApID0+IHsKICoJCQljb25zdCBjb250ZXh0ID0gYXJnc1sgMCBdOwogKgkJCWNvbnN0IGNoaWxkRGVmaW5pdGlvbiA9IGFyZ3NbIDEgXTsKICoKICoJCQlpZiAoIGNvbnRleHQuZW5kc1dpdGgoICdibG9ja1F1b3RlJyApICYmIGNoaWxkRGVmaW5pdGlvbiAmJiBjaGlsZERlZmluaXRpb24ubmFtZSA9PSAnaGVhZGluZzEnICkgewogKgkJCQkvLyBQcmV2ZW50IG5leHQgbGlzdGVuZXJzIGZyb20gYmVpbmcgY2FsbGVkLgogKgkJCQlldnQuc3RvcCgpOwogKgkJCQkvLyBTZXQgdGhlIGNoZWNrQ2hpbGQoKSdzIHJldHVybiB2YWx1ZS4KICoJCQkJZXZ0LnJldHVybiA9IGZhbHNlOwogKgkJCX0KICoJCX0sIHsgcHJpb3JpdHk6ICdoaWdoJyB9ICk7CiAqCiAqIEFsbG93aW5nIGVsZW1lbnRzIGluIHNwZWNpZmljIGNvbnRleHRzIHdpbGwgYmUgYSBmYXIgbGVzcyBjb21tb24gdXNlIGNhc2UsIGJlY2F1c2UgaXQncyBub3JtYWxseSBoYW5kbGVkIGJ5CiAqIGBhbGxvd0luYCBydWxlIGZyb20ge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYUl0ZW1EZWZpbml0aW9ufSBidXQgaWYgeW91IGhhdmUgYSBjb21wbGV4IHNjZW5hcmlvCiAqIHdoZXJlIGBsaXN0SXRlbWAgc2hvdWxkIGJlIGFsbG93ZWQgb25seSBpbiBlbGVtZW50IGBmb29gIHdoaWNoIG11c3QgYmUgaW4gZWxlbWVudCBgYmFyYCwgdGhlbiB0aGlzIHdvdWxkIGJlIHRoZSB3YXk6CiAqCiAqCQlzY2hlbWEub24oICdjaGVja0NoaWxkJywgKCBldnQsIGFyZ3MgKSA9PiB7CiAqCQkJY29uc3QgY29udGV4dCA9IGFyZ3NbIDAgXTsKICoJCQljb25zdCBjaGlsZERlZmluaXRpb24gPSBhcmdzWyAxIF07CiAqCiAqCQkJaWYgKCBjb250ZXh0LmVuZHNXaXRoKCAnYmFyIGZvbycgKSAmJiBjaGlsZERlZmluaXRpb24ubmFtZSA9PSAnbGlzdEl0ZW0nICkgewogKgkJCQkvLyBQcmV2ZW50IG5leHQgbGlzdGVuZXJzIGZyb20gYmVpbmcgY2FsbGVkLgogKgkJCQlldnQuc3RvcCgpOwogKgkJCQkvLyBTZXQgdGhlIGNoZWNrQ2hpbGQoKSdzIHJldHVybiB2YWx1ZS4KICoJCQkJZXZ0LnJldHVybiA9IHRydWU7CiAqCQkJfQogKgkJfSwgeyBwcmlvcml0eTogJ2hpZ2gnIH0gKTsKICoKICogQGV2ZW50IGNoZWNrQ2hpbGQKICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYGNoZWNrQ2hpbGQoKWAncyBhcmd1bWVudHMuCiAqLwoKLyoqCiAqIEV2ZW50IGZpcmVkIHdoZW4gdGhlIHtAbGluayAjY2hlY2tBdHRyaWJ1dGV9IG1ldGhvZCBpcyBjYWxsZWQuIEl0IGFsbG93cyBwbHVnZ2luZyBpbgogKiBhZGRpdGlvbmFsIGJlaGF2aW9yIOKAkyBlLmcuIGltcGxlbWVudGluZyBydWxlcyB3aGljaCBjYW5ub3QgYmUgZGVmaW5lZCB1c2luZyB0aGUgZGVjbGFyYXRpdmUKICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYUl0ZW1EZWZpbml0aW9ufSBpbnRlcmZhY2UuCiAqCiAqICoqTm90ZToqKiBUaGUge0BsaW5rICNhZGRBdHRyaWJ1dGVDaGVja30gbWV0aG9kIGlzIGEgbW9yZSBoYW5keSB3YXkgdG8gcmVnaXN0ZXIgY2FsbGJhY2tzLiBJbnRlcm5hbGx5LAogKiBpdCByZWdpc3RlcnMgYSBsaXN0ZW5lciB0byB0aGlzIGV2ZW50IGJ1dCBjb21lcyB3aXRoIGEgc2ltcGxlciBBUEkgYW5kIGl0IGlzIHRoZSByZWNvbW1lbmRlZCBjaG9pY2UKICogaW4gbW9zdCBvZiB0aGUgY2FzZXMuCiAqCiAqIFRoZSB7QGxpbmsgI2NoZWNrQXR0cmlidXRlfSBtZXRob2QgZmlyZXMgYW4gZXZlbnQgYmVjYXVzZSBpdCdzCiAqIHtAbGluayBtb2R1bGU6dXRpbHMvb2JzZXJ2YWJsZW1peGlufk9ic2VydmFibGVNaXhpbiNkZWNvcmF0ZSBkZWNvcmF0ZWR9IHdpdGggaXQuIFRoYW5rcyB0byB0aGF0IHlvdSBjYW4KICogdXNlIHRoaXMgZXZlbnQgaW4gYSB2YXJpb3VzIHdheSwgYnV0IHRoZSBtb3N0IGltcG9ydGFudCB1c2UgY2FzZSBpcyBvdmVycmlkaW5nIHN0YW5kYXJkIGJlaGF2aW91ciBvZiB0aGUKICogYGNoZWNrQXR0cmlidXRlKClgIG1ldGhvZC4gTGV0J3Mgc2VlIGEgdHlwaWNhbCBsaXN0ZW5lciB0ZW1wbGF0ZToKICoKICoJCXNjaGVtYS5vbiggJ2NoZWNrQXR0cmlidXRlJywgKCBldnQsIGFyZ3MgKSA9PiB7CiAqCQkJY29uc3QgY29udGV4dCA9IGFyZ3NbIDAgXTsKICoJCQljb25zdCBhdHRyaWJ1dGVOYW1lID0gYXJnc1sgMSBdOwogKgkJfSwgeyBwcmlvcml0eTogJ2hpZ2gnIH0gKTsKICoKICogVGhlIGxpc3RlbmVyIGlzIGFkZGVkIHdpdGggYSBgaGlnaGAgcHJpb3JpdHkgdG8gYmUgZXhlY3V0ZWQgYmVmb3JlIHRoZSBkZWZhdWx0IG1ldGhvZCBpcyByZWFsbHkgY2FsbGVkLiBUaGUgYGFyZ3NgIGNhbGxiYWNrCiAqIHBhcmFtZXRlciBjb250YWlucyBhcmd1bWVudHMgcGFzc2VkIHRvIGBjaGVja0F0dHJpYnV0ZSggY29udGV4dCwgYXR0cmlidXRlTmFtZSApYC4gSG93ZXZlciwgdGhlIGBjb250ZXh0YCBwYXJhbWV0ZXIgaXMgYWxyZWFkeQogKiBub3JtYWxpemVkIHRvIGEge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYUNvbnRleHR9IGluc3RhbmNlLCBzbyB5b3UgZG9uJ3QgaGF2ZSB0byB3b3JyeSBhYm91dAogKiB0aGUgdmFyaW91cyB3YXlzIGhvdyBgY29udGV4dGAgbWF5IGJlIHBhc3NlZCB0byBgY2hlY2tBdHRyaWJ1dGUoKWAuCiAqCiAqIFNvLCBpbiBvcmRlciB0byBpbXBsZW1lbnQgYSBydWxlICJkaXNhbGxvdyBgYm9sZGAgaW4gYSB0ZXh0IHdoaWNoIGlzIGluIGEgYGhlYWRpbmcxYCB5b3UgY2FuIGFkZCBzdWNoIGEgbGlzdGVuZXI6CiAqCiAqCQlzY2hlbWEub24oICdjaGVja0F0dHJpYnV0ZScsICggZXZ0LCBhcmdzICkgPT4gewogKgkJCWNvbnN0IGNvbnRleHQgPSBhcmdzWyAwIF07CiAqCQkJY29uc3QgYXRyaWJ1dGVOYW1lID0gYXJnc1sgMSBdOwogKgogKgkJCWlmICggY29udGV4dC5lbmRzV2l0aCggJ2hlYWRpbmcxICR0ZXh0JyApICYmIGF0dHJpYnV0ZU5hbWUgPT0gJ2JvbGQnICkgewogKgkJCQkvLyBQcmV2ZW50IG5leHQgbGlzdGVuZXJzIGZyb20gYmVpbmcgY2FsbGVkLgogKgkJCQlldnQuc3RvcCgpOwogKgkJCQkvLyBTZXQgdGhlIGNoZWNrQXR0cmlidXRlKCkncyByZXR1cm4gdmFsdWUuCiAqCQkJCWV2dC5yZXR1cm4gPSBmYWxzZTsKICoJCQl9CiAqCQl9LCB7IHByaW9yaXR5OiAnaGlnaCcgfSApOwogKgogKiBBbGxvd2luZyBhdHRyaWJ1dGVzIGluIHNwZWNpZmljIGNvbnRleHRzIHdpbGwgYmUgYSBmYXIgbGVzcyBjb21tb24gdXNlIGNhc2UsIGJlY2F1c2UgaXQncyBub3JtYWxseSBoYW5kbGVkIGJ5CiAqIGBhbGxvd0F0dHJpYnV0ZXNgIHJ1bGUgZnJvbSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hSXRlbURlZmluaXRpb259IGJ1dCBpZiB5b3UgaGF2ZSBhIGNvbXBsZXggc2NlbmFyaW8KICogd2hlcmUgYGJvbGRgIHNob3VsZCBiZSBhbGxvd2VkIG9ubHkgaW4gZWxlbWVudCBgZm9vYCB3aGljaCBtdXN0IGJlIGluIGVsZW1lbnQgYGJhcmAsIHRoZW4gdGhpcyB3b3VsZCBiZSB0aGUgd2F5OgogKgogKgkJc2NoZW1hLm9uKCAnY2hlY2tBdHRyaWJ1dGUnLCAoIGV2dCwgYXJncyApID0+IHsKICoJCQljb25zdCBjb250ZXh0ID0gYXJnc1sgMCBdOwogKgkJCWNvbnN0IGF0cmlidXRlTmFtZSA9IGFyZ3NbIDEgXTsKICoKICoJCQlpZiAoIGNvbnRleHQuZW5kc1dpdGgoICdiYXIgZm9vICR0ZXh0JyApICYmIGF0dHJpYnV0ZU5hbWUgPT0gJ2JvbGQnICkgewogKgkJCQkvLyBQcmV2ZW50IG5leHQgbGlzdGVuZXJzIGZyb20gYmVpbmcgY2FsbGVkLgogKgkJCQlldnQuc3RvcCgpOwogKgkJCQkvLyBTZXQgdGhlIGNoZWNrQXR0cmlidXRlKCkncyByZXR1cm4gdmFsdWUuCiAqCQkJCWV2dC5yZXR1cm4gPSB0cnVlOwogKgkJCX0KICoJCX0sIHsgcHJpb3JpdHk6ICdoaWdoJyB9ICk7CiAqCiAqIEBldmVudCBjaGVja0F0dHJpYnV0ZQogKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBgY2hlY2tBdHRyaWJ1dGUoKWAncyBhcmd1bWVudHMuCiAqLwoKLyoqCiAqIEEgZGVmaW5pdGlvbiBvZiBhIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWEgc2NoZW1hfSBpdGVtLgogKgogKiBZb3UgY2FuIGRlZmluZSB0aGUgZm9sbG93aW5nIHJ1bGVzOgogKgogKiAqIGBhbGxvd0luYCAmbmRhc2g7IEEgc3RyaW5nIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MuIERlZmluZXMgaW4gd2hpY2ggb3RoZXIgaXRlbXMgdGhpcyBpdGVtIHdpbGwgYmUgYWxsb3dlZC4KICogKiBgYWxsb3dBdHRyaWJ1dGVzYCAmbmRhc2g7IEEgc3RyaW5nIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MuIERlZmluZXMgYWxsb3dlZCBhdHRyaWJ1dGVzIG9mIHRoZSBnaXZlbiBpdGVtLgogKiAqIGBhbGxvd0NvbnRlbnRPZmAgJm5kYXNoOyBBIHN0cmluZyBvciBhbiBhcnJheSBvZiBzdHJpbmdzLiBJbmhlcml0cyAiYWxsb3dlZCBjaGlsZHJlbiIgZnJvbSBvdGhlciBpdGVtcy4KICogKiBgYWxsb3dXaGVyZWAgJm5kYXNoOyBBIHN0cmluZyBvciBhbiBhcnJheSBvZiBzdHJpbmdzLiBJbmhlcml0cyAiYWxsb3dlZCBpbiIgZnJvbSBvdGhlciBpdGVtcy4KICogKiBgYWxsb3dBdHRyaWJ1dGVzT2ZgICZuZGFzaDsgQSBzdHJpbmcgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncy4gSW5oZXJpdHMgYXR0cmlidXRlcyBmcm9tIG90aGVyIGl0ZW1zLgogKiAqIGBpbmhlcml0VHlwZXNGcm9tYCAmbmRhc2g7IEEgc3RyaW5nIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MuIEluaGVyaXRzIGBpcypgIHByb3BlcnRpZXMgb2Ygb3RoZXIgaXRlbXMuCiAqICogYGluaGVyaXRBbGxGcm9tYCAmbmRhc2g7IEEgc3RyaW5nLiBBIHNob3J0aGFuZCBmb3IgYGFsbG93Q29udGVudE9mYCwgYGFsbG93V2hlcmVgLCBgYWxsb3dBdHRyaWJ1dGVzT2ZgLCBgaW5oZXJpdFR5cGVzRnJvbWAuCiAqICogQWRkaXRpb25hbGx5LCB5b3UgY2FuIGRlZmluZSB0aGUgZm9sbG93aW5nIGBpcypgIHByb3BlcnRpZXM6IGBpc0Jsb2NrYCwgYGlzTGltaXRgLCBgaXNPYmplY3RgLCBgaXNJbmxpbmVgLiBSZWFkIGFib3V0IHRoZW0gYmVsb3cuCiAqCiAqICMgVGhlIGlzKiBwcm9wZXJ0aWVzCiAqCiAqIFRoZXJlIGFyZSAzIGNvbW1vbmx5IHVzZWQgYGlzKmAgcHJvcGVydGllcy4gVGhlaXIgcm9sZSBpcyB0byBhc3NpZ24gYWRkaXRpb25hbCBzZW1hbnRpY3MgdG8gc2NoZW1hIGl0ZW1zLgogKiBZb3UgY2FuIGRlZmluZSBtb3JlIHByb3BlcnRpZXMgYnV0IHlvdSB3aWxsIGFsc28gbmVlZCB0byBpbXBsZW1lbnQgc3VwcG9ydCBmb3IgdGhlbSBpbiB0aGUgZXhpc3RpbmcgZWRpdG9yIGZlYXR1cmVzLgogKgogKiAqIGBpc0Jsb2NrYCAmbmRhc2g7IFdoZXRoZXIgdGhpcyBpdGVtIGlzIHBhcmFncmFwaC1saWtlLiBHZW5lcmFsbHkgc3BlYWtpbmcsIGNvbnRlbnQgaXMgdXN1YWxseSBtYWRlIG91dCBvZiBibG9ja3MKICogbGlrZSBwYXJhZ3JhcGhzLCBsaXN0IGl0ZW1zLCBpbWFnZXMsIGhlYWRpbmdzLCBldGMuIEFsbCB0aGVzZSBlbGVtZW50cyBhcmUgbWFya2VkIGFzIGJsb2Nrcy4gQSBibG9jawogKiBzaG91bGQgbm90IGFsbG93IGFub3RoZXIgYmxvY2sgaW5zaWRlLiBOb3RlOiBUaGVyZSBpcyBhbHNvIHRoZSBgJGJsb2NrYCBnZW5lcmljIGl0ZW0gd2hpY2ggaGFzIGBpc0Jsb2NrYCBzZXQgdG8gYHRydWVgLgogKiBNb3N0IGJsb2NrIHR5cGUgaXRlbXMgd2lsbCBpbmhlcml0IGZyb20gYCRibG9ja2AgKHRocm91Z2ggYGluaGVyaXRBbGxGcm9tYCkuCiAqICogYGlzTGltaXRgICZuZGFzaDsgSXQgY2FuIGJlIHVuZGVyc3Rvb2QgYXMgd2hldGhlciB0aGlzIGVsZW1lbnQgc2hvdWxkIG5vdCBiZSBzcGxpdCBieSA8a2JkPkVudGVyPC9rYmQ+LgogKiBFeGFtcGxlcyBvZiBsaW1pdCBlbGVtZW50czogYCRyb290YCwgdGFibGUgY2VsbCwgaW1hZ2UgY2FwdGlvbiwgZXRjLiBJbiBvdGhlciB3b3JkcywgYWxsIGFjdGlvbnMgdGhhdCBoYXBwZW4gaW5zaWRlCiAqIGEgbGltaXQgZWxlbWVudCBhcmUgbGltaXRlZCB0byBpdHMgY29udGVudC4gKipOb3RlOioqIEFsbCBvYmplY3RzIChgaXNPYmplY3RgKSBhcmUgdHJlYXRlZCBhcyBsaW1pdCBlbGVtZW50cywgdG9vLgogKiAqIGBpc09iamVjdGAgJm5kYXNoOyBXaGV0aGVyIGFuIGl0ZW0gaXMgInNlbGYtY29udGFpbmVkIiBhbmQgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgYSB3aG9sZS4gRXhhbXBsZXMgb2Ygb2JqZWN0IGVsZW1lbnRzOgogKiBgaW1hZ2VgLCBgdGFibGVgLCBgdmlkZW9gLCBldGMuICoqTm90ZToqKiBBbiBvYmplY3QgaXMgYWxzbyBhIGxpbWl0LCBzbwogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hI2lzTGltaXQgYGlzTGltaXQoKWB9IHJldHVybnMgYHRydWVgIGZvciBvYmplY3QgZWxlbWVudHMgYXV0b21hdGljYWxseS4KICogKiBgaXNJbmxpbmVgICZuZGFzaDsgV2hldGhlciBhbiBpdGVtIGlzICJ0ZXh0LWxpa2UiIGFuZCBzaG91bGQgYmUgdHJlYXRlZCBhcyBhbiBpbmxpbmUgbm9kZS4gRXhhbXBsZXMgb2YgaW5saW5lIGVsZW1lbnRzOgogKiBgJHRleHRgLCBgc29mdEJyZWFrYCAoYDxicj5gKSwgZXRjLgogKgogKiAjIEdlbmVyaWMgaXRlbXMKICoKICogVGhlcmUgYXJlIHRocmVlIGJhc2ljIGdlbmVyaWMgaXRlbXM6IGAkcm9vdGAsIGAkYmxvY2tgIGFuZCBgJHRleHRgLgogKiBUaGV5IGFyZSBkZWZpbmVkIGFzIGZvbGxvd3M6CiAqCiAqCQl0aGlzLnNjaGVtYS5yZWdpc3RlciggJyRyb290JywgewogKgkJCWlzTGltaXQ6IHRydWUKICoJCX0gKTsKICoJCXRoaXMuc2NoZW1hLnJlZ2lzdGVyKCAnJGJsb2NrJywgewogKgkJCWFsbG93SW46ICckcm9vdCcsCiAqCQkJaXNCbG9jazogdHJ1ZQogKgkJfSApOwogKgkJdGhpcy5zY2hlbWEucmVnaXN0ZXIoICckdGV4dCcsIHsKICoJCQlhbGxvd0luOiAnJGJsb2NrJywKICoJCQlpc0lubGluZTogdHJ1ZQogKgkJfSApOwogKgogKiBUaGV5IHJlZmxlY3QgdHlwaWNhbCBlZGl0b3IgY29udGVudCB0aGF0IGlzIGNvbnRhaW5lZCB3aXRoaW4gb25lIHJvb3QsIGNvbnNpc3RzIG9mIHNldmVyYWwgYmxvY2tzCiAqIChwYXJhZ3JhcGhzLCBsaXN0cyBpdGVtcywgaGVhZGluZ3MsIGltYWdlcykgd2hpY2gsIGluIHR1cm4sIG1heSBjb250YWluIHRleHQgaW5zaWRlLgogKgogKiBCeSBpbmhlcml0aW5nIGZyb20gdGhlIGdlbmVyaWMgaXRlbXMgeW91IGNhbiBkZWZpbmUgbmV3IGl0ZW1zIHdoaWNoIHdpbGwgZ2V0IGV4dGVuZGVkIGJ5IG90aGVyIGVkaXRvciBmZWF0dXJlcy4KICogUmVhZCBtb3JlIGFib3V0IGdlbmVyaWMgdHlwZXMgaW4gdGhlIHtAZ2xpbmsgZnJhbWV3b3JrL2d1aWRlcy9kZWVwLWRpdmUvc2NoZW1hIERlZmluaW5nIHNjaGVtYX0gZ3VpZGUuCiAqCiAqICMgRXhhbXBsZSBkZWZpbml0aW9ucwogKgogKiBBbGxvdyBgcGFyYWdyYXBoYCBpbiByb290cyBhbmQgYmxvY2sgcXVvdGVzOgogKgogKgkJc2NoZW1hLnJlZ2lzdGVyKCAncGFyYWdyYXBoJywgewogKgkJCWFsbG93SW46IFsgJyRyb290JywgJ2Jsb2NrUXVvdGUnIF0sCiAqCQkJaXNCbG9jazogdHJ1ZQogKgkJfSApOwogKgogKiBBbGxvdyBgcGFyYWdyYXBoYCBldmVyeXdoZXJlIHdoZXJlIGAkYmxvY2tgIGlzIGFsbG93ZWQgKGkuZS4gaW4gYCRyb290YCk6CiAqCiAqCQlzY2hlbWEucmVnaXN0ZXIoICdwYXJhZ3JhcGgnLCB7CiAqCQkJYWxsb3dXaGVyZTogJyRibG9jaycsCiAqCQkJaXNCbG9jazogdHJ1ZQogKgkJfSApOwogKgogKiBNYWtlIGBpbWFnZWAgYSBibG9jayBvYmplY3QsIHdoaWNoIGlzIGFsbG93ZWQgZXZlcnl3aGVyZSB3aGVyZSBgJGJsb2NrYCBpcy4KICogQWxzbywgYWxsb3cgYHNyY2AgYW5kIGBhbHRgIGF0dHJpYnV0ZXMgaW4gaXQ6CiAqCiAqCQlzY2hlbWEucmVnaXN0ZXIoICdpbWFnZScsIHsKICoJCQlhbGxvd1doZXJlOiAnJGJsb2NrJywKICoJCQlhbGxvd0F0dHJpYnV0ZXM6IFsgJ3NyYycsICdhbHQnIF0sCiAqCQkJaXNCbG9jazogdHJ1ZSwKICoJCQlpc09iamVjdDogdHJ1ZQogKgkJfSApOwogKgogKiBNYWtlIGBjYXB0aW9uYCBhbGxvd2VkIGluIGBpbWFnZWAgYW5kIG1ha2UgaXQgYWxsb3cgYWxsIHRoZSBjb250ZW50IG9mIGAkYmxvY2tgcyAodXN1YWxseSwgYCR0ZXh0YCkuCiAqIEFsc28sIG1hcmsgaXQgYXMgYSBsaW1pdCBlbGVtZW50IHNvIGl0IGNhbm5vdCBiZSBzcGxpdDoKICoKICoJCXNjaGVtYS5yZWdpc3RlciggJ2NhcHRpb24nLCB7CiAqCQkJYWxsb3dJbjogJ2ltYWdlJywKICoJCQlhbGxvd0NvbnRlbnRPZjogJyRibG9jaycsCiAqCQkJaXNMaW1pdDogdHJ1ZQogKgkJfSApOwogKgogKiBNYWtlIGBsaXN0SXRlbWAgaW5oZXJpdCBhbGwgZnJvbSBgJGJsb2NrYCBidXQgYWxzbyBhbGxvdyBhZGRpdGlvbmFsIGF0dHJpYnV0ZXM6CiAqCiAqCQlzY2hlbWEucmVnaXN0ZXIoICdsaXN0SXRlbScsIHsKICoJCQlpbmhlcml0QWxsRnJvbTogJyRibG9jaycsCiAqCQkJYWxsb3dBdHRyaWJ1dGVzOiBbICdsaXN0VHlwZScsICdsaXN0SW5kZW50JyBdCiAqCQl9ICk7CiAqCiAqIFdoaWNoIHRyYW5zbGF0ZXMgdG86CiAqCiAqCQlzY2hlbWEucmVnaXN0ZXIoICdsaXN0SXRlbScsIHsKICoJCQlhbGxvd1doZXJlOiAnJGJsb2NrJywKICoJCQlhbGxvd0NvbnRlbnRPZjogJyRibG9jaycsCiAqCQkJYWxsb3dBdHRyaWJ1dGVzT2Y6ICckYmxvY2snLAogKgkJCWluaGVyaXRUeXBlc0Zyb206ICckYmxvY2snLAogKgkJCWFsbG93QXR0cmlidXRlczogWyAnbGlzdFR5cGUnLCAnbGlzdEluZGVudCcgXQogKgkJfSApOwogKgogKiAjIFRpcHMKICoKICogKiBDaGVjayBzY2hlbWEgZGVmaW5pdGlvbnMgb2YgZXhpc3RpbmcgZmVhdHVyZXMgdG8gc2VlIGhvdyB0aGV5IGFyZSBkZWZpbmVkLgogKiAqIElmIHlvdSB3YW50IHRvIHB1Ymxpc2ggeW91ciBmZWF0dXJlIHNvIG90aGVyIGRldmVsb3BlcnMgY2FuIHVzZSBpdCwgdHJ5IHRvIHVzZQogKiBnZW5lcmljIGl0ZW1zIGFzIG11Y2ggYXMgcG9zc2libGUuCiAqICogS2VlcCB5b3VyIG1vZGVsIGNsZWFuLiBMaW1pdCBpdCB0byB0aGUgYWN0dWFsIGRhdGEgYW5kIHN0b3JlIGluZm9ybWF0aW9uIGluIGEgbm9ybWFsaXplZCB3YXkuCiAqICogUmVtZW1iZXIgYWJvdXQgZGVmaW5pbmluZyB0aGUgYGlzKmAgcHJvcGVydGllcy4gVGhleSBkbyBub3QgYWZmZWN0IHRoZSBhbGxvd2VkIHN0cnVjdHVyZXMsIGJ1dCB0aGV5IGNhbgogKiBhZmZlY3QgaG93IHRoZSBlZGl0b3IgZmVhdHVyZXMgdHJlYXQgeW91ciBlbGVtZW50cy4KICoKICogQHR5cGVkZWYge09iamVjdH0gbW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hSXRlbURlZmluaXRpb24KICovCgovKioKICogQSBzaW1wbGlmaWVkIHZlcnNpb24gb2Yge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYUl0ZW1EZWZpbml0aW9ufSBhZnRlcgogKiBjb21waWxhdGlvbiBieSB0aGUge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYSBzY2hlbWF9LgogKiBSdWxlcyBmZWQgdG8gdGhlIHNjaGVtYSBieSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hI3JlZ2lzdGVyfQogKiBhbmQge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYSNleHRlbmR9IG1ldGhvZHMgYXJlIGRlZmluZWQgaW4gdGhlCiAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWFJdGVtRGVmaW5pdGlvbn0gZm9ybWF0LgogKiBMYXRlciBvbiwgdGhleSBhcmUgY29tcGlsZWQgdG8gYFNjaGVtYUNvbXBpbGVkSXRlbURlZml0aW9uYCBzbyB3aGVuIHlvdSB1c2UgZS5nLgogKiB0aGUge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYSNnZXREZWZpbml0aW9ufSBtZXRob2QgeW91IGdldCB0aGUgY29tcGlsZWQgdmVyc2lvbi4KICoKICogVGhlIGNvbXBpbGVkIHZlcnNpb24gY29udGFpbnMgb25seSB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6CiAqCiAqICogVGhlIGBuYW1lYCBwcm9wZXJ0eSwKICogKiBUaGUgYGlzKmAgcHJvcGVydGllcywKICogKiBUaGUgYGFsbG93SW5gIGFycmF5LAogKiAqIFRoZSBgYWxsb3dBdHRyaWJ1dGVzYCBhcnJheS4KICoKICogQHR5cGVkZWYge09iamVjdH0gbW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hQ29tcGlsZWRJdGVtRGVmaW5pdGlvbgogKi8KCi8qKgogKiBBIHNjaGVtYSBjb250ZXh0ICZtZGFzaDsgYSBsaXN0IG9mIGFuY2VzdG9ycyBvZiBhIGdpdmVuIHBvc2l0aW9uIGluIHRoZSBkb2N1bWVudC4KICoKICogQ29uc2lkZXJpbmcgc3VjaCBwb3NpdGlvbjoKICoKICoJCTwkcm9vdD4KICoJCQk8YmxvY2tRdW90ZT4KICoJCQkJPHBhcmFncmFwaD4KICoJCQkJCV4KICoJCQkJPC9wYXJhZ3JhcGg+CiAqCQkJPC9ibG9ja1F1b3RlPgogKgkJPC8kcm9vdD4KICoKICogVGhlIGNvbnRleHQgb2YgdGhpcyBwb3NpdGlvbiBpcyBpdHMge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb24jZ2V0QW5jZXN0b3JzIGxpc3RzIG9mIGFuY2VzdG9yc306CiAqCiAqCQlbIHJvb3RFbGVtZW50LCBibG9ja1F1b3RlRWxlbWVudCwgcGFyYWdyYXBoRWxlbWVudCBdCiAqCiAqIENvbnRleHRzIGFyZSB1c2VkIGluIHRoZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hI2V2ZW50OmNoZWNrQ2hpbGQgYFNjaGVtYSNjaGVja0NoaWxkYH0gYW5kCiAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWEjZXZlbnQ6Y2hlY2tBdHRyaWJ1dGUgYFNjaGVtYSNjaGVja0F0dHJpYnV0ZWB9IGV2ZW50cyBhcyBhIGRlZmluaXRpb24KICogb2YgYSBwbGFjZSBpbiB0aGUgZG9jdW1lbnQgd2hlcmUgdGhlIGNoZWNrIG9jY3Vycy4gVGhlIGNvbnRleHQgaW5zdGFuY2VzIGFyZSBjcmVhdGVkIGJhc2VkIG9uIHRoZSBmaXJzdCBhcmd1bWVudHMKICogb2YgdGhlIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWEjY2hlY2tDaGlsZCBgU2NoZW1hI2NoZWNrQ2hpbGQoKWB9IGFuZAogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hI2NoZWNrQXR0cmlidXRlIGBTY2hlbWEjY2hlY2tBdHRyaWJ1dGUoKWB9IG1ldGhvZHMgc28gd2hlbgogKiB1c2luZyB0aGVzZSBtZXRob2RzIHlvdSBuZWVkIHRvIHVzZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hQ29udGV4dERlZmluaXRpb259cy4KICovCgpleHBvcnQgY2xhc3MgU2NoZW1hQ29udGV4dCB7CiAgLyoqCiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGUgY29udGV4dC4KICAgKgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hQ29udGV4dERlZmluaXRpb259IGNvbnRleHQKICAgKi8KICBjb25zdHJ1Y3Rvcihjb250ZXh0KSB7CiAgICBpZiAoY29udGV4dCBpbnN0YW5jZW9mIFNjaGVtYUNvbnRleHQpIHsKICAgICAgcmV0dXJuIGNvbnRleHQ7CiAgICB9CgogICAgaWYgKHR5cGVvZiBjb250ZXh0ID09ICdzdHJpbmcnKSB7CiAgICAgIGNvbnRleHQgPSBbY29udGV4dF07CiAgICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KGNvbnRleHQpKSB7CiAgICAgIC8vIGBjb250ZXh0YCBpcyBpdGVtIG9yIHBvc2l0aW9uLgogICAgICAvLyBQb3NpdGlvbiNnZXRBbmNlc3RvcnMoKSBkb2Vzbid0IGFjY2VwdCBhbnkgcGFyYW1ldGVycyBidXQgaXQgd29ya3MganVzdCBmaW5lIGhlcmUuCiAgICAgIGNvbnRleHQgPSBjb250ZXh0LmdldEFuY2VzdG9ycyh7CiAgICAgICAgaW5jbHVkZVNlbGY6IHRydWUKICAgICAgfSk7CiAgICB9CgogICAgaWYgKGNvbnRleHRbMF0gJiYgdHlwZW9mIGNvbnRleHRbMF0gIT0gJ3N0cmluZycgJiYgY29udGV4dFswXS5pcygnZG9jdW1lbnRGcmFnbWVudCcpKSB7CiAgICAgIGNvbnRleHQuc2hpZnQoKTsKICAgIH0KCiAgICB0aGlzLl9pdGVtcyA9IGNvbnRleHQubWFwKG1hcENvbnRleHRJdGVtKTsKICB9CiAgLyoqCiAgICogVGhlIG51bWJlciBvZiBpdGVtcy4KICAgKgogICAqIEB0eXBlIHtOdW1iZXJ9CiAgICovCgoKICBnZXQgbGVuZ3RoKCkgewogICAgcmV0dXJuIHRoaXMuX2l0ZW1zLmxlbmd0aDsKICB9CiAgLyoqCiAgICogVGhlIGxhc3QgaXRlbSAodGhlIGxvd2VzdCBub2RlKS4KICAgKgogICAqIEB0eXBlIHttb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWFDb250ZXh0SXRlbX0KICAgKi8KCgogIGdldCBsYXN0KCkgewogICAgcmV0dXJuIHRoaXMuX2l0ZW1zW3RoaXMuX2l0ZW1zLmxlbmd0aCAtIDFdOwogIH0KICAvKioKICAgKiBJdGVyYWJsZSBpbnRlcmZhY2UuCiAgICoKICAgKiBJdGVyYXRlcyBvdmVyIGFsbCBjb250ZXh0IGl0ZW1zLgogICAqCiAgICogQHJldHVybnMge0l0ZXJhYmxlLjxtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWFDb250ZXh0SXRlbT59CiAgICovCgoKICBbU3ltYm9sLml0ZXJhdG9yXSgpIHsKICAgIHJldHVybiB0aGlzLl9pdGVtc1tTeW1ib2wuaXRlcmF0b3JdKCk7CiAgfQogIC8qKgogICAqIFJldHVybnMgYSBuZXcgc2NoZW1hIGNvbnRleHQgaW5zdGFuY2Ugd2l0aCBhbiBhZGRpdGlvbmFsIGl0ZW0uCiAgICoKICAgKiBJdGVtIGNhbiBiZSBhZGRlZCBhczoKICAgKgogICAqIAkJY29uc3QgY29udGV4dCA9IG5ldyBTY2hlbWFDb250ZXh0KCBbICckcm9vdCcgXSApOwogICAqCiAgICogCQkvLyBBbiBlbGVtZW50LgogICAqIAkJY29uc3QgZm9vRWxlbWVudCA9IHdyaXRlci5jcmVhdGVFbGVtZW50KCAnZm9vRWxlbWVudCcgKTsKICAgKiAJCWNvbnN0IG5ld0NvbnRleHQgPSBjb250ZXh0LnB1c2goIGZvb0VsZW1lbnQgKTsgLy8gWyAnJHJvb3QnLCAnZm9vRWxlbWVudCcgXQogICAqCiAgICogCQkvLyBBIHRleHQgbm9kZS4KICAgKiAJCWNvbnN0IHRleHQgPSB3cml0ZXIuY3JlYXRlVGV4dCggJ2Zvb2JhcicgKTsKICAgKiAJCWNvbnN0IG5ld0NvbnRleHQgPSBjb250ZXh0LnB1c2goIHRleHQgKTsgLy8gWyAnJHJvb3QnLCAnJHRleHQnIF0KICAgKgogICAqIAkJLy8gQSBzdHJpbmcgKGVsZW1lbnQgbmFtZSkuCiAgICogCQljb25zdCBuZXdDb250ZXh0ID0gY29udGV4dC5wdXNoKCAnYmFyRWxlbWVudCcgKTsgLy8gWyAnJHJvb3QnLCAnYmFyRWxlbWVudCcgXQogICAqCiAgICogKipOb3RlKioge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbm9kZX5Ob2RlfSB0aGF0IGlzIGFscmVhZHkgaW4gdGhlIG1vZGVsIHRyZWUgd2lsbCBiZSBhZGRlZCBhcyB0aGUgb25seSBpdGVtCiAgICogKHdpdGhvdXQgYW5jZXN0b3JzKS4KICAgKgogICAqIEBwYXJhbSB7U3RyaW5nfG1vZHVsZTplbmdpbmUvbW9kZWwvbm9kZX5Ob2RlfEFycmF5PFN0cmluZ3xtb2R1bGU6ZW5naW5lL21vZGVsL25vZGV+Tm9kZT59IGl0ZW0gQW4gaXRlbSB0aGF0IHdpbGwgYmUgYWRkZWQKICAgKiB0byB0aGUgY3VycmVudCBjb250ZXh0LgogICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWFDb250ZXh0fSBBIG5ldyBzY2hlbWEgY29udGV4dCBpbnN0YW5jZSB3aXRoIGFuIGFkZGl0aW9uYWwgaXRlbS4KICAgKi8KCgogIHB1c2goaXRlbSkgewogICAgY29uc3QgY3R4ID0gbmV3IFNjaGVtYUNvbnRleHQoW2l0ZW1dKTsKICAgIGN0eC5faXRlbXMgPSBbLi4udGhpcy5faXRlbXMsIC4uLmN0eC5faXRlbXNdOwogICAgcmV0dXJuIGN0eDsKICB9CiAgLyoqCiAgICogR2V0cyBhbiBpdGVtIG9uIHRoZSBnaXZlbiBpbmRleC4KICAgKgogICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWFDb250ZXh0SXRlbX0KICAgKi8KCgogIGdldEl0ZW0oaW5kZXgpIHsKICAgIHJldHVybiB0aGlzLl9pdGVtc1tpbmRleF07CiAgfQogIC8qKgogICAqIFJldHVybnMgdGhlIG5hbWVzIG9mIGl0ZW1zLgogICAqCiAgICogQHJldHVybnMge0l0ZXJhYmxlLjxTdHJpbmc+fQogICAqLwoKCiAgKmdldE5hbWVzKCkgewogICAgeWllbGQqIHRoaXMuX2l0ZW1zLm1hcChpdGVtID0+IGl0ZW0ubmFtZSk7CiAgfQogIC8qKgogICAqIENoZWNrcyB3aGV0aGVyIHRoZSBjb250ZXh0IGVuZHMgd2l0aCB0aGUgZ2l2ZW4gbm9kZXMuCiAgICoKICAgKgkJY29uc3QgY3R4ID0gbmV3IFNjaGVtYUNvbnRleHQoIFsgcm9vdEVsZW1lbnQsIHBhcmFncmFwaEVsZW1lbnQsIHRleHROb2RlIF0gKTsKICAgKgogICAqCQljdHguZW5kc1dpdGgoICckdGV4dCcgKTsgLy8gLT4gdHJ1ZQogICAqCQljdHguZW5kc1dpdGgoICdwYXJhZ3JhcGggJHRleHQnICk7IC8vIC0+IHRydWUKICAgKgkJY3R4LmVuZHNXaXRoKCAnJHJvb3QnICk7IC8vIC0+IGZhbHNlCiAgICoJCWN0eC5lbmRzV2l0aCggJ3BhcmFncmFwaCcgKTsgLy8gLT4gZmFsc2UKICAgKgogICAqIEBwYXJhbSB7U3RyaW5nfSBxdWVyeQogICAqIEByZXR1cm5zIHtCb29sZWFufQogICAqLwoKCiAgZW5kc1dpdGgocXVlcnkpIHsKICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuZ2V0TmFtZXMoKSkuam9pbignICcpLmVuZHNXaXRoKHF1ZXJ5KTsKICB9Cgp9Ci8qKgogKiBUaGUgZGVmaW5pdGlvbiBvZiBhIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWFDb250ZXh0IHNjaGVtYSBjb250ZXh0fS4KICoKICogQ29udGV4dHMgY2FuIGJlIGNyZWF0ZWQgaW4gbXVsdGlwbGUgd2F5czoKICoKICogKiBCeSBkZWZpbmluZyBhICoqbm9kZSoqIOKAkyBpbiB0aGlzIGNhc2VzIHRoaXMgbm9kZSBhbmQgYWxsIGl0cyBhbmNlc3RvcnMgd2lsbCBiZSB1c2VkLgogKiAqIEJ5IGRlZmluaW5nIGEgKipwb3NpdGlvbioqIGluIHRoZSBkb2N1bWVudCDigJMgaW4gdGhpcyBjYXNlIGFsbCBpdHMgYW5jZXN0b3JzIHdpbGwgYmUgdXNlZC4KICogKiBCeSBkZWZpbmluZyBhbiAqKmFycmF5IG9mIG5vZGVzKiog4oCTIGluIHRoaXMgY2FzZSB0aGlzIGFycmF5IGRlZmluZXMgdGhlIGVudGlyZSBjb250ZXh0LgogKiAqIEJ5IGRlZmluaW5nIGEgKipuYW1lIG9mIG5vZGUqKiAtIGluIHRoaXMgY2FzZSBub2RlIHdpbGwgYmUgIm1vY2tlZCIuIEl0IGlzIG5vdCByZWNvbW1lbmRlZCBiZWNhdXNlIGNvbnRleHQKICogd2lsbCBiZSB1bnJlYWxpc3RpYyAoZS5nLiBhdHRyaWJ1dGVzIG9mIHRoZXNlIG5vZGVzIGFyZSBub3Qgc3BlY2lmaWVkKS4gSG93ZXZlciwgYXQgdGltZXMgdGhpcyBtYXkgYmUgdGhlIG9ubHkKICogd2F5IHRvIGRlZmluZSB0aGUgY29udGV4dCAoZS5nLiB3aGVuIGNoZWNraW5nIHNvbWUgaHlwb3RoZXRpY2FsIHNpdHVhdGlvbikuCiAqICogQnkgZGVmaW5pbmcgYW4gKiphcnJheSBvZiBub2RlIG5hbWVzKiogKHBvdGVudGlhbGx5LCBtaXhlZCB3aXRoIHJlYWwgbm9kZXMpIOKAkyBUaGUgc2FtZSBhcyAqKm5hbWUgb2Ygbm9kZSoqCiAqIGJ1dCBpdCBpcyBwb3NzaWJsZSB0byBjcmVhdGUgYSBwYXRoLgogKiAqIEJ5IGRlZmluaW5nIGEge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYUNvbnRleHR9IGluc3RhbmNlIC0gaW4gdGhpcyBjYXNlIHRoZSBzYW1lIGluc3RhbmNlIGFzIHByb3ZpZGVkCiAqIHdpbGwgYmUgcmV0dXJuLgogKgogKiBFeGFtcGxlcyBvZiBjb250ZXh0IGRlZmluaXRpb25zIHBhc3NlZCB0byB0aGUge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYSNjaGVja0NoaWxkIGBTY2hlbWEjY2hlY2tDaGlsZCgpYH0KICogbWV0aG9kOgogKgogKgkJLy8gQXNzdW1pbmcgdGhhdCB3ZSBoYXZlIGEgJHJvb3QgPiBibG9ja1F1b3RlID4gcGFyYWdyYXBoIHN0cnVjdHVyZSwgdGhlIGZvbGxvd2luZyBjb2RlCiAqCQkvLyB3aWxsIGNoZWNrIG5vZGUgJ2ZvbycgaW4gdGhlIGZvbGxvd2luZyBjb250ZXh0OgogKgkJLy8gWyByb290RWxlbWVudCwgYmxvY2tRdW90ZUVsZW1lbnQsIHBhcmFncmFwaEVsZW1lbnQgXQogKgkJY29uc3QgY29udGV4dERlZmluaXRpb24gPSBwYXJhZ3JhcGhFbGVtZW50OwogKiAJCWNvbnN0IGNoaWxkVG9DaGVjayA9ICdmb28nOwogKgkJc2NoZW1hLmNoZWNrQ2hpbGQoIGNvbnRleHREZWZpbml0aW9uLCBjaGlsZFRvQ2hlY2sgKTsKICoKICoJCS8vIEFsc28gY2hlY2sgaW4gWyByb290RWxlbWVudCwgYmxvY2tRdW90ZUVsZW1lbnQsIHBhcmFncmFwaEVsZW1lbnQgXS4KICoJCXNjaGVtYS5jaGVja0NoaWxkKCBtb2RlbC5jcmVhdGVQb3NpdGlvbkF0KCBwYXJhZ3JhcGhFbGVtZW50LCAwICksICdmb28nICk7CiAqCiAqCQkvLyBDaGVjayBpbiBbIHJvb3RFbGVtZW50LCBwYXJhZ3JhcGhFbGVtZW50IF0uCiAqCQlzY2hlbWEuY2hlY2tDaGlsZCggWyByb290RWxlbWVudCwgcGFyYWdyYXBoRWxlbWVudCBdLCAnZm9vJyApOwogKgogKgkJLy8gQ2hlY2sgb25seSBmYWtlUGFyYWdyYXBoRWxlbWVudC4KICoJCXNjaGVtYS5jaGVja0NoaWxkKCAncGFyYWdyYXBoJywgJ2ZvbycgKTsKICoKICoJCS8vIENoZWNrIGluIFsgZmFrZVJvb3RFbGVtZW50LCBmYWtlQmFyRWxlbWVudCwgcGFyYWdyYXBoRWxlbWVudCBdLgogKgkJc2NoZW1hLmNoZWNrQ2hpbGQoIFsgJyRyb290JywgJ2JhcicsIHBhcmFncmFwaEVsZW1lbnQgXSwgJ2ZvbycgKTsKICoKICogQWxsIHRoZXNlIGBjaGVja0NoaWxkKClgIGNhbGxzIHdpbGwgZmlyZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hI2V2ZW50OmNoZWNrQ2hpbGQgYFNjaGVtYSNjaGVja0NoaWxkYH0KICogZXZlbnRzIGluIHdoaWNoIGBhcmdzWyAwIF1gIGlzIGFuIGluc3RhbmNlIG9mIHRoZSBjb250ZXh0LiBUaGVyZWZvcmUsIHlvdSBjYW4gd3JpdGUgYSBsaXN0ZW5lciBsaWtlIHRoaXM6CiAqCiAqCQlzY2hlbWEub24oICdjaGVja0NoaWxkJywgKCBldnQsIGFyZ3MgKSA9PiB7CiAqCQkJY29uc3QgY3R4ID0gYXJnc1sgMCBdOwogKgogKgkJCWNvbnNvbGUubG9nKCBBcnJheS5mcm9tKCBjdHguZ2V0TmFtZXMoKSApICk7CiAqCQl9ICk7CiAqCiAqIFdoaWNoIHdpbGwgbG9nIHRoZSBmb2xsb3dpbmc6CiAqCiAqCQlbICckcm9vdCcsICdibG9ja1F1b3RlJywgJ3BhcmFncmFwaCcgXQogKgkJWyAnJHJvb3QnLCAncGFyYWdyYXBoJyBdCiAqCQlbICckcm9vdCcsICdiYXInLCAncGFyYWdyYXBoJyBdCiAqCiAqIE5vdGU6IFdoZW4gdXNpbmcgdGhlIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWEjY2hlY2tBdHRyaWJ1dGUgYFNjaGVtYSNjaGVja0F0dHJpYnV0ZSgpYH0gbWV0aG9kCiAqIHlvdSBtYXkgd2FudCB0byBjaGVjayB3aGV0aGVyIGEgdGV4dCBub2RlIG1heSBoYXZlIGFuIGF0dHJpYnV0ZS4gQSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC90ZXh0flRleHR9IGlzIGEKICogY29ycmVjdCB3YXkgdG8gZGVmaW5lIGEgY29udGV4dCBzbyB5b3UgY2FuIGRvIHRoaXM6CiAqCiAqCQlzY2hlbWEuY2hlY2tBdHRyaWJ1dGUoIHRleHROb2RlLCAnYm9sZCcgKTsKICoKICogQnV0IHNvbWV0aW1lcyB5b3Ugd2FudCB0byBjaGVjayB3aGV0aGVyIGEgdGV4dCBhdCBhIGdpdmVuIHBvc2l0aW9uIG1pZ2h0J3ZlIGhhZCBzb21lIGF0dHJpYnV0ZSwKICogaW4gd2hpY2ggY2FzZSB5b3UgY2FuIGNyZWF0ZSBhIGNvbnRleHQgYnkgbWlzaW5nIGFuIGFycmF5IG9mIGVsZW1lbnRzIHdpdGggYSBgJyR0ZXh0J2Agc3RyaW5nOgogKgogKgkJLy8gQ2hlY2sgaW4gWyByb290RWxlbWVudCwgcGFyYWdyYXBoRWxlbWVudCwgdGV4dE5vZGUgXS4KICoJCXNjaGVtYS5jaGVja0NoaWxkKCBbIC4uLnBvc2l0aW9uSW5QYXJhZ3JhcGguZ2V0QW5jZXN0b3JzKCksICckdGV4dCcgXSwgJ2JvbGQnICk7CiAqCiAqIEB0eXBlZGVmIHttb2R1bGU6ZW5naW5lL21vZGVsL25vZGV+Tm9kZXxtb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufG1vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYUNvbnRleHR8CiAqIFN0cmluZ3xBcnJheS48U3RyaW5nfG1vZHVsZTplbmdpbmUvbW9kZWwvbm9kZX5Ob2RlPn0gbW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hQ29udGV4dERlZmluaXRpb24KICovCgovKioKICogQW4gaXRlbSBvZiB0aGUge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYUNvbnRleHQgc2NoZW1hIGNvbnRleHR9LgogKgogKiBJdCBjb250YWlucyAzIHByb3BlcnRpZXM6CiAqCiAqICogYG5hbWVgIOKAkyB0aGUgbmFtZSBvZiB0aGlzIGl0ZW0sCiAqICogYCogZ2V0QXR0cmlidXRlS2V5cygpYCDigJMgYSBnZW5lcmF0b3Igb2Yga2V5cyBvZiBpdGVtIGF0dHJpYnV0ZXMsCiAqICogYGdldEF0dHJpYnV0ZSgga2V5TmFtZSApYCDigJMgYSBtZXRob2QgdG8gZ2V0IGF0dHJpYnV0ZSB2YWx1ZXMuCiAqCiAqIFRoZSBjb250ZXh0IGl0ZW0gaW50ZXJmYWNlIGlzIGEgaGlnaGx5IHNpbXBsaWZpZWQgdmVyc2lvbiBvZiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9ub2Rlfk5vZGV9IGFuZCBpdHMgcm9sZQogKiBpcyB0byBleHBvc2Ugb25seSB0aGUgaW5mb3JtYXRpb24gd2hpY2ggc2NoZW1hIGNoZWNrcyBhcmUgYWJsZSB0byBwcm92aWRlICh3aGljaCBpcyB0aGUgbmFtZSBvZiB0aGUgbm9kZSBhbmQKICogbm9kZSdzIGF0dHJpYnV0ZXMpLgogKgogKgkJc2NoZW1hLm9uKCAnY2hlY2tDaGlsZCcsICggZXZ0LCBhcmdzICkgPT4gewogKgkJCWNvbnN0IGN0eCA9IGFyZ3NbIDAgXTsKICoJCQljb25zdCBmaXJzdEl0ZW0gPSBjdHguZ2V0SXRlbSggMCApOwogKgogKgkJCWNvbnNvbGUubG9nKCBmaXJzdEl0ZW0ubmFtZSApOyAvLyAtPiAnJHJvb3QnCiAqCQkJY29uc29sZS5sb2coIGZpcnN0SXRlbS5nZXRBdHRyaWJ1dGUoICdmb28nICkgKTsgLy8gLT4gJ2JhcicKICoJCQljb25zb2xlLmxvZyggQXJyYXkuZnJvbSggZmlyc3RJdGVtLmdldEF0dHJpYnV0ZUtleXMoKSApICk7IC8vIC0+IFsgJ2ZvbycsICdmYWEnIF0KICoJCX0gKTsKICoKICogQHR5cGVkZWYge09iamVjdH0gbW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hQ29udGV4dEl0ZW0KICovCgovKioKICogQSBzdHJ1Y3R1cmUgY29udGFpbmluZyBhZGRpdGlvbmFsIG1ldGFkYXRhIGRlc2NyaWJpbmcgdGhlIGF0dHJpYnV0ZS4KICoKICogU2VlIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWEjc2V0QXR0cmlidXRlUHJvcGVydGllcyBgU2NoZW1hI3NldEF0dHJpYnV0ZVByb3BlcnRpZXMoKWB9IGZvciB1c2FnZSBleGFtcGxlcy4KICoKICogQHR5cGVkZWYge09iamVjdH0gbW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+QXR0cmlidXRlUHJvcGVydGllcwogKiBAcHJvcGVydHkge0Jvb2xlYW59IFtpc0Zvcm1hdHRpbmddIEluZGljYXRlcyB0aGF0IHRoZSBhdHRyaWJ1dGUgc2hvdWxkIGJlIGNvbnNpZGVyZWQgYXMgYSB2aXN1YWwgZm9ybWF0dGluZywgbGlrZSBgYm9sZGAsIGBpdGFsaWNgIG9yCiAqIGBmb250U2l6ZWAgcmF0aGVyIHRoYW4gc2VtYW50aWMgYXR0cmlidXRlIChzdWNoIGFzIGBzcmNgLCBgbGlzdFR5cGVgLCBldGMuKS4gRm9yIGV4YW1wbGUsIGl0IGlzIHVzZWQgYnkgdGhlICJSZW1vdmUgZm9ybWF0IiBmZWF0dXJlLgogKiBAcHJvcGVydHkge0Jvb2xlYW59IFtjb3B5T25FbnRlcl0gSW5kaWNhdGVzIHRoYXQgZ2l2ZW4gdGV4dCBhdHRyaWJ1dGUgc2hvdWxkIGJlIGNvcGllZCB0byB0aGUgbmV4dCBibG9jayB3aGVuIGVudGVyIGlzIHByZXNzZWQuCiAqLwoKZnVuY3Rpb24gY29tcGlsZUJhc2VJdGVtUnVsZShzb3VyY2VJdGVtUnVsZXMsIGl0ZW1OYW1lKSB7CiAgY29uc3QgaXRlbVJ1bGUgPSB7CiAgICBuYW1lOiBpdGVtTmFtZSwKICAgIGFsbG93SW46IFtdLAogICAgYWxsb3dDb250ZW50T2Y6IFtdLAogICAgYWxsb3dXaGVyZTogW10sCiAgICBhbGxvd0F0dHJpYnV0ZXM6IFtdLAogICAgYWxsb3dBdHRyaWJ1dGVzT2Y6IFtdLAogICAgaW5oZXJpdFR5cGVzRnJvbTogW10KICB9OwogIGNvcHlUeXBlcyhzb3VyY2VJdGVtUnVsZXMsIGl0ZW1SdWxlKTsKICBjb3B5UHJvcGVydHkoc291cmNlSXRlbVJ1bGVzLCBpdGVtUnVsZSwgJ2FsbG93SW4nKTsKICBjb3B5UHJvcGVydHkoc291cmNlSXRlbVJ1bGVzLCBpdGVtUnVsZSwgJ2FsbG93Q29udGVudE9mJyk7CiAgY29weVByb3BlcnR5KHNvdXJjZUl0ZW1SdWxlcywgaXRlbVJ1bGUsICdhbGxvd1doZXJlJyk7CiAgY29weVByb3BlcnR5KHNvdXJjZUl0ZW1SdWxlcywgaXRlbVJ1bGUsICdhbGxvd0F0dHJpYnV0ZXMnKTsKICBjb3B5UHJvcGVydHkoc291cmNlSXRlbVJ1bGVzLCBpdGVtUnVsZSwgJ2FsbG93QXR0cmlidXRlc09mJyk7CiAgY29weVByb3BlcnR5KHNvdXJjZUl0ZW1SdWxlcywgaXRlbVJ1bGUsICdpbmhlcml0VHlwZXNGcm9tJyk7CiAgbWFrZUluaGVyaXRBbGxXb3JrKHNvdXJjZUl0ZW1SdWxlcywgaXRlbVJ1bGUpOwogIHJldHVybiBpdGVtUnVsZTsKfQoKZnVuY3Rpb24gY29tcGlsZUFsbG93Q29udGVudE9mKGNvbXBpbGVkRGVmaW5pdGlvbnMsIGl0ZW1OYW1lKSB7CiAgZm9yIChjb25zdCBhbGxvd0NvbnRlbnRPZkl0ZW1OYW1lIG9mIGNvbXBpbGVkRGVmaW5pdGlvbnNbaXRlbU5hbWVdLmFsbG93Q29udGVudE9mKSB7CiAgICAvLyBUaGUgYWxsb3dDb250ZW50T2YgcHJvcGVydHkgbWF5IHBvaW50IHRvIGFuIHVucmVnaXN0ZXJlZCBlbGVtZW50LgogICAgaWYgKGNvbXBpbGVkRGVmaW5pdGlvbnNbYWxsb3dDb250ZW50T2ZJdGVtTmFtZV0pIHsKICAgICAgY29uc3QgYWxsb3dlZENoaWxkcmVuID0gZ2V0QWxsb3dlZENoaWxkcmVuKGNvbXBpbGVkRGVmaW5pdGlvbnMsIGFsbG93Q29udGVudE9mSXRlbU5hbWUpOwogICAgICBhbGxvd2VkQ2hpbGRyZW4uZm9yRWFjaChhbGxvd2VkSXRlbSA9PiB7CiAgICAgICAgYWxsb3dlZEl0ZW0uYWxsb3dJbi5wdXNoKGl0ZW1OYW1lKTsKICAgICAgfSk7CiAgICB9CiAgfQoKICBkZWxldGUgY29tcGlsZWREZWZpbml0aW9uc1tpdGVtTmFtZV0uYWxsb3dDb250ZW50T2Y7Cn0KCmZ1bmN0aW9uIGNvbXBpbGVBbGxvd1doZXJlKGNvbXBpbGVkRGVmaW5pdGlvbnMsIGl0ZW1OYW1lKSB7CiAgZm9yIChjb25zdCBhbGxvd1doZXJlSXRlbU5hbWUgb2YgY29tcGlsZWREZWZpbml0aW9uc1tpdGVtTmFtZV0uYWxsb3dXaGVyZSkgewogICAgY29uc3QgaW5oZXJpdEZyb20gPSBjb21waWxlZERlZmluaXRpb25zW2FsbG93V2hlcmVJdGVtTmFtZV07IC8vIFRoZSBhbGxvd1doZXJlIHByb3BlcnR5IG1heSBwb2ludCB0byBhbiB1bnJlZ2lzdGVyZWQgZWxlbWVudC4KCiAgICBpZiAoaW5oZXJpdEZyb20pIHsKICAgICAgY29uc3QgYWxsb3dlZEluID0gaW5oZXJpdEZyb20uYWxsb3dJbjsKICAgICAgY29tcGlsZWREZWZpbml0aW9uc1tpdGVtTmFtZV0uYWxsb3dJbi5wdXNoKC4uLmFsbG93ZWRJbik7CiAgICB9CiAgfQoKICBkZWxldGUgY29tcGlsZWREZWZpbml0aW9uc1tpdGVtTmFtZV0uYWxsb3dXaGVyZTsKfQoKZnVuY3Rpb24gY29tcGlsZUFsbG93QXR0cmlidXRlc09mKGNvbXBpbGVkRGVmaW5pdGlvbnMsIGl0ZW1OYW1lKSB7CiAgZm9yIChjb25zdCBhbGxvd0F0dHJpYnV0ZU9mSXRlbSBvZiBjb21waWxlZERlZmluaXRpb25zW2l0ZW1OYW1lXS5hbGxvd0F0dHJpYnV0ZXNPZikgewogICAgY29uc3QgaW5oZXJpdEZyb20gPSBjb21waWxlZERlZmluaXRpb25zW2FsbG93QXR0cmlidXRlT2ZJdGVtXTsKCiAgICBpZiAoaW5oZXJpdEZyb20pIHsKICAgICAgY29uc3QgaW5oZXJpdEF0dHJpYnV0ZXMgPSBpbmhlcml0RnJvbS5hbGxvd0F0dHJpYnV0ZXM7CiAgICAgIGNvbXBpbGVkRGVmaW5pdGlvbnNbaXRlbU5hbWVdLmFsbG93QXR0cmlidXRlcy5wdXNoKC4uLmluaGVyaXRBdHRyaWJ1dGVzKTsKICAgIH0KICB9CgogIGRlbGV0ZSBjb21waWxlZERlZmluaXRpb25zW2l0ZW1OYW1lXS5hbGxvd0F0dHJpYnV0ZXNPZjsKfQoKZnVuY3Rpb24gY29tcGlsZUluaGVyaXRQcm9wZXJ0aWVzRnJvbShjb21waWxlZERlZmluaXRpb25zLCBpdGVtTmFtZSkgewogIGNvbnN0IGl0ZW0gPSBjb21waWxlZERlZmluaXRpb25zW2l0ZW1OYW1lXTsKCiAgZm9yIChjb25zdCBpbmhlcml0UHJvcGVydGllc09mSXRlbSBvZiBpdGVtLmluaGVyaXRUeXBlc0Zyb20pIHsKICAgIGNvbnN0IGluaGVyaXRGcm9tID0gY29tcGlsZWREZWZpbml0aW9uc1tpbmhlcml0UHJvcGVydGllc09mSXRlbV07CgogICAgaWYgKGluaGVyaXRGcm9tKSB7CiAgICAgIGNvbnN0IHR5cGVOYW1lcyA9IE9iamVjdC5rZXlzKGluaGVyaXRGcm9tKS5maWx0ZXIobmFtZSA9PiBuYW1lLnN0YXJ0c1dpdGgoJ2lzJykpOwoKICAgICAgZm9yIChjb25zdCBuYW1lIG9mIHR5cGVOYW1lcykgewogICAgICAgIGlmICghKG5hbWUgaW4gaXRlbSkpIHsKICAgICAgICAgIGl0ZW1bbmFtZV0gPSBpbmhlcml0RnJvbVtuYW1lXTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KICB9CgogIGRlbGV0ZSBpdGVtLmluaGVyaXRUeXBlc0Zyb207Cn0gLy8gUmVtb3ZlIGl0ZW1zIHdoaWNoIHdlcmVuJ3QgcmVnaXN0ZXJlZCAoYmVjYXVzZSBpdCBtYXkgYnJlYWsgc29tZSBjaGVja3Mgb3Igd2UnZCBuZWVkIHRvIGNvbXBsaWNhdGUgdGhlbSkuCi8vIE1ha2Ugc3VyZSBhbGxvd0luIGRvZXNuJ3QgY29udGFpbiByZXBlYXRlZCB2YWx1ZXMuCgoKZnVuY3Rpb24gY2xlYW5VcEFsbG93SW4oY29tcGlsZWREZWZpbml0aW9ucywgaXRlbU5hbWUpIHsKICBjb25zdCBpdGVtUnVsZSA9IGNvbXBpbGVkRGVmaW5pdGlvbnNbaXRlbU5hbWVdOwogIGNvbnN0IGV4aXN0aW5nSXRlbXMgPSBpdGVtUnVsZS5hbGxvd0luLmZpbHRlcihpdGVtVG9DaGVjayA9PiBjb21waWxlZERlZmluaXRpb25zW2l0ZW1Ub0NoZWNrXSk7CiAgaXRlbVJ1bGUuYWxsb3dJbiA9IEFycmF5LmZyb20obmV3IFNldChleGlzdGluZ0l0ZW1zKSk7Cn0KCmZ1bmN0aW9uIGNsZWFuVXBBbGxvd0F0dHJpYnV0ZXMoY29tcGlsZWREZWZpbml0aW9ucywgaXRlbU5hbWUpIHsKICBjb25zdCBpdGVtUnVsZSA9IGNvbXBpbGVkRGVmaW5pdGlvbnNbaXRlbU5hbWVdOwogIGl0ZW1SdWxlLmFsbG93QXR0cmlidXRlcyA9IEFycmF5LmZyb20obmV3IFNldChpdGVtUnVsZS5hbGxvd0F0dHJpYnV0ZXMpKTsKfQoKZnVuY3Rpb24gY29weVR5cGVzKHNvdXJjZUl0ZW1SdWxlcywgaXRlbVJ1bGUpIHsKICBmb3IgKGNvbnN0IHNvdXJjZUl0ZW1SdWxlIG9mIHNvdXJjZUl0ZW1SdWxlcykgewogICAgY29uc3QgdHlwZU5hbWVzID0gT2JqZWN0LmtleXMoc291cmNlSXRlbVJ1bGUpLmZpbHRlcihuYW1lID0+IG5hbWUuc3RhcnRzV2l0aCgnaXMnKSk7CgogICAgZm9yIChjb25zdCBuYW1lIG9mIHR5cGVOYW1lcykgewogICAgICBpdGVtUnVsZVtuYW1lXSA9IHNvdXJjZUl0ZW1SdWxlW25hbWVdOwogICAgfQogIH0KfQoKZnVuY3Rpb24gY29weVByb3BlcnR5KHNvdXJjZUl0ZW1SdWxlcywgaXRlbVJ1bGUsIHByb3BlcnR5TmFtZSkgewogIGZvciAoY29uc3Qgc291cmNlSXRlbVJ1bGUgb2Ygc291cmNlSXRlbVJ1bGVzKSB7CiAgICBpZiAodHlwZW9mIHNvdXJjZUl0ZW1SdWxlW3Byb3BlcnR5TmFtZV0gPT0gJ3N0cmluZycpIHsKICAgICAgaXRlbVJ1bGVbcHJvcGVydHlOYW1lXS5wdXNoKHNvdXJjZUl0ZW1SdWxlW3Byb3BlcnR5TmFtZV0pOwogICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHNvdXJjZUl0ZW1SdWxlW3Byb3BlcnR5TmFtZV0pKSB7CiAgICAgIGl0ZW1SdWxlW3Byb3BlcnR5TmFtZV0ucHVzaCguLi5zb3VyY2VJdGVtUnVsZVtwcm9wZXJ0eU5hbWVdKTsKICAgIH0KICB9Cn0KCmZ1bmN0aW9uIG1ha2VJbmhlcml0QWxsV29yayhzb3VyY2VJdGVtUnVsZXMsIGl0ZW1SdWxlKSB7CiAgZm9yIChjb25zdCBzb3VyY2VJdGVtUnVsZSBvZiBzb3VyY2VJdGVtUnVsZXMpIHsKICAgIGNvbnN0IGluaGVyaXRGcm9tID0gc291cmNlSXRlbVJ1bGUuaW5oZXJpdEFsbEZyb207CgogICAgaWYgKGluaGVyaXRGcm9tKSB7CiAgICAgIGl0ZW1SdWxlLmFsbG93Q29udGVudE9mLnB1c2goaW5oZXJpdEZyb20pOwogICAgICBpdGVtUnVsZS5hbGxvd1doZXJlLnB1c2goaW5oZXJpdEZyb20pOwogICAgICBpdGVtUnVsZS5hbGxvd0F0dHJpYnV0ZXNPZi5wdXNoKGluaGVyaXRGcm9tKTsKICAgICAgaXRlbVJ1bGUuaW5oZXJpdFR5cGVzRnJvbS5wdXNoKGluaGVyaXRGcm9tKTsKICAgIH0KICB9Cn0KCmZ1bmN0aW9uIGdldEFsbG93ZWRDaGlsZHJlbihjb21waWxlZERlZmluaXRpb25zLCBpdGVtTmFtZSkgewogIGNvbnN0IGl0ZW1SdWxlID0gY29tcGlsZWREZWZpbml0aW9uc1tpdGVtTmFtZV07CiAgcmV0dXJuIGdldFZhbHVlcyhjb21waWxlZERlZmluaXRpb25zKS5maWx0ZXIoZGVmID0+IGRlZi5hbGxvd0luLmluY2x1ZGVzKGl0ZW1SdWxlLm5hbWUpKTsKfQoKZnVuY3Rpb24gZ2V0VmFsdWVzKG9iaikgewogIHJldHVybiBPYmplY3Qua2V5cyhvYmopLm1hcChrZXkgPT4gb2JqW2tleV0pOwp9CgpmdW5jdGlvbiBtYXBDb250ZXh0SXRlbShjdHhJdGVtKSB7CiAgaWYgKHR5cGVvZiBjdHhJdGVtID09ICdzdHJpbmcnKSB7CiAgICByZXR1cm4gewogICAgICBuYW1lOiBjdHhJdGVtLAoKICAgICAgKmdldEF0dHJpYnV0ZUtleXMoKSB7fSwKCiAgICAgIGdldEF0dHJpYnV0ZSgpIHt9CgogICAgfTsKICB9IGVsc2UgewogICAgcmV0dXJuIHsKICAgICAgLy8gJyR0ZXh0JyBtZWFucyB0ZXh0IG5vZGVzIGFuZCB0ZXh0IHByb3hpZXMuCiAgICAgIG5hbWU6IGN0eEl0ZW0uaXMoJ2VsZW1lbnQnKSA/IGN0eEl0ZW0ubmFtZSA6ICckdGV4dCcsCgogICAgICAqZ2V0QXR0cmlidXRlS2V5cygpIHsKICAgICAgICB5aWVsZCogY3R4SXRlbS5nZXRBdHRyaWJ1dGVLZXlzKCk7CiAgICAgIH0sCgogICAgICBnZXRBdHRyaWJ1dGUoa2V5KSB7CiAgICAgICAgcmV0dXJuIGN0eEl0ZW0uZ2V0QXR0cmlidXRlKGtleSk7CiAgICAgIH0KCiAgICB9OwogIH0KfSAvLyBHZW5lcmF0b3IgZnVuY3Rpb24gcmV0dXJuaW5nIHZhbHVlcyBmcm9tIHByb3ZpZGVkIHdhbGtlcnMsIHN3aXRjaGluZyBiZXR3ZWVuIHRoZW0gYXQgZWFjaCBpdGVyYXRpb24uIElmIG9ubHkgb25lIHdhbGtlcgovLyBpcyBwcm92aWRlZCBpdCB3aWxsIHJldHVybiBkYXRhIG9ubHkgZnJvbSB0aGF0IHdhbGtlci4KLy8KLy8gQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZHVsZS90cmVld2Fsa2VyflRyZWVXYWxrZXJ9IFtiYWNrd2FyZF0gV2Fsa2VyIGl0ZXJhdGluZyBpbiBiYWNrd2FyZCBkaXJlY3Rpb24uCi8vIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2R1bGUvdHJlZXdhbGtlcn5UcmVlV2Fsa2VyfSBbZm9yd2FyZF0gV2Fsa2VyIGl0ZXJhdGluZyBpbiBmb3J3YXJkIGRpcmVjdGlvbi4KLy8gQHJldHVybnMge0l0ZXJhYmxlLjxPYmplY3Q+fSBPYmplY3QgcmV0dXJuZWQgYXQgZWFjaCBpdGVyYXRpb24gY29udGFpbnMgYHZhbHVlYCBhbmQgYHdhbGtlcmAgKGluZm9ybWluZyB3aGljaCB3YWxrZXIgcmV0dXJuZWQKLy8gZ2l2ZW4gdmFsdWUpIGZpZWxkcy4KCgpmdW5jdGlvbiogY29tYmluZVdhbGtlcnMoYmFja3dhcmQsIGZvcndhcmQpIHsKICBsZXQgZG9uZSA9IGZhbHNlOwoKICB3aGlsZSAoIWRvbmUpIHsKICAgIGRvbmUgPSB0cnVlOwoKICAgIGlmIChiYWNrd2FyZCkgewogICAgICBjb25zdCBzdGVwID0gYmFja3dhcmQubmV4dCgpOwoKICAgICAgaWYgKCFzdGVwLmRvbmUpIHsKICAgICAgICBkb25lID0gZmFsc2U7CiAgICAgICAgeWllbGQgewogICAgICAgICAgd2Fsa2VyOiBiYWNrd2FyZCwKICAgICAgICAgIHZhbHVlOiBzdGVwLnZhbHVlCiAgICAgICAgfTsKICAgICAgfQogICAgfQoKICAgIGlmIChmb3J3YXJkKSB7CiAgICAgIGNvbnN0IHN0ZXAgPSBmb3J3YXJkLm5leHQoKTsKCiAgICAgIGlmICghc3RlcC5kb25lKSB7CiAgICAgICAgZG9uZSA9IGZhbHNlOwogICAgICAgIHlpZWxkIHsKICAgICAgICAgIHdhbGtlcjogZm9yd2FyZCwKICAgICAgICAgIHZhbHVlOiBzdGVwLnZhbHVlCiAgICAgICAgfTsKICAgICAgfQogICAgfQogIH0KfSAvLyBUYWtlcyBhbiBhcnJheSBvZiBub24taW50ZXJzZWN0aW5nIHJhbmdlcy4gRm9yIGVhY2ggb2YgdGhlbSBnZXRzIG1pbmltYWwgZmxhdCByYW5nZXMgY292ZXJpbmcgdGhhdCByYW5nZSBhbmQgcmV0dXJucwovLyBhbGwgdGhvc2UgbWluaW1hbCBmbGF0IHJhbmdlcy4KLy8KLy8gQHBhcmFtIHtBcnJheS48bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZT59IHJhbmdlcyBSYW5nZXMgdG8gcHJvY2Vzcy4KLy8gQHJldHVybnMge0l0ZXJhYmxlLjxtb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlPn0gTWluaW1hbCBmbGF0IHJhbmdlcyBvZiBnaXZlbiBgcmFuZ2VzYC4KCgpmdW5jdGlvbiogY29udmVydFRvTWluaW1hbEZsYXRSYW5nZXMocmFuZ2VzKSB7CiAgZm9yIChjb25zdCByYW5nZSBvZiByYW5nZXMpIHsKICAgIHlpZWxkKiByYW5nZS5nZXRNaW5pbWFsRmxhdFJhbmdlcygpOwogIH0KfQoKZnVuY3Rpb24gcmVtb3ZlRGlzYWxsb3dlZEF0dHJpYnV0ZUZyb21Ob2RlKHNjaGVtYSwgbm9kZSwgd3JpdGVyKSB7CiAgZm9yIChjb25zdCBhdHRyaWJ1dGUgb2Ygbm9kZS5nZXRBdHRyaWJ1dGVLZXlzKCkpIHsKICAgIGlmICghc2NoZW1hLmNoZWNrQXR0cmlidXRlKG5vZGUsIGF0dHJpYnV0ZSkpIHsKICAgICAgd3JpdGVyLnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGUsIG5vZGUpOwogICAgfQogIH0KfQ=="},{"version":3,"sources":["/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-engine/src/model/schema.js"],"names":["CKEditorError","ObservableMixin","mix","Range","Position","Element","Text","TreeWalker","Schema","constructor","_sourceDefinitions","_attributeProperties","decorate","on","evt","args","SchemaContext","priority","getDefinition","register","itemName","definition","Object","assign","_clearCache","extend","push","getDefinitions","_compiledDefinitions","_compile","item","is","name","isRegistered","isBlock","def","isLimit","isObject","isInline","checkChild","context","_checkContextMatch","checkAttribute","attributeName","last","allowAttributes","includes","checkMerge","positionOrBaseElement","elementToMerge","nodeBefore","nodeAfter","child","getChildren","addChildCheck","callback","ctx","childDef","retValue","stop","return","addAttributeCheck","setAttributeProperties","properties","getAttributeProperties","getLimitElement","selectionOrRangeOrPosition","element","parent","ranges","Array","from","getRanges","reduce","range","rangeCommonAncestor","getCommonAncestor","includeSelf","checkAttributeInSelection","selection","attribute","isCollapsed","firstPosition","getFirstPosition","getAncestors","getAttributes","value","getValidRanges","convertToMinimalFlatRanges","_getValidRangesForRange","getNearestSelectionRange","position","direction","backwardWalker","forwardWalker","startPosition","data","combineWalkers","type","walker","_createOn","nextPosition","findAllowedParent","node","removeDisallowedAttributes","nodes","writer","removeDisallowedAttributeFromNode","rangeInNode","_createIn","positionsInRange","getPositions","createContext","compiledDefinitions","sourceRules","itemNames","keys","compileBaseItemRule","compileAllowContentOf","compileAllowWhere","compileAllowAttributesOf","compileInheritPropertiesFrom","cleanUpAllowIn","cleanUpAllowAttributes","contextItemIndex","length","contextItem","getItem","allowIn","parentRule","start","end","getItems","shallow","isEqual","_createAfter","isArray","shift","_items","map","mapContextItem","Symbol","iterator","index","getNames","endsWith","query","join","sourceItemRules","itemRule","allowContentOf","allowWhere","allowAttributesOf","inheritTypesFrom","copyTypes","copyProperty","makeInheritAllWork","allowContentOfItemName","allowedChildren","getAllowedChildren","forEach","allowedItem","allowWhereItemName","inheritFrom","allowedIn","allowAttributeOfItem","inheritAttributes","inheritPropertiesOfItem","typeNames","filter","startsWith","existingItems","itemToCheck","Set","sourceItemRule","propertyName","inheritAllFrom","getValues","obj","key","ctxItem","getAttributeKeys","getAttribute","backward","forward","done","step","next","getMinimalFlatRanges","schema","removeAttribute"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/schema\n */\n\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\n\nimport Range from './range';\nimport Position from './position';\nimport Element from './element';\nimport Text from './text';\nimport TreeWalker from './treewalker';\n\n/**\n * The model's schema. It defines allowed and disallowed structures of nodes as well as nodes' attributes.\n * The schema is usually defined by features and based on them the editing framework and features\n * make decisions how to change and process the model.\n *\n * The instance of schema is available in {@link module:engine/model/model~Model#schema `editor.model.schema`}.\n *\n * Read more about the schema in:\n *\n * * {@glink framework/guides/architecture/editing-engine#schema \"Schema\"} section of the\n * {@glink framework/guides/architecture/editing-engine Introduction to the \"Editing engine architecture\"}.\n * * {@glink framework/guides/deep-dive/schema \"Schema\" deep dive} guide.\n *\n * @mixes module:utils/observablemixin~ObservableMixin\n */\nexport default class Schema {\n\t/**\n\t * Creates schema instance.\n\t */\n\tconstructor() {\n\t\tthis._sourceDefinitions = {};\n\n\t\t/**\n\t\t * A dictionary containing attribute properties.\n\t\t *\n\t\t * @private\n\t\t * @member {Object.<String,String>}\n\t\t */\n\t\tthis._attributeProperties = {};\n\n\t\tthis.decorate( 'checkChild' );\n\t\tthis.decorate( 'checkAttribute' );\n\n\t\tthis.on( 'checkAttribute', ( evt, args ) => {\n\t\t\targs[ 0 ] = new SchemaContext( args[ 0 ] );\n\t\t}, { priority: 'highest' } );\n\n\t\tthis.on( 'checkChild', ( evt, args ) => {\n\t\t\targs[ 0 ] = new SchemaContext( args[ 0 ] );\n\t\t\targs[ 1 ] = this.getDefinition( args[ 1 ] );\n\t\t}, { priority: 'highest' } );\n\t}\n\n\t/**\n\t * Registers schema item. Can only be called once for every item name.\n\t *\n\t *\t\tschema.register( 'paragraph', {\n\t *\t\t\tinheritAllFrom: '$block'\n\t *\t\t} );\n\t *\n\t * @param {String} itemName\n\t * @param {module:engine/model/schema~SchemaItemDefinition} definition\n\t */\n\tregister( itemName, definition ) {\n\t\tif ( this._sourceDefinitions[ itemName ] ) {\n\t\t\t/**\n\t\t\t * A single item cannot be registered twice in the schema.\n\t\t\t *\n\t\t\t * This situation may happen when:\n\t\t\t *\n\t\t\t * * Two or more plugins called {@link #register `register()`} with the same name. This will usually mean that\n\t\t\t * there is a collision between plugins which try to use the same element in the model. Unfortunately,\n\t\t\t * the only way to solve this is by modifying one of these plugins to use a unique model element name.\n\t\t\t * * A single plugin was loaded twice. This happens when it is installed by npm/yarn in two versions\n\t\t\t * and usually means one or more of the following issues:\n\t\t\t *     * a version mismatch (two of your dependencies require two different versions of this plugin),\n\t\t\t *     * incorrect imports (this plugin is somehow imported twice in a way which confuses webpack),\n\t\t\t *     * mess in `node_modules/` (`rm -rf node_modules/` may help).\n\t\t\t *\n\t\t\t * **Note:** Check the logged `itemName` to better understand which plugin was duplicated/conflicting.\n\t\t\t *\n\t\t\t * @param itemName The name of the model element that is being registered twice.\n\t\t\t * @error schema-cannot-register-item-twice\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'schema-cannot-register-item-twice: A single item cannot be registered twice in the schema.',\n\t\t\t\tthis,\n\t\t\t\t{\n\t\t\t\t\titemName\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\t\tthis._sourceDefinitions[ itemName ] = [\n\t\t\tObject.assign( {}, definition )\n\t\t];\n\n\t\tthis._clearCache();\n\t}\n\n\t/**\n\t * Extends a {@link #register registered} item's definition.\n\t *\n\t * Extending properties such as `allowIn` will add more items to the existing properties,\n\t * while redefining properties such as `isBlock` will override the previously defined ones.\n\t *\n\t *\t\tschema.register( 'foo', {\n\t *\t\t\tallowIn: '$root',\n\t *\t\t\tisBlock: true;\n\t *\t\t} );\n\t *\t\tschema.extend( 'foo', {\n\t *\t\t\tallowIn: 'blockQuote',\n\t *\t\t\tisBlock: false\n\t *\t\t} );\n\t *\n\t *\t\tschema.getDefinition( 'foo' );\n\t *\t\t//\t{\n\t *\t\t//\t\tallowIn: [ '$root', 'blockQuote' ],\n\t *\t\t// \t\tisBlock: false\n\t *\t\t//\t}\n\t *\n\t * @param {String} itemName\n\t * @param {module:engine/model/schema~SchemaItemDefinition} definition\n\t */\n\textend( itemName, definition ) {\n\t\tif ( !this._sourceDefinitions[ itemName ] ) {\n\t\t\t/**\n\t\t\t * Cannot extend an item which was not registered yet.\n\t\t\t *\n\t\t\t * This error happens when a plugin tries to extend the schema definition of an item which was not\n\t\t\t * {@link #register registered} yet.\n\t\t\t *\n\t\t\t * @param itemName The name of the model element which is being extended.\n\t\t\t * @error schema-cannot-extend-missing-item\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'schema-cannot-extend-missing-item: Cannot extend an item which was not registered yet.', this, {\n\t\t\t\titemName\n\t\t\t} );\n\t\t}\n\n\t\tthis._sourceDefinitions[ itemName ].push( Object.assign( {}, definition ) );\n\n\t\tthis._clearCache();\n\t}\n\n\t/**\n\t * Returns all registered items.\n\t *\n\t * @returns {Object.<String,module:engine/model/schema~SchemaCompiledItemDefinition>}\n\t */\n\tgetDefinitions() {\n\t\tif ( !this._compiledDefinitions ) {\n\t\t\tthis._compile();\n\t\t}\n\n\t\treturn this._compiledDefinitions;\n\t}\n\n\t/**\n\t * Returns a definition of the given item or `undefined` if item is not registered.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n\t * @returns {module:engine/model/schema~SchemaCompiledItemDefinition}\n\t */\n\tgetDefinition( item ) {\n\t\tlet itemName;\n\n\t\tif ( typeof item == 'string' ) {\n\t\t\titemName = item;\n\t\t} else if ( item.is && ( item.is( 'text' ) || item.is( 'textProxy' ) ) ) {\n\t\t\titemName = '$text';\n\t\t}\n\t\t// Element or module:engine/model/schema~SchemaContextItem.\n\t\telse {\n\t\t\titemName = item.name;\n\t\t}\n\n\t\treturn this.getDefinitions()[ itemName ];\n\t}\n\n\t/**\n\t * Returns `true` if the given item is registered in the schema.\n\t *\n\t *\t\tschema.isRegistered( 'paragraph' ); // -> true\n\t *\t\tschema.isRegistered( editor.model.document.getRoot() ); // -> true\n\t *\t\tschema.isRegistered( 'foo' ); // -> false\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n\t */\n\tisRegistered( item ) {\n\t\treturn !!this.getDefinition( item );\n\t}\n\n\t/**\n\t * Returns `true` if the given item is defined to be\n\t * a block by {@link module:engine/model/schema~SchemaItemDefinition}'s `isBlock` property.\n\t *\n\t *\t\tschema.isBlock( 'paragraph' ); // -> true\n\t *\t\tschema.isBlock( '$root' ); // -> false\n\t *\n\t *\t\tconst paragraphElement = writer.createElement( 'paragraph' );\n\t *\t\tschema.isBlock( paragraphElement ); // -> true\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n\t */\n\tisBlock( item ) {\n\t\tconst def = this.getDefinition( item );\n\n\t\treturn !!( def && def.isBlock );\n\t}\n\n\t/**\n\t * Returns `true` if the given item is defined to be\n\t * a limit element by {@link module:engine/model/schema~SchemaItemDefinition}'s `isLimit` or `isObject` property\n\t * (all objects are also limits).\n\t *\n\t *\t\tschema.isLimit( 'paragraph' ); // -> false\n\t *\t\tschema.isLimit( '$root' ); // -> true\n\t *\t\tschema.isLimit( editor.model.document.getRoot() ); // -> true\n\t *\t\tschema.isLimit( 'image' ); // -> true\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n\t */\n\tisLimit( item ) {\n\t\tconst def = this.getDefinition( item );\n\n\t\tif ( !def ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn !!( def.isLimit || def.isObject );\n\t}\n\n\t/**\n\t * Returns `true` if the given item is defined to be\n\t * an object element by {@link module:engine/model/schema~SchemaItemDefinition}'s `isObject` property.\n\t *\n\t *\t\tschema.isObject( 'paragraph' ); // -> false\n\t *\t\tschema.isObject( 'image' ); // -> true\n\t *\n\t *\t\tconst imageElement = writer.createElement( 'image' );\n\t *\t\tschema.isObject( imageElement ); // -> true\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n\t */\n\tisObject( item ) {\n\t\tconst def = this.getDefinition( item );\n\n\t\treturn !!( def && def.isObject );\n\t}\n\n\t/**\n\t * Returns `true` if the given item is defined to be\n\t * an inline element by {@link module:engine/model/schema~SchemaItemDefinition}'s `isInline` property.\n\t *\n\t *\t\tschema.isInline( 'paragraph' ); // -> false\n\t *\t\tschema.isInline( 'softBreak' ); // -> true\n\t *\n\t *\t\tconst text = writer.createText('foo' );\n\t *\t\tschema.isInline( text ); // -> true\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item\n\t */\n\tisInline( item ) {\n\t\tconst def = this.getDefinition( item );\n\n\t\treturn !!( def && def.isInline );\n\t}\n\n\t/**\n\t * Checks whether the given node (`child`) can be a child of the given context.\n\t *\n\t *\t\tschema.checkChild( model.document.getRoot(), paragraph ); // -> false\n\t *\n\t *\t\tschema.register( 'paragraph', {\n\t *\t\t\tallowIn: '$root'\n\t *\t\t} );\n\t *\t\tschema.checkChild( model.document.getRoot(), paragraph ); // -> true\n\t *\n\t * Note: When verifying whether the given node can be a child of the given context, the\n\t * schema also verifies the entire context &mdash; from its root to its last element. Therefore, it is possible\n\t * for `checkChild()` to return `false` even though the context's last element can contain the checked child.\n\t * It happens if one of the context's elements does not allow its child.\n\t *\n\t * @fires checkChild\n\t * @param {module:engine/model/schema~SchemaContextDefinition} context The context in which the child will be checked.\n\t * @param {module:engine/model/node~Node|String} def The child to check.\n\t */\n\tcheckChild( context, def ) {\n\t\t// Note: context and child are already normalized here to a SchemaContext and SchemaCompiledItemDefinition.\n\t\tif ( !def ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn this._checkContextMatch( def, context );\n\t}\n\n\t/**\n\t * Checks whether the given attribute can be applied in the given context (on the last\n\t * item of the context).\n\t *\n\t *\t\tschema.checkAttribute( textNode, 'bold' ); // -> false\n\t *\n\t *\t\tschema.extend( '$text', {\n\t *\t\t\tallowAttributes: 'bold'\n\t *\t\t} );\n\t *\t\tschema.checkAttribute( textNode, 'bold' ); // -> true\n\t *\n\t * @fires checkAttribute\n\t * @param {module:engine/model/schema~SchemaContextDefinition} context The context in which the attribute will be checked.\n\t * @param {String} attributeName\n\t */\n\tcheckAttribute( context, attributeName ) {\n\t\tconst def = this.getDefinition( context.last );\n\n\t\tif ( !def ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn def.allowAttributes.includes( attributeName );\n\t}\n\n\t/**\n\t * Checks whether the given element (`elementToMerge`) can be merged with the specified base element (`positionOrBaseElement`).\n\t *\n\t * In other words &mdash; whether `elementToMerge`'s children {@link #checkChild are allowed} in the `positionOrBaseElement`.\n\t *\n\t * This check ensures that elements merged with {@link module:engine/model/writer~Writer#merge `Writer#merge()`}\n\t * will be valid.\n\t *\n\t * Instead of elements, you can pass the instance of the {@link module:engine/model/position~Position} class as the\n\t * `positionOrBaseElement`. It means that the elements before and after the position will be checked whether they can be merged.\n\t *\n\t * @param {module:engine/model/position~Position|module:engine/model/element~Element} positionOrBaseElement The position or base\n\t * element to which the `elementToMerge` will be merged.\n\t * @param {module:engine/model/element~Element} elementToMerge The element to merge. Required if `positionOrBaseElement` is an element.\n\t * @returns {Boolean}\n\t */\n\tcheckMerge( positionOrBaseElement, elementToMerge = null ) {\n\t\tif ( positionOrBaseElement instanceof Position ) {\n\t\t\tconst nodeBefore = positionOrBaseElement.nodeBefore;\n\t\t\tconst nodeAfter = positionOrBaseElement.nodeAfter;\n\n\t\t\tif ( !( nodeBefore instanceof Element ) ) {\n\t\t\t\t/**\n\t\t\t\t * The node before the merge position must be an element.\n\t\t\t\t *\n\t\t\t\t * @error schema-check-merge-no-element-before\n\t\t\t\t */\n\t\t\t\tthrow new CKEditorError(\n\t\t\t\t\t'schema-check-merge-no-element-before: The node before the merge position must be an element.',\n\t\t\t\t\tthis\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif ( !( nodeAfter instanceof Element ) ) {\n\t\t\t\t/**\n\t\t\t\t * The node after the merge position must be an element.\n\t\t\t\t *\n\t\t\t\t * @error schema-check-merge-no-element-after\n\t\t\t\t */\n\t\t\t\tthrow new CKEditorError(\n\t\t\t\t\t'schema-check-merge-no-element-after: The node after the merge position must be an element.',\n\t\t\t\t\tthis\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn this.checkMerge( nodeBefore, nodeAfter );\n\t\t}\n\n\t\tfor ( const child of elementToMerge.getChildren() ) {\n\t\t\tif ( !this.checkChild( positionOrBaseElement, child ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Allows registering a callback to the {@link #checkChild} method calls.\n\t *\n\t * Callbacks allow you to implement rules which are not otherwise possible to achieve\n\t * by using the declarative API of {@link module:engine/model/schema~SchemaItemDefinition}.\n\t * For example, by using this method you can disallow elements in specific contexts.\n\t *\n\t * This method is a shorthand for using the {@link #event:checkChild} event. For even better control,\n\t * you can use that event instead.\n\t *\n\t * Example:\n\t *\n\t *\t\t// Disallow heading1 directly inside a blockQuote.\n\t *\t\tschema.addChildCheck( ( context, childDefinition ) => {\n\t *\t\t\tif ( context.endsWith( 'blockQuote' ) && childDefinition.name == 'heading1' ) {\n\t *\t\t\t\treturn false;\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * Which translates to:\n\t *\n\t *\t\tschema.on( 'checkChild', ( evt, args ) => {\n\t *\t\t\tconst context = args[ 0 ];\n\t *\t\t\tconst childDefinition = args[ 1 ];\n\t *\n\t *\t\t\tif ( context.endsWith( 'blockQuote' ) && childDefinition && childDefinition.name == 'heading1' ) {\n\t *\t\t\t\t// Prevent next listeners from being called.\n\t *\t\t\t\tevt.stop();\n\t *\t\t\t\t// Set the checkChild()'s return value.\n\t *\t\t\t\tevt.return = false;\n\t *\t\t\t}\n\t *\t\t}, { priority: 'high' } );\n\t *\n\t * @param {Function} callback The callback to be called. It is called with two parameters:\n\t * {@link module:engine/model/schema~SchemaContext} (context) instance and\n\t * {@link module:engine/model/schema~SchemaCompiledItemDefinition} (child-to-check definition).\n\t * The callback may return `true/false` to override `checkChild()`'s return value. If it does not return\n\t * a boolean value, the default algorithm (or other callbacks) will define `checkChild()`'s return value.\n\t */\n\taddChildCheck( callback ) {\n\t\tthis.on( 'checkChild', ( evt, [ ctx, childDef ] ) => {\n\t\t\t// checkChild() was called with a non-registered child.\n\t\t\t// In 99% cases such check should return false, so not to overcomplicate all callbacks\n\t\t\t// don't even execute them.\n\t\t\tif ( !childDef ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst retValue = callback( ctx, childDef );\n\n\t\t\tif ( typeof retValue == 'boolean' ) {\n\t\t\t\tevt.stop();\n\t\t\t\tevt.return = retValue;\n\t\t\t}\n\t\t}, { priority: 'high' } );\n\t}\n\n\t/**\n\t * Allows registering a callback to the {@link #checkAttribute} method calls.\n\t *\n\t * Callbacks allow you to implement rules which are not otherwise possible to achieve\n\t * by using the declarative API of {@link module:engine/model/schema~SchemaItemDefinition}.\n\t * For example, by using this method you can disallow attribute if node to which it is applied\n\t * is contained within some other element (e.g. you want to disallow `bold` on `$text` within `heading1`).\n\t *\n\t * This method is a shorthand for using the {@link #event:checkAttribute} event. For even better control,\n\t * you can use that event instead.\n\t *\n\t * Example:\n\t *\n\t *\t\t// Disallow bold on $text inside heading1.\n\t *\t\tschema.addAttributeCheck( ( context, attributeName ) => {\n\t *\t\t\tif ( context.endsWith( 'heading1 $text' ) && attributeName == 'bold' ) {\n\t *\t\t\t\treturn false;\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * Which translates to:\n\t *\n\t *\t\tschema.on( 'checkAttribute', ( evt, args ) => {\n\t *\t\t\tconst context = args[ 0 ];\n\t *\t\t\tconst attributeName = args[ 1 ];\n\t *\n\t *\t\t\tif ( context.endsWith( 'heading1 $text' ) && attributeName == 'bold' ) {\n\t *\t\t\t\t// Prevent next listeners from being called.\n\t *\t\t\t\tevt.stop();\n\t *\t\t\t\t// Set the checkAttribute()'s return value.\n\t *\t\t\t\tevt.return = false;\n\t *\t\t\t}\n\t *\t\t}, { priority: 'high' } );\n\t *\n\t * @param {Function} callback The callback to be called. It is called with two parameters:\n\t * {@link module:engine/model/schema~SchemaContext} (context) instance and attribute name.\n\t * The callback may return `true/false` to override `checkAttribute()`'s return value. If it does not return\n\t * a boolean value, the default algorithm (or other callbacks) will define `checkAttribute()`'s return value.\n\t */\n\taddAttributeCheck( callback ) {\n\t\tthis.on( 'checkAttribute', ( evt, [ ctx, attributeName ] ) => {\n\t\t\tconst retValue = callback( ctx, attributeName );\n\n\t\t\tif ( typeof retValue == 'boolean' ) {\n\t\t\t\tevt.stop();\n\t\t\t\tevt.return = retValue;\n\t\t\t}\n\t\t}, { priority: 'high' } );\n\t}\n\n\t/**\n\t * This method allows assigning additional metadata to the model attributes. For example,\n\t * {@link module:engine/model/schema~AttributeProperties `AttributeProperties#isFormatting` property} is\n\t * used to mark formatting attributes (like `bold` or `italic`).\n\t *\n\t *\t\t// Mark bold as a formatting attribute.\n\t *\t\tschema.setAttributeProperties( 'bold', {\n\t *\t\t\tisFormatting: true\n\t *\t\t} );\n\t *\n\t *\t\t// Override code not to be considered a formatting markup.\n\t *\t\tschema.setAttributeProperties( 'code', {\n\t *\t\t\tisFormatting: false\n\t *\t\t} );\n\t *\n\t * Properties are not limited to members defined in the\n\t * {@link module:engine/model/schema~AttributeProperties `AttributeProperties` type} and you can also use custom properties:\n\t *\n\t *\t\tschema.setAttributeProperties( 'blockQuote', {\n\t *\t\t\tcustomProperty: 'value'\n\t *\t\t} );\n\t *\n\t * Subsequent calls with the same attribute will extend its custom properties:\n\t *\n\t *\t\tschema.setAttributeProperties( 'blockQuote', {\n\t *\t\t\tone: 1\n\t *\t\t} );\n\t *\n\t *\t\tschema.setAttributeProperties( 'blockQuote', {\n\t *\t\t\ttwo: 2\n\t *\t\t} );\n\t *\n\t *\t\tconsole.log( schema.getAttributeProperties( 'blockQuote' ) );\n\t *\t\t// Logs: { one: 1, two: 2 }\n\t *\n\t * @param {String} attributeName A name of the attribute to receive the properties.\n\t * @param {module:engine/model/schema~AttributeProperties} properties A dictionary of properties.\n\t */\n\tsetAttributeProperties( attributeName, properties ) {\n\t\tthis._attributeProperties[ attributeName ] = Object.assign( this.getAttributeProperties( attributeName ), properties );\n\t}\n\n\t/**\n\t * Returns properties associated with a given model attribute. See {@link #setAttributeProperties `setAttributeProperties()`}.\n\t *\n\t * @param {String} attributeName A name of the attribute.\n\t * @returns {module:engine/model/schema~AttributeProperties}\n\t */\n\tgetAttributeProperties( attributeName ) {\n\t\treturn this._attributeProperties[ attributeName ] || {};\n\t}\n\n\t/**\n\t * Returns the lowest {@link module:engine/model/schema~Schema#isLimit limit element} containing the entire\n\t * selection/range/position or the root otherwise.\n\t *\n\t * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection|\n\t * module:engine/model/range~Range|module:engine/model/position~Position} selectionOrRangeOrPosition\n\t * The selection/range/position to check.\n\t * @returns {module:engine/model/element~Element} The lowest limit element containing\n\t * the entire `selectionOrRangeOrPosition`.\n\t */\n\tgetLimitElement( selectionOrRangeOrPosition ) {\n\t\tlet element;\n\n\t\tif ( selectionOrRangeOrPosition instanceof Position ) {\n\t\t\telement = selectionOrRangeOrPosition.parent;\n\t\t} else {\n\t\t\tconst ranges = selectionOrRangeOrPosition instanceof Range ?\n\t\t\t\t[ selectionOrRangeOrPosition ] :\n\t\t\t\tArray.from( selectionOrRangeOrPosition.getRanges() );\n\n\t\t\t// Find the common ancestor for all selection's ranges.\n\t\t\telement = ranges\n\t\t\t\t.reduce( ( element, range ) => {\n\t\t\t\t\tconst rangeCommonAncestor = range.getCommonAncestor();\n\n\t\t\t\t\tif ( !element ) {\n\t\t\t\t\t\treturn rangeCommonAncestor;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn element.getCommonAncestor( rangeCommonAncestor, { includeSelf: true } );\n\t\t\t\t}, null );\n\t\t}\n\n\t\twhile ( !this.isLimit( element ) ) {\n\t\t\tif ( element.parent ) {\n\t\t\t\telement = element.parent;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn element;\n\t}\n\n\t/**\n\t * Checks whether the attribute is allowed in selection:\n\t *\n\t * * if the selection is not collapsed, then checks if the attribute is allowed on any of nodes in that range,\n\t * * if the selection is collapsed, then checks if on the selection position there's a text with the\n\t * specified attribute allowed.\n\t *\n\t * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n\t * Selection which will be checked.\n\t * @param {String} attribute The name of the attribute to check.\n\t * @returns {Boolean}\n\t */\n\tcheckAttributeInSelection( selection, attribute ) {\n\t\tif ( selection.isCollapsed ) {\n\t\t\tconst firstPosition = selection.getFirstPosition();\n\t\t\tconst context = [\n\t\t\t\t...firstPosition.getAncestors(),\n\t\t\t\tnew Text( '', selection.getAttributes() )\n\t\t\t];\n\n\t\t\t// Check whether schema allows for a text with the attribute in the selection.\n\t\t\treturn this.checkAttribute( context, attribute );\n\t\t} else {\n\t\t\tconst ranges = selection.getRanges();\n\n\t\t\t// For all ranges, check nodes in them until you find a node that is allowed to have the attribute.\n\t\t\tfor ( const range of ranges ) {\n\t\t\t\tfor ( const value of range ) {\n\t\t\t\t\tif ( this.checkAttribute( value.item, attribute ) ) {\n\t\t\t\t\t\t// If we found a node that is allowed to have the attribute, return true.\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If we haven't found such node, return false.\n\t\treturn false;\n\t}\n\n\t/**\n\t * Transforms the given set of ranges into a set of ranges where the given attribute is allowed (and can be applied).\n\t *\n\t * @param {Array.<module:engine/model/range~Range>} ranges Ranges to be validated.\n\t * @param {String} attribute The name of the attribute to check.\n\t * @returns {Iterable.<module:engine/model/range~Range>} Ranges in which the attribute is allowed.\n\t */\n\t* getValidRanges( ranges, attribute ) {\n\t\tranges = convertToMinimalFlatRanges( ranges );\n\n\t\tfor ( const range of ranges ) {\n\t\t\tyield* this._getValidRangesForRange( range, attribute );\n\t\t}\n\t}\n\n\t/**\n\t * Basing on given `position`, finds and returns a {@link module:engine/model/range~Range range} which is\n\t * nearest to that `position` and is a correct range for selection.\n\t *\n\t * The correct selection range might be collapsed when it is located in a position where the text node can be placed.\n\t * Non-collapsed range is returned when selection can be placed around element marked as an \"object\" in\n\t * the {@link module:engine/model/schema~Schema schema}.\n\t *\n\t * Direction of searching for the nearest correct selection range can be specified as:\n\t *\n\t * * `both` - searching will be performed in both ways,\n\t * * `forward` - searching will be performed only forward,\n\t * * `backward` - searching will be performed only backward.\n\t *\n\t * When valid selection range cannot be found, `null` is returned.\n\t *\n\t * @param {module:engine/model/position~Position} position Reference position where new selection range should be looked for.\n\t * @param {'both'|'forward'|'backward'} [direction='both'] Search direction.\n\t * @returns {module:engine/model/range~Range|null} Nearest selection range or `null` if one cannot be found.\n\t */\n\tgetNearestSelectionRange( position, direction = 'both' ) {\n\t\t// Return collapsed range if provided position is valid.\n\t\tif ( this.checkChild( position, '$text' ) ) {\n\t\t\treturn new Range( position );\n\t\t}\n\n\t\tlet backwardWalker, forwardWalker;\n\n\t\tif ( direction == 'both' || direction == 'backward' ) {\n\t\t\tbackwardWalker = new TreeWalker( { startPosition: position, direction: 'backward' } );\n\t\t}\n\n\t\tif ( direction == 'both' || direction == 'forward' ) {\n\t\t\tforwardWalker = new TreeWalker( { startPosition: position } );\n\t\t}\n\n\t\tfor ( const data of combineWalkers( backwardWalker, forwardWalker ) ) {\n\t\t\tconst type = ( data.walker == backwardWalker ? 'elementEnd' : 'elementStart' );\n\t\t\tconst value = data.value;\n\n\t\t\tif ( value.type == type && this.isObject( value.item ) ) {\n\t\t\t\treturn Range._createOn( value.item );\n\t\t\t}\n\n\t\t\tif ( this.checkChild( value.nextPosition, '$text' ) ) {\n\t\t\t\treturn new Range( value.nextPosition );\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Tries to find position ancestors that allows to insert given node.\n\t * It starts searching from the given position and goes node by node to the top of the model tree\n\t * as long as {@link module:engine/model/schema~Schema#isLimit limit element},\n\t * {@link module:engine/model/schema~Schema#isObject object element} or top-most ancestor won't be reached.\n\t *\n\t * @params {module:engine/model/position~Position} position Position from searching will start.\n\t * @params {module:engine/model/node~Node|String} node Node for which allowed parent should be found or its name.\n\t * @returns {module:engine/model/element~Element|null} element Allowed parent or null if nothing was found.\n\t */\n\tfindAllowedParent( position, node ) {\n\t\tlet parent = position.parent;\n\n\t\twhile ( parent ) {\n\t\t\tif ( this.checkChild( parent, node ) ) {\n\t\t\t\treturn parent;\n\t\t\t}\n\n\t\t\t// Do not split limit elements.\n\t\t\tif ( this.isLimit( parent ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tparent = parent.parent;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Removes attributes disallowed by the schema.\n\t *\n\t * @param {Iterable.<module:engine/model/node~Node>} nodes Nodes that will be filtered.\n\t * @param {module:engine/model/writer~Writer} writer\n\t */\n\tremoveDisallowedAttributes( nodes, writer ) {\n\t\tfor ( const node of nodes ) {\n\t\t\t// When node is a `Text` it has no children, so just filter it out.\n\t\t\tif ( node.is( 'text' ) ) {\n\t\t\t\tremoveDisallowedAttributeFromNode( this, node, writer );\n\t\t\t}\n\t\t\t// In a case of `Element` iterates through positions between nodes inside this element\n\t\t\t// and filter out node before the current position, or position parent when position\n\t\t\t// is at start of an element. Using positions prevent from omitting merged nodes\n\t\t\t// see https://github.com/ckeditor/ckeditor5-engine/issues/1789.\n\t\t\telse {\n\t\t\t\tconst rangeInNode = Range._createIn( node );\n\t\t\t\tconst positionsInRange = rangeInNode.getPositions();\n\n\t\t\t\tfor ( const position of positionsInRange ) {\n\t\t\t\t\tconst item = position.nodeBefore || position.parent;\n\n\t\t\t\t\tremoveDisallowedAttributeFromNode( this, item, writer );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Creates an instance of the schema context.\n\t *\n\t * @param {module:engine/model/schema~SchemaContextDefinition} context\n\t * @returns {module:engine/model/schema~SchemaContext}\n\t */\n\tcreateContext( context ) {\n\t\treturn new SchemaContext( context );\n\t}\n\n\t/**\n\t * @private\n\t */\n\t_clearCache() {\n\t\tthis._compiledDefinitions = null;\n\t}\n\n\t/**\n\t * @private\n\t */\n\t_compile() {\n\t\tconst compiledDefinitions = {};\n\t\tconst sourceRules = this._sourceDefinitions;\n\t\tconst itemNames = Object.keys( sourceRules );\n\n\t\tfor ( const itemName of itemNames ) {\n\t\t\tcompiledDefinitions[ itemName ] = compileBaseItemRule( sourceRules[ itemName ], itemName );\n\t\t}\n\n\t\tfor ( const itemName of itemNames ) {\n\t\t\tcompileAllowContentOf( compiledDefinitions, itemName );\n\t\t}\n\n\t\tfor ( const itemName of itemNames ) {\n\t\t\tcompileAllowWhere( compiledDefinitions, itemName );\n\t\t}\n\n\t\tfor ( const itemName of itemNames ) {\n\t\t\tcompileAllowAttributesOf( compiledDefinitions, itemName );\n\t\t\tcompileInheritPropertiesFrom( compiledDefinitions, itemName );\n\t\t}\n\n\t\tfor ( const itemName of itemNames ) {\n\t\t\tcleanUpAllowIn( compiledDefinitions, itemName );\n\t\t\tcleanUpAllowAttributes( compiledDefinitions, itemName );\n\t\t}\n\n\t\tthis._compiledDefinitions = compiledDefinitions;\n\t}\n\n\t/**\n\t * @private\n\t * @param {module:engine/model/schema~SchemaCompiledItemDefinition} def\n\t * @param {module:engine/model/schema~SchemaContext} context\n\t * @param {Number} contextItemIndex\n\t */\n\t_checkContextMatch( def, context, contextItemIndex = context.length - 1 ) {\n\t\tconst contextItem = context.getItem( contextItemIndex );\n\n\t\tif ( def.allowIn.includes( contextItem.name ) ) {\n\t\t\tif ( contextItemIndex == 0 ) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tconst parentRule = this.getDefinition( contextItem );\n\n\t\t\t\treturn this._checkContextMatch( parentRule, context, contextItemIndex - 1 );\n\t\t\t}\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Takes a flat range and an attribute name. Traverses the range recursively and deeply to find and return all ranges\n\t * inside the given range on which the attribute can be applied.\n\t *\n\t * This is a helper function for {@link ~Schema#getValidRanges}.\n\t *\n\t * @private\n\t * @param {module:engine/model/range~Range} range Range to process.\n\t * @param {String} attribute The name of the attribute to check.\n\t * @returns {Iterable.<module:engine/model/range~Range>} Ranges in which the attribute is allowed.\n\t */\n\t* _getValidRangesForRange( range, attribute ) {\n\t\tlet start = range.start;\n\t\tlet end = range.start;\n\n\t\tfor ( const item of range.getItems( { shallow: true } ) ) {\n\t\t\tif ( item.is( 'element' ) ) {\n\t\t\t\tyield* this._getValidRangesForRange( Range._createIn( item ), attribute );\n\t\t\t}\n\n\t\t\tif ( !this.checkAttribute( item, attribute ) ) {\n\t\t\t\tif ( !start.isEqual( end ) ) {\n\t\t\t\t\tyield new Range( start, end );\n\t\t\t\t}\n\n\t\t\t\tstart = Position._createAfter( item );\n\t\t\t}\n\n\t\t\tend = Position._createAfter( item );\n\t\t}\n\n\t\tif ( !start.isEqual( end ) ) {\n\t\t\tyield new Range( start, end );\n\t\t}\n\t}\n}\n\nmix( Schema, ObservableMixin );\n\n/**\n * Event fired when the {@link #checkChild} method is called. It allows plugging in\n * additional behavior  e.g. implementing rules which cannot be defined using the declarative\n * {@link module:engine/model/schema~SchemaItemDefinition} interface.\n *\n * **Note:** The {@link #addChildCheck} method is a more handy way to register callbacks. Internally,\n * it registers a listener to this event but comes with a simpler API and it is the recommended choice\n * in most of the cases.\n *\n * The {@link #checkChild} method fires an event because it is\n * {@link module:utils/observablemixin~ObservableMixin#decorate decorated} with it. Thanks to that you can\n * use this event in a various way, but the most important use case is overriding standard behaviour of the\n * `checkChild()` method. Let's see a typical listener template:\n *\n *\t\tschema.on( 'checkChild', ( evt, args ) => {\n *\t\t\tconst context = args[ 0 ];\n *\t\t\tconst childDefinition = args[ 1 ];\n *\t\t}, { priority: 'high' } );\n *\n * The listener is added with a `high` priority to be executed before the default method is really called. The `args` callback\n * parameter contains arguments passed to `checkChild( context, child )`. However, the `context` parameter is already\n * normalized to a {@link module:engine/model/schema~SchemaContext} instance and `child` to a\n * {@link module:engine/model/schema~SchemaCompiledItemDefinition} instance, so you don't have to worry about\n * the various ways how `context` and `child` may be passed to `checkChild()`.\n *\n * **Note:** `childDefinition` may be `undefined` if `checkChild()` was called with a non-registered element.\n *\n * So, in order to implement a rule \"disallow `heading1` in `blockQuote`\" you can add such a listener:\n *\n *\t\tschema.on( 'checkChild', ( evt, args ) => {\n *\t\t\tconst context = args[ 0 ];\n *\t\t\tconst childDefinition = args[ 1 ];\n *\n *\t\t\tif ( context.endsWith( 'blockQuote' ) && childDefinition && childDefinition.name == 'heading1' ) {\n *\t\t\t\t// Prevent next listeners from being called.\n *\t\t\t\tevt.stop();\n *\t\t\t\t// Set the checkChild()'s return value.\n *\t\t\t\tevt.return = false;\n *\t\t\t}\n *\t\t}, { priority: 'high' } );\n *\n * Allowing elements in specific contexts will be a far less common use case, because it's normally handled by\n * `allowIn` rule from {@link module:engine/model/schema~SchemaItemDefinition} but if you have a complex scenario\n * where `listItem` should be allowed only in element `foo` which must be in element `bar`, then this would be the way:\n *\n *\t\tschema.on( 'checkChild', ( evt, args ) => {\n *\t\t\tconst context = args[ 0 ];\n *\t\t\tconst childDefinition = args[ 1 ];\n *\n *\t\t\tif ( context.endsWith( 'bar foo' ) && childDefinition.name == 'listItem' ) {\n *\t\t\t\t// Prevent next listeners from being called.\n *\t\t\t\tevt.stop();\n *\t\t\t\t// Set the checkChild()'s return value.\n *\t\t\t\tevt.return = true;\n *\t\t\t}\n *\t\t}, { priority: 'high' } );\n *\n * @event checkChild\n * @param {Array} args The `checkChild()`'s arguments.\n */\n\n/**\n * Event fired when the {@link #checkAttribute} method is called. It allows plugging in\n * additional behavior  e.g. implementing rules which cannot be defined using the declarative\n * {@link module:engine/model/schema~SchemaItemDefinition} interface.\n *\n * **Note:** The {@link #addAttributeCheck} method is a more handy way to register callbacks. Internally,\n * it registers a listener to this event but comes with a simpler API and it is the recommended choice\n * in most of the cases.\n *\n * The {@link #checkAttribute} method fires an event because it's\n * {@link module:utils/observablemixin~ObservableMixin#decorate decorated} with it. Thanks to that you can\n * use this event in a various way, but the most important use case is overriding standard behaviour of the\n * `checkAttribute()` method. Let's see a typical listener template:\n *\n *\t\tschema.on( 'checkAttribute', ( evt, args ) => {\n *\t\t\tconst context = args[ 0 ];\n *\t\t\tconst attributeName = args[ 1 ];\n *\t\t}, { priority: 'high' } );\n *\n * The listener is added with a `high` priority to be executed before the default method is really called. The `args` callback\n * parameter contains arguments passed to `checkAttribute( context, attributeName )`. However, the `context` parameter is already\n * normalized to a {@link module:engine/model/schema~SchemaContext} instance, so you don't have to worry about\n * the various ways how `context` may be passed to `checkAttribute()`.\n *\n * So, in order to implement a rule \"disallow `bold` in a text which is in a `heading1` you can add such a listener:\n *\n *\t\tschema.on( 'checkAttribute', ( evt, args ) => {\n *\t\t\tconst context = args[ 0 ];\n *\t\t\tconst atributeName = args[ 1 ];\n *\n *\t\t\tif ( context.endsWith( 'heading1 $text' ) && attributeName == 'bold' ) {\n *\t\t\t\t// Prevent next listeners from being called.\n *\t\t\t\tevt.stop();\n *\t\t\t\t// Set the checkAttribute()'s return value.\n *\t\t\t\tevt.return = false;\n *\t\t\t}\n *\t\t}, { priority: 'high' } );\n *\n * Allowing attributes in specific contexts will be a far less common use case, because it's normally handled by\n * `allowAttributes` rule from {@link module:engine/model/schema~SchemaItemDefinition} but if you have a complex scenario\n * where `bold` should be allowed only in element `foo` which must be in element `bar`, then this would be the way:\n *\n *\t\tschema.on( 'checkAttribute', ( evt, args ) => {\n *\t\t\tconst context = args[ 0 ];\n *\t\t\tconst atributeName = args[ 1 ];\n *\n *\t\t\tif ( context.endsWith( 'bar foo $text' ) && attributeName == 'bold' ) {\n *\t\t\t\t// Prevent next listeners from being called.\n *\t\t\t\tevt.stop();\n *\t\t\t\t// Set the checkAttribute()'s return value.\n *\t\t\t\tevt.return = true;\n *\t\t\t}\n *\t\t}, { priority: 'high' } );\n *\n * @event checkAttribute\n * @param {Array} args The `checkAttribute()`'s arguments.\n */\n\n/**\n * A definition of a {@link module:engine/model/schema~Schema schema} item.\n *\n * You can define the following rules:\n *\n * * `allowIn` &ndash; A string or an array of strings. Defines in which other items this item will be allowed.\n * * `allowAttributes` &ndash; A string or an array of strings. Defines allowed attributes of the given item.\n * * `allowContentOf` &ndash; A string or an array of strings. Inherits \"allowed children\" from other items.\n * * `allowWhere` &ndash; A string or an array of strings. Inherits \"allowed in\" from other items.\n * * `allowAttributesOf` &ndash; A string or an array of strings. Inherits attributes from other items.\n * * `inheritTypesFrom` &ndash; A string or an array of strings. Inherits `is*` properties of other items.\n * * `inheritAllFrom` &ndash; A string. A shorthand for `allowContentOf`, `allowWhere`, `allowAttributesOf`, `inheritTypesFrom`.\n * * Additionally, you can define the following `is*` properties: `isBlock`, `isLimit`, `isObject`, `isInline`. Read about them below.\n *\n * # The is* properties\n *\n * There are 3 commonly used `is*` properties. Their role is to assign additional semantics to schema items.\n * You can define more properties but you will also need to implement support for them in the existing editor features.\n *\n * * `isBlock` &ndash; Whether this item is paragraph-like. Generally speaking, content is usually made out of blocks\n * like paragraphs, list items, images, headings, etc. All these elements are marked as blocks. A block\n * should not allow another block inside. Note: There is also the `$block` generic item which has `isBlock` set to `true`.\n * Most block type items will inherit from `$block` (through `inheritAllFrom`).\n * * `isLimit` &ndash; It can be understood as whether this element should not be split by <kbd>Enter</kbd>.\n * Examples of limit elements: `$root`, table cell, image caption, etc. In other words, all actions that happen inside\n * a limit element are limited to its content. **Note:** All objects (`isObject`) are treated as limit elements, too.\n * * `isObject` &ndash; Whether an item is \"self-contained\" and should be treated as a whole. Examples of object elements:\n * `image`, `table`, `video`, etc. **Note:** An object is also a limit, so\n * {@link module:engine/model/schema~Schema#isLimit `isLimit()`} returns `true` for object elements automatically.\n * * `isInline` &ndash; Whether an item is \"text-like\" and should be treated as an inline node. Examples of inline elements:\n * `$text`, `softBreak` (`<br>`), etc.\n *\n * # Generic items\n *\n * There are three basic generic items: `$root`, `$block` and `$text`.\n * They are defined as follows:\n *\n *\t\tthis.schema.register( '$root', {\n *\t\t\tisLimit: true\n *\t\t} );\n *\t\tthis.schema.register( '$block', {\n *\t\t\tallowIn: '$root',\n *\t\t\tisBlock: true\n *\t\t} );\n *\t\tthis.schema.register( '$text', {\n *\t\t\tallowIn: '$block',\n *\t\t\tisInline: true\n *\t\t} );\n *\n * They reflect typical editor content that is contained within one root, consists of several blocks\n * (paragraphs, lists items, headings, images) which, in turn, may contain text inside.\n *\n * By inheriting from the generic items you can define new items which will get extended by other editor features.\n * Read more about generic types in the {@glink framework/guides/deep-dive/schema Defining schema} guide.\n *\n * # Example definitions\n *\n * Allow `paragraph` in roots and block quotes:\n *\n *\t\tschema.register( 'paragraph', {\n *\t\t\tallowIn: [ '$root', 'blockQuote' ],\n *\t\t\tisBlock: true\n *\t\t} );\n *\n * Allow `paragraph` everywhere where `$block` is allowed (i.e. in `$root`):\n *\n *\t\tschema.register( 'paragraph', {\n *\t\t\tallowWhere: '$block',\n *\t\t\tisBlock: true\n *\t\t} );\n *\n * Make `image` a block object, which is allowed everywhere where `$block` is.\n * Also, allow `src` and `alt` attributes in it:\n *\n *\t\tschema.register( 'image', {\n *\t\t\tallowWhere: '$block',\n *\t\t\tallowAttributes: [ 'src', 'alt' ],\n *\t\t\tisBlock: true,\n *\t\t\tisObject: true\n *\t\t} );\n *\n * Make `caption` allowed in `image` and make it allow all the content of `$block`s (usually, `$text`).\n * Also, mark it as a limit element so it cannot be split:\n *\n *\t\tschema.register( 'caption', {\n *\t\t\tallowIn: 'image',\n *\t\t\tallowContentOf: '$block',\n *\t\t\tisLimit: true\n *\t\t} );\n *\n * Make `listItem` inherit all from `$block` but also allow additional attributes:\n *\n *\t\tschema.register( 'listItem', {\n *\t\t\tinheritAllFrom: '$block',\n *\t\t\tallowAttributes: [ 'listType', 'listIndent' ]\n *\t\t} );\n *\n * Which translates to:\n *\n *\t\tschema.register( 'listItem', {\n *\t\t\tallowWhere: '$block',\n *\t\t\tallowContentOf: '$block',\n *\t\t\tallowAttributesOf: '$block',\n *\t\t\tinheritTypesFrom: '$block',\n *\t\t\tallowAttributes: [ 'listType', 'listIndent' ]\n *\t\t} );\n *\n * # Tips\n *\n * * Check schema definitions of existing features to see how they are defined.\n * * If you want to publish your feature so other developers can use it, try to use\n * generic items as much as possible.\n * * Keep your model clean. Limit it to the actual data and store information in a normalized way.\n * * Remember about definining the `is*` properties. They do not affect the allowed structures, but they can\n * affect how the editor features treat your elements.\n *\n * @typedef {Object} module:engine/model/schema~SchemaItemDefinition\n */\n\n/**\n * A simplified version of {@link module:engine/model/schema~SchemaItemDefinition} after\n * compilation by the {@link module:engine/model/schema~Schema schema}.\n * Rules fed to the schema by {@link module:engine/model/schema~Schema#register}\n * and {@link module:engine/model/schema~Schema#extend} methods are defined in the\n * {@link module:engine/model/schema~SchemaItemDefinition} format.\n * Later on, they are compiled to `SchemaCompiledItemDefition` so when you use e.g.\n * the {@link module:engine/model/schema~Schema#getDefinition} method you get the compiled version.\n *\n * The compiled version contains only the following properties:\n *\n * * The `name` property,\n * * The `is*` properties,\n * * The `allowIn` array,\n * * The `allowAttributes` array.\n *\n * @typedef {Object} module:engine/model/schema~SchemaCompiledItemDefinition\n */\n\n/**\n * A schema context &mdash; a list of ancestors of a given position in the document.\n *\n * Considering such position:\n *\n *\t\t<$root>\n *\t\t\t<blockQuote>\n *\t\t\t\t<paragraph>\n *\t\t\t\t\t^\n *\t\t\t\t</paragraph>\n *\t\t\t</blockQuote>\n *\t\t</$root>\n *\n * The context of this position is its {@link module:engine/model/position~Position#getAncestors lists of ancestors}:\n *\n *\t\t[ rootElement, blockQuoteElement, paragraphElement ]\n *\n * Contexts are used in the {@link module:engine/model/schema~Schema#event:checkChild `Schema#checkChild`} and\n * {@link module:engine/model/schema~Schema#event:checkAttribute `Schema#checkAttribute`} events as a definition\n * of a place in the document where the check occurs. The context instances are created based on the first arguments\n * of the {@link module:engine/model/schema~Schema#checkChild `Schema#checkChild()`} and\n * {@link module:engine/model/schema~Schema#checkAttribute `Schema#checkAttribute()`} methods so when\n * using these methods you need to use {@link module:engine/model/schema~SchemaContextDefinition}s.\n */\nexport class SchemaContext {\n\t/**\n\t * Creates an instance of the context.\n\t *\n\t * @param {module:engine/model/schema~SchemaContextDefinition} context\n\t */\n\tconstructor( context ) {\n\t\tif ( context instanceof SchemaContext ) {\n\t\t\treturn context;\n\t\t}\n\n\t\tif ( typeof context == 'string' ) {\n\t\t\tcontext = [ context ];\n\t\t} else if ( !Array.isArray( context ) ) {\n\t\t\t// `context` is item or position.\n\t\t\t// Position#getAncestors() doesn't accept any parameters but it works just fine here.\n\t\t\tcontext = context.getAncestors( { includeSelf: true } );\n\t\t}\n\n\t\tif ( context[ 0 ] && typeof context[ 0 ] != 'string' && context[ 0 ].is( 'documentFragment' ) ) {\n\t\t\tcontext.shift();\n\t\t}\n\n\t\tthis._items = context.map( mapContextItem );\n\t}\n\n\t/**\n\t * The number of items.\n\t *\n\t * @type {Number}\n\t */\n\tget length() {\n\t\treturn this._items.length;\n\t}\n\n\t/**\n\t * The last item (the lowest node).\n\t *\n\t * @type {module:engine/model/schema~SchemaContextItem}\n\t */\n\tget last() {\n\t\treturn this._items[ this._items.length - 1 ];\n\t}\n\n\t/**\n\t * Iterable interface.\n\t *\n\t * Iterates over all context items.\n\t *\n\t * @returns {Iterable.<module:engine/model/schema~SchemaContextItem>}\n\t */\n\t[ Symbol.iterator ]() {\n\t\treturn this._items[ Symbol.iterator ]();\n\t}\n\n\t/**\n\t * Returns a new schema context instance with an additional item.\n\t *\n\t * Item can be added as:\n\t *\n\t * \t\tconst context = new SchemaContext( [ '$root' ] );\n\t *\n\t * \t\t// An element.\n\t * \t\tconst fooElement = writer.createElement( 'fooElement' );\n\t * \t\tconst newContext = context.push( fooElement ); // [ '$root', 'fooElement' ]\n\t *\n\t * \t\t// A text node.\n\t * \t\tconst text = writer.createText( 'foobar' );\n\t * \t\tconst newContext = context.push( text ); // [ '$root', '$text' ]\n\t *\n\t * \t\t// A string (element name).\n\t * \t\tconst newContext = context.push( 'barElement' ); // [ '$root', 'barElement' ]\n\t *\n\t * **Note** {@link module:engine/model/node~Node} that is already in the model tree will be added as the only item\n\t * (without ancestors).\n\t *\n\t * @param {String|module:engine/model/node~Node|Array<String|module:engine/model/node~Node>} item An item that will be added\n\t * to the current context.\n\t * @returns {module:engine/model/schema~SchemaContext} A new schema context instance with an additional item.\n\t */\n\tpush( item ) {\n\t\tconst ctx = new SchemaContext( [ item ] );\n\n\t\tctx._items = [ ...this._items, ...ctx._items ];\n\n\t\treturn ctx;\n\t}\n\n\t/**\n\t * Gets an item on the given index.\n\t *\n\t * @returns {module:engine/model/schema~SchemaContextItem}\n\t */\n\tgetItem( index ) {\n\t\treturn this._items[ index ];\n\t}\n\n\t/**\n\t * Returns the names of items.\n\t *\n\t * @returns {Iterable.<String>}\n\t */\n\t* getNames() {\n\t\tyield* this._items.map( item => item.name );\n\t}\n\n\t/**\n\t * Checks whether the context ends with the given nodes.\n\t *\n\t *\t\tconst ctx = new SchemaContext( [ rootElement, paragraphElement, textNode ] );\n\t *\n\t *\t\tctx.endsWith( '$text' ); // -> true\n\t *\t\tctx.endsWith( 'paragraph $text' ); // -> true\n\t *\t\tctx.endsWith( '$root' ); // -> false\n\t *\t\tctx.endsWith( 'paragraph' ); // -> false\n\t *\n\t * @param {String} query\n\t * @returns {Boolean}\n\t */\n\tendsWith( query ) {\n\t\treturn Array.from( this.getNames() ).join( ' ' ).endsWith( query );\n\t}\n}\n\n/**\n * The definition of a {@link module:engine/model/schema~SchemaContext schema context}.\n *\n * Contexts can be created in multiple ways:\n *\n * * By defining a **node**  in this cases this node and all its ancestors will be used.\n * * By defining a **position** in the document  in this case all its ancestors will be used.\n * * By defining an **array of nodes**  in this case this array defines the entire context.\n * * By defining a **name of node** - in this case node will be \"mocked\". It is not recommended because context\n * will be unrealistic (e.g. attributes of these nodes are not specified). However, at times this may be the only\n * way to define the context (e.g. when checking some hypothetical situation).\n * * By defining an **array of node names** (potentially, mixed with real nodes)  The same as **name of node**\n * but it is possible to create a path.\n * * By defining a {@link module:engine/model/schema~SchemaContext} instance - in this case the same instance as provided\n * will be return.\n *\n * Examples of context definitions passed to the {@link module:engine/model/schema~Schema#checkChild `Schema#checkChild()`}\n * method:\n *\n *\t\t// Assuming that we have a $root > blockQuote > paragraph structure, the following code\n *\t\t// will check node 'foo' in the following context:\n *\t\t// [ rootElement, blockQuoteElement, paragraphElement ]\n *\t\tconst contextDefinition = paragraphElement;\n * \t\tconst childToCheck = 'foo';\n *\t\tschema.checkChild( contextDefinition, childToCheck );\n *\n *\t\t// Also check in [ rootElement, blockQuoteElement, paragraphElement ].\n *\t\tschema.checkChild( model.createPositionAt( paragraphElement, 0 ), 'foo' );\n *\n *\t\t// Check in [ rootElement, paragraphElement ].\n *\t\tschema.checkChild( [ rootElement, paragraphElement ], 'foo' );\n *\n *\t\t// Check only fakeParagraphElement.\n *\t\tschema.checkChild( 'paragraph', 'foo' );\n *\n *\t\t// Check in [ fakeRootElement, fakeBarElement, paragraphElement ].\n *\t\tschema.checkChild( [ '$root', 'bar', paragraphElement ], 'foo' );\n *\n * All these `checkChild()` calls will fire {@link module:engine/model/schema~Schema#event:checkChild `Schema#checkChild`}\n * events in which `args[ 0 ]` is an instance of the context. Therefore, you can write a listener like this:\n *\n *\t\tschema.on( 'checkChild', ( evt, args ) => {\n *\t\t\tconst ctx = args[ 0 ];\n *\n *\t\t\tconsole.log( Array.from( ctx.getNames() ) );\n *\t\t} );\n *\n * Which will log the following:\n *\n *\t\t[ '$root', 'blockQuote', 'paragraph' ]\n *\t\t[ '$root', 'paragraph' ]\n *\t\t[ '$root', 'bar', 'paragraph' ]\n *\n * Note: When using the {@link module:engine/model/schema~Schema#checkAttribute `Schema#checkAttribute()`} method\n * you may want to check whether a text node may have an attribute. A {@link module:engine/model/text~Text} is a\n * correct way to define a context so you can do this:\n *\n *\t\tschema.checkAttribute( textNode, 'bold' );\n *\n * But sometimes you want to check whether a text at a given position might've had some attribute,\n * in which case you can create a context by mising an array of elements with a `'$text'` string:\n *\n *\t\t// Check in [ rootElement, paragraphElement, textNode ].\n *\t\tschema.checkChild( [ ...positionInParagraph.getAncestors(), '$text' ], 'bold' );\n *\n * @typedef {module:engine/model/node~Node|module:engine/model/position~Position|module:engine/model/schema~SchemaContext|\n * String|Array.<String|module:engine/model/node~Node>} module:engine/model/schema~SchemaContextDefinition\n */\n\n/**\n * An item of the {@link module:engine/model/schema~SchemaContext schema context}.\n *\n * It contains 3 properties:\n *\n * * `name`  the name of this item,\n * * `* getAttributeKeys()`  a generator of keys of item attributes,\n * * `getAttribute( keyName )`  a method to get attribute values.\n *\n * The context item interface is a highly simplified version of {@link module:engine/model/node~Node} and its role\n * is to expose only the information which schema checks are able to provide (which is the name of the node and\n * node's attributes).\n *\n *\t\tschema.on( 'checkChild', ( evt, args ) => {\n *\t\t\tconst ctx = args[ 0 ];\n *\t\t\tconst firstItem = ctx.getItem( 0 );\n *\n *\t\t\tconsole.log( firstItem.name ); // -> '$root'\n *\t\t\tconsole.log( firstItem.getAttribute( 'foo' ) ); // -> 'bar'\n *\t\t\tconsole.log( Array.from( firstItem.getAttributeKeys() ) ); // -> [ 'foo', 'faa' ]\n *\t\t} );\n *\n * @typedef {Object} module:engine/model/schema~SchemaContextItem\n */\n\n/**\n * A structure containing additional metadata describing the attribute.\n *\n * See {@link module:engine/model/schema~Schema#setAttributeProperties `Schema#setAttributeProperties()`} for usage examples.\n *\n * @typedef {Object} module:engine/model/schema~AttributeProperties\n * @property {Boolean} [isFormatting] Indicates that the attribute should be considered as a visual formatting, like `bold`, `italic` or\n * `fontSize` rather than semantic attribute (such as `src`, `listType`, etc.). For example, it is used by the \"Remove format\" feature.\n * @property {Boolean} [copyOnEnter] Indicates that given text attribute should be copied to the next block when enter is pressed.\n */\n\nfunction compileBaseItemRule( sourceItemRules, itemName ) {\n\tconst itemRule = {\n\t\tname: itemName,\n\n\t\tallowIn: [],\n\t\tallowContentOf: [],\n\t\tallowWhere: [],\n\n\t\tallowAttributes: [],\n\t\tallowAttributesOf: [],\n\n\t\tinheritTypesFrom: []\n\t};\n\n\tcopyTypes( sourceItemRules, itemRule );\n\n\tcopyProperty( sourceItemRules, itemRule, 'allowIn' );\n\tcopyProperty( sourceItemRules, itemRule, 'allowContentOf' );\n\tcopyProperty( sourceItemRules, itemRule, 'allowWhere' );\n\n\tcopyProperty( sourceItemRules, itemRule, 'allowAttributes' );\n\tcopyProperty( sourceItemRules, itemRule, 'allowAttributesOf' );\n\n\tcopyProperty( sourceItemRules, itemRule, 'inheritTypesFrom' );\n\n\tmakeInheritAllWork( sourceItemRules, itemRule );\n\n\treturn itemRule;\n}\n\nfunction compileAllowContentOf( compiledDefinitions, itemName ) {\n\tfor ( const allowContentOfItemName of compiledDefinitions[ itemName ].allowContentOf ) {\n\t\t// The allowContentOf property may point to an unregistered element.\n\t\tif ( compiledDefinitions[ allowContentOfItemName ] ) {\n\t\t\tconst allowedChildren = getAllowedChildren( compiledDefinitions, allowContentOfItemName );\n\n\t\t\tallowedChildren.forEach( allowedItem => {\n\t\t\t\tallowedItem.allowIn.push( itemName );\n\t\t\t} );\n\t\t}\n\t}\n\n\tdelete compiledDefinitions[ itemName ].allowContentOf;\n}\n\nfunction compileAllowWhere( compiledDefinitions, itemName ) {\n\tfor ( const allowWhereItemName of compiledDefinitions[ itemName ].allowWhere ) {\n\t\tconst inheritFrom = compiledDefinitions[ allowWhereItemName ];\n\n\t\t// The allowWhere property may point to an unregistered element.\n\t\tif ( inheritFrom ) {\n\t\t\tconst allowedIn = inheritFrom.allowIn;\n\n\t\t\tcompiledDefinitions[ itemName ].allowIn.push( ...allowedIn );\n\t\t}\n\t}\n\n\tdelete compiledDefinitions[ itemName ].allowWhere;\n}\n\nfunction compileAllowAttributesOf( compiledDefinitions, itemName ) {\n\tfor ( const allowAttributeOfItem of compiledDefinitions[ itemName ].allowAttributesOf ) {\n\t\tconst inheritFrom = compiledDefinitions[ allowAttributeOfItem ];\n\n\t\tif ( inheritFrom ) {\n\t\t\tconst inheritAttributes = inheritFrom.allowAttributes;\n\n\t\t\tcompiledDefinitions[ itemName ].allowAttributes.push( ...inheritAttributes );\n\t\t}\n\t}\n\n\tdelete compiledDefinitions[ itemName ].allowAttributesOf;\n}\n\nfunction compileInheritPropertiesFrom( compiledDefinitions, itemName ) {\n\tconst item = compiledDefinitions[ itemName ];\n\n\tfor ( const inheritPropertiesOfItem of item.inheritTypesFrom ) {\n\t\tconst inheritFrom = compiledDefinitions[ inheritPropertiesOfItem ];\n\n\t\tif ( inheritFrom ) {\n\t\t\tconst typeNames = Object.keys( inheritFrom ).filter( name => name.startsWith( 'is' ) );\n\n\t\t\tfor ( const name of typeNames ) {\n\t\t\t\tif ( !( name in item ) ) {\n\t\t\t\t\titem[ name ] = inheritFrom[ name ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdelete item.inheritTypesFrom;\n}\n\n// Remove items which weren't registered (because it may break some checks or we'd need to complicate them).\n// Make sure allowIn doesn't contain repeated values.\nfunction cleanUpAllowIn( compiledDefinitions, itemName ) {\n\tconst itemRule = compiledDefinitions[ itemName ];\n\tconst existingItems = itemRule.allowIn.filter( itemToCheck => compiledDefinitions[ itemToCheck ] );\n\n\titemRule.allowIn = Array.from( new Set( existingItems ) );\n}\n\nfunction cleanUpAllowAttributes( compiledDefinitions, itemName ) {\n\tconst itemRule = compiledDefinitions[ itemName ];\n\n\titemRule.allowAttributes = Array.from( new Set( itemRule.allowAttributes ) );\n}\n\nfunction copyTypes( sourceItemRules, itemRule ) {\n\tfor ( const sourceItemRule of sourceItemRules ) {\n\t\tconst typeNames = Object.keys( sourceItemRule ).filter( name => name.startsWith( 'is' ) );\n\n\t\tfor ( const name of typeNames ) {\n\t\t\titemRule[ name ] = sourceItemRule[ name ];\n\t\t}\n\t}\n}\n\nfunction copyProperty( sourceItemRules, itemRule, propertyName ) {\n\tfor ( const sourceItemRule of sourceItemRules ) {\n\t\tif ( typeof sourceItemRule[ propertyName ] == 'string' ) {\n\t\t\titemRule[ propertyName ].push( sourceItemRule[ propertyName ] );\n\t\t} else if ( Array.isArray( sourceItemRule[ propertyName ] ) ) {\n\t\t\titemRule[ propertyName ].push( ...sourceItemRule[ propertyName ] );\n\t\t}\n\t}\n}\n\nfunction makeInheritAllWork( sourceItemRules, itemRule ) {\n\tfor ( const sourceItemRule of sourceItemRules ) {\n\t\tconst inheritFrom = sourceItemRule.inheritAllFrom;\n\n\t\tif ( inheritFrom ) {\n\t\t\titemRule.allowContentOf.push( inheritFrom );\n\t\t\titemRule.allowWhere.push( inheritFrom );\n\t\t\titemRule.allowAttributesOf.push( inheritFrom );\n\t\t\titemRule.inheritTypesFrom.push( inheritFrom );\n\t\t}\n\t}\n}\n\nfunction getAllowedChildren( compiledDefinitions, itemName ) {\n\tconst itemRule = compiledDefinitions[ itemName ];\n\n\treturn getValues( compiledDefinitions ).filter( def => def.allowIn.includes( itemRule.name ) );\n}\n\nfunction getValues( obj ) {\n\treturn Object.keys( obj ).map( key => obj[ key ] );\n}\n\nfunction mapContextItem( ctxItem ) {\n\tif ( typeof ctxItem == 'string' ) {\n\t\treturn {\n\t\t\tname: ctxItem,\n\n\t\t\t* getAttributeKeys() {},\n\n\t\t\tgetAttribute() {}\n\t\t};\n\t} else {\n\t\treturn {\n\t\t\t// '$text' means text nodes and text proxies.\n\t\t\tname: ctxItem.is( 'element' ) ? ctxItem.name : '$text',\n\n\t\t\t* getAttributeKeys() {\n\t\t\t\tyield* ctxItem.getAttributeKeys();\n\t\t\t},\n\n\t\t\tgetAttribute( key ) {\n\t\t\t\treturn ctxItem.getAttribute( key );\n\t\t\t}\n\t\t};\n\t}\n}\n\n// Generator function returning values from provided walkers, switching between them at each iteration. If only one walker\n// is provided it will return data only from that walker.\n//\n// @param {module:engine/module/treewalker~TreeWalker} [backward] Walker iterating in backward direction.\n// @param {module:engine/module/treewalker~TreeWalker} [forward] Walker iterating in forward direction.\n// @returns {Iterable.<Object>} Object returned at each iteration contains `value` and `walker` (informing which walker returned\n// given value) fields.\nfunction* combineWalkers( backward, forward ) {\n\tlet done = false;\n\n\twhile ( !done ) {\n\t\tdone = true;\n\n\t\tif ( backward ) {\n\t\t\tconst step = backward.next();\n\n\t\t\tif ( !step.done ) {\n\t\t\t\tdone = false;\n\t\t\t\tyield {\n\t\t\t\t\twalker: backward,\n\t\t\t\t\tvalue: step.value\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tif ( forward ) {\n\t\t\tconst step = forward.next();\n\n\t\t\tif ( !step.done ) {\n\t\t\t\tdone = false;\n\t\t\t\tyield {\n\t\t\t\t\twalker: forward,\n\t\t\t\t\tvalue: step.value\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Takes an array of non-intersecting ranges. For each of them gets minimal flat ranges covering that range and returns\n// all those minimal flat ranges.\n//\n// @param {Array.<module:engine/model/range~Range>} ranges Ranges to process.\n// @returns {Iterable.<module:engine/model/range~Range>} Minimal flat ranges of given `ranges`.\nfunction* convertToMinimalFlatRanges( ranges ) {\n\tfor ( const range of ranges ) {\n\t\tyield* range.getMinimalFlatRanges();\n\t}\n}\n\nfunction removeDisallowedAttributeFromNode( schema, node, writer ) {\n\tfor ( const attribute of node.getAttributeKeys() ) {\n\t\tif ( !schema.checkAttribute( node, attribute ) ) {\n\t\t\twriter.removeAttribute( attribute, node );\n\t\t}\n\t}\n}\n"]}]}