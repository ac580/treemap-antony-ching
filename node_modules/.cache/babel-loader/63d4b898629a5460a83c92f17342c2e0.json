{"remainingRequest":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/babel-loader/lib/index.js!/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-engine/src/controller/datacontroller.js","dependencies":[{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-engine/src/controller/datacontroller.js","mtime":499162500000},{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js","mtime":499162500000},{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/babel-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:LyoqCiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDE5LCBDS1NvdXJjZSAtIEZyZWRlcmljbyBLbmFiYmVuLiBBbGwgcmlnaHRzIHJlc2VydmVkLgogKiBGb3IgbGljZW5zaW5nLCBzZWUgTElDRU5TRS5tZCBvciBodHRwczovL2NrZWRpdG9yLmNvbS9sZWdhbC9ja2VkaXRvci1vc3MtbGljZW5zZQogKi8KCi8qKgogKiBAbW9kdWxlIGVuZ2luZS9jb250cm9sbGVyL2RhdGFjb250cm9sbGVyCiAqLwppbXBvcnQgbWl4IGZyb20gJ0Bja2VkaXRvci9ja2VkaXRvcjUtdXRpbHMvc3JjL21peCc7CmltcG9ydCBPYnNlcnZhYmxlTWl4aW4gZnJvbSAnQGNrZWRpdG9yL2NrZWRpdG9yNS11dGlscy9zcmMvb2JzZXJ2YWJsZW1peGluJzsKaW1wb3J0IENLRWRpdG9yRXJyb3IgZnJvbSAnQGNrZWRpdG9yL2NrZWRpdG9yNS11dGlscy9zcmMvY2tlZGl0b3JlcnJvcic7CmltcG9ydCBNYXBwZXIgZnJvbSAnLi4vY29udmVyc2lvbi9tYXBwZXInOwppbXBvcnQgRG93bmNhc3REaXNwYXRjaGVyIGZyb20gJy4uL2NvbnZlcnNpb24vZG93bmNhc3RkaXNwYXRjaGVyJzsKaW1wb3J0IHsgaW5zZXJ0VGV4dCB9IGZyb20gJy4uL2NvbnZlcnNpb24vZG93bmNhc3RoZWxwZXJzJzsKaW1wb3J0IFVwY2FzdERpc3BhdGNoZXIgZnJvbSAnLi4vY29udmVyc2lvbi91cGNhc3RkaXNwYXRjaGVyJzsKaW1wb3J0IHsgY29udmVydFRleHQsIGNvbnZlcnRUb01vZGVsRnJhZ21lbnQgfSBmcm9tICcuLi9jb252ZXJzaW9uL3VwY2FzdGhlbHBlcnMnOwppbXBvcnQgVmlld0RvY3VtZW50RnJhZ21lbnQgZnJvbSAnLi4vdmlldy9kb2N1bWVudGZyYWdtZW50JzsKaW1wb3J0IFZpZXdEb2N1bWVudCBmcm9tICcuLi92aWV3L2RvY3VtZW50JzsKaW1wb3J0IFZpZXdEb3duY2FzdFdyaXRlciBmcm9tICcuLi92aWV3L2Rvd25jYXN0d3JpdGVyJzsKaW1wb3J0IE1vZGVsUmFuZ2UgZnJvbSAnLi4vbW9kZWwvcmFuZ2UnOwovKioKICogQ29udHJvbGxlciBmb3IgdGhlIGRhdGEgcGlwZWxpbmUuIFRoZSBkYXRhIHBpcGVsaW5lIGNvbnRyb2xzIGhvdyBkYXRhIGlzIHJldHJpZXZlZCBmcm9tIHRoZSBkb2N1bWVudAogKiBhbmQgc2V0IGluc2lkZSBpdC4gSGVuY2UsIHRoZSBjb250cm9sbGVyIGZlYXR1cmVzIHR3byBtZXRob2RzIHdoaWNoIGFsbG93IHRvIHtAbGluayB+RGF0YUNvbnRyb2xsZXIjZ2V0IGdldH0KICogYW5kIHtAbGluayB+RGF0YUNvbnRyb2xsZXIjc2V0IHNldH0gZGF0YSBvZiB0aGUge0BsaW5rIH5EYXRhQ29udHJvbGxlciNtb2RlbCBtb2RlbH0KICogdXNpbmcgZ2l2ZW46CiAqCiAqICoge0BsaW5rIG1vZHVsZTplbmdpbmUvZGF0YXByb2Nlc3Nvci9kYXRhcHJvY2Vzc29yfkRhdGFQcm9jZXNzb3IgZGF0YSBwcm9jZXNzb3J9LAogKiAqIGRvd25jYXN0IGNvbnZlcnRlcnMsCiAqICogdXBjYXN0IGNvbnZlcnRlcnMuCiAqCiAqIEFuIGluc3RhbmNlIG9mIHRoZSBkYXRhIGNvbnRyb2xsZXIgaXMgYWx3YXlzIGF2YWlsYWJsZSBpbiB0aGUge0BsaW5rIG1vZHVsZTpjb3JlL2VkaXRvci9lZGl0b3J+RWRpdG9yI2RhdGEgYGVkaXRvci5kYXRhYH0KICogcHJvcGVydHk6CiAqCiAqCQllZGl0b3IuZGF0YS5nZXQoIHsgcm9vdE5hbWU6ICdjdXN0b21Sb290JyB9ICk7IC8vIC0+ICc8cD5IZWxsbyE8L3A+JwogKgogKiBAbWl4ZXMgbW9kdWxlOnV0aWxzL29ic2VydmFibGVtaXhpbn5PYnNlcnZhYmxlTWl4aW4KICovCgpleHBvcnQgZGVmYXVsdCBjbGFzcyBEYXRhQ29udHJvbGxlciB7CiAgLyoqCiAgICogQ3JlYXRlcyBhIGRhdGEgY29udHJvbGxlciBpbnN0YW5jZS4KICAgKgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9tb2RlbH5Nb2RlbH0gbW9kZWwgRGF0YSBtb2RlbC4KICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvZGF0YXByb2Nlc3Nvci9kYXRhcHJvY2Vzc29yfkRhdGFQcm9jZXNzb3J9IFtkYXRhUHJvY2Vzc29yXSBEYXRhIHByb2Nlc3NvciB0aGF0IHNob3VsZCBiZSB1c2VkCiAgICogYnkgdGhlIGNvbnRyb2xsZXIuCiAgICovCiAgY29uc3RydWN0b3IobW9kZWwsIGRhdGFQcm9jZXNzb3IpIHsKICAgIC8qKgogICAgICogRGF0YSBtb2RlbC4KICAgICAqCiAgICAgKiBAcmVhZG9ubHkKICAgICAqIEBtZW1iZXIge21vZHVsZTplbmdpbmUvbW9kZWwvbW9kZWx+TW9kZWx9CiAgICAgKi8KICAgIHRoaXMubW9kZWwgPSBtb2RlbDsKICAgIC8qKgogICAgICogRGF0YSBwcm9jZXNzb3IgdXNlZCBkdXJpbmcgdGhlIGNvbnZlcnNpb24uCiAgICAgKgogICAgICogQHJlYWRvbmx5CiAgICAgKiBAbWVtYmVyIHttb2R1bGU6ZW5naW5lL2RhdGFwcm9jZXNzb3IvZGF0YXByb2Nlc3Nvcn5EYXRhUHJvY2Vzc29yfQogICAgICovCgogICAgdGhpcy5wcm9jZXNzb3IgPSBkYXRhUHJvY2Vzc29yOwogICAgLyoqCiAgICAgKiBNYXBwZXIgdXNlZCBmb3IgdGhlIGNvbnZlcnNpb24uIEl0IGhhcyBubyBwZXJtYW5lbnQgYmluZGluZ3MsIGJlY2F1c2UgdGhleSBhcmUgY3JlYXRlZCB3aGVuIGdldHRpbmcgZGF0YSBhbmQKICAgICAqIGNsZWFyZWQgZGlyZWN0bHkgYWZ0ZXIgdGhlIGRhdGEgYXJlIGNvbnZlcnRlZC4gSG93ZXZlciwgdGhlIG1hcHBlciBpcyBkZWZpbmVkIGFzIGEgY2xhc3MgcHJvcGVydHksIGJlY2F1c2UKICAgICAqIGl0IG5lZWRzIHRvIGJlIHBhc3NlZCB0byB0aGUgYERvd25jYXN0RGlzcGF0Y2hlcmAgYXMgYSBjb252ZXJzaW9uIEFQSS4KICAgICAqCiAgICAgKiBAcmVhZG9ubHkKICAgICAqIEBtZW1iZXIge21vZHVsZTplbmdpbmUvY29udmVyc2lvbi9tYXBwZXJ+TWFwcGVyfQogICAgICovCgogICAgdGhpcy5tYXBwZXIgPSBuZXcgTWFwcGVyKCk7CiAgICAvKioKICAgICAqIERvd25jYXN0IGRpc3BhdGNoZXIgdXNlZCBieSB0aGUge0BsaW5rICNnZXQgZ2V0IG1ldGhvZH0uIERvd25jYXN0IGNvbnZlcnRlcnMgc2hvdWxkIGJlIGF0dGFjaGVkIHRvIGl0LgogICAgICoKICAgICAqIEByZWFkb25seQogICAgICogQG1lbWJlciB7bW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL2Rvd25jYXN0ZGlzcGF0Y2hlcn5Eb3duY2FzdERpc3BhdGNoZXJ9CiAgICAgKi8KCiAgICB0aGlzLmRvd25jYXN0RGlzcGF0Y2hlciA9IG5ldyBEb3duY2FzdERpc3BhdGNoZXIoewogICAgICBtYXBwZXI6IHRoaXMubWFwcGVyCiAgICB9KTsKICAgIHRoaXMuZG93bmNhc3REaXNwYXRjaGVyLm9uKCdpbnNlcnQ6JHRleHQnLCBpbnNlcnRUZXh0KCksIHsKICAgICAgcHJpb3JpdHk6ICdsb3dlc3QnCiAgICB9KTsKICAgIC8qKgogICAgICogVXBjYXN0IGRpc3BhdGNoZXIgdXNlZCBieSB0aGUge0BsaW5rICNzZXQgc2V0IG1ldGhvZH0uIFVwY2FzdCBjb252ZXJ0ZXJzIHNob3VsZCBiZSBhdHRhY2hlZCB0byBpdC4KICAgICAqCiAgICAgKiBAcmVhZG9ubHkKICAgICAqIEBtZW1iZXIge21vZHVsZTplbmdpbmUvY29udmVyc2lvbi91cGNhc3RkaXNwYXRjaGVyflVwY2FzdERpc3BhdGNoZXJ9CiAgICAgKi8KCiAgICB0aGlzLnVwY2FzdERpc3BhdGNoZXIgPSBuZXcgVXBjYXN0RGlzcGF0Y2hlcih7CiAgICAgIHNjaGVtYTogbW9kZWwuc2NoZW1hCiAgICB9KTsgLy8gRGVmaW5lIGRlZmF1bHQgY29udmVydGVycyBmb3IgdGV4dCBhbmQgZWxlbWVudHMuCiAgICAvLwogICAgLy8gTm90ZSB0aGF0IGlmIHRoZXJlIGlzIG5vIGRlZmF1bHQgY29udmVydGVyIGZvciB0aGUgZWxlbWVudCBpdCB3aWxsIGJlIHNraXBwZWQsIGZvciBpbnN0YW5jZSBgPGI+Zm9vPC9iPmAgd2lsbCBiZQogICAgLy8gY29udmVydGVkIHRvIG5vdGhpbmcuIFdlIGFkZCBgY29udmVydFRvTW9kZWxGcmFnbWVudGAgYXMgYSBsYXN0IGNvbnZlcnRlciBzbyBpdCBjb252ZXJ0cyBjaGlsZHJlbiBvZiB0aGF0CiAgICAvLyBlbGVtZW50IHRvIHRoZSBkb2N1bWVudCBmcmFnbWVudCBzbyBgPGI+Zm9vPC9iPmAgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gYGZvb2AgaWYgdGhlcmUgaXMgbm8gY29udmVydGVyIGZvciBgPGI+YC4KCiAgICB0aGlzLnVwY2FzdERpc3BhdGNoZXIub24oJ3RleHQnLCBjb252ZXJ0VGV4dCgpLCB7CiAgICAgIHByaW9yaXR5OiAnbG93ZXN0JwogICAgfSk7CiAgICB0aGlzLnVwY2FzdERpc3BhdGNoZXIub24oJ2VsZW1lbnQnLCBjb252ZXJ0VG9Nb2RlbEZyYWdtZW50KCksIHsKICAgICAgcHJpb3JpdHk6ICdsb3dlc3QnCiAgICB9KTsKICAgIHRoaXMudXBjYXN0RGlzcGF0Y2hlci5vbignZG9jdW1lbnRGcmFnbWVudCcsIGNvbnZlcnRUb01vZGVsRnJhZ21lbnQoKSwgewogICAgICBwcmlvcml0eTogJ2xvd2VzdCcKICAgIH0pOwogICAgdGhpcy5kZWNvcmF0ZSgnaW5pdCcpOyAvLyBGaXJlIGByZWFkeWAgZXZlbnQgd2hlbiBpbml0aWFsaXNhdGlvbiBoYXMgY29tcGxldGVkLiBTdWNoIGxvdyBsZXZlbCBsaXN0ZW5lciBnaXZlcyBwb3NzaWJpbGl0eQogICAgLy8gdG8gcGx1ZyBpbnRvIGluaXRpYWxpc2F0aW9uIHBpcGVsaW5lIHdpdGhvdXQgaW50ZXJydXB0aW5nIHRoZSBpbml0aWFsaXNhdGlvbiBmbG93LgoKICAgIHRoaXMub24oJ2luaXQnLCAoKSA9PiB7CiAgICAgIHRoaXMuZmlyZSgncmVhZHknKTsKICAgIH0sIHsKICAgICAgcHJpb3JpdHk6ICdsb3dlc3QnCiAgICB9KTsKICB9CiAgLyoqCiAgICogUmV0dXJucyB0aGUgbW9kZWwncyBkYXRhIGNvbnZlcnRlZCBieSBkb3duY2FzdCBkaXNwYXRjaGVycyBhdHRhY2hlZCB0byB7QGxpbmsgI2Rvd25jYXN0RGlzcGF0Y2hlcn0gYW5kCiAgICogZm9ybWF0dGVkIGJ5IHRoZSB7QGxpbmsgI3Byb2Nlc3NvciBkYXRhIHByb2Nlc3Nvcn0uCiAgICoKICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdCiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnJvb3ROYW1lPSdtYWluJ10gUm9vdCBuYW1lLgogICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy50cmltPSdlbXB0eSddIFdoZXRoZXIgcmV0dXJuZWQgZGF0YSBzaG91bGQgYmUgdHJpbW1lZC4gVGhpcyBvcHRpb24gaXMgc2V0IHRvIGBlbXB0eWAgYnkgZGVmYXVsdCwKICAgKiB3aGljaCBtZWFucyB3aGVuZXZlciBlZGl0b3IgY29udGVudCBpcyBjb25zaWRlcmVkIGVtcHR5LCBhbiBlbXB0eSBzdHJpbmcgd2lsbCBiZSByZXR1cm5lZC4gVG8gdHVybiBvZmYgdHJpbW1pbmcgY29tcGxldGVseQogICAqIHVzZSBgJ25vbmUnYC4gSW4gc3VjaCBjYXNlcyBleGFjdCBjb250ZW50IHdpbGwgYmUgcmV0dXJuZWQgKGZvciBleGFtcGxlIGA8cD4mbmJzcDs8L3A+YCBmb3IgYW4gZW1wdHkgZWRpdG9yKS4KICAgKiBAcmV0dXJucyB7U3RyaW5nfSBPdXRwdXQgZGF0YS4KICAgKi8KCgogIGdldChvcHRpb25zKSB7CiAgICBjb25zdCB7CiAgICAgIHJvb3ROYW1lID0gJ21haW4nLAogICAgICB0cmltID0gJ2VtcHR5JwogICAgfSA9IG9wdGlvbnMgfHwge307CgogICAgaWYgKCF0aGlzLl9jaGVja0lmUm9vdHNFeGlzdHMoW3Jvb3ROYW1lXSkpIHsKICAgICAgLyoqCiAgICAgICAqIENhbm5vdCBnZXQgZGF0YSBmcm9tIGEgbm9uLWV4aXN0aW5nIHJvb3QuIFRoaXMgZXJyb3IgaXMgdGhyb3duIHdoZW4ge0BsaW5rICNnZXQgRGF0YUNvbnRyb2xsZXIjZ2V0KCkgbWV0aG9kfQogICAgICAgKiBpcyBjYWxsZWQgd2l0aCBub24tZXhpc3RlbnQgcm9vdCBuYW1lLiBGb3IgZXhhbXBsZSwgaWYgdGhlcmUgaXMgYW4gZWRpdG9yIGluc3RhbmNlIHdpdGggb25seSBgbWFpbmAgcm9vdCwKICAgICAgICogY2FsbGluZyB7QGxpbmsgI2dldH0gbGlrZToKICAgICAgICoKICAgICAgICoJCWRhdGEuZ2V0KCB7IHJvb3ROYW1lOiAncm9vdDInIH0gKTsKICAgICAgICoKICAgICAgICogd2lsbCB0aHJvdyB0aGlzIGVycm9yLgogICAgICAgKgogICAgICAgKiBAZXJyb3IgZGF0YWNvbnRyb2xsZXItZ2V0LW5vbi1leGlzdGVudC1yb290CiAgICAgICAqLwogICAgICB0aHJvdyBuZXcgQ0tFZGl0b3JFcnJvcignZGF0YWNvbnRyb2xsZXItZ2V0LW5vbi1leGlzdGVudC1yb290OiBBdHRlbXB0aW5nIHRvIGdldCBkYXRhIGZyb20gYSBub24tZXhpc3Rpbmcgcm9vdC4nLCB0aGlzKTsKICAgIH0KCiAgICBjb25zdCByb290ID0gdGhpcy5tb2RlbC5kb2N1bWVudC5nZXRSb290KHJvb3ROYW1lKTsKCiAgICBpZiAodHJpbSA9PT0gJ2VtcHR5JyAmJiAhdGhpcy5tb2RlbC5oYXNDb250ZW50KHJvb3QsIHsKICAgICAgaWdub3JlV2hpdGVzcGFjZXM6IHRydWUKICAgIH0pKSB7CiAgICAgIHJldHVybiAnJzsKICAgIH0KCiAgICByZXR1cm4gdGhpcy5zdHJpbmdpZnkocm9vdCk7CiAgfQogIC8qKgogICAqIFJldHVybnMgdGhlIGNvbnRlbnQgb2YgdGhlIGdpdmVuIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudCBtb2RlbCdzIGVsZW1lbnR9IG9yCiAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50IG1vZGVsIGRvY3VtZW50IGZyYWdtZW50fSBjb252ZXJ0ZWQgYnkgdGhlIGRvd25jYXN0IGNvbnZlcnRlcnMKICAgKiBhdHRhY2hlZCB0byB7QGxpbmsgI2Rvd25jYXN0RGlzcGF0Y2hlcn0gYW5kIGZvcm1hdHRlZCBieSB0aGUge0BsaW5rICNwcm9jZXNzb3IgZGF0YSBwcm9jZXNzb3J9LgogICAqCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudHxtb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudH0gbW9kZWxFbGVtZW50T3JGcmFnbWVudAogICAqIEVsZW1lbnQgd2hvc2UgY29udGVudCB3aWxsIGJlIHN0cmluZ2lmaWVkLgogICAqIEByZXR1cm5zIHtTdHJpbmd9IE91dHB1dCBkYXRhLgogICAqLwoKCiAgc3RyaW5naWZ5KG1vZGVsRWxlbWVudE9yRnJhZ21lbnQpIHsKICAgIC8vIE1vZGVsIC0+IHZpZXcuCiAgICBjb25zdCB2aWV3RG9jdW1lbnRGcmFnbWVudCA9IHRoaXMudG9WaWV3KG1vZGVsRWxlbWVudE9yRnJhZ21lbnQpOyAvLyBWaWV3IC0+IGRhdGEuCgogICAgcmV0dXJuIHRoaXMucHJvY2Vzc29yLnRvRGF0YSh2aWV3RG9jdW1lbnRGcmFnbWVudCk7CiAgfQogIC8qKgogICAqIFJldHVybnMgdGhlIGNvbnRlbnQgb2YgdGhlIGdpdmVuIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudCBtb2RlbCBlbGVtZW50fSBvcgogICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudCBtb2RlbCBkb2N1bWVudCBmcmFnbWVudH0gY29udmVydGVkIGJ5IHRoZSBkb3duY2FzdAogICAqIGNvbnZlcnRlcnMgYXR0YWNoZWQgdG8ge0BsaW5rICNkb3duY2FzdERpc3BhdGNoZXJ9IHRvIGEKICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudCB2aWV3IGRvY3VtZW50IGZyYWdtZW50fS4KICAgKgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR8bW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnR9IG1vZGVsRWxlbWVudE9yRnJhZ21lbnQKICAgKiBFbGVtZW50IG9yIGRvY3VtZW50IGZyYWdtZW50IHdob3NlIGNvbnRlbnQgd2lsbCBiZSBjb252ZXJ0ZWQuCiAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnR9IE91dHB1dCB2aWV3IERvY3VtZW50RnJhZ21lbnQuCiAgICovCgoKICB0b1ZpZXcobW9kZWxFbGVtZW50T3JGcmFnbWVudCkgewogICAgLy8gQ2xlYXIgYmluZGluZ3Mgc28gdGhlIGNhbGwgdG8gdGhpcyBtZXRob2QgZ2l2ZXMgY29ycmVjdCByZXN1bHRzLgogICAgdGhpcy5tYXBwZXIuY2xlYXJCaW5kaW5ncygpOyAvLyBGaXJzdCwgY29udmVydCBlbGVtZW50cy4KCiAgICBjb25zdCBtb2RlbFJhbmdlID0gTW9kZWxSYW5nZS5fY3JlYXRlSW4obW9kZWxFbGVtZW50T3JGcmFnbWVudCk7CgogICAgY29uc3Qgdmlld0RvY3VtZW50RnJhZ21lbnQgPSBuZXcgVmlld0RvY3VtZW50RnJhZ21lbnQoKTsgLy8gQ3JlYXRlIHNlcGFyYXRlIFZpZXdEb3duY2FzdFdyaXRlciBqdXN0IGZvciBkYXRhIGNvbnZlcnNpb24gcHVycG9zZXMuCiAgICAvLyBXZSBoYXZlIG5vIHZpZXcgY29udHJvbGxlciBhbmQgcmVuZGVyaW5nIGRvIERPTSBpbiBEYXRhQ29udHJvbGxlciBzbyB2aWV3LmNoYW5nZSgpIGJsb2NrIGlzIG5vdCB1c2VkIGhlcmUuCgogICAgY29uc3Qgdmlld1dyaXRlciA9IG5ldyBWaWV3RG93bmNhc3RXcml0ZXIobmV3IFZpZXdEb2N1bWVudCgpKTsKICAgIHRoaXMubWFwcGVyLmJpbmRFbGVtZW50cyhtb2RlbEVsZW1lbnRPckZyYWdtZW50LCB2aWV3RG9jdW1lbnRGcmFnbWVudCk7CiAgICB0aGlzLmRvd25jYXN0RGlzcGF0Y2hlci5jb252ZXJ0SW5zZXJ0KG1vZGVsUmFuZ2UsIHZpZXdXcml0ZXIpOwoKICAgIGlmICghbW9kZWxFbGVtZW50T3JGcmFnbWVudC5pcygnZG9jdW1lbnRGcmFnbWVudCcpKSB7CiAgICAgIC8vIFRoZW4sIGlmIGEgZG9jdW1lbnQgZWxlbWVudCBpcyBjb252ZXJ0ZWQsIGNvbnZlcnQgbWFya2Vycy4KICAgICAgLy8gRnJvbSBhbGwgZG9jdW1lbnQgbWFya2VycywgZ2V0IHRob3NlLCB3aGljaCAiaW50ZXJzZWN0IiB3aXRoIHRoZSBjb252ZXJ0ZXIgZWxlbWVudC4KICAgICAgY29uc3QgbWFya2VycyA9IF9nZXRNYXJrZXJzUmVsYXRpdmVUb0VsZW1lbnQobW9kZWxFbGVtZW50T3JGcmFnbWVudCk7CgogICAgICBmb3IgKGNvbnN0IFtuYW1lLCByYW5nZV0gb2YgbWFya2VycykgewogICAgICAgIHRoaXMuZG93bmNhc3REaXNwYXRjaGVyLmNvbnZlcnRNYXJrZXJBZGQobmFtZSwgcmFuZ2UsIHZpZXdXcml0ZXIpOwogICAgICB9CiAgICB9CgogICAgcmV0dXJuIHZpZXdEb2N1bWVudEZyYWdtZW50OwogIH0KICAvKioKICAgKiBTZXRzIGluaXRpYWwgaW5wdXQgZGF0YSBwYXJzZWQgYnkgdGhlIHtAbGluayAjcHJvY2Vzc29yIGRhdGEgcHJvY2Vzc29yfSBhbmQKICAgKiBjb252ZXJ0ZWQgYnkgdGhlIHtAbGluayAjdXBjYXN0RGlzcGF0Y2hlciB2aWV3LXRvLW1vZGVsIGNvbnZlcnRlcnN9LgogICAqIEluaXRpYWwgZGF0YSBjYW4gYmUgc2V0IG9ubHkgdG8gZG9jdW1lbnQgdGhhdCB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudH5Eb2N1bWVudCN2ZXJzaW9ufSBpcyBlcXVhbCAwLgogICAqCiAgICogKipOb3RlKiogVGhpcyBtZXRob2QgaXMge0BsaW5rIG1vZHVsZTp1dGlscy9vYnNlcnZhYmxlbWl4aW5+T2JzZXJ2YWJsZU1peGluI2RlY29yYXRlIGRlY29yYXRlZH0gd2hpY2ggaXMKICAgKiB1c2VkIGJ5IGUuZy4gY29sbGFib3JhdGl2ZSBlZGl0aW5nIHBsdWdpbiB0aGF0IHN5bmNzIHJlbW90ZSBkYXRhIG9uIGluaXQuCiAgICoKICAgKiBXaGVuIGRhdGEgaXMgcGFzc2VkIGFzIGEgc3RyaW5nIGl0IGlzIGluaXRpYWxpemVkIG9uIGEgZGVmYXVsdCBgbWFpbmAgcm9vdDoKICAgKgogICAqCQlkYXRhQ29udHJvbGxlci5pbml0KCAnPHA+Rm9vPC9wPicgKTsgLy8gSW5pdGlhbGl6ZXMgZGF0YSBvbiB0aGUgYG1haW5gIHJvb3QuCiAgICoKICAgKiBUbyBpbml0aWFsaXplIGRhdGEgb24gYSBkaWZmZXJlbnQgcm9vdCBvciBtdWx0aXBsZSByb290cyBhdCBvbmNlLCBvYmplY3QgY29udGFpbmluZyBgcm9vdE5hbWVgIC0gYGRhdGFgIHBhaXJzIHNob3VsZCBiZSBwYXNzZWQ6CiAgICoKICAgKgkJZGF0YUNvbnRyb2xsZXIuaW5pdCggeyBtYWluOiAnPHA+Rm9vPC9wPicsIHRpdGxlOiAnPGgxPkJhcjwvaDE+JyB9ICk7IC8vIEluaXRpYWxpemVzIGRhdGEgb24gdGhlIGBtYWluYCBhbmQgYHRpdGxlYCByb290cy4KICAgKgogICAqIEBmaXJlcyBpbml0CiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0LjxTdHJpbmcsU3RyaW5nPn0gZGF0YSBJbnB1dCBkYXRhIGFzIGEgc3RyaW5nIG9yIGFuIG9iamVjdCBjb250YWluaW5nIGByb290TmFtZWAgLSBgZGF0YWAKICAgKiBwYWlycyB0byBpbml0aWFsaXplIGRhdGEgb24gbXVsdGlwbGUgcm9vdHMgYXQgb25jZS4KICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gUHJvbWlzZSB0aGF0IGlzIHJlc29sdmVkIGFmdGVyIHRoZSBkYXRhIGlzIHNldCBvbiB0aGUgZWRpdG9yLgogICAqLwoKCiAgaW5pdChkYXRhKSB7CiAgICBpZiAodGhpcy5tb2RlbC5kb2N1bWVudC52ZXJzaW9uKSB7CiAgICAgIC8qKgogICAgICAgKiBDYW5ub3Qgc2V0IGluaXRpYWwgZGF0YSB0byBub3QgZW1wdHkge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnR+RG9jdW1lbnR9LgogICAgICAgKiBJbml0aWFsIGRhdGEgc2hvdWxkIGJlIHNldCBvbmNlLCBkdXJpbmcge0BsaW5rIG1vZHVsZTpjb3JlL2VkaXRvci9lZGl0b3J+RWRpdG9yfSBpbml0aWFsaXphdGlvbiwKICAgICAgICogd2hlbiB0aGUge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnR+RG9jdW1lbnQjdmVyc2lvbn0gaXMgZXF1YWwgMC4KICAgICAgICoKICAgICAgICogQGVycm9yIGRhdGFjb250cm9sbGVyLWluaXQtZG9jdW1lbnQtbm90LWVtcHR5CiAgICAgICAqLwogICAgICB0aHJvdyBuZXcgQ0tFZGl0b3JFcnJvcignZGF0YWNvbnRyb2xsZXItaW5pdC1kb2N1bWVudC1ub3QtZW1wdHk6IFRyeWluZyB0byBzZXQgaW5pdGlhbCBkYXRhIHRvIG5vdCBlbXB0eSBkb2N1bWVudC4nLCB0aGlzKTsKICAgIH0KCiAgICBsZXQgaW5pdGlhbERhdGEgPSB7fTsKCiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7CiAgICAgIGluaXRpYWxEYXRhLm1haW4gPSBkYXRhOyAvLyBEZWZhdWx0IHJvb3QgaXMgJ21haW4nLiBUbyBpbml0aWF0ZSBkYXRhIG9uIGEgZGlmZmVyZW50IHJvb3QsIG9iamVjdCBzaG91bGQgYmUgcGFzc2VkLgogICAgfSBlbHNlIHsKICAgICAgaW5pdGlhbERhdGEgPSBkYXRhOwogICAgfQoKICAgIGlmICghdGhpcy5fY2hlY2tJZlJvb3RzRXhpc3RzKE9iamVjdC5rZXlzKGluaXRpYWxEYXRhKSkpIHsKICAgICAgLyoqCiAgICAgICAqIENhbm5vdCBpbml0IGRhdGEgb24gYSBub24tZXhpc3Rpbmcgcm9vdC4gVGhpcyBlcnJvciBpcyB0aHJvd24gd2hlbiB7QGxpbmsgI2luaXQgRGF0YUNvbnRyb2xsZXIjaW5pdCgpIG1ldGhvZH0KICAgICAgICogaXMgY2FsbGVkIHdpdGggbm9uLWV4aXN0ZW50IHJvb3QgbmFtZS4gRm9yIGV4YW1wbGUsIGlmIHRoZXJlIGlzIGFuIGVkaXRvciBpbnN0YW5jZSB3aXRoIG9ubHkgYG1haW5gIHJvb3QsCiAgICAgICAqIGNhbGxpbmcge0BsaW5rICNpbml0fSBsaWtlOgogICAgICAgKgogICAgICAgKiAJCWRhdGEuaW5pdCggeyBtYWluOiAnPHA+Rm9vPC9wPicsIHJvb3QyOiAnPHA+QmFyPC9wPicgfSApOwogICAgICAgKgogICAgICAgKiB3aWxsIHRocm93IHRoaXMgZXJyb3IuCiAgICAgICAqCiAgICAgICAqIEBlcnJvciBkYXRhY29udHJvbGxlci1pbml0LW5vbi1leGlzdGVudC1yb290CiAgICAgICAqLwogICAgICB0aHJvdyBuZXcgQ0tFZGl0b3JFcnJvcignZGF0YWNvbnRyb2xsZXItaW5pdC1ub24tZXhpc3RlbnQtcm9vdDogQXR0ZW1wdGluZyB0byBpbml0IGRhdGEgb24gYSBub24tZXhpc3Rpbmcgcm9vdC4nLCB0aGlzKTsKICAgIH0KCiAgICB0aGlzLm1vZGVsLmVucXVldWVDaGFuZ2UoJ3RyYW5zcGFyZW50Jywgd3JpdGVyID0+IHsKICAgICAgZm9yIChjb25zdCByb290TmFtZSBvZiBPYmplY3Qua2V5cyhpbml0aWFsRGF0YSkpIHsKICAgICAgICBjb25zdCBtb2RlbFJvb3QgPSB0aGlzLm1vZGVsLmRvY3VtZW50LmdldFJvb3Qocm9vdE5hbWUpOwogICAgICAgIHdyaXRlci5pbnNlcnQodGhpcy5wYXJzZShpbml0aWFsRGF0YVtyb290TmFtZV0sIG1vZGVsUm9vdCksIG1vZGVsUm9vdCwgMCk7CiAgICAgIH0KICAgIH0pOwogICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpOwogIH0KICAvKioKICAgKiBTZXRzIGlucHV0IGRhdGEgcGFyc2VkIGJ5IHRoZSB7QGxpbmsgI3Byb2Nlc3NvciBkYXRhIHByb2Nlc3Nvcn0gYW5kCiAgICogY29udmVydGVkIGJ5IHRoZSB7QGxpbmsgI3VwY2FzdERpc3BhdGNoZXIgdmlldy10by1tb2RlbCBjb252ZXJ0ZXJzfS4KICAgKiBUaGlzIG1ldGhvZCBjYW4gYmUgdXNlZCBhbnkgdGltZSB0byByZXBsYWNlIGV4aXN0aW5nIGVkaXRvciBkYXRhIGJ5IHRoZSBuZXcgb25lIHdpdGhvdXQgY2xlYXJpbmcgdGhlCiAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnR+RG9jdW1lbnQjaGlzdG9yeSBkb2N1bWVudCBoaXN0b3J5fS4KICAgKgogICAqIFRoaXMgbWV0aG9kIGFsc28gY3JlYXRlcyBhIGJhdGNoIHdpdGggYWxsIHRoZSBjaGFuZ2VzIGFwcGxpZWQuIElmIGFsbCB5b3UgbmVlZCBpcyB0byBwYXJzZSBkYXRhLCB1c2UKICAgKiB0aGUge0BsaW5rICNwYXJzZX0gbWV0aG9kLgogICAqCiAgICogV2hlbiBkYXRhIGlzIHBhc3NlZCBhcyBhIHN0cmluZyBpdCBpcyBzZXQgb24gYSBkZWZhdWx0IGBtYWluYCByb290OgogICAqCiAgICoJCWRhdGFDb250cm9sbGVyLnNldCggJzxwPkZvbzwvcD4nICk7IC8vIFNldHMgZGF0YSBvbiB0aGUgYG1haW5gIHJvb3QuCiAgICoKICAgKiBUbyBzZXQgZGF0YSBvbiBhIGRpZmZlcmVudCByb290IG9yIG11bHRpcGxlIHJvb3RzIGF0IG9uY2UsIG9iamVjdCBjb250YWluaW5nIGByb290TmFtZWAgLSBgZGF0YWAgcGFpcnMgc2hvdWxkIGJlIHBhc3NlZDoKICAgKgogICAqCQlkYXRhQ29udHJvbGxlci5zZXQoIHsgbWFpbjogJzxwPkZvbzwvcD4nLCB0aXRsZTogJzxoMT5CYXI8L2gxPicgfSApOyAvLyBTZXRzIGRhdGEgb24gdGhlIGBtYWluYCBhbmQgYHRpdGxlYCByb290cy4KICAgKgogICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdC48U3RyaW5nLFN0cmluZz59IGRhdGEgSW5wdXQgZGF0YSBhcyBhIHN0cmluZyBvciBhbiBvYmplY3QgY29udGFpbmluZyBgcm9vdE5hbWVgIC0gYGRhdGFgCiAgICogcGFpcnMgdG8gc2V0IGRhdGEgb24gbXVsdGlwbGUgcm9vdHMgYXQgb25jZS4KICAgKi8KCgogIHNldChkYXRhKSB7CiAgICBsZXQgbmV3RGF0YSA9IHt9OwoKICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHsKICAgICAgbmV3RGF0YS5tYWluID0gZGF0YTsgLy8gRGVmYXVsdCByb290IGlzICdtYWluJy4gVG8gc2V0IGRhdGEgb24gYSBkaWZmZXJlbnQgcm9vdCwgb2JqZWN0IHNob3VsZCBiZSBwYXNzZWQuCiAgICB9IGVsc2UgewogICAgICBuZXdEYXRhID0gZGF0YTsKICAgIH0KCiAgICBpZiAoIXRoaXMuX2NoZWNrSWZSb290c0V4aXN0cyhPYmplY3Qua2V5cyhuZXdEYXRhKSkpIHsKICAgICAgLyoqCiAgICAgICAqIENhbm5vdCBzZXQgZGF0YSBvbiBhIG5vbi1leGlzdGluZyByb290LiBUaGlzIGVycm9yIGlzIHRocm93biB3aGVuIHtAbGluayAjc2V0IERhdGFDb250cm9sbGVyI3NldCgpIG1ldGhvZH0KICAgICAgICogaXMgY2FsbGVkIHdpdGggbm9uLWV4aXN0ZW50IHJvb3QgbmFtZS4gRm9yIGV4YW1wbGUsIGlmIHRoZXJlIGlzIGFuIGVkaXRvciBpbnN0YW5jZSB3aXRoIG9ubHkgYG1haW5gIHJvb3QsCiAgICAgICAqIGNhbGxpbmcge0BsaW5rICNzZXR9IGxpa2U6CiAgICAgICAqCiAgICAgICAqIAkJZGF0YS5zZXQoIHsgbWFpbjogJzxwPkZvbzwvcD4nLCByb290MjogJzxwPkJhcjwvcD4nIH0gKTsKICAgICAgICoKICAgICAgICogd2lsbCB0aHJvdyB0aGlzIGVycm9yLgogICAgICAgKgogICAgICAgKiBAZXJyb3IgZGF0YWNvbnRyb2xsZXItc2V0LW5vbi1leGlzdGVudC1yb290CiAgICAgICAqLwogICAgICB0aHJvdyBuZXcgQ0tFZGl0b3JFcnJvcignZGF0YWNvbnRyb2xsZXItc2V0LW5vbi1leGlzdGVudC1yb290OiBBdHRlbXB0aW5nIHRvIHNldCBkYXRhIG9uIGEgbm9uLWV4aXN0aW5nIHJvb3QuJywgdGhpcyk7CiAgICB9CgogICAgdGhpcy5tb2RlbC5lbnF1ZXVlQ2hhbmdlKCd0cmFuc3BhcmVudCcsIHdyaXRlciA9PiB7CiAgICAgIHdyaXRlci5zZXRTZWxlY3Rpb24obnVsbCk7CiAgICAgIHdyaXRlci5yZW1vdmVTZWxlY3Rpb25BdHRyaWJ1dGUodGhpcy5tb2RlbC5kb2N1bWVudC5zZWxlY3Rpb24uZ2V0QXR0cmlidXRlS2V5cygpKTsKCiAgICAgIGZvciAoY29uc3Qgcm9vdE5hbWUgb2YgT2JqZWN0LmtleXMobmV3RGF0YSkpIHsKICAgICAgICAvLyBTYXZlIHRvIG1vZGVsLgogICAgICAgIGNvbnN0IG1vZGVsUm9vdCA9IHRoaXMubW9kZWwuZG9jdW1lbnQuZ2V0Um9vdChyb290TmFtZSk7CiAgICAgICAgd3JpdGVyLnJlbW92ZSh3cml0ZXIuY3JlYXRlUmFuZ2VJbihtb2RlbFJvb3QpKTsKICAgICAgICB3cml0ZXIuaW5zZXJ0KHRoaXMucGFyc2UobmV3RGF0YVtyb290TmFtZV0sIG1vZGVsUm9vdCksIG1vZGVsUm9vdCwgMCk7CiAgICAgIH0KICAgIH0pOwogIH0KICAvKioKICAgKiBSZXR1cm5zIHRoZSBkYXRhIHBhcnNlZCBieSB0aGUge0BsaW5rICNwcm9jZXNzb3IgZGF0YSBwcm9jZXNzb3J9IGFuZCB0aGVuIGNvbnZlcnRlZCBieSB1cGNhc3QgY29udmVydGVycwogICAqIGF0dGFjaGVkIHRvIHRoZSB7QGxpbmsgI3VwY2FzdERpc3BhdGNoZXJ9LgogICAqCiAgICogQHNlZSAjc2V0CiAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEgRGF0YSB0byBwYXJzZS4KICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYUNvbnRleHREZWZpbml0aW9ufSBbY29udGV4dD0nJHJvb3QnXSBCYXNlIGNvbnRleHQgaW4gd2hpY2ggdGhlIHZpZXcgd2lsbAogICAqIGJlIGNvbnZlcnRlZCB0byB0aGUgbW9kZWwuIFNlZToge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi91cGNhc3RkaXNwYXRjaGVyflVwY2FzdERpc3BhdGNoZXIjY29udmVydH0uCiAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50fSBQYXJzZWQgZGF0YS4KICAgKi8KCgogIHBhcnNlKGRhdGEsIGNvbnRleHQgPSAnJHJvb3QnKSB7CiAgICAvLyBkYXRhIC0+IHZpZXcKICAgIGNvbnN0IHZpZXdEb2N1bWVudEZyYWdtZW50ID0gdGhpcy5wcm9jZXNzb3IudG9WaWV3KGRhdGEpOyAvLyB2aWV3IC0+IG1vZGVsCgogICAgcmV0dXJuIHRoaXMudG9Nb2RlbCh2aWV3RG9jdW1lbnRGcmFnbWVudCwgY29udGV4dCk7CiAgfQogIC8qKgogICAqIFJldHVybnMgdGhlIHJlc3VsdCBvZiB0aGUgZ2l2ZW4ge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnQgdmlldyBlbGVtZW50fSBvcgogICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50IHZpZXcgZG9jdW1lbnQgZnJhZ21lbnR9IGNvbnZlcnRlZCBieSB0aGUKICAgKiB7QGxpbmsgI3VwY2FzdERpc3BhdGNoZXIgdmlldy10by1tb2RlbCBjb252ZXJ0ZXJzfSwgd3JhcHBlZCBieSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnR9LgogICAqCiAgICogV2hlbiBtYXJrZXIgZWxlbWVudHMgd2VyZSBjb252ZXJ0ZWQgZHVyaW5nIHRoZSBjb252ZXJzaW9uIHByb2Nlc3MsIGl0IHdpbGwgYmUgc2V0IGFzIGEgZG9jdW1lbnQgZnJhZ21lbnQncwogICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudCNtYXJrZXJzIHN0YXRpYyBtYXJrZXJzIG1hcH0uCiAgICoKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnR8bW9kdWxlOmVuZ2luZS92aWV3L2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudH0gdmlld0VsZW1lbnRPckZyYWdtZW50CiAgICogRWxlbWVudCBvciBkb2N1bWVudCBmcmFnbWVudCB3aG9zZSBjb250ZW50IHdpbGwgYmUgY29udmVydGVkLgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hQ29udGV4dERlZmluaXRpb259IFtjb250ZXh0PSckcm9vdCddIEJhc2UgY29udGV4dCBpbiB3aGljaCB0aGUgdmlldyB3aWxsCiAgICogYmUgY29udmVydGVkIHRvIHRoZSBtb2RlbC4gU2VlOiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL3VwY2FzdGRpc3BhdGNoZXJ+VXBjYXN0RGlzcGF0Y2hlciNjb252ZXJ0fS4KICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnR9IE91dHB1dCBkb2N1bWVudCBmcmFnbWVudC4KICAgKi8KCgogIHRvTW9kZWwodmlld0VsZW1lbnRPckZyYWdtZW50LCBjb250ZXh0ID0gJyRyb290JykgewogICAgcmV0dXJuIHRoaXMubW9kZWwuY2hhbmdlKHdyaXRlciA9PiB7CiAgICAgIHJldHVybiB0aGlzLnVwY2FzdERpc3BhdGNoZXIuY29udmVydCh2aWV3RWxlbWVudE9yRnJhZ21lbnQsIHdyaXRlciwgY29udGV4dCk7CiAgICB9KTsKICB9CiAgLyoqCiAgICogUmVtb3ZlcyBhbGwgZXZlbnQgbGlzdGVuZXJzIHNldCBieSB0aGUgRGF0YUNvbnRyb2xsZXIuCiAgICovCgoKICBkZXN0cm95KCkgewogICAgdGhpcy5zdG9wTGlzdGVuaW5nKCk7CiAgfQogIC8qKgogICAqIENoZWNrcyBpZiBhbGwgcHJvdmlkZWQgcm9vdCBuYW1lcyBhcmUgZXhpc3RpbmcgZWRpdG9yIHJvb3RzLgogICAqCiAgICogQHByaXZhdGUKICAgKiBAcGFyYW0ge0FycmF5LjxTdHJpbmc+fSByb290TmFtZXMgUm9vdCBuYW1lcyB0byBjaGVjay4KICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciBhbGwgcHJvdmlkZWQgcm9vdCBuYW1lcyBhcmUgZXhpc3RpbmcgZWRpdG9yIHJvb3RzLgogICAqLwoKCiAgX2NoZWNrSWZSb290c0V4aXN0cyhyb290TmFtZXMpIHsKICAgIGZvciAoY29uc3Qgcm9vdE5hbWUgb2Ygcm9vdE5hbWVzKSB7CiAgICAgIGlmICghdGhpcy5tb2RlbC5kb2N1bWVudC5nZXRSb290TmFtZXMoKS5pbmNsdWRlcyhyb290TmFtZSkpIHsKICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH0KICAgIH0KCiAgICByZXR1cm4gdHJ1ZTsKICB9CiAgLyoqCiAgICogRXZlbnQgZmlyZWQgb25jZSBkYXRhIGluaXRpYWxpc2F0aW9uIGhhcyBmaW5pc2hlZC4KICAgKgogICAqIEBldmVudCByZWFkeQogICAqLwoKICAvKioKICAgKiBFdmVudCBmaXJlZCBhZnRlciB7QGxpbmsgI2luaXQgaW5pdCgpIG1ldGhvZH0gaGFzIGJlZW4gcnVuLiBJdCBjYW4gYmUge0BsaW5rICNsaXN0ZW5UbyBsaXN0ZW5lZCB0b30gdG8gYWRqdXN0L21vZGlmeQogICAqIHRoZSBpbml0aWFsaXNhdGlvbiBmbG93LiBIb3dldmVyLCBpZiB0aGUgYGluaXRgIGV2ZW50IGlzIHN0b3BwZWQgb3IgcHJldmVudGVkLCB0aGUge0BsaW5rICNldmVudDpyZWFkeSByZWFkeSBldmVudH0KICAgKiBzaG91bGQgYmUgZmlyZWQgbWFudWFsbHkuCiAgICoKICAgKiBUaGUgYGluaXRgIGV2ZW50IGlzIGZpcmVkIGJ5IGRlY29yYXRlZCB7QGxpbmsgI2luaXR9IG1ldGhvZC4KICAgKiBTZWUge0BsaW5rIG1vZHVsZTp1dGlscy9vYnNlcnZhYmxlbWl4aW5+T2JzZXJ2YWJsZU1peGluI2RlY29yYXRlfSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBhbmQgc2FtcGxlcy4KICAgKgogICAqIEBldmVudCBpbml0CiAgICovCgoKfQptaXgoRGF0YUNvbnRyb2xsZXIsIE9ic2VydmFibGVNaXhpbik7IC8vIEhlbHBlciBmdW5jdGlvbiBmb3IgZG93bmNhc3QgY29udmVyc2lvbi4KLy8KLy8gVGFrZXMgYSBkb2N1bWVudCBlbGVtZW50IChlbGVtZW50IHRoYXQgaXMgYWRkZWQgdG8gYSBtb2RlbCBkb2N1bWVudCkgYW5kIGNoZWNrcyB3aGljaCBtYXJrZXJzIGFyZSBpbnNpZGUgaXQKLy8gYW5kIHdoaWNoIG1hcmtlcnMgYXJlIGNvbnRhaW5pbmcgaXQuIElmIHRoZSBtYXJrZXIgaXMgaW50ZXJzZWN0aW5nIHdpdGggZWxlbWVudCwgdGhlIGludGVyc2VjdGlvbiBpcyByZXR1cm5lZC4KCmZ1bmN0aW9uIF9nZXRNYXJrZXJzUmVsYXRpdmVUb0VsZW1lbnQoZWxlbWVudCkgewogIGNvbnN0IHJlc3VsdCA9IFtdOwogIGNvbnN0IGRvYyA9IGVsZW1lbnQucm9vdC5kb2N1bWVudDsKCiAgaWYgKCFkb2MpIHsKICAgIHJldHVybiBbXTsKICB9CgogIGNvbnN0IGVsZW1lbnRSYW5nZSA9IE1vZGVsUmFuZ2UuX2NyZWF0ZUluKGVsZW1lbnQpOwoKICBmb3IgKGNvbnN0IG1hcmtlciBvZiBkb2MubW9kZWwubWFya2VycykgewogICAgY29uc3QgaW50ZXJzZWN0aW9uID0gZWxlbWVudFJhbmdlLmdldEludGVyc2VjdGlvbihtYXJrZXIuZ2V0UmFuZ2UoKSk7CgogICAgaWYgKGludGVyc2VjdGlvbikgewogICAgICByZXN1bHQucHVzaChbbWFya2VyLm5hbWUsIGludGVyc2VjdGlvbl0pOwogICAgfQogIH0KCiAgcmV0dXJuIHJlc3VsdDsKfQ=="},{"version":3,"sources":["/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-engine/src/controller/datacontroller.js"],"names":["mix","ObservableMixin","CKEditorError","Mapper","DowncastDispatcher","insertText","UpcastDispatcher","convertText","convertToModelFragment","ViewDocumentFragment","ViewDocument","ViewDowncastWriter","ModelRange","DataController","constructor","model","dataProcessor","processor","mapper","downcastDispatcher","on","priority","upcastDispatcher","schema","decorate","fire","get","options","rootName","trim","_checkIfRootsExists","root","document","getRoot","hasContent","ignoreWhitespaces","stringify","modelElementOrFragment","viewDocumentFragment","toView","toData","clearBindings","modelRange","_createIn","viewWriter","bindElements","convertInsert","is","markers","_getMarkersRelativeToElement","name","range","convertMarkerAdd","init","data","version","initialData","main","Object","keys","enqueueChange","writer","modelRoot","insert","parse","Promise","resolve","set","newData","setSelection","removeSelectionAttribute","selection","getAttributeKeys","remove","createRangeIn","context","toModel","viewElementOrFragment","change","convert","destroy","stopListening","rootNames","getRootNames","includes","element","result","doc","elementRange","marker","intersection","getIntersection","getRange","push"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/controller/datacontroller\n */\n\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n\nimport Mapper from '../conversion/mapper';\n\nimport DowncastDispatcher from '../conversion/downcastdispatcher';\nimport { insertText } from '../conversion/downcasthelpers';\n\nimport UpcastDispatcher from '../conversion/upcastdispatcher';\nimport { convertText, convertToModelFragment } from '../conversion/upcasthelpers';\n\nimport ViewDocumentFragment from '../view/documentfragment';\nimport ViewDocument from '../view/document';\nimport ViewDowncastWriter from '../view/downcastwriter';\n\nimport ModelRange from '../model/range';\n\n/**\n * Controller for the data pipeline. The data pipeline controls how data is retrieved from the document\n * and set inside it. Hence, the controller features two methods which allow to {@link ~DataController#get get}\n * and {@link ~DataController#set set} data of the {@link ~DataController#model model}\n * using given:\n *\n * * {@link module:engine/dataprocessor/dataprocessor~DataProcessor data processor},\n * * downcast converters,\n * * upcast converters.\n *\n * An instance of the data controller is always available in the {@link module:core/editor/editor~Editor#data `editor.data`}\n * property:\n *\n *\t\teditor.data.get( { rootName: 'customRoot' } ); // -> '<p>Hello!</p>'\n *\n * @mixes module:utils/observablemixin~ObservableMixin\n */\nexport default class DataController {\n\t/**\n\t * Creates a data controller instance.\n\t *\n\t * @param {module:engine/model/model~Model} model Data model.\n\t * @param {module:engine/dataprocessor/dataprocessor~DataProcessor} [dataProcessor] Data processor that should be used\n\t * by the controller.\n\t */\n\tconstructor( model, dataProcessor ) {\n\t\t/**\n\t\t * Data model.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/model~Model}\n\t\t */\n\t\tthis.model = model;\n\n\t\t/**\n\t\t * Data processor used during the conversion.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/dataprocessor/dataprocessor~DataProcessor}\n\t\t */\n\t\tthis.processor = dataProcessor;\n\n\t\t/**\n\t\t * Mapper used for the conversion. It has no permanent bindings, because they are created when getting data and\n\t\t * cleared directly after the data are converted. However, the mapper is defined as a class property, because\n\t\t * it needs to be passed to the `DowncastDispatcher` as a conversion API.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/conversion/mapper~Mapper}\n\t\t */\n\t\tthis.mapper = new Mapper();\n\n\t\t/**\n\t\t * Downcast dispatcher used by the {@link #get get method}. Downcast converters should be attached to it.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/conversion/downcastdispatcher~DowncastDispatcher}\n\t\t */\n\t\tthis.downcastDispatcher = new DowncastDispatcher( {\n\t\t\tmapper: this.mapper\n\t\t} );\n\t\tthis.downcastDispatcher.on( 'insert:$text', insertText(), { priority: 'lowest' } );\n\n\t\t/**\n\t\t * Upcast dispatcher used by the {@link #set set method}. Upcast converters should be attached to it.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/conversion/upcastdispatcher~UpcastDispatcher}\n\t\t */\n\t\tthis.upcastDispatcher = new UpcastDispatcher( {\n\t\t\tschema: model.schema\n\t\t} );\n\n\t\t// Define default converters for text and elements.\n\t\t//\n\t\t// Note that if there is no default converter for the element it will be skipped, for instance `<b>foo</b>` will be\n\t\t// converted to nothing. We add `convertToModelFragment` as a last converter so it converts children of that\n\t\t// element to the document fragment so `<b>foo</b>` will be converted to `foo` if there is no converter for `<b>`.\n\t\tthis.upcastDispatcher.on( 'text', convertText(), { priority: 'lowest' } );\n\t\tthis.upcastDispatcher.on( 'element', convertToModelFragment(), { priority: 'lowest' } );\n\t\tthis.upcastDispatcher.on( 'documentFragment', convertToModelFragment(), { priority: 'lowest' } );\n\n\t\tthis.decorate( 'init' );\n\n\t\t// Fire `ready` event when initialisation has completed. Such low level listener gives possibility\n\t\t// to plug into initialisation pipeline without interrupting the initialisation flow.\n\t\tthis.on( 'init', () => {\n\t\t\tthis.fire( 'ready' );\n\t\t}, { priority: 'lowest' } );\n\t}\n\n\t/**\n\t * Returns the model's data converted by downcast dispatchers attached to {@link #downcastDispatcher} and\n\t * formatted by the {@link #processor data processor}.\n\t *\n\t * @param {Object} [options]\n\t * @param {String} [options.rootName='main'] Root name.\n\t * @param {String} [options.trim='empty'] Whether returned data should be trimmed. This option is set to `empty` by default,\n\t * which means whenever editor content is considered empty, an empty string will be returned. To turn off trimming completely\n\t * use `'none'`. In such cases exact content will be returned (for example `<p>&nbsp;</p>` for an empty editor).\n\t * @returns {String} Output data.\n\t */\n\tget( options ) {\n\t\tconst { rootName = 'main', trim = 'empty' } = options || {};\n\n\t\tif ( !this._checkIfRootsExists( [ rootName ] ) ) {\n\t\t\t/**\n\t\t\t * Cannot get data from a non-existing root. This error is thrown when {@link #get DataController#get() method}\n\t\t\t * is called with non-existent root name. For example, if there is an editor instance with only `main` root,\n\t\t\t * calling {@link #get} like:\n\t\t\t *\n\t\t\t *\t\tdata.get( { rootName: 'root2' } );\n\t\t\t *\n\t\t\t * will throw this error.\n\t\t\t *\n\t\t\t * @error datacontroller-get-non-existent-root\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'datacontroller-get-non-existent-root: Attempting to get data from a non-existing root.', this );\n\t\t}\n\n\t\tconst root = this.model.document.getRoot( rootName );\n\n\t\tif ( trim === 'empty' && !this.model.hasContent( root, { ignoreWhitespaces: true } ) ) {\n\t\t\treturn '';\n\t\t}\n\n\t\treturn this.stringify( root );\n\t}\n\n\t/**\n\t * Returns the content of the given {@link module:engine/model/element~Element model's element} or\n\t * {@link module:engine/model/documentfragment~DocumentFragment model document fragment} converted by the downcast converters\n\t * attached to {@link #downcastDispatcher} and formatted by the {@link #processor data processor}.\n\t *\n\t * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} modelElementOrFragment\n\t * Element whose content will be stringified.\n\t * @returns {String} Output data.\n\t */\n\tstringify( modelElementOrFragment ) {\n\t\t// Model -> view.\n\t\tconst viewDocumentFragment = this.toView( modelElementOrFragment );\n\n\t\t// View -> data.\n\t\treturn this.processor.toData( viewDocumentFragment );\n\t}\n\n\t/**\n\t * Returns the content of the given {@link module:engine/model/element~Element model element} or\n\t * {@link module:engine/model/documentfragment~DocumentFragment model document fragment} converted by the downcast\n\t * converters attached to {@link #downcastDispatcher} to a\n\t * {@link module:engine/view/documentfragment~DocumentFragment view document fragment}.\n\t *\n\t * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} modelElementOrFragment\n\t * Element or document fragment whose content will be converted.\n\t * @returns {module:engine/view/documentfragment~DocumentFragment} Output view DocumentFragment.\n\t */\n\ttoView( modelElementOrFragment ) {\n\t\t// Clear bindings so the call to this method gives correct results.\n\t\tthis.mapper.clearBindings();\n\n\t\t// First, convert elements.\n\t\tconst modelRange = ModelRange._createIn( modelElementOrFragment );\n\n\t\tconst viewDocumentFragment = new ViewDocumentFragment();\n\n\t\t// Create separate ViewDowncastWriter just for data conversion purposes.\n\t\t// We have no view controller and rendering do DOM in DataController so view.change() block is not used here.\n\t\tconst viewWriter = new ViewDowncastWriter( new ViewDocument() );\n\t\tthis.mapper.bindElements( modelElementOrFragment, viewDocumentFragment );\n\n\t\tthis.downcastDispatcher.convertInsert( modelRange, viewWriter );\n\n\t\tif ( !modelElementOrFragment.is( 'documentFragment' ) ) {\n\t\t\t// Then, if a document element is converted, convert markers.\n\t\t\t// From all document markers, get those, which \"intersect\" with the converter element.\n\t\t\tconst markers = _getMarkersRelativeToElement( modelElementOrFragment );\n\n\t\t\tfor ( const [ name, range ] of markers ) {\n\t\t\t\tthis.downcastDispatcher.convertMarkerAdd( name, range, viewWriter );\n\t\t\t}\n\t\t}\n\n\t\treturn viewDocumentFragment;\n\t}\n\n\t/**\n\t * Sets initial input data parsed by the {@link #processor data processor} and\n\t * converted by the {@link #upcastDispatcher view-to-model converters}.\n\t * Initial data can be set only to document that {@link module:engine/model/document~Document#version} is equal 0.\n\t *\n\t * **Note** This method is {@link module:utils/observablemixin~ObservableMixin#decorate decorated} which is\n\t * used by e.g. collaborative editing plugin that syncs remote data on init.\n\t *\n\t * When data is passed as a string it is initialized on a default `main` root:\n\t *\n\t *\t\tdataController.init( '<p>Foo</p>' ); // Initializes data on the `main` root.\n\t *\n\t * To initialize data on a different root or multiple roots at once, object containing `rootName` - `data` pairs should be passed:\n\t *\n\t *\t\tdataController.init( { main: '<p>Foo</p>', title: '<h1>Bar</h1>' } ); // Initializes data on the `main` and `title` roots.\n\t *\n\t * @fires init\n\t * @param {String|Object.<String,String>} data Input data as a string or an object containing `rootName` - `data`\n\t * pairs to initialize data on multiple roots at once.\n\t * @returns {Promise} Promise that is resolved after the data is set on the editor.\n\t */\n\tinit( data ) {\n\t\tif ( this.model.document.version ) {\n\t\t\t/**\n\t\t\t * Cannot set initial data to not empty {@link module:engine/model/document~Document}.\n\t\t\t * Initial data should be set once, during {@link module:core/editor/editor~Editor} initialization,\n\t\t\t * when the {@link module:engine/model/document~Document#version} is equal 0.\n\t\t\t *\n\t\t\t * @error datacontroller-init-document-not-empty\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'datacontroller-init-document-not-empty: Trying to set initial data to not empty document.', this );\n\t\t}\n\n\t\tlet initialData = {};\n\t\tif ( typeof data === 'string' ) {\n\t\t\tinitialData.main = data; // Default root is 'main'. To initiate data on a different root, object should be passed.\n\t\t} else {\n\t\t\tinitialData = data;\n\t\t}\n\n\t\tif ( !this._checkIfRootsExists( Object.keys( initialData ) ) ) {\n\t\t\t/**\n\t\t\t * Cannot init data on a non-existing root. This error is thrown when {@link #init DataController#init() method}\n\t\t\t * is called with non-existent root name. For example, if there is an editor instance with only `main` root,\n\t\t\t * calling {@link #init} like:\n\t\t\t *\n\t\t\t * \t\tdata.init( { main: '<p>Foo</p>', root2: '<p>Bar</p>' } );\n\t\t\t *\n\t\t\t * will throw this error.\n\t\t\t *\n\t\t\t * @error datacontroller-init-non-existent-root\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'datacontroller-init-non-existent-root: Attempting to init data on a non-existing root.', this );\n\t\t}\n\n\t\tthis.model.enqueueChange( 'transparent', writer => {\n\t\t\tfor ( const rootName of Object.keys( initialData ) ) {\n\t\t\t\tconst modelRoot = this.model.document.getRoot( rootName );\n\t\t\t\twriter.insert( this.parse( initialData[ rootName ], modelRoot ), modelRoot, 0 );\n\t\t\t}\n\t\t} );\n\n\t\treturn Promise.resolve();\n\t}\n\n\t/**\n\t * Sets input data parsed by the {@link #processor data processor} and\n\t * converted by the {@link #upcastDispatcher view-to-model converters}.\n\t * This method can be used any time to replace existing editor data by the new one without clearing the\n\t * {@link module:engine/model/document~Document#history document history}.\n\t *\n\t * This method also creates a batch with all the changes applied. If all you need is to parse data, use\n\t * the {@link #parse} method.\n\t *\n\t * When data is passed as a string it is set on a default `main` root:\n\t *\n\t *\t\tdataController.set( '<p>Foo</p>' ); // Sets data on the `main` root.\n\t *\n\t * To set data on a different root or multiple roots at once, object containing `rootName` - `data` pairs should be passed:\n\t *\n\t *\t\tdataController.set( { main: '<p>Foo</p>', title: '<h1>Bar</h1>' } ); // Sets data on the `main` and `title` roots.\n\t *\n\t * @param {String|Object.<String,String>} data Input data as a string or an object containing `rootName` - `data`\n\t * pairs to set data on multiple roots at once.\n\t */\n\tset( data ) {\n\t\tlet newData = {};\n\n\t\tif ( typeof data === 'string' ) {\n\t\t\tnewData.main = data; // Default root is 'main'. To set data on a different root, object should be passed.\n\t\t} else {\n\t\t\tnewData = data;\n\t\t}\n\n\t\tif ( !this._checkIfRootsExists( Object.keys( newData ) ) ) {\n\t\t\t/**\n\t\t\t * Cannot set data on a non-existing root. This error is thrown when {@link #set DataController#set() method}\n\t\t\t * is called with non-existent root name. For example, if there is an editor instance with only `main` root,\n\t\t\t * calling {@link #set} like:\n\t\t\t *\n\t\t\t * \t\tdata.set( { main: '<p>Foo</p>', root2: '<p>Bar</p>' } );\n\t\t\t *\n\t\t\t * will throw this error.\n\t\t\t *\n\t\t\t * @error datacontroller-set-non-existent-root\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'datacontroller-set-non-existent-root: Attempting to set data on a non-existing root.', this );\n\t\t}\n\n\t\tthis.model.enqueueChange( 'transparent', writer => {\n\t\t\twriter.setSelection( null );\n\t\t\twriter.removeSelectionAttribute( this.model.document.selection.getAttributeKeys() );\n\n\t\t\tfor ( const rootName of Object.keys( newData ) ) {\n\t\t\t\t// Save to model.\n\t\t\t\tconst modelRoot = this.model.document.getRoot( rootName );\n\n\t\t\t\twriter.remove( writer.createRangeIn( modelRoot ) );\n\t\t\t\twriter.insert( this.parse( newData[ rootName ], modelRoot ), modelRoot, 0 );\n\t\t\t}\n\t\t} );\n\t}\n\n\t/**\n\t * Returns the data parsed by the {@link #processor data processor} and then converted by upcast converters\n\t * attached to the {@link #upcastDispatcher}.\n\t *\n\t * @see #set\n\t * @param {String} data Data to parse.\n\t * @param {module:engine/model/schema~SchemaContextDefinition} [context='$root'] Base context in which the view will\n\t * be converted to the model. See: {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher#convert}.\n\t * @returns {module:engine/model/documentfragment~DocumentFragment} Parsed data.\n\t */\n\tparse( data, context = '$root' ) {\n\t\t// data -> view\n\t\tconst viewDocumentFragment = this.processor.toView( data );\n\n\t\t// view -> model\n\t\treturn this.toModel( viewDocumentFragment, context );\n\t}\n\n\t/**\n\t * Returns the result of the given {@link module:engine/view/element~Element view element} or\n\t * {@link module:engine/view/documentfragment~DocumentFragment view document fragment} converted by the\n\t * {@link #upcastDispatcher view-to-model converters}, wrapped by {@link module:engine/model/documentfragment~DocumentFragment}.\n\t *\n\t * When marker elements were converted during the conversion process, it will be set as a document fragment's\n\t * {@link module:engine/model/documentfragment~DocumentFragment#markers static markers map}.\n\t *\n\t * @param {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment} viewElementOrFragment\n\t * Element or document fragment whose content will be converted.\n\t * @param {module:engine/model/schema~SchemaContextDefinition} [context='$root'] Base context in which the view will\n\t * be converted to the model. See: {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher#convert}.\n\t * @returns {module:engine/model/documentfragment~DocumentFragment} Output document fragment.\n\t */\n\ttoModel( viewElementOrFragment, context = '$root' ) {\n\t\treturn this.model.change( writer => {\n\t\t\treturn this.upcastDispatcher.convert( viewElementOrFragment, writer, context );\n\t\t} );\n\t}\n\n\t/**\n\t * Removes all event listeners set by the DataController.\n\t */\n\tdestroy() {\n\t\tthis.stopListening();\n\t}\n\n\t/**\n\t * Checks if all provided root names are existing editor roots.\n\t *\n\t * @private\n\t * @param {Array.<String>} rootNames Root names to check.\n\t * @returns {Boolean} Whether all provided root names are existing editor roots.\n\t */\n\t_checkIfRootsExists( rootNames ) {\n\t\tfor ( const rootName of rootNames ) {\n\t\t\tif ( !this.model.document.getRootNames().includes( rootName ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Event fired once data initialisation has finished.\n\t *\n\t * @event ready\n\t */\n\n\t/**\n\t * Event fired after {@link #init init() method} has been run. It can be {@link #listenTo listened to} to adjust/modify\n\t * the initialisation flow. However, if the `init` event is stopped or prevented, the {@link #event:ready ready event}\n\t * should be fired manually.\n\t *\n\t * The `init` event is fired by decorated {@link #init} method.\n\t * See {@link module:utils/observablemixin~ObservableMixin#decorate} for more information and samples.\n\t *\n\t * @event init\n\t */\n}\n\nmix( DataController, ObservableMixin );\n\n// Helper function for downcast conversion.\n//\n// Takes a document element (element that is added to a model document) and checks which markers are inside it\n// and which markers are containing it. If the marker is intersecting with element, the intersection is returned.\nfunction _getMarkersRelativeToElement( element ) {\n\tconst result = [];\n\tconst doc = element.root.document;\n\n\tif ( !doc ) {\n\t\treturn [];\n\t}\n\n\tconst elementRange = ModelRange._createIn( element );\n\n\tfor ( const marker of doc.model.markers ) {\n\t\tconst intersection = elementRange.getIntersection( marker.getRange() );\n\n\t\tif ( intersection ) {\n\t\t\tresult.push( [ marker.name, intersection ] );\n\t\t}\n\t}\n\n\treturn result;\n}\n"]}]}