{"remainingRequest":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/babel-loader/lib/index.js!/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-engine/src/model/model.js","dependencies":[{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-engine/src/model/model.js","mtime":499162500000},{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js","mtime":499162500000},{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/babel-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:LyoqCiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDE5LCBDS1NvdXJjZSAtIEZyZWRlcmljbyBLbmFiYmVuLiBBbGwgcmlnaHRzIHJlc2VydmVkLgogKiBGb3IgbGljZW5zaW5nLCBzZWUgTElDRU5TRS5tZCBvciBodHRwczovL2NrZWRpdG9yLmNvbS9sZWdhbC9ja2VkaXRvci1vc3MtbGljZW5zZQogKi8KCi8qKgogKiBAbW9kdWxlIGVuZ2luZS9tb2RlbC9tb2RlbAogKi8KaW1wb3J0IEJhdGNoIGZyb20gJy4vYmF0Y2gnOwppbXBvcnQgV3JpdGVyIGZyb20gJy4vd3JpdGVyJzsKaW1wb3J0IFNjaGVtYSBmcm9tICcuL3NjaGVtYSc7CmltcG9ydCBEb2N1bWVudCBmcm9tICcuL2RvY3VtZW50JzsKaW1wb3J0IE1hcmtlckNvbGxlY3Rpb24gZnJvbSAnLi9tYXJrZXJjb2xsZWN0aW9uJzsKaW1wb3J0IE9ic2VydmFibGVNaXhpbiBmcm9tICdAY2tlZGl0b3IvY2tlZGl0b3I1LXV0aWxzL3NyYy9vYnNlcnZhYmxlbWl4aW4nOwppbXBvcnQgbWl4IGZyb20gJ0Bja2VkaXRvci9ja2VkaXRvcjUtdXRpbHMvc3JjL21peCc7CmltcG9ydCBNb2RlbEVsZW1lbnQgZnJvbSAnLi9lbGVtZW50JzsKaW1wb3J0IE1vZGVsUmFuZ2UgZnJvbSAnLi9yYW5nZSc7CmltcG9ydCBNb2RlbFBvc2l0aW9uIGZyb20gJy4vcG9zaXRpb24nOwppbXBvcnQgTW9kZWxTZWxlY3Rpb24gZnJvbSAnLi9zZWxlY3Rpb24nOwppbXBvcnQgaW5zZXJ0Q29udGVudCBmcm9tICcuL3V0aWxzL2luc2VydGNvbnRlbnQnOwppbXBvcnQgZGVsZXRlQ29udGVudCBmcm9tICcuL3V0aWxzL2RlbGV0ZWNvbnRlbnQnOwppbXBvcnQgbW9kaWZ5U2VsZWN0aW9uIGZyb20gJy4vdXRpbHMvbW9kaWZ5c2VsZWN0aW9uJzsKaW1wb3J0IGdldFNlbGVjdGVkQ29udGVudCBmcm9tICcuL3V0aWxzL2dldHNlbGVjdGVkY29udGVudCc7CmltcG9ydCB7IGluamVjdFNlbGVjdGlvblBvc3RGaXhlciB9IGZyb20gJy4vdXRpbHMvc2VsZWN0aW9uLXBvc3QtZml4ZXInOwppbXBvcnQgQ0tFZGl0b3JFcnJvciBmcm9tICdAY2tlZGl0b3IvY2tlZGl0b3I1LXV0aWxzL3NyYy9ja2VkaXRvcmVycm9yJzsgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLyBjb25zdCB7IGR1bXBUcmVlcyB9ID0gcmVxdWlyZSggJy4uL2Rldi11dGlscy91dGlscycgKTsKLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLyBjb25zdCB7IE9wZXJhdGlvblJlcGxheWVyIH0gPSByZXF1aXJlKCAnLi4vZGV2LXV0aWxzL29wZXJhdGlvbnJlcGxheWVyJyApLmRlZmF1bHQ7CgovKioKICogRWRpdG9yJ3MgZGF0YSBtb2RlbC4gUmVhZCBhYm91dCB0aGUgbW9kZWwgaW4gdGhlCiAqIHtAZ2xpbmsgZnJhbWV3b3JrL2d1aWRlcy9hcmNoaXRlY3R1cmUvZWRpdGluZy1lbmdpbmUgZW5naW5lIGFyY2hpdGVjdHVyZSBndWlkZX0uCiAqCiAqIEBtaXhlcyBtb2R1bGU6dXRpbHMvb2JzZXJ2YWJsZW1peGlufk9ic2VydmFibGVNaXhpbgogKi8KCmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1vZGVsIHsKICBjb25zdHJ1Y3RvcigpIHsKICAgIC8qKgogICAgICogTW9kZWwncyBtYXJrZXIgY29sbGVjdGlvbi4KICAgICAqCiAgICAgKiBAcmVhZG9ubHkKICAgICAqIEBtZW1iZXIge21vZHVsZTplbmdpbmUvbW9kZWwvbWFya2VyY29sbGVjdGlvbn5NYXJrZXJDb2xsZWN0aW9ufQogICAgICovCiAgICB0aGlzLm1hcmtlcnMgPSBuZXcgTWFya2VyQ29sbGVjdGlvbigpOwogICAgLyoqCiAgICAgKiBNb2RlbCdzIGRvY3VtZW50LgogICAgICoKICAgICAqIEByZWFkb25seQogICAgICogQG1lbWJlciB7bW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudH5Eb2N1bWVudH0KICAgICAqLwoKICAgIHRoaXMuZG9jdW1lbnQgPSBuZXcgRG9jdW1lbnQodGhpcyk7CiAgICAvKioKICAgICAqIE1vZGVsJ3Mgc2NoZW1hLgogICAgICoKICAgICAqIEByZWFkb25seQogICAgICogQG1lbWJlciB7bW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hfQogICAgICovCgogICAgdGhpcy5zY2hlbWEgPSBuZXcgU2NoZW1hKCk7CiAgICAvKioKICAgICAqIEFsbCBjYWxsYmFja3MgYWRkZWQgYnkge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbW9kZWx+TW9kZWwjY2hhbmdlfSBvcgogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbW9kZWx+TW9kZWwjZW5xdWV1ZUNoYW5nZX0gbWV0aG9kcyB3YWl0aW5nIHRvIGJlIGV4ZWN1dGVkLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAdHlwZSB7QXJyYXkuPEZ1bmN0aW9uPn0KICAgICAqLwoKICAgIHRoaXMuX3BlbmRpbmdDaGFuZ2VzID0gW107CiAgICAvKioKICAgICAqIFRoZSBsYXN0IGNyZWF0ZWQgYW5kIGN1cnJlbnRseSB1c2VkIHdyaXRlciBpbnN0YW5jZS4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQG1lbWJlciB7bW9kdWxlOmVuZ2luZS9tb2RlbC93cml0ZXJ+V3JpdGVyfQogICAgICovCgogICAgdGhpcy5fY3VycmVudFdyaXRlciA9IG51bGw7CiAgICBbJ2luc2VydENvbnRlbnQnLCAnZGVsZXRlQ29udGVudCcsICdtb2RpZnlTZWxlY3Rpb24nLCAnZ2V0U2VsZWN0ZWRDb250ZW50JywgJ2FwcGx5T3BlcmF0aW9uJ10uZm9yRWFjaChtZXRob2ROYW1lID0+IHRoaXMuZGVjb3JhdGUobWV0aG9kTmFtZSkpOyAvLyBBZGRpbmcgb3BlcmF0aW9uIHZhbGlkYXRpb24gd2l0aCBgaGlnaGVzdGAgcHJpb3JpdHksIHNvIGl0IGlzIGNhbGxlZCBiZWZvcmUgYW55IG90aGVyIGZlYXR1cmUgd291bGQgbGlrZQogICAgLy8gdG8gZG8gYW55dGhpbmcgd2l0aCB0aGUgb3BlcmF0aW9uLiBJZiB0aGUgb3BlcmF0aW9uIGhhcyBpbmNvcnJlY3QgcGFyYW1ldGVycyBpdCBzaG91bGQgdGhyb3cgb24gdGhlIGVhcmxpZXN0IG9jY2FzaW9uLgoKICAgIHRoaXMub24oJ2FwcGx5T3BlcmF0aW9uJywgKGV2dCwgYXJncykgPT4gewogICAgICBjb25zdCBvcGVyYXRpb24gPSBhcmdzWzBdOwoKICAgICAgb3BlcmF0aW9uLl92YWxpZGF0ZSgpOwogICAgfSwgewogICAgICBwcmlvcml0eTogJ2hpZ2hlc3QnCiAgICB9KTsgLy8gUmVnaXN0ZXIgc29tZSBkZWZhdWx0IGFic3RyYWN0IGVudGl0aWVzLgoKICAgIHRoaXMuc2NoZW1hLnJlZ2lzdGVyKCckcm9vdCcsIHsKICAgICAgaXNMaW1pdDogdHJ1ZQogICAgfSk7CiAgICB0aGlzLnNjaGVtYS5yZWdpc3RlcignJGJsb2NrJywgewogICAgICBhbGxvd0luOiAnJHJvb3QnLAogICAgICBpc0Jsb2NrOiB0cnVlCiAgICB9KTsKICAgIHRoaXMuc2NoZW1hLnJlZ2lzdGVyKCckdGV4dCcsIHsKICAgICAgYWxsb3dJbjogJyRibG9jaycsCiAgICAgIGlzSW5saW5lOiB0cnVlCiAgICB9KTsKICAgIHRoaXMuc2NoZW1hLnJlZ2lzdGVyKCckY2xpcGJvYXJkSG9sZGVyJywgewogICAgICBhbGxvd0NvbnRlbnRPZjogJyRyb290JywKICAgICAgaXNMaW1pdDogdHJ1ZQogICAgfSk7CiAgICB0aGlzLnNjaGVtYS5leHRlbmQoJyR0ZXh0JywgewogICAgICBhbGxvd0luOiAnJGNsaXBib2FyZEhvbGRlcicKICAgIH0pOyAvLyBBbiBlbGVtZW50IG5lZWRlZCBieSB0aGUgYHVwY2FzdEVsZW1lbnRUb01hcmtlcmAgY29udmVydGVyLgogICAgLy8gVGhpcyBlbGVtZW50IHRlbXBvcmFyaWx5IHJlcHJlc2VudHMgYSBtYXJrZXIgYm91bmRhcnkgZHVyaW5nIHRoZSBjb252ZXJzaW9uIHByb2Nlc3MgYW5kIGlzIHJlbW92ZWQKICAgIC8vIGF0IHRoZSBlbmQgb2YgdGhlIGNvbnZlcnNpb24uIGBVcGNhc3REaXNwYXRjaGVyYCBvciBhdCBsZWFzdCBgQ29udmVyc2lvbmAgY2xhc3MgbG9va3MgbGlrZSBhCiAgICAvLyBiZXR0ZXIgcGxhY2UgZm9yIHRoaXMgcmVnaXN0cmF0aW9uIGJ1dCBib3RoIGtub3cgbm90aGluZyBhYm91dCBgU2NoZW1hYC4KCiAgICB0aGlzLnNjaGVtYS5yZWdpc3RlcignJG1hcmtlcicpOwogICAgdGhpcy5zY2hlbWEuYWRkQ2hpbGRDaGVjaygoY29udGV4dCwgY2hpbGREZWZpbml0aW9uKSA9PiB7CiAgICAgIGlmIChjaGlsZERlZmluaXRpb24ubmFtZSA9PT0gJyRtYXJrZXInKSB7CiAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgIH0KICAgIH0pOwogICAgaW5qZWN0U2VsZWN0aW9uUG9zdEZpeGVyKHRoaXMpOyAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vIHRoaXMub24oICdhcHBseU9wZXJhdGlvbicsICgpID0+IHsKICAgIC8vIEBpZiBDS19ERUJVR19FTkdJTkUgLy8gCWR1bXBUcmVlcyggdGhpcy5kb2N1bWVudCwgdGhpcy5kb2N1bWVudC52ZXJzaW9uICk7CiAgICAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vIH0sIHsgcHJpb3JpdHk6ICdsb3dlc3QnIH0gKTsKICB9CiAgLyoqCiAgICogVGhlIGBjaGFuZ2UoKWAgbWV0aG9kIGlzIHRoZSBwcmltYXJ5IHdheSBvZiBjaGFuZ2luZyB0aGUgbW9kZWwuIFlvdSBzaG91bGQgdXNlIGl0IHRvIG1vZGlmeSBhbGwgZG9jdW1lbnQgbm9kZXMKICAgKiAoaW5jbHVkaW5nIGRldGFjaGVkIG5vZGVzIOKAkyBpLmUuIG5vZGVzIG5vdCBhZGRlZCB0byB0aGUge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbW9kZWx+TW9kZWwjZG9jdW1lbnQgbW9kZWwgZG9jdW1lbnR9KSwKICAgKiB0aGUge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnR+RG9jdW1lbnQjc2VsZWN0aW9uIGRvY3VtZW50J3Mgc2VsZWN0aW9ufSwgYW5kCiAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbW9kZWx+TW9kZWwjbWFya2VycyBtb2RlbCBtYXJrZXJzfS4KICAgKgogICAqCQltb2RlbC5jaGFuZ2UoIHdyaXRlciA9PiB7CiAgICoJCQl3cml0ZXIuaW5zZXJ0VGV4dCggJ2ZvbycsIHBhcmFncmFwaCwgJ2VuZCcgKTsKICAgKgkJfSApOwogICAqCiAgICogQWxsIGNoYW5nZXMgaW5zaWRlIHRoZSBjaGFuZ2UgYmxvY2sgdXNlIHRoZSBzYW1lIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2JhdGNofkJhdGNofSBzbyB0aGV5IGFyZSBjb21iaW5lZAogICAqIGludG8gYSBzaW5nbGUgdW5kbyBzdGVwLgogICAqCiAgICoJCW1vZGVsLmNoYW5nZSggd3JpdGVyID0+IHsKICAgKgkJCXdyaXRlci5pbnNlcnRUZXh0KCAnZm9vJywgcGFyYWdyYXBoLCAnZW5kJyApOyAvLyBmb28uCiAgICoKICAgKgkJCW1vZGVsLmNoYW5nZSggd3JpdGVyID0+IHsKICAgKgkJCQl3cml0ZXIuaW5zZXJ0VGV4dCggJ2JhcicsIHBhcmFncmFwaCwgJ2VuZCcgKTsgLy8gZm9vYmFyLgogICAqCQkJfSApOwogICAqCiAgICogCQkJd3JpdGVyLmluc2VydFRleHQoICdib20nLCBwYXJhZ3JhcGgsICdlbmQnICk7IC8vIGZvb2JhcmJvbS4KICAgKgkJfSApOwogICAqCiAgICogVGhlIGNhbGxiYWNrIG9mIHRoZSBgY2hhbmdlKClgIGJsb2NrIGlzIGV4ZWN1dGVkIHN5bmNocm9ub3VzbHkuCiAgICoKICAgKiBZb3UgY2FuIGFsc28gcmV0dXJuIGEgdmFsdWUgZnJvbSB0aGUgY2hhbmdlIGJsb2NrLgogICAqCiAgICoJCWNvbnN0IGltZyA9IG1vZGVsLmNoYW5nZSggd3JpdGVyID0+IHsKICAgKgkJCXJldHVybiB3cml0ZXIuY3JlYXRlRWxlbWVudCggJ2ltZycgKTsKICAgKgkJfSApOwogICAqCiAgICogQHNlZSAjZW5xdWV1ZUNoYW5nZQogICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uIHdoaWNoIG1heSBtb2RpZnkgdGhlIG1vZGVsLgogICAqIEByZXR1cm5zIHsqfSBWYWx1ZSByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2suCiAgICovCgoKICBjaGFuZ2UoY2FsbGJhY2spIHsKICAgIHRyeSB7CiAgICAgIGlmICh0aGlzLl9wZW5kaW5nQ2hhbmdlcy5sZW5ndGggPT09IDApIHsKICAgICAgICAvLyBJZiB0aGlzIGlzIHRoZSBvdXRlcm1vc3QgYmxvY2ssIGNyZWF0ZSBhIG5ldyBiYXRjaCBhbmQgc3RhcnQgYF9ydW5QZW5kaW5nQ2hhbmdlc2AgZXhlY3V0aW9uIGZsb3cuCiAgICAgICAgdGhpcy5fcGVuZGluZ0NoYW5nZXMucHVzaCh7CiAgICAgICAgICBiYXRjaDogbmV3IEJhdGNoKCksCiAgICAgICAgICBjYWxsYmFjawogICAgICAgIH0pOwoKICAgICAgICByZXR1cm4gdGhpcy5fcnVuUGVuZGluZ0NoYW5nZXMoKVswXTsKICAgICAgfSBlbHNlIHsKICAgICAgICAvLyBJZiB0aGlzIGlzIG5vdCB0aGUgb3V0ZXJtb3N0IGJsb2NrLCBqdXN0IGV4ZWN1dGUgdGhlIGNhbGxiYWNrLgogICAgICAgIHJldHVybiBjYWxsYmFjayh0aGlzLl9jdXJyZW50V3JpdGVyKTsKICAgICAgfQogICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgIC8vIEBpZiBDS19ERUJVRyAvLyB0aHJvdyBlcnI7CgogICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLwogICAgICBDS0VkaXRvckVycm9yLnJldGhyb3dVbmV4cGVjdGVkRXJyb3IoZXJyLCB0aGlzKTsKICAgIH0KICB9CiAgLyoqCiAgICogVGhlIGBlbnF1ZXVlQ2hhbmdlKClgIG1ldGhvZCBwZXJmb3JtcyBzaW1pbGFyIHRhc2sgYXMgdGhlIHtAbGluayAjY2hhbmdlIGBjaGFuZ2UoKWAgbWV0aG9kfSwgd2l0aCB0d28gbWFqb3IgZGlmZmVyZW5jZXMuCiAgICoKICAgKiBGaXJzdCwgdGhlIGNhbGxiYWNrIG9mIGBlbnF1ZXVlQ2hhbmdlKClgIGlzIGV4ZWN1dGVkIHdoZW4gYWxsIG90aGVyIGVucXVldWVkIGNoYW5nZXMgYXJlIGRvbmUuIEl0IG1pZ2h0IGJlIGV4ZWN1dGVkCiAgICogaW1tZWRpYXRlbHkgaWYgaXQgaXMgbm90IG5lc3RlZCBpbiBhbnkgb3RoZXIgY2hhbmdlIGJsb2NrLCBidXQgaWYgaXQgaXMgbmVzdGVkIGluIGFub3RoZXIgKGVucXVldWUpY2hhbmdlIGJsb2NrLAogICAqIGl0IHdpbGwgYmUgZGVsYXllZCBhbmQgZXhlY3V0ZWQgYWZ0ZXIgdGhlIG91dGVybW9zdCBibG9jay4KICAgKgogICAqCQltb2RlbC5jaGFuZ2UoIHdyaXRlciA9PiB7CiAgICoJCQljb25zb2xlLmxvZyggMSApOwogICAqCiAgICoJCQltb2RlbC5lbnF1ZXVlQ2hhbmdlKCB3cml0ZXIgPT4gewogICAqCQkJCWNvbnNvbGUubG9nKCAyICk7CiAgICoJCQl9ICk7CiAgICoKICAgKiAJCQljb25zb2xlLmxvZyggMyApOwogICAqCQl9ICk7IC8vIFdpbGwgbG9nOiAxLCAzLCAyLgogICAqCiAgICogU2Vjb25kLCBpdCBsZXRzIHlvdSBkZWZpbmUgdGhlIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2JhdGNofkJhdGNofSBpbnRvIHdoaWNoIHlvdSB3YW50IHRvIGFkZCB5b3VyIGNoYW5nZXMuCiAgICogQnkgZGVmYXVsdCwgYSBuZXcgYmF0Y2ggaXMgY3JlYXRlZC4gSW4gdGhlIHNhbXBsZSBhYm92ZSwgYGNoYW5nZWAgYW5kIGBlbnF1ZXVlQ2hhbmdlYCBibG9ja3MgdXNlIGEgZGlmZmVyZW50CiAgICogYmF0Y2ggKGFuZCBkaWZmZXJlbnQge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvd3JpdGVyfldyaXRlcn0gc2luY2UgZWFjaCBvZiB0aGVtIG9wZXJhdGVzIG9uIHRoZSBzZXBhcmF0ZSBiYXRjaCkuCiAgICoKICAgKiBXaGVuIHVzaW5nIHRoZSBgZW5xdWV1ZUNoYW5nZSgpYCBibG9jayB5b3UgY2FuIGFsc28gYWRkIHNvbWUgY2hhbmdlcyB0byB0aGUgYmF0Y2ggeW91IHVzZWQgYmVmb3JlLgogICAqCiAgICoJCW1vZGVsLmVucXVldWVDaGFuZ2UoIGJhdGNoLCB3cml0ZXIgPT4gewogICAqCQkJd3JpdGVyLmluc2VydFRleHQoICdmb28nLCBwYXJhZ3JhcGgsICdlbmQnICk7CiAgICoJCX0gKTsKICAgKgogICAqIFRoZSBiYXRjaCBpbnN0YW5jZSBjYW4gYmUgb2J0YWluZWQgZnJvbSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC93cml0ZXJ+V3JpdGVyI2JhdGNoIHRoZSB3cml0ZXJ9LgogICAqCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2JhdGNofkJhdGNofCd0cmFuc3BhcmVudCd8J2RlZmF1bHQnfSBiYXRjaE9yVHlwZSBCYXRjaCBvciBiYXRjaCB0eXBlIHNob3VsZCBiZSB1c2VkIGluIHRoZSBjYWxsYmFjay4KICAgKiBJZiBub3QgZGVmaW5lZCwgYSBuZXcgYmF0Y2ggd2lsbCBiZSBjcmVhdGVkLgogICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uIHdoaWNoIG1heSBtb2RpZnkgdGhlIG1vZGVsLgogICAqLwoKCiAgZW5xdWV1ZUNoYW5nZShiYXRjaE9yVHlwZSwgY2FsbGJhY2spIHsKICAgIHRyeSB7CiAgICAgIGlmICh0eXBlb2YgYmF0Y2hPclR5cGUgPT09ICdzdHJpbmcnKSB7CiAgICAgICAgYmF0Y2hPclR5cGUgPSBuZXcgQmF0Y2goYmF0Y2hPclR5cGUpOwogICAgICB9IGVsc2UgaWYgKHR5cGVvZiBiYXRjaE9yVHlwZSA9PSAnZnVuY3Rpb24nKSB7CiAgICAgICAgY2FsbGJhY2sgPSBiYXRjaE9yVHlwZTsKICAgICAgICBiYXRjaE9yVHlwZSA9IG5ldyBCYXRjaCgpOwogICAgICB9CgogICAgICB0aGlzLl9wZW5kaW5nQ2hhbmdlcy5wdXNoKHsKICAgICAgICBiYXRjaDogYmF0Y2hPclR5cGUsCiAgICAgICAgY2FsbGJhY2sKICAgICAgfSk7CgogICAgICBpZiAodGhpcy5fcGVuZGluZ0NoYW5nZXMubGVuZ3RoID09IDEpIHsKICAgICAgICB0aGlzLl9ydW5QZW5kaW5nQ2hhbmdlcygpOwogICAgICB9CiAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgLy8gQGlmIENLX0RFQlVHIC8vIHRocm93IGVycjsKCiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovCiAgICAgIENLRWRpdG9yRXJyb3IucmV0aHJvd1VuZXhwZWN0ZWRFcnJvcihlcnIsIHRoaXMpOwogICAgfQogIH0KICAvKioKICAgKiB7QGxpbmsgbW9kdWxlOnV0aWxzL29ic2VydmFibGVtaXhpbn5PYnNlcnZhYmxlTWl4aW4jZGVjb3JhdGUgRGVjb3JhdGVkfSBmdW5jdGlvbiBmb3IgYXBwbHlpbmcKICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9vcGVyYXRpb24vb3BlcmF0aW9ufk9wZXJhdGlvbiBvcGVyYXRpb25zfSB0byB0aGUgbW9kZWwuCiAgICoKICAgKiBUaGlzIGlzIGEgbG93LWxldmVsIHdheSBvZiBjaGFuZ2luZyB0aGUgbW9kZWwuIEl0IGlzIGV4cG9zZWQgZm9yIHZlcnkgc3BlY2lmaWMgdXNlIGNhc2VzIChsaWtlIHRoZSB1bmRvIGZlYXR1cmUpLgogICAqIE5vcm1hbGx5LCB0byBtb2RpZnkgdGhlIG1vZGVsLCB5b3Ugd2lsbCB3YW50IHRvIHVzZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC93cml0ZXJ+V3JpdGVyIGBXcml0ZXJgfS4KICAgKiBTZWUgYWxzbyB7QGdsaW5rIGZyYW1ld29yay9ndWlkZXMvYXJjaGl0ZWN0dXJlL2VkaXRpbmctZW5naW5lI2NoYW5naW5nLXRoZS1tb2RlbCBDaGFuZ2luZyB0aGUgbW9kZWx9IHNlY3Rpb24KICAgKiBvZiB0aGUge0BnbGluayBmcmFtZXdvcmsvZ3VpZGVzL2FyY2hpdGVjdHVyZS9lZGl0aW5nLWVuZ2luZSBFZGl0aW5nIGFyY2hpdGVjdHVyZX0gZ3VpZGUuCiAgICoKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvb3BlcmF0aW9uL29wZXJhdGlvbn5PcGVyYXRpb259IG9wZXJhdGlvbiBUaGUgb3BlcmF0aW9uIHRvIGFwcGx5LgogICAqLwoKCiAgYXBwbHlPcGVyYXRpb24ob3BlcmF0aW9uKSB7CiAgICAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vIGNvbnNvbGUubG9nKCAnQXBwbHlpbmcgJyArIG9wZXJhdGlvbiApOwogICAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLyBpZiAoICF0aGlzLl9vcGVyYXRpb25Mb2dzICkgewogICAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLwl0aGlzLl9vcGVyYXRpb25Mb2dzID0gW107CiAgICAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vIH0KICAgIC8vIEBpZiBDS19ERUJVR19FTkdJTkUgLy8gdGhpcy5fb3BlcmF0aW9uTG9ncy5wdXNoKCBKU09OLnN0cmluZ2lmeSggb3BlcmF0aW9uICkgKTsKICAgIC8vIEBpZiBDS19ERUJVR19FTkdJTkUgLy9pZiAoICF0aGlzLl9hcHBsaWVkT3BlcmF0aW9ucyApIHsKICAgIC8vIEBpZiBDS19ERUJVR19FTkdJTkUgLy8JdGhpcy5fYXBwbGllZE9wZXJhdGlvbnMgPSBbXTsKICAgIC8vIEBpZiBDS19ERUJVR19FTkdJTkUgLy99CiAgICAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vdGhpcy5fYXBwbGllZE9wZXJhdGlvbnMucHVzaCggb3BlcmF0aW9uICk7CiAgICBvcGVyYXRpb24uX2V4ZWN1dGUoKTsKICB9IC8vIEBpZiBDS19ERUJVR19FTkdJTkUgLy8gZ2V0QXBwbGllZE9wZXJhdGlvbigpIHsKICAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vCWlmICggIXRoaXMuX2FwcGxpZWRPcGVyYXRpb25zICkgewogIC8vIEBpZiBDS19ERUJVR19FTkdJTkUgLy8JCXJldHVybiAnJzsKICAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vCX0KICAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vCXJldHVybiB0aGlzLl9hcHBsaWVkT3BlcmF0aW9ucy5tYXAoIEpTT04uc3RyaW5naWZ5ICkuam9pbiggJy0tLS0tLS0nICk7CiAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLyB9CiAgLy8gQGlmIENLX0RFQlVHX0VOR0lORSAvLyBjcmVhdGVSZXBsYXllciggc3RyaW5naWZpZWRPcGVyYXRpb25zICkgewogIC8vIEBpZiBDS19ERUJVR19FTkdJTkUgLy8JcmV0dXJuIG5ldyBPcGVyYXRpb25SZXBsYXllciggdGhpcywgJy0tLS0tLS0nLCBzdHJpbmdpZmllZE9wZXJhdGlvbnMgKTsKICAvLyBAaWYgQ0tfREVCVUdfRU5HSU5FIC8vIH0KCiAgLyoqCiAgICogSW5zZXJ0cyBjb250ZW50IGF0IHRoZSBwb3NpdGlvbiBpbiB0aGUgZWRpdG9yIHNwZWNpZmllZCBieSB0aGUgc2VsZWN0aW9uLCBhcyBvbmUgd291bGQgZXhwZWN0IHRoZSBwYXN0ZQogICAqIGZ1bmN0aW9uYWxpdHkgdG8gd29yay4KICAgKgogICAqIFRoaXMgaXMgYSBoaWdoLWxldmVsIG1ldGhvZC4gSXQgdGFrZXMgdGhlIHtAbGluayAjc2NoZW1hIHNjaGVtYX0gaW50byBjb25zaWRlcmF0aW9uIHdoZW4gaW5zZXJ0aW5nCiAgICogdGhlIGNvbnRlbnQsIGNsZWFycyB0aGUgZ2l2ZW4gc2VsZWN0aW9uJ3MgY29udGVudCBiZWZvcmUgaW5zZXJ0aW5nIG5vZGVzIGFuZCBtb3ZlcyB0aGUgc2VsZWN0aW9uCiAgICogdG8gaXRzIHRhcmdldCBwb3NpdGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBwcm9jZXNzLgogICAqIEl0IGNhbiBzcGxpdCBlbGVtZW50cywgbWVyZ2UgdGhlbSwgd3JhcCBiYXJlIHRleHQgbm9kZXMgd2l0aCBwYXJhZ3JhcGhzLCBldGMuICZtZGFzaDsganVzdCBsaWtlIHRoZQogICAqIHBhc3RpbmcgZmVhdHVyZSBzaG91bGQgZG8uCiAgICoKICAgKiBGb3IgbG93ZXItbGV2ZWwgbWV0aG9kcyBzZWUge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvd3JpdGVyfldyaXRlciBgV3JpdGVyYH0uCiAgICoKICAgKiBUaGlzIG1ldGhvZCwgdW5saWtlIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3dyaXRlcn5Xcml0ZXIgYFdyaXRlcmB9J3MgbWV0aG9kcywgZG9lcyBub3QgaGF2ZSB0byBiZSB1c2VkCiAgICogaW5zaWRlIGEge0BsaW5rICNjaGFuZ2UgYGNoYW5nZSgpYCBibG9ja30uCiAgICoKICAgKiAjIENvbnZlcnNpb24gYW5kIHNjaGVtYQogICAqCiAgICogSW5zZXJ0aW5nIGVsZW1lbnRzIGFuZCB0ZXh0IG5vZGVzIGludG8gdGhlIG1vZGVsIGlzIG5vdCBlbm91Z2ggdG8gbWFrZSBDS0VkaXRvciA1IHJlbmRlciB0aGF0IGNvbnRlbnQKICAgKiB0byB0aGUgdXNlci4gQ0tFZGl0b3IgNSBpbXBsZW1lbnRzIGEgbW9kZWwtdmlldy1jb250cm9sbGVyIGFyY2hpdGVjdHVyZSBhbmQgd2hhdCBgbW9kZWwuaW5zZXJ0Q29udGVudCgpYCBkb2VzCiAgICogaXMgb25seSBhZGRpbmcgbm9kZXMgdG8gdGhlIG1vZGVsLiBBZGRpdGlvbmFsbHksIHlvdSBuZWVkIHRvIGRlZmluZQogICAqIHtAZ2xpbmsgZnJhbWV3b3JrL2d1aWRlcy9hcmNoaXRlY3R1cmUvZWRpdGluZy1lbmdpbmUjY29udmVyc2lvbiBjb252ZXJ0ZXJzfSBiZXR3ZWVuIHRoZSBtb2RlbCBhbmQgdmlldwogICAqIGFuZCBkZWZpbmUgdGhvc2Ugbm9kZXMgaW4gdGhlIHtAZ2xpbmsgZnJhbWV3b3JrL2d1aWRlcy9hcmNoaXRlY3R1cmUvZWRpdGluZy1lbmdpbmUjc2NoZW1hIHNjaGVtYX0uCiAgICoKICAgKiBTbywgd2hpbGUgdGhpcyBtZXRob2QgbWF5IHNlZW0gc2ltaWxhciB0byBDS0VkaXRvciA0IGBlZGl0b3IuaW5zZXJ0SHRtbCgpYCAoaW4gZmFjdCwgYm90aCBtZXRob2RzCiAgICogYXJlIHVzZWQgZm9yIHBhc3RlLWxpa2UgY29udGVudCBpbnNlcnRpb24pLCB0aGUgQ0tFZGl0b3IgNSBtZXRob2QgY2Fubm90IGJlIHVzZSB0byBpbnNlcnQgYXJiaXRyYXJ5IEhUTUwKICAgKiB1bmxlc3MgY29udmVydGVycyBhcmUgZGVmaW5lZCBmb3IgYWxsIGVsZW1lbnRzIGFuZCBhdHRyaWJ1dGVzIGluIHRoYXQgSFRNTC4KICAgKgogICAqICMgRXhhbXBsZXMKICAgKgogICAqIFVzaW5nIGBpbnNlcnRDb250ZW50KClgIHdpdGggYSBtYW51YWxseSBjcmVhdGVkIG1vZGVsIHN0cnVjdHVyZToKICAgKgogICAqCQkvLyBMZXQncyBjcmVhdGUgYSBkb2N1bWVudCBmcmFnbWVudCBjb250YWluaW5nIHN1Y2ggY29udGVudCBhczoKICAgKgkJLy8KICAgKgkJLy8gPHBhcmFncmFwaD5mb288L3BhcmFncmFwaD4KICAgKgkJLy8gPGJsb2NrUXVvdGU+CiAgICoJCS8vICAgIDxwYXJhZ3JhcGg+YmFyPC9wYXJhZ3JhcGg+CiAgICoJCS8vIDwvYmxvY2tRdW90ZT4KICAgKgkJY29uc3QgZG9jRnJhZyA9IGVkaXRvci5tb2RlbC5jaGFuZ2UoIHdyaXRlciA9PiB7CiAgICoJCQljb25zdCBwMSA9IHdyaXRlci5jcmVhdGVFbGVtZW50KCAncGFyYWdyYXBoJyApOwogICAqCQkJY29uc3QgcDIgPSB3cml0ZXIuY3JlYXRlRWxlbWVudCggJ3BhcmFncmFwaCcgKTsKICAgKgkJCWNvbnN0IGJsb2NrUXVvdGUgPSB3cml0ZXIuY3JlYXRlRWxlbWVudCggJ2Jsb2NrUXVvdGUnICk7CiAgICoJCQljb25zdCBkb2NGcmFnID0gd3JpdGVyLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTsKICAgKgogICAqCQkJd3JpdGVyLmFwcGVuZCggcDEsIGRvY0ZyYWcgKTsKICAgKgkJCXdyaXRlci5hcHBlbmQoIGJsb2NrUXVvdGUsIGRvY0ZyYWcgKTsKICAgKgkJCXdyaXRlci5hcHBlbmQoIHAyLCBibG9ja1F1b3RlICk7CiAgICoJCQl3cml0ZXIuaW5zZXJ0VGV4dCggJ2ZvbycsIHAxICk7CiAgICoJCQl3cml0ZXIuaW5zZXJ0VGV4dCggJ2JhcicsIHAyICk7CiAgICoKICAgKgkJCXJldHVybiBkb2NGcmFnOwogICAqCQl9ICk7CiAgICoKICAgKgkJLy8gaW5zZXJ0Q29udGVudCgpIGRvZXMgbm90IGhhdmUgdG8gYmUgdXNlZCBpbiBhIGNoYW5nZSgpIGJsb2NrLiBJdCBjYW4sIHRob3VnaCwKICAgKgkJLy8gc28gdGhpcyBjb2RlIGNvdWxkIGJlIG1vdmVkIHRvIHRoZSBjYWxsYmFjayBkZWZpbmVkIGFib3ZlLgogICAqCQllZGl0b3IubW9kZWwuaW5zZXJ0Q29udGVudCggZG9jRnJhZyApOwogICAqCiAgICogVXNpbmcgYGluc2VydENvbnRlbnQoKWAgd2l0aCBhbiBIVE1MIHN0cmluZyBjb252ZXJ0ZWQgdG8gYSBtb2RlbCBkb2N1bWVudCBmcmFnbWVudCAoc2ltaWxhciB0byB0aGUgcGFzdGluZyBtZWNoYW5pc20pOgogICAqCiAgICoJCS8vIFlvdSBjYW4gY3JlYXRlIHlvdXIgb3duIEh0bWxEYXRhUHJvY2Vzc29yIGluc3RhbmNlIG9yIHVzZSBlZGl0b3IuZGF0YS5wcm9jZXNzb3IKICAgKgkJLy8gaWYgeW91IGhhdmUgbm90IG92ZXJyaWRkZW4gdGhlIGRlZmF1bHQgb25lICh3aGljaCBpcyB0aGUgSHRtbERhdGFQcm9jZXNzb3IgaW5zdGFuY2UpLgogICAqCQljb25zdCBodG1sRFAgPSBuZXcgSHRtbERhdGFQcm9jZXNzb3IoKTsKICAgKgogICAqCQkvLyBDb252ZXJ0IGFuIEhUTUwgc3RyaW5nIHRvIGEgdmlldyBkb2N1bWVudCBmcmFnbWVudDoKICAgKgkJY29uc3Qgdmlld0ZyYWdtZW50ID0gaHRtbERQLnRvVmlldyggaHRtbFN0cmluZyApOwogICAqCiAgICoJCS8vIENvbnZlcnQgdGhlIHZpZXcgZG9jdW1lbnQgZnJhZ21lbnQgdG8gYSBtb2RlbCBkb2N1bWVudCBmcmFnbWVudAogICAqCQkvLyBpbiB0aGUgY29udGV4dCBvZiAkcm9vdC4gVGhpcyBjb252ZXJzaW9uIHRha2VzIHRoZSBzY2hlbWEgaW50bwogICAqCQkvLyBhY2NvdW50IHNvIGlmLCBmb3IgZXhhbXBsZSwgdGhlIHZpZXcgZG9jdW1lbnQgZnJhZ21lbnQgY29udGFpbmVkIGEgYmFyZSB0ZXh0IG5vZGUsCiAgICoJCS8vIHRoaXMgdGV4dCBub2RlIGNhbm5vdCBiZSBhIGNoaWxkIG9mICRyb290LCBzbyBpdCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkKICAgKgkJLy8gd3JhcHBlZCB3aXRoIGEgPHBhcmFncmFwaD4uIFlvdSBjYW4gZGVmaW5lIHRoZSBjb250ZXh0IHlvdXJzZWxmIChpbiB0aGUgc2Vjb25kIHBhcmFtZXRlciksCiAgICoJCS8vIGFuZCBlLmcuIGNvbnZlcnQgdGhlIGNvbnRlbnQgbGlrZSBpdCB3b3VsZCBoYXBwZW4gaW4gYSA8cGFyYWdyYXBoPi4KICAgKgkJLy8gTm90ZTogVGhlIGNsaXBib2FyZCBmZWF0dXJlIHVzZXMgYSBjdXN0b20gY29udGV4dCBjYWxsZWQgJGNsaXBib2FyZEhvbGRlcgogICAqCQkvLyB3aGljaCBoYXMgYSBsb29zZW5lZCBzY2hlbWEuCiAgICoJCWNvbnN0IG1vZGVsRnJhZ21lbnQgPSBlZGl0b3IuZGF0YS50b01vZGVsKCB2aWV3RnJhZ21lbnQgKTsKICAgKgogICAqCQllZGl0b3IubW9kZWwuaW5zZXJ0Q29udGVudCggbW9kZWxGcmFnbWVudCApOwogICAqCiAgICogQnkgZGVmYXVsdCB0aGlzIG1ldGhvZCB3aWxsIHVzZSB0aGUgZG9jdW1lbnQgc2VsZWN0aW9uIGJ1dCBpdCBjYW4gYWxzbyBiZSB1c2VkIHdpdGggYSBwb3NpdGlvbiwgcmFuZ2Ugb3Igc2VsZWN0aW9uIGluc3RhbmNlLgogICAqCiAgICoJCS8vIEluc2VydCB0ZXh0IGF0IHRoZSBjdXJyZW50IGRvY3VtZW50IHNlbGVjdGlvbiBwb3NpdGlvbi4KICAgKgkJZWRpdG9yLm1vZGVsLmNoYW5nZSggd3JpdGVyID0+IHsKICAgKgkJCWVkaXRvci5tb2RlbC5pbnNlcnRDb250ZW50KCB3cml0ZXIuY3JlYXRlVGV4dCggJ3gnICkgKTsKICAgKgkJfSApOwogICAqCiAgICoJCS8vIEluc2VydCB0ZXh0IGF0IGEgZ2l2ZW4gcG9zaXRpb24gLSB0aGUgZG9jdW1lbnQgc2VsZWN0aW9uIHdpbGwgbm90IGJlIG1vZGlmaWVkLgogICAqCQllZGl0b3IubW9kZWwuY2hhbmdlKCB3cml0ZXIgPT4gewogICAqCQkJZWRpdG9yLm1vZGVsLmluc2VydENvbnRlbnQoIHdyaXRlci5jcmVhdGVUZXh0KCAneCcgKSwgZG9jLmdldFJvb3QoKSwgMiApOwogICAqCiAgICoJCQkvLyBXaGljaCBpcyBhIHNob3J0aGFuZCBmb3I6CiAgICoJCQllZGl0b3IubW9kZWwuaW5zZXJ0Q29udGVudCggd3JpdGVyLmNyZWF0ZVRleHQoICd4JyApLCB3cml0ZXIuY3JlYXRlUG9zaXRpb25BdCggZG9jLmdldFJvb3QoKSwgMiApICk7CiAgICoJCX0gKTsKICAgKgogICAqIElmIGFuIGluc3RhbmNlIG9mIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NlbGVjdGlvbn5TZWxlY3Rpb259IGlzIHBhc3NlZCBhcyBgc2VsZWN0YWJsZWAKICAgKiBpdCB3aWxsIGJlIG1vdmVkIHRvIHRoZSB0YXJnZXQgcG9zaXRpb24gKHdoZXJlIHRoZSBkb2N1bWVudCBzZWxlY3Rpb24gc2hvdWxkIGJlIG1vdmVkIGFmdGVyIHRoZSBpbnNlcnRpb24pLgogICAqCiAgICoJCWVkaXRvci5tb2RlbC5jaGFuZ2UoIHdyaXRlciA9PiB7CiAgICoJCQkvLyBJbnNlcnQgdGV4dCByZXBsYWNpbmcgdGhlIGdpdmVuIHNlbGVjdGlvbiBpbnN0YW5jZS4KICAgKgkJCWNvbnN0IHNlbGVjdGlvbiA9IHdyaXRlci5jcmVhdGVTZWxlY3Rpb24oIHBhcmFncmFwaCwgJ2luJyApOwogICAqCiAgICoJCQllZGl0b3IubW9kZWwuaW5zZXJ0Q29udGVudCggd3JpdGVyLmNyZWF0ZVRleHQoICd4JyApLCBzZWxlY3Rpb24gKTsKICAgKgogICAqCQkJLy8gaW5zZXJ0Q29udGVudCgpIG1vZGlmaWVzIHRoZSBwYXNzZWQgc2VsZWN0aW9uIGluc3RhbmNlIHNvIGl0IGNhbiBiZSB1c2VkIHRvIHNldCB0aGUgZG9jdW1lbnQgc2VsZWN0aW9uLgogICAqCQkJLy8gTm90ZTogVGhpcyBpcyBub3QgbmVjZXNzYXJ5IHdoZW4geW91IHBhc3NlZCB0aGUgZG9jdW1lbnQgc2VsZWN0aW9uIHRvIGluc2VydENvbnRlbnQoKS4KICAgKgkJCXdyaXRlci5zZXRTZWxlY3Rpb24oIHNlbGVjdGlvbiApOwogICAqCQl9ICk7CiAgICoKICAgKiBAZmlyZXMgaW5zZXJ0Q29udGVudAogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnR8bW9kdWxlOmVuZ2luZS9tb2RlbC9pdGVtfkl0ZW19IGNvbnRlbnQgVGhlIGNvbnRlbnQgdG8gaW5zZXJ0LgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9zZWxlY3Rpb25+U2VsZWN0YWJsZX0gW3NlbGVjdGFibGU9bW9kZWwuZG9jdW1lbnQuc2VsZWN0aW9uXQogICAqIFRoZSBzZWxlY3Rpb24gaW50byB3aGljaCB0aGUgY29udGVudCBzaG91bGQgYmUgaW5zZXJ0ZWQuIElmIG5vdCBwcm92aWRlZCB0aGUgY3VycmVudCBtb2RlbCBkb2N1bWVudCBzZWxlY3Rpb24gd2lsbCBiZSB1c2VkLgogICAqIEBwYXJhbSB7TnVtYmVyfCdiZWZvcmUnfCdlbmQnfCdhZnRlcid8J29uJ3wnaW4nfSBbcGxhY2VPck9mZnNldF0gVG8gYmUgdXNlZCB3aGVuIGEgbW9kZWwgaXRlbSB3YXMgcGFzc2VkIGFzIGBzZWxlY3RhYmxlYC4KICAgKiBUaGlzIHBhcmFtIGRlZmluZXMgYSBwb3NpdGlvbiBpbiByZWxhdGlvbiB0byB0aGF0IGl0ZW0uCiAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2V9IFJhbmdlIHdoaWNoIGNvbnRhaW5zIGFsbCB0aGUgcGVyZm9ybWVkIGNoYW5nZXMuIFRoaXMgaXMgYSByYW5nZSB0aGF0LCBpZiByZW1vdmVkLAogICAqIHdvdWxkIHJldHVybiB0aGUgbW9kZWwgdG8gdGhlIHN0YXRlIGJlZm9yZSB0aGUgaW5zZXJ0aW9uLiBJZiBubyBjaGFuZ2VzIHdlcmUgcHJlZm9ybWVkIGJ5IGBpbnNlcnRDb250ZW50YCwgcmV0dXJucyBhIHJhbmdlIGNvbGxhcHNlZAogICAqIGF0IHRoZSBpbnNlcnRpb24gcG9zaXRpb24uCiAgICovCgoKICBpbnNlcnRDb250ZW50KGNvbnRlbnQsIHNlbGVjdGFibGUsIHBsYWNlT3JPZmZzZXQpIHsKICAgIHJldHVybiBpbnNlcnRDb250ZW50KHRoaXMsIGNvbnRlbnQsIHNlbGVjdGFibGUsIHBsYWNlT3JPZmZzZXQpOwogIH0KICAvKioKICAgKiBEZWxldGVzIGNvbnRlbnQgb2YgdGhlIHNlbGVjdGlvbiBhbmQgbWVyZ2Ugc2libGluZ3MuIFRoZSByZXN1bHRpbmcgc2VsZWN0aW9uIGlzIGFsd2F5cyBjb2xsYXBzZWQuCiAgICoKICAgKiAqKk5vdGU6KiogRm9yIHRoZSBzYWtlIG9mIHByZWRpY3RhYmlsaXR5LCB0aGUgcmVzdWx0aW5nIHNlbGVjdGlvbiBzaG91bGQgYWx3YXlzIGJlIGNvbGxhcHNlZC4KICAgKiBJbiBjYXNlcyB3aGVyZSBhIGZlYXR1cmUgd2FudHMgdG8gbW9kaWZ5IGRlbGV0aW5nIGJlaGF2aW9yIHNvIHNlbGVjdGlvbiBpc24ndCBjb2xsYXBzZWQKICAgKiAoZS5nLiBhIHRhYmxlIGZlYXR1cmUgbWF5IHdhbnQgdG8ga2VlcCByb3cgc2VsZWN0aW9uIGFmdGVyIHByZXNzaW5nIDxrYmQ+QmFja3NwYWNlPC9rYmQ+KSwKICAgKiB0aGVuIHRoYXQgYmVoYXZpb3Igc2hvdWxkIGJlIGltcGxlbWVudGVkIGluIHRoZSB2aWV3J3MgbGlzdGVuZXIuIEF0IHRoZSBzYW1lIHRpbWUsIHRoZSB0YWJsZSBmZWF0dXJlCiAgICogd2lsbCBuZWVkIHRvIG1vZGlmeSB0aGlzIG1ldGhvZCdzIGJlaGF2aW9yIHRvbywgZS5nLiB0byAiZGVsZXRlIGNvbnRlbnRzIGFuZCB0aGVuIGNvbGxhcHNlCiAgICogdGhlIHNlbGVjdGlvbiBpbnNpZGUgdGhlIGxhc3Qgc2VsZWN0ZWQgY2VsbCIgb3IgImRlbGV0ZSB0aGUgcm93IGFuZCBjb2xsYXBzZSBzZWxlY3Rpb24gc29tZXdoZXJlIG5lYXIiLgogICAqIFRoYXQgbmVlZHMgdG8gYmUgZG9uZSBpbiBvcmRlciB0byBlbnN1cmUgdGhhdCBvdGhlciBmZWF0dXJlcyB3aGljaCB1c2UgYGRlbGV0ZUNvbnRlbnQoKWAgd2lsbCB3b3JrIHdlbGwgd2l0aCB0YWJsZXMuCiAgICoKICAgKiBAZmlyZXMgZGVsZXRlQ29udGVudAogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9zZWxlY3Rpb25+U2VsZWN0aW9ufG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnRzZWxlY3Rpb25+RG9jdW1lbnRTZWxlY3Rpb259IHNlbGVjdGlvbgogICAqIFNlbGVjdGlvbiBvZiB3aGljaCB0aGUgY29udGVudCBzaG91bGQgYmUgZGVsZXRlZC4KICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdCiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5sZWF2ZVVubWVyZ2VkPWZhbHNlXSBXaGV0aGVyIHRvIG1lcmdlIGVsZW1lbnRzIGFmdGVyIHJlbW92aW5nIHRoZSBjb250ZW50IG9mIHRoZSBzZWxlY3Rpb24uCiAgICoKICAgKiBGb3IgZXhhbXBsZSBgPGhlYWRpbmcxPnhbeDwvaGVhZGluZzE+PHBhcmFncmFwaD55XXk8L3BhcmFncmFwaD5gIHdpbGwgYmVjb21lOgogICAqCiAgICogKiBgPGhlYWRpbmcxPnheeTwvaGVhZGluZzE+YCB3aXRoIHRoZSBvcHRpb24gZGlzYWJsZWQgKGBsZWF2ZVVubWVyZ2VkID09IGZhbHNlYCkKICAgKiAqIGA8aGVhZGluZzE+eF48L2hlYWRpbmcxPjxwYXJhZ3JhcGg+eTwvcGFyYWdyYXBoPmAgd2l0aCBlbmFibGVkIChgbGVhdmVVbm1lcmdlZCA9PSB0cnVlYCkuCiAgICoKICAgKiBOb3RlOiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9zY2hlbWF+U2NoZW1hI2lzT2JqZWN0IG9iamVjdH0gYW5kIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NjaGVtYX5TY2hlbWEjaXNMaW1pdCBsaW1pdH0KICAgKiBlbGVtZW50cyB3aWxsIG5vdCBiZSBtZXJnZWQuCiAgICoKICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmRvTm90UmVzZXRFbnRpcmVDb250ZW50PWZhbHNlXSBXaGV0aGVyIHRvIHNraXAgcmVwbGFjaW5nIHRoZSBlbnRpcmUgY29udGVudCB3aXRoIGEKICAgKiBwYXJhZ3JhcGggd2hlbiB0aGUgZW50aXJlIGNvbnRlbnQgd2FzIHNlbGVjdGVkLgogICAqCiAgICogRm9yIGV4YW1wbGUgYDxoZWFkaW5nMT5beDwvaGVhZGluZzE+PHBhcmFncmFwaD55XTwvcGFyYWdyYXBoPmAgd2lsbCBiZWNvbWU6CiAgICoKICAgKiAqIGA8cGFyYWdyYXBoPl48L3BhcmFncmFwaD5gIHdpdGggdGhlIG9wdGlvbiBkaXNhYmxlZCAoYGRvTm90UmVzZXRFbnRpcmVDb250ZW50ID09IGZhbHNlYCkKICAgKiAqIGA8aGVhZGluZzE+XjwvaGVhZGluZzE+YCB3aXRoIGVuYWJsZWQgKGBkb05vdFJlc2V0RW50aXJlQ29udGVudCA9PSB0cnVlYCkKICAgKgogICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZG9Ob3RBdXRvcGFyYWdyYXBoPWZhbHNlXSBXaGV0aGVyIHRvIGNyZWF0ZSBhIHBhcmFncmFwaCBpZiBhZnRlciBjb250ZW50IGRlbGV0aW9uIHNlbGVjdGlvbiBpcyBtb3ZlZAogICAqIHRvIGEgcGxhY2Ugd2hlcmUgdGV4dCBjYW5ub3QgYmUgaW5zZXJ0ZWQuCiAgICoKICAgKiBGb3IgZXhhbXBsZSBgPHBhcmFncmFwaD54PC9wYXJhZ3JhcGg+WzxpbWFnZSBzcmM9ImZvby5qcGciPjwvaW1hZ2U+XWAgd2lsbCBiZWNvbWU6CiAgICoKICAgKiAqIGA8cGFyYWdyYXBoPng8L3BhcmFncmFwaD48cGFyYWdyYXBoPltdPC9wYXJhZ3JhcGg+YCB3aXRoIHRoZSBvcHRpb24gZGlzYWJsZWQgKGBkb05vdEF1dG9wYXJhZ3JhcGggPT0gZmFsc2VgKQogICAqICogYDxwYXJhZ3JhcGg+eFtdPC9wYXJhZ3JhcGg+YCB3aXRoIHRoZSBvcHRpb24gZW5hYmxlZCAoYGRvTm90QXV0b3BhcmFncmFwaCA9PSB0cnVlYCkuCiAgICoKICAgKiAqKk5vdGU6KiogaWYgdGhlcmUgaXMgbm8gdmFsaWQgcG9zaXRpb24gZm9yIHRoZSBzZWxlY3Rpb24sIHRoZSBwYXJhZ3JhcGggd2lsbCBhbHdheXMgYmUgY3JlYXRlZDoKICAgKgogICAqIGBbPGltYWdlIHNyYz0iZm9vLmpwZyI+PC9pbWFnZT5dYCAtPiBgPHBhcmFncmFwaD5bXTwvcGFyYWdyYXBoPmAuCiAgICovCgoKICBkZWxldGVDb250ZW50KHNlbGVjdGlvbiwgb3B0aW9ucykgewogICAgZGVsZXRlQ29udGVudCh0aGlzLCBzZWxlY3Rpb24sIG9wdGlvbnMpOwogIH0KICAvKioKICAgKiBNb2RpZmllcyB0aGUgc2VsZWN0aW9uLiBDdXJyZW50bHksIHRoZSBzdXBwb3J0ZWQgbW9kaWZpY2F0aW9ucyBhcmU6CiAgICoKICAgKiAqIEV4dGVuZGluZy4gVGhlIHNlbGVjdGlvbiBmb2N1cyBpcyBtb3ZlZCBpbiB0aGUgc3BlY2lmaWVkIGBvcHRpb25zLmRpcmVjdGlvbmAgd2l0aCBhIHN0ZXAgc3BlY2lmaWVkIGluIGBvcHRpb25zLnVuaXRgLgogICAqIFBvc3NpYmxlIHZhbHVlcyBmb3IgYHVuaXRgIGFyZToKICAgKiAgKiBgJ2NoYXJhY3RlcidgIChkZWZhdWx0KSAtIG1vdmVzIHNlbGVjdGlvbiBieSBvbmUgdXNlci1wZXJjZWl2ZWQgY2hhcmFjdGVyLiBJbiBtb3N0IGNhc2VzIHRoaXMgbWVhbnMgbW92aW5nIGJ5IG9uZQogICAqICBjaGFyYWN0ZXIgaW4gYFN0cmluZ2Agc2Vuc2UuIEhvd2V2ZXIsIHVuaWNvZGUgYWxzbyBkZWZpbmVzICJjb21iaW5nIG1hcmtzIi4gVGhlc2UgYXJlIHNwZWNpYWwgc3ltYm9scywgdGhhdCBjb21iaW5lcwogICAqICB3aXRoIGEgc3ltYm9sIGJlZm9yZSBpdCAoImJhc2UgY2hhcmFjdGVyIikgdG8gY3JlYXRlIG9uZSB1c2VyLXBlcmNlaXZlZCBjaGFyYWN0ZXIuIEZvciBleGFtcGxlLCBgccyHzKNgIGlzIGEgbm9ybWFsCiAgICogIGxldHRlciBgcWAgd2l0aCB0d28gImNvbWJpbmluZyBtYXJrcyI6IHVwcGVyIGRvdCAoYFV4MDMwN2ApIGFuZCBsb3dlciBkb3QgKGBVeDAzMjNgKS4gRm9yIG1vc3QgYWN0aW9ucywgaS5lLiBleHRlbmRpbmcKICAgKiAgc2VsZWN0aW9uIGJ5IG9uZSBwb3NpdGlvbiwgaXQgaXMgY29ycmVjdCB0byBpbmNsdWRlIGJvdGggImJhc2UgY2hhcmFjdGVyIiBhbmQgYWxsIG9mIGl0J3MgImNvbWJpbmluZyBtYXJrcyIuIFRoYXQgaXMKICAgKiAgd2h5IGAnY2hhcmFjdGVyJ2AgdmFsdWUgaXMgbW9zdCBuYXR1cmFsIGFuZCBjb21tb24gbWV0aG9kIG9mIG1vZGlmeWluZyBzZWxlY3Rpb24uCiAgICogICogYCdjb2RlUG9pbnQnYCAtIG1vdmVzIHNlbGVjdGlvbiBieSBvbmUgdW5pY29kZSBjb2RlIHBvaW50LiBJbiBjb250cmFyeSB0bywgYCdjaGFyYWN0ZXInYCB1bml0LCB0aGlzIHdpbGwgaW5zZXJ0CiAgICogIHNlbGVjdGlvbiBiZXR3ZWVuICJiYXNlIGNoYXJhY3RlciIgYW5kICJjb21iaW5pbmcgbWFyayIsIGJlY2F1c2UgImNvbWJpbmluZyBtYXJrcyIgaGF2ZSB0aGVpciBvd24gdW5pY29kZSBjb2RlIHBvaW50cy4KICAgKiAgSG93ZXZlciwgZm9yIHRlY2huaWNhbCByZWFzb25zLCB1bmljb2RlIGNvZGUgcG9pbnRzIHdpdGggdmFsdWVzIGFib3ZlIGBVeEZGRkZgIGFyZSByZXByZXNlbnRlZCBpbiBuYXRpdmUgYFN0cmluZ2AgYnkKICAgKiAgdHdvIGNoYXJhY3RlcnMsIGNhbGxlZCAic3Vycm9nYXRlIHBhaXJzIi4gSGFsdmVzIG9mICJzdXJyb2dhdGUgcGFpcnMiIGhhdmUgYSBtZWFuaW5nIG9ubHkgd2hlbiBwbGFjZWQgbmV4dCB0byBlYWNoIG90aGVyLgogICAqICBGb3IgZXhhbXBsZSBg8KitjmAgaXMgcmVwcmVzZW50ZWQgaW4gYFN0cmluZ2AgYnkgYFx1RDg2Mlx1REY0RWAuIEJvdGggYFx1RDg2MmAgYW5kIGBcdURGNEVgIGRvIG5vdCBoYXZlIGFueSBtZWFuaW5nCiAgICogIG91dHNpZGUgdGhlIHBhaXIgKGFyZSByZW5kZXJlZCBhcyA/IHdoZW4gYWxvbmUpLiBQb3NpdGlvbiBiZXR3ZWVuIHRoZW0gd291bGQgYmUgaW5jb3JyZWN0LiBJbiB0aGlzIGNhc2UsIHNlbGVjdGlvbgogICAqICBleHRlbnNpb24gd2lsbCBpbmNsdWRlIHdob2xlICJzdXJyb2dhdGUgcGFpciIuCiAgICogICogYCd3b3JkJ2AgLSBtb3ZlcyBzZWxlY3Rpb24gYnkgYSB3aG9sZSB3b3JkLgogICAqCiAgICogKipOb3RlOioqIGlmIHlvdSBleHRlbmQgYSBmb3J3YXJkIHNlbGVjdGlvbiBpbiBhIGJhY2t3YXJkIGRpcmVjdGlvbiB5b3Ugd2lsbCBpbiBmYWN0IHNocmluayBpdC4KICAgKgogICAqIEBmaXJlcyBtb2RpZnlTZWxlY3Rpb24KICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvc2VsZWN0aW9uflNlbGVjdGlvbnxtb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50c2VsZWN0aW9ufkRvY3VtZW50U2VsZWN0aW9ufSBzZWxlY3Rpb24KICAgKiBUaGUgc2VsZWN0aW9uIHRvIG1vZGlmeS4KICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdCiAgICogQHBhcmFtIHsnZm9yd2FyZCd8J2JhY2t3YXJkJ30gW29wdGlvbnMuZGlyZWN0aW9uPSdmb3J3YXJkJ10gVGhlIGRpcmVjdGlvbiBpbiB3aGljaCB0aGUgc2VsZWN0aW9uIHNob3VsZCBiZSBtb2RpZmllZC4KICAgKiBAcGFyYW0geydjaGFyYWN0ZXInfCdjb2RlUG9pbnQnfCd3b3JkJ30gW29wdGlvbnMudW5pdD0nY2hhcmFjdGVyJ10gVGhlIHVuaXQgYnkgd2hpY2ggc2VsZWN0aW9uIHNob3VsZCBiZSBtb2RpZmllZC4KICAgKi8KCgogIG1vZGlmeVNlbGVjdGlvbihzZWxlY3Rpb24sIG9wdGlvbnMpIHsKICAgIG1vZGlmeVNlbGVjdGlvbih0aGlzLCBzZWxlY3Rpb24sIG9wdGlvbnMpOwogIH0KICAvKioKICAgKiBHZXRzIGEgY2xvbmUgb2YgdGhlIHNlbGVjdGVkIGNvbnRlbnQuCiAgICoKICAgKiBGb3IgZXhhbXBsZSwgZm9yIHRoZSBmb2xsb3dpbmcgc2VsZWN0aW9uOgogICAqCiAgICogYGBgaHRtbAogICAqIDxwYXJhZ3JhcGg+eDwvcGFyYWdyYXBoPgogICAqIDxibG9ja1F1b3RlPgogICAqCTxwYXJhZ3JhcGg+eTwvcGFyYWdyYXBoPgogICAqCTxoZWFkaW5nMT5maXJbc3Q8L2hlYWRpbmcxPgogICAqIDwvYmxvY2tRdW90ZT4KICAgKiA8cGFyYWdyYXBoPnNlXWNvbmQ8L3BhcmFncmFwaD4KICAgKiA8cGFyYWdyYXBoPno8L3BhcmFncmFwaD4KICAgKiBgYGAKICAgKgogICAqIEl0IHdpbGwgcmV0dXJuIGEgZG9jdW1lbnQgZnJhZ21lbnQgd2l0aCBzdWNoIGEgY29udGVudDoKICAgKgogICAqIGBgYGh0bWwKICAgKiA8YmxvY2tRdW90ZT4KICAgKgk8aGVhZGluZzE+c3Q8L2hlYWRpbmcxPgogICAqIDwvYmxvY2tRdW90ZT4KICAgKiA8cGFyYWdyYXBoPnNlPC9wYXJhZ3JhcGg+CiAgICogYGBgCiAgICoKICAgKiBAZmlyZXMgZ2V0U2VsZWN0ZWRDb250ZW50CiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3NlbGVjdGlvbn5TZWxlY3Rpb258bW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudHNlbGVjdGlvbn5Eb2N1bWVudFNlbGVjdGlvbn0gc2VsZWN0aW9uCiAgICogVGhlIHNlbGVjdGlvbiBvZiB3aGljaCBjb250ZW50IHdpbGwgYmUgcmV0dXJuZWQuCiAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50fQogICAqLwoKCiAgZ2V0U2VsZWN0ZWRDb250ZW50KHNlbGVjdGlvbikgewogICAgcmV0dXJuIGdldFNlbGVjdGVkQ29udGVudCh0aGlzLCBzZWxlY3Rpb24pOwogIH0KICAvKioKICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4ge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2UgcmFuZ2V9IG9yCiAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50IGVsZW1lbnR9IGhhcyBhbnkgbWVhbmluZ2Z1bCBjb250ZW50LgogICAqCiAgICogTWVhbmluZ2Z1bCBjb250ZW50IGlzOgogICAqCiAgICogKiBhbnkgdGV4dCBub2RlIChgb3B0aW9ucy5pZ25vcmVXaGl0ZXNwYWNlc2AgYWxsb3dzIGNvbnRyb2xsaW5nIHdoZXRoZXIgdGhpcyB0ZXh0IG5vZGUgbXVzdCBhbHNvIGNvbnRhaW4KICAgKiBhbnkgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVycyksCiAgICogKiBvciBhbnkge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvc2NoZW1hflNjaGVtYSNpc09iamVjdCBvYmplY3QgZWxlbWVudH0sCiAgICogKiBvciBhbnkge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbWFya2VyY29sbGVjdGlvbn5NYXJrZXIgbWFya2VyfSB3aGljaAogICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL21hcmtlcmNvbGxlY3Rpb25+TWFya2VyI19hZmZlY3RzRGF0YSBhZmZlY3RzIGRhdGF9LgogICAqCiAgICogVGhpcyBtZWFucyB0aGF0IGEgcmFuZ2UgY29udGFpbmluZyBhbiBlbXB0eSBgPHBhcmFncmFwaD48L3BhcmFncmFwaD5gIGlzIG5vdCBjb25zaWRlcmVkIHRvIGhhdmUgYSBtZWFuaW5nZnVsIGNvbnRlbnQuCiAgICogSG93ZXZlciwgYSByYW5nZSBjb250YWluaW5nIGFuIGA8aW1hZ2U+PC9pbWFnZT5gICh3aGljaCB3b3VsZCBub3JtYWxseSBiZSBtYXJrZWQgaW4gdGhlIHNjaGVtYSBhcyBhbiBvYmplY3QgZWxlbWVudCkKICAgKiBpcyBjb25zaWRlcmVkIG5vbi1lbXB0eS4KICAgKgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZXxtb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudH0gcmFuZ2VPckVsZW1lbnQgUmFuZ2Ugb3IgZWxlbWVudCB0byBjaGVjay4KICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdCiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5pZ25vcmVXaGl0ZXNwYWNlc10gV2hldGhlciB0ZXh0IG5vZGUgd2l0aCB3aGl0ZXNwYWNlcyBvbmx5IHNob3VsZCBiZSBjb25zaWRlcmVkIGVtcHR5LgogICAqIEByZXR1cm5zIHtCb29sZWFufQogICAqLwoKCiAgaGFzQ29udGVudChyYW5nZU9yRWxlbWVudCwgb3B0aW9ucykgewogICAgY29uc3QgcmFuZ2UgPSByYW5nZU9yRWxlbWVudCBpbnN0YW5jZW9mIE1vZGVsRWxlbWVudCA/IE1vZGVsUmFuZ2UuX2NyZWF0ZUluKHJhbmdlT3JFbGVtZW50KSA6IHJhbmdlT3JFbGVtZW50OwoKICAgIGlmIChyYW5nZS5pc0NvbGxhcHNlZCkgewogICAgICByZXR1cm4gZmFsc2U7CiAgICB9IC8vIENoZWNrIGlmIHRoZXJlIGFyZSBhbnkgbWFya2VycyB3aGljaCBhZmZlY3RzIGRhdGEgaW4gdGhpcyBnaXZlbiByYW5nZS4KCgogICAgZm9yIChjb25zdCBpbnRlcnNlY3RpbmdNYXJrZXIgb2YgdGhpcy5tYXJrZXJzLmdldE1hcmtlcnNJbnRlcnNlY3RpbmdSYW5nZShyYW5nZSkpIHsKICAgICAgaWYgKGludGVyc2VjdGluZ01hcmtlci5hZmZlY3RzRGF0YSkgewogICAgICAgIHJldHVybiB0cnVlOwogICAgICB9CiAgICB9CgogICAgY29uc3QgewogICAgICBpZ25vcmVXaGl0ZXNwYWNlcyA9IGZhbHNlCiAgICB9ID0gb3B0aW9ucyB8fCB7fTsKCiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgcmFuZ2UuZ2V0SXRlbXMoKSkgewogICAgICBpZiAoaXRlbS5pcygndGV4dFByb3h5JykpIHsKICAgICAgICBpZiAoIWlnbm9yZVdoaXRlc3BhY2VzKSB7CiAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICB9IGVsc2UgaWYgKGl0ZW0uZGF0YS5zZWFyY2goL1xTLykgIT09IC0xKSB7CiAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICB9CiAgICAgIH0gZWxzZSBpZiAodGhpcy5zY2hlbWEuaXNPYmplY3QoaXRlbSkpIHsKICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgfQogICAgfQoKICAgIHJldHVybiBmYWxzZTsKICB9CiAgLyoqCiAgICogQ3JlYXRlcyBhIHBvc2l0aW9uIGZyb20gdGhlIGdpdmVuIHJvb3QgYW5kIHBhdGggaW4gdGhhdCByb290LgogICAqCiAgICogTm90ZTogVGhpcyBtZXRob2QgaXMgYWxzbyBhdmFpbGFibGUgYXMKICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC93cml0ZXJ+V3JpdGVyI2NyZWF0ZVBvc2l0aW9uRnJvbVBhdGggYFdyaXRlciNjcmVhdGVQb3NpdGlvbkZyb21QYXRoKClgfS4KICAgKgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR8bW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnR9IHJvb3QgUm9vdCBvZiB0aGUgcG9zaXRpb24uCiAgICogQHBhcmFtIHtBcnJheS48TnVtYmVyPn0gcGF0aCBQb3NpdGlvbiBwYXRoLiBTZWUge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb24jcGF0aH0uCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9uU3RpY2tpbmVzc30gW3N0aWNraW5lc3M9J3RvTm9uZSddIFBvc2l0aW9uIHN0aWNraW5lc3MuCiAgICogU2VlIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9uU3RpY2tpbmVzc30uCiAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259CiAgICovCgoKICBjcmVhdGVQb3NpdGlvbkZyb21QYXRoKHJvb3QsIHBhdGgsIHN0aWNraW5lc3MpIHsKICAgIHJldHVybiBuZXcgTW9kZWxQb3NpdGlvbihyb290LCBwYXRoLCBzdGlja2luZXNzKTsKICB9CiAgLyoqCiAgICogQ3JlYXRlcyBwb3NpdGlvbiBhdCB0aGUgZ2l2ZW4gbG9jYXRpb24uIFRoZSBsb2NhdGlvbiBjYW4gYmUgc3BlY2lmaWVkIGFzOgogICAqCiAgICogKiBhIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9uIHBvc2l0aW9ufSwKICAgKiAqIGEgcGFyZW50IGVsZW1lbnQgYW5kIG9mZnNldCBpbiB0aGF0IGVsZW1lbnQsCiAgICogKiBhIHBhcmVudCBlbGVtZW50IGFuZCBgJ2VuZCdgICh0aGUgcG9zaXRpb24gd2lsbCBiZSBzZXQgYXQgdGhlIGVuZCBvZiB0aGF0IGVsZW1lbnQpLAogICAqICogYSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9pdGVtfkl0ZW0gbW9kZWwgaXRlbX0gYW5kIGAnYmVmb3JlJ2Agb3IgYCdhZnRlcidgCiAgICogKHRoZSBwb3NpdGlvbiB3aWxsIGJlIHNldCBiZWZvcmUgb3IgYWZ0ZXIgdGhlIGdpdmVuIG1vZGVsIGl0ZW0pLgogICAqCiAgICogVGhpcyBtZXRob2QgaXMgYSBzaG9ydGN1dCB0byBvdGhlciBmYWN0b3J5IG1ldGhvZHMgc3VjaCBhczoKICAgKgogICAqICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbW9kZWx+TW9kZWwjY3JlYXRlUG9zaXRpb25CZWZvcmUgYGNyZWF0ZVBvc2l0aW9uQmVmb3JlKClgfSwKICAgKiAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL21vZGVsfk1vZGVsI2NyZWF0ZVBvc2l0aW9uQWZ0ZXIgYGNyZWF0ZVBvc2l0aW9uQWZ0ZXIoKWB9LgogICAqCiAgICogTm90ZTogVGhpcyBtZXRob2QgaXMgYWxzbyBhdmFpbGFibGUgYXMKICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC93cml0ZXJ+V3JpdGVyI2NyZWF0ZVBvc2l0aW9uQXQgYFdyaXRlciNjcmVhdGVQb3NpdGlvbkF0KClgfSwKICAgKgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9pdGVtfkl0ZW18bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0gaXRlbU9yUG9zaXRpb24KICAgKiBAcGFyYW0ge051bWJlcnwnZW5kJ3wnYmVmb3JlJ3wnYWZ0ZXInfSBbb2Zmc2V0XSBPZmZzZXQgb3Igb25lIG9mIHRoZSBmbGFncy4gVXNlZCBvbmx5IHdoZW4KICAgKiBmaXJzdCBwYXJhbWV0ZXIgaXMgYSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9pdGVtfkl0ZW0gbW9kZWwgaXRlbX0uCiAgICovCgoKICBjcmVhdGVQb3NpdGlvbkF0KGl0ZW1PclBvc2l0aW9uLCBvZmZzZXQpIHsKICAgIHJldHVybiBNb2RlbFBvc2l0aW9uLl9jcmVhdGVBdChpdGVtT3JQb3NpdGlvbiwgb2Zmc2V0KTsKICB9CiAgLyoqCiAgICogQ3JlYXRlcyBhIG5ldyBwb3NpdGlvbiBhZnRlciB0aGUgZ2l2ZW4ge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtIG1vZGVsIGl0ZW19LgogICAqCiAgICogTm90ZTogVGhpcyBtZXRob2QgaXMgYWxzbyBhdmFpbGFibGUgYXMKICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC93cml0ZXJ+V3JpdGVyI2NyZWF0ZVBvc2l0aW9uQWZ0ZXIgYFdyaXRlciNjcmVhdGVQb3NpdGlvbkFmdGVyKClgfS4KICAgKgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9pdGVtfkl0ZW19IGl0ZW0gSXRlbSBhZnRlciB3aGljaCB0aGUgcG9zaXRpb24gc2hvdWxkIGJlIHBsYWNlZC4KICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0KICAgKi8KCgogIGNyZWF0ZVBvc2l0aW9uQWZ0ZXIoaXRlbSkgewogICAgcmV0dXJuIE1vZGVsUG9zaXRpb24uX2NyZWF0ZUFmdGVyKGl0ZW0pOwogIH0KICAvKioKICAgKiBDcmVhdGVzIGEgbmV3IHBvc2l0aW9uIGJlZm9yZSB0aGUgZ2l2ZW4ge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtIG1vZGVsIGl0ZW19LgogICAqCiAgICogTm90ZTogVGhpcyBtZXRob2QgaXMgYWxzbyBhdmFpbGFibGUgYXMKICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC93cml0ZXJ+V3JpdGVyI2NyZWF0ZVBvc2l0aW9uQmVmb3JlIGBXcml0ZXIjY3JlYXRlUG9zaXRpb25CZWZvcmUoKWB9LgogICAqCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbX0gaXRlbSBJdGVtIGJlZm9yZSB3aGljaCB0aGUgcG9zaXRpb24gc2hvdWxkIGJlIHBsYWNlZC4KICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0KICAgKi8KCgogIGNyZWF0ZVBvc2l0aW9uQmVmb3JlKGl0ZW0pIHsKICAgIHJldHVybiBNb2RlbFBvc2l0aW9uLl9jcmVhdGVCZWZvcmUoaXRlbSk7CiAgfQogIC8qKgogICAqIENyZWF0ZXMgYSByYW5nZSBzcGFubmluZyBmcm9tIHRoZSBgc3RhcnRgIHBvc2l0aW9uIHRvIHRoZSBgZW5kYCBwb3NpdGlvbi4KICAgKgogICAqIE5vdGU6IFRoaXMgbWV0aG9kIGlzIGFsc28gYXZhaWxhYmxlIGFzCiAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvd3JpdGVyfldyaXRlciNjcmVhdGVSYW5nZSBgV3JpdGVyI2NyZWF0ZVJhbmdlKClgfToKICAgKgogICAqCQltb2RlbC5jaGFuZ2UoIHdyaXRlciA9PiB7CiAgICoJCQljb25zdCByYW5nZSA9IHdyaXRlci5jcmVhdGVSYW5nZSggc3RhcnQsIGVuZCApOwogICAqCQl9ICk7CiAgICoKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259IHN0YXJ0IFN0YXJ0IHBvc2l0aW9uLgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0gW2VuZF0gRW5kIHBvc2l0aW9uLiBJZiBub3Qgc2V0LCB0aGUgcmFuZ2Ugd2lsbCBiZSBjb2xsYXBzZWQKICAgKiB0byB0aGUgYHN0YXJ0YCBwb3NpdGlvbi4KICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZX0KICAgKi8KCgogIGNyZWF0ZVJhbmdlKHN0YXJ0LCBlbmQpIHsKICAgIHJldHVybiBuZXcgTW9kZWxSYW5nZShzdGFydCwgZW5kKTsKICB9CiAgLyoqCiAgICogQ3JlYXRlcyBhIHJhbmdlIGluc2lkZSB0aGUgZ2l2ZW4gZWxlbWVudCB3aGljaCBzdGFydHMgYmVmb3JlIHRoZSBmaXJzdCBjaGlsZCBvZgogICAqIHRoYXQgZWxlbWVudCBhbmQgZW5kcyBhZnRlciB0aGUgbGFzdCBjaGlsZCBvZiB0aGF0IGVsZW1lbnQuCiAgICoKICAgKiBOb3RlOiBUaGlzIG1ldGhvZCBpcyBhbHNvIGF2YWlsYWJsZSBhcwogICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3dyaXRlcn5Xcml0ZXIjY3JlYXRlUmFuZ2VJbiBgV3JpdGVyI2NyZWF0ZVJhbmdlSW4oKWB9OgogICAqCiAgICoJCW1vZGVsLmNoYW5nZSggd3JpdGVyID0+IHsKICAgKgkJCWNvbnN0IHJhbmdlID0gd3JpdGVyLmNyZWF0ZVJhbmdlSW4oIHBhcmFncmFwaCApOwogICAqCQl9ICk7CiAgICoKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgd2hpY2ggaXMgYSBwYXJlbnQgZm9yIHRoZSByYW5nZS4KICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZX0KICAgKi8KCgogIGNyZWF0ZVJhbmdlSW4oZWxlbWVudCkgewogICAgcmV0dXJuIE1vZGVsUmFuZ2UuX2NyZWF0ZUluKGVsZW1lbnQpOwogIH0KICAvKioKICAgKiBDcmVhdGVzIGEgcmFuZ2UgdGhhdCBzdGFydHMgYmVmb3JlIHRoZSBnaXZlbiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9pdGVtfkl0ZW0gbW9kZWwgaXRlbX0gYW5kIGVuZHMgYWZ0ZXIgaXQuCiAgICoKICAgKiBOb3RlOiBUaGlzIG1ldGhvZCBpcyBhbHNvIGF2YWlsYWJsZSBvbiBgd3JpdGVyYCBpbnN0YW5jZSBhcwogICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3dyaXRlcn5Xcml0ZXIjY3JlYXRlUmFuZ2VPbiBgV3JpdGVyLmNyZWF0ZVJhbmdlT24oKWB9OgogICAqCiAgICoJCW1vZGVsLmNoYW5nZSggd3JpdGVyID0+IHsKICAgKgkJCWNvbnN0IHJhbmdlID0gd3JpdGVyLmNyZWF0ZVJhbmdlT24oIHBhcmFncmFwaCApOwogICAqCQl9ICk7CiAgICoKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtfSBpdGVtCiAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2V9CiAgICovCgoKICBjcmVhdGVSYW5nZU9uKGl0ZW0pIHsKICAgIHJldHVybiBNb2RlbFJhbmdlLl9jcmVhdGVPbihpdGVtKTsKICB9CiAgLyoqCiAgICogQ3JlYXRlcyBhIG5ldyBzZWxlY3Rpb24gaW5zdGFuY2UgYmFzZWQgb24gdGhlIGdpdmVuIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3NlbGVjdGlvbn5TZWxlY3RhYmxlIHNlbGVjdGFibGV9CiAgICogb3IgY3JlYXRlcyBhbiBlbXB0eSBzZWxlY3Rpb24gaWYgbm8gYXJndW1lbnRzIHdlcmUgcGFzc2VkLgogICAqCiAgICogTm90ZTogVGhpcyBtZXRob2QgaXMgYWxzbyBhdmFpbGFibGUgYXMKICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC93cml0ZXJ+V3JpdGVyI2NyZWF0ZVNlbGVjdGlvbiBgV3JpdGVyI2NyZWF0ZVNlbGVjdGlvbigpYH0uCiAgICoKICAgKgkJLy8gQ3JlYXRlcyBlbXB0eSBzZWxlY3Rpb24gd2l0aG91dCByYW5nZXMuCiAgICoJCWNvbnN0IHNlbGVjdGlvbiA9IHdyaXRlci5jcmVhdGVTZWxlY3Rpb24oKTsKICAgKgogICAqCQkvLyBDcmVhdGVzIHNlbGVjdGlvbiBhdCB0aGUgZ2l2ZW4gcmFuZ2UuCiAgICoJCWNvbnN0IHJhbmdlID0gd3JpdGVyLmNyZWF0ZVJhbmdlKCBzdGFydCwgZW5kICk7CiAgICoJCWNvbnN0IHNlbGVjdGlvbiA9IHdyaXRlci5jcmVhdGVTZWxlY3Rpb24oIHJhbmdlICk7CiAgICoKICAgKgkJLy8gQ3JlYXRlcyBzZWxlY3Rpb24gYXQgdGhlIGdpdmVuIHJhbmdlcwogICAqCQljb25zdCByYW5nZXMgPSBbIHdyaXRlci5jcmVhdGVSYW5nZSggc3RhcnQxLCBlbmQyICksIHdyaXRlci5jcmVhdGVSYW5nZSggc3RhcjIsIGVuZDIgKSBdOwogICAqCQljb25zdCBzZWxlY3Rpb24gPSB3cml0ZXIuY3JlYXRlU2VsZWN0aW9uKCByYW5nZXMgKTsKICAgKgogICAqCQkvLyBDcmVhdGVzIHNlbGVjdGlvbiBmcm9tIHRoZSBvdGhlciBzZWxlY3Rpb24uCiAgICoJCS8vIE5vdGU6IEl0IGRvZXNuJ3QgY29waWVzIHNlbGVjdGlvbiBhdHRyaWJ1dGVzLgogICAqCQljb25zdCBvdGhlclNlbGVjdGlvbiA9IHdyaXRlci5jcmVhdGVTZWxlY3Rpb24oKTsKICAgKgkJY29uc3Qgc2VsZWN0aW9uID0gd3JpdGVyLmNyZWF0ZVNlbGVjdGlvbiggb3RoZXJTZWxlY3Rpb24gKTsKICAgKgogICAqCQkvLyBDcmVhdGVzIHNlbGVjdGlvbiBmcm9tIHRoZSBnaXZlbiBkb2N1bWVudCBzZWxlY3Rpb24uCiAgICoJCS8vIE5vdGU6IEl0IGRvZXNuJ3QgY29waWVzIHNlbGVjdGlvbiBhdHRyaWJ1dGVzLgogICAqCQljb25zdCBkb2N1bWVudFNlbGVjdGlvbiA9IG1vZGVsLmRvY3VtZW50LnNlbGVjdGlvbjsKICAgKgkJY29uc3Qgc2VsZWN0aW9uID0gd3JpdGVyLmNyZWF0ZVNlbGVjdGlvbiggZG9jdW1lbnRTZWxlY3Rpb24gKTsKICAgKgogICAqCQkvLyBDcmVhdGVzIHNlbGVjdGlvbiBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uCiAgICoJCWNvbnN0IHBvc2l0aW9uID0gd3JpdGVyLmNyZWF0ZVBvc2l0aW9uRnJvbVBhdGgoIHJvb3QsIHBhdGggKTsKICAgKgkJY29uc3Qgc2VsZWN0aW9uID0gd3JpdGVyLmNyZWF0ZVNlbGVjdGlvbiggcG9zaXRpb24gKTsKICAgKgogICAqCQkvLyBDcmVhdGVzIHNlbGVjdGlvbiBhdCB0aGUgZ2l2ZW4gb2Zmc2V0IGluIHRoZSBnaXZlbiBlbGVtZW50LgogICAqCQljb25zdCBwYXJhZ3JhcGggPSB3cml0ZXIuY3JlYXRlRWxlbWVudCggJ3BhcmFncmFwaCcgKTsKICAgKgkJY29uc3Qgc2VsZWN0aW9uID0gd3JpdGVyLmNyZWF0ZVNlbGVjdGlvbiggcGFyYWdyYXBoLCBvZmZzZXQgKTsKICAgKgogICAqCQkvLyBDcmVhdGVzIGEgcmFuZ2UgaW5zaWRlIGFuIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudCBlbGVtZW50fSB3aGljaCBzdGFydHMgYmVmb3JlIHRoZQogICAqCQkvLyBmaXJzdCBjaGlsZCBvZiB0aGF0IGVsZW1lbnQgYW5kIGVuZHMgYWZ0ZXIgdGhlIGxhc3QgY2hpbGQgb2YgdGhhdCBlbGVtZW50LgogICAqCQljb25zdCBzZWxlY3Rpb24gPSB3cml0ZXIuY3JlYXRlU2VsZWN0aW9uKCBwYXJhZ3JhcGgsICdpbicgKTsKICAgKgogICAqCQkvLyBDcmVhdGVzIGEgcmFuZ2Ugb24gYW4ge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtIGl0ZW19IHdoaWNoIHN0YXJ0cyBiZWZvcmUgdGhlIGl0ZW0gYW5kIGVuZHMKICAgKgkJLy8ganVzdCBhZnRlciB0aGUgaXRlbS4KICAgKgkJY29uc3Qgc2VsZWN0aW9uID0gd3JpdGVyLmNyZWF0ZVNlbGVjdGlvbiggcGFyYWdyYXBoLCAnb24nICk7CiAgICoKICAgKgkJLy8gQWRkaXRpb25hbCBvcHRpb25zIChgJ2JhY2t3YXJkJ2ApIGNhbiBiZSBzcGVjaWZpZWQgYXMgdGhlIGxhc3QgYXJndW1lbnQuCiAgICoKICAgKgkJLy8gQ3JlYXRlcyBiYWNrd2FyZCBzZWxlY3Rpb24uCiAgICoJCWNvbnN0IHNlbGVjdGlvbiA9IHdyaXRlci5jcmVhdGVTZWxlY3Rpb24oIHJhbmdlLCB7IGJhY2t3YXJkOiB0cnVlIH0gKTsKICAgKgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9zZWxlY3Rpb25+U2VsZWN0YWJsZX0gc2VsZWN0YWJsZQogICAqIEBwYXJhbSB7TnVtYmVyfCdiZWZvcmUnfCdlbmQnfCdhZnRlcid8J29uJ3wnaW4nfSBbcGxhY2VPck9mZnNldF0gU2V0cyBwbGFjZSBvciBvZmZzZXQgb2YgdGhlIHNlbGVjdGlvbi4KICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdCiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5iYWNrd2FyZF0gU2V0cyB0aGlzIHNlbGVjdGlvbiBpbnN0YW5jZSB0byBiZSBiYWNrd2FyZC4KICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9zZWxlY3Rpb25+U2VsZWN0aW9ufQogICAqLwoKCiAgY3JlYXRlU2VsZWN0aW9uKHNlbGVjdGFibGUsIHBsYWNlT3JPZmZzZXQsIG9wdGlvbnMpIHsKICAgIHJldHVybiBuZXcgTW9kZWxTZWxlY3Rpb24oc2VsZWN0YWJsZSwgcGxhY2VPck9mZnNldCwgb3B0aW9ucyk7CiAgfQogIC8qKgogICAqIENyZWF0ZXMgYSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9iYXRjaH5CYXRjaH0gaW5zdGFuY2UuCiAgICoKICAgKiAqKk5vdGU6KiogSW4gbW9zdCBjYXNlcyBjcmVhdGluZyBhIGJhdGNoIGluc3RhbmNlIGlzIG5vdCBuZWNlc3NhcnkgYXMgdGhleSBhcmUgY3JlYXRlZCB3aGVuIHVzaW5nOgogICAqCiAgICogKiB7QGxpbmsgI2NoYW5nZSBgY2hhbmdlKClgfSwKICAgKiAqIHtAbGluayAjZW5xdWV1ZUNoYW5nZSBgZW5xdWV1ZUNoYW5nZSgpYH0uCiAgICoKICAgKiBAcGFyYW0geyd0cmFuc3BhcmVudCd8J2RlZmF1bHQnfSBbdHlwZT0nZGVmYXVsdCddIFRoZSB0eXBlIG9mIHRoZSBiYXRjaC4KICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9iYXRjaH5CYXRjaH0KICAgKi8KCgogIGNyZWF0ZUJhdGNoKHR5cGUpIHsKICAgIHJldHVybiBuZXcgQmF0Y2godHlwZSk7CiAgfQogIC8qKgogICAqIFJlbW92ZXMgYWxsIGV2ZW50cyBsaXN0ZW5lcnMgc2V0IGJ5IG1vZGVsIGluc3RhbmNlIGFuZCBkZXN0cm95cyB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudH5Eb2N1bWVudH0uCiAgICovCgoKICBkZXN0cm95KCkgewogICAgdGhpcy5kb2N1bWVudC5kZXN0cm95KCk7CiAgICB0aGlzLnN0b3BMaXN0ZW5pbmcoKTsKICB9CiAgLyoqCiAgICogQ29tbW9uIHBhcnQgb2Yge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbW9kZWx+TW9kZWwjY2hhbmdlfSBhbmQge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbW9kZWx+TW9kZWwjZW5xdWV1ZUNoYW5nZX0KICAgKiB3aGljaCBjYWxscyBjYWxsYmFja3MgYW5kIHJldHVybnMgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZXNlIGNhbGxiYWNrcy4KICAgKgogICAqIEBwcml2YXRlCiAgICogQHJldHVybnMge0FycmF5LjwqPn0gQXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IGNhbGxiYWNrcy4KICAgKi8KCgogIF9ydW5QZW5kaW5nQ2hhbmdlcygpIHsKICAgIGNvbnN0IHJldCA9IFtdOwogICAgdGhpcy5maXJlKCdfYmVmb3JlQ2hhbmdlcycpOwoKICAgIHdoaWxlICh0aGlzLl9wZW5kaW5nQ2hhbmdlcy5sZW5ndGgpIHsKICAgICAgLy8gQ3JlYXRlIGEgbmV3IHdyaXRlciB1c2luZyBiYXRjaCBpbnN0YW5jZSBjcmVhdGVkIGZvciB0aGlzIGNoYWluIG9mIGNoYW5nZXMuCiAgICAgIGNvbnN0IGN1cnJlbnRCYXRjaCA9IHRoaXMuX3BlbmRpbmdDaGFuZ2VzWzBdLmJhdGNoOwogICAgICB0aGlzLl9jdXJyZW50V3JpdGVyID0gbmV3IFdyaXRlcih0aGlzLCBjdXJyZW50QmF0Y2gpOyAvLyBFeGVjdXRlIGNoYW5nZXMgY2FsbGJhY2sgYW5kIGdhdGhlciB0aGUgcmV0dXJuZWQgdmFsdWUuCgogICAgICBjb25zdCBjYWxsYmFja1JldHVyblZhbHVlID0gdGhpcy5fcGVuZGluZ0NoYW5nZXNbMF0uY2FsbGJhY2sodGhpcy5fY3VycmVudFdyaXRlcik7CgogICAgICByZXQucHVzaChjYWxsYmFja1JldHVyblZhbHVlKTsKCiAgICAgIHRoaXMuZG9jdW1lbnQuX2hhbmRsZUNoYW5nZUJsb2NrKHRoaXMuX2N1cnJlbnRXcml0ZXIpOwoKICAgICAgdGhpcy5fcGVuZGluZ0NoYW5nZXMuc2hpZnQoKTsKCiAgICAgIHRoaXMuX2N1cnJlbnRXcml0ZXIgPSBudWxsOwogICAgfQoKICAgIHRoaXMuZmlyZSgnX2FmdGVyQ2hhbmdlcycpOwogICAgcmV0dXJuIHJldDsKICB9CiAgLyoqCiAgICogRmlyZWQgd2hlbiBlbnRlcmluZyB0aGUgb3V0ZXJtb3N0IHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL21vZGVsfk1vZGVsI2VucXVldWVDaGFuZ2V9IG9yCiAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbW9kZWx+TW9kZWwjY2hhbmdlfSBibG9jay4KICAgKgogICAqIEBwcm90ZWN0ZWQKICAgKiBAZXZlbnQgX2JlZm9yZUNoYW5nZXMKICAgKi8KCiAgLyoqCiAgICogRmlyZWQgd2hlbiBsZWF2aW5nIHRoZSBvdXRlcm1vc3Qge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvbW9kZWx+TW9kZWwjZW5xdWV1ZUNoYW5nZX0gb3IKICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9tb2RlbH5Nb2RlbCNjaGFuZ2V9IGJsb2NrLgogICAqCiAgICogQHByb3RlY3RlZAogICAqIEBldmVudCBfYWZ0ZXJDaGFuZ2VzCiAgICovCgogIC8qKgogICAqIEZpcmVkIGV2ZXJ5IHRpbWUgYW55IHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL29wZXJhdGlvbi9vcGVyYXRpb25+T3BlcmF0aW9uIG9wZXJhdGlvbn0gaXMgYXBwbGllZCBvbiB0aGUgbW9kZWwKICAgKiB1c2luZyB7QGxpbmsgI2FwcGx5T3BlcmF0aW9ufS4KICAgKgogICAqIE5vdGUgdGhhdCB0aGlzIGV2ZW50IGlzIHN1aXRhYmxlIG9ubHkgZm9yIHZlcnkgc3BlY2lmaWMgdXNlLWNhc2VzLiBVc2UgaXQgaWYgeW91IG5lZWQgdG8gbGlzdGVuIHRvIGV2ZXJ5IHNpbmdsZSBvcGVyYXRpb24KICAgKiBhcHBsaWVkIG9uIHRoZSBkb2N1bWVudC4gSG93ZXZlciwgaW4gbW9zdCBjYXNlcyB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudH5Eb2N1bWVudCNldmVudDpjaGFuZ2V9IHNob3VsZAogICAqIGJlIHVzZWQuCiAgICoKICAgKiBBIGZldyBjYWxsYmFja3MgYXJlIGFscmVhZHkgYWRkZWQgdG8gdGhpcyBldmVudCBieSBlbmdpbmUgaW50ZXJuYWwgY2xhc3NlczoKICAgKgogICAqICogd2l0aCBgaGlnaGVzdGAgcHJpb3JpdHkgb3BlcmF0aW9uIGlzIHZhbGlkYXRlZCwKICAgKiAqIHdpdGggYG5vcm1hbGAgcHJpb3JpdHkgb3BlcmF0aW9uIGlzIGV4ZWN1dGVkLAogICAqICogd2l0aCBgbG93YCBwcmlvcml0eSB0aGUge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnR+RG9jdW1lbnR9IHVwZGF0ZXMgaXRzIHZlcnNpb24sCiAgICogKiB3aXRoIGBsb3dgIHByaW9yaXR5IHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2xpdmVwb3NpdGlvbn5MaXZlUG9zaXRpb259IGFuZCB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9saXZlcmFuZ2V+TGl2ZVJhbmdlfQogICAqIHVwZGF0ZSB0aGVtc2VsdmVzLgogICAqCiAgICogQGV2ZW50IGFwcGx5T3BlcmF0aW9uCiAgICogQHBhcmFtIHtBcnJheX0gYXJncyBBcmd1bWVudHMgb2YgdGhlIGBhcHBseU9wZXJhdGlvbmAgd2hpY2ggaXMgYW4gYXJyYXkgd2l0aCBhIHNpbmdsZSBlbGVtZW50IC0gYXBwbGllZAogICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL29wZXJhdGlvbi9vcGVyYXRpb25+T3BlcmF0aW9uIG9wZXJhdGlvbn0uCiAgICovCgogIC8qKgogICAqIEV2ZW50IGZpcmVkIHdoZW4ge0BsaW5rICNpbnNlcnRDb250ZW50fSBtZXRob2QgaXMgY2FsbGVkLgogICAqCiAgICogVGhlIHtAbGluayAjaW5zZXJ0Q29udGVudCBkZWZhdWx0IGFjdGlvbiBvZiB0aGF0IG1ldGhvZH0gaXMgaW1wbGVtZW50ZWQgYXMgYQogICAqIGxpc3RlbmVyIHRvIHRoaXMgZXZlbnQgc28gaXQgY2FuIGJlIGZ1bGx5IGN1c3RvbWl6ZWQgYnkgdGhlIGZlYXR1cmVzLgogICAqCiAgICogKipOb3RlKiogVGhlIGBzZWxlY3RhYmxlYCBwYXJhbWV0ZXIgZm9yIHRoZSB7QGxpbmsgI2luc2VydENvbnRlbnR9IGlzIG9wdGlvbmFsLiBXaGVuIGB1bmRlZmluZWRgIHZhbHVlIGlzIHBhc3NlZCB0aGUgbWV0aG9kIHVzZXMKICAgKiBgbW9kZWwuZG9jdW1lbnQuc2VsZWN0aW9uYC4KICAgKgogICAqIEBldmVudCBpbnNlcnRDb250ZW50CiAgICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgb3JpZ2luYWwgbWV0aG9kLgogICAqLwoKICAvKioKICAgKiBFdmVudCBmaXJlZCB3aGVuIHtAbGluayAjZGVsZXRlQ29udGVudH0gbWV0aG9kIGlzIGNhbGxlZC4KICAgKgogICAqIFRoZSB7QGxpbmsgI2RlbGV0ZUNvbnRlbnQgZGVmYXVsdCBhY3Rpb24gb2YgdGhhdCBtZXRob2R9IGlzIGltcGxlbWVudGVkIGFzIGEKICAgKiBsaXN0ZW5lciB0byB0aGlzIGV2ZW50IHNvIGl0IGNhbiBiZSBmdWxseSBjdXN0b21pemVkIGJ5IHRoZSBmZWF0dXJlcy4KICAgKgogICAqIEBldmVudCBkZWxldGVDb250ZW50CiAgICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgb3JpZ2luYWwgbWV0aG9kLgogICAqLwoKICAvKioKICAgKiBFdmVudCBmaXJlZCB3aGVuIHtAbGluayAjbW9kaWZ5U2VsZWN0aW9ufSBtZXRob2QgaXMgY2FsbGVkLgogICAqCiAgICogVGhlIHtAbGluayAjbW9kaWZ5U2VsZWN0aW9uIGRlZmF1bHQgYWN0aW9uIG9mIHRoYXQgbWV0aG9kfSBpcyBpbXBsZW1lbnRlZCBhcyBhCiAgICogbGlzdGVuZXIgdG8gdGhpcyBldmVudCBzbyBpdCBjYW4gYmUgZnVsbHkgY3VzdG9taXplZCBieSB0aGUgZmVhdHVyZXMuCiAgICoKICAgKiBAZXZlbnQgbW9kaWZ5U2VsZWN0aW9uCiAgICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgb3JpZ2luYWwgbWV0aG9kLgogICAqLwoKICAvKioKICAgKiBFdmVudCBmaXJlZCB3aGVuIHtAbGluayAjZ2V0U2VsZWN0ZWRDb250ZW50fSBtZXRob2QgaXMgY2FsbGVkLgogICAqCiAgICogVGhlIHtAbGluayAjZ2V0U2VsZWN0ZWRDb250ZW50IGRlZmF1bHQgYWN0aW9uIG9mIHRoYXQgbWV0aG9kfSBpcyBpbXBsZW1lbnRlZCBhcyBhCiAgICogbGlzdGVuZXIgdG8gdGhpcyBldmVudCBzbyBpdCBjYW4gYmUgZnVsbHkgY3VzdG9taXplZCBieSB0aGUgZmVhdHVyZXMuCiAgICoKICAgKiBAZXZlbnQgZ2V0U2VsZWN0ZWRDb250ZW50CiAgICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgb3JpZ2luYWwgbWV0aG9kLgogICAqLwoKCn0KbWl4KE1vZGVsLCBPYnNlcnZhYmxlTWl4aW4pOw=="},{"version":3,"sources":["/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-engine/src/model/model.js"],"names":["Batch","Writer","Schema","Document","MarkerCollection","ObservableMixin","mix","ModelElement","ModelRange","ModelPosition","ModelSelection","insertContent","deleteContent","modifySelection","getSelectedContent","injectSelectionPostFixer","CKEditorError","Model","constructor","markers","document","schema","_pendingChanges","_currentWriter","forEach","methodName","decorate","on","evt","args","operation","_validate","priority","register","isLimit","allowIn","isBlock","isInline","allowContentOf","extend","addChildCheck","context","childDefinition","name","change","callback","length","push","batch","_runPendingChanges","err","rethrowUnexpectedError","enqueueChange","batchOrType","applyOperation","_execute","content","selectable","placeOrOffset","selection","options","hasContent","rangeOrElement","range","_createIn","isCollapsed","intersectingMarker","getMarkersIntersectingRange","affectsData","ignoreWhitespaces","item","getItems","is","data","search","isObject","createPositionFromPath","root","path","stickiness","createPositionAt","itemOrPosition","offset","_createAt","createPositionAfter","_createAfter","createPositionBefore","_createBefore","createRange","start","end","createRangeIn","element","createRangeOn","_createOn","createSelection","createBatch","type","destroy","stopListening","ret","fire","currentBatch","callbackReturnValue","_handleChangeBlock","shift"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/model\n */\n\nimport Batch from './batch';\nimport Writer from './writer';\nimport Schema from './schema';\nimport Document from './document';\nimport MarkerCollection from './markercollection';\nimport ObservableMixin from '@ckeditor/ckeditor5-utils/src/observablemixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\nimport ModelElement from './element';\nimport ModelRange from './range';\nimport ModelPosition from './position';\nimport ModelSelection from './selection';\n\nimport insertContent from './utils/insertcontent';\nimport deleteContent from './utils/deletecontent';\nimport modifySelection from './utils/modifyselection';\nimport getSelectedContent from './utils/getselectedcontent';\nimport { injectSelectionPostFixer } from './utils/selection-post-fixer';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\n\n// @if CK_DEBUG_ENGINE // const { dumpTrees } = require( '../dev-utils/utils' );\n// @if CK_DEBUG_ENGINE // const { OperationReplayer } = require( '../dev-utils/operationreplayer' ).default;\n\n/**\n * Editor's data model. Read about the model in the\n * {@glink framework/guides/architecture/editing-engine engine architecture guide}.\n *\n * @mixes module:utils/observablemixin~ObservableMixin\n */\nexport default class Model {\n\tconstructor() {\n\t\t/**\n\t\t * Model's marker collection.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/markercollection~MarkerCollection}\n\t\t */\n\t\tthis.markers = new MarkerCollection();\n\n\t\t/**\n\t\t * Model's document.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/document~Document}\n\t\t */\n\t\tthis.document = new Document( this );\n\n\t\t/**\n\t\t * Model's schema.\n\t\t *\n\t\t * @readonly\n\t\t * @member {module:engine/model/schema~Schema}\n\t\t */\n\t\tthis.schema = new Schema();\n\n\t\t/**\n\t\t * All callbacks added by {@link module:engine/model/model~Model#change} or\n\t\t * {@link module:engine/model/model~Model#enqueueChange} methods waiting to be executed.\n\t\t *\n\t\t * @private\n\t\t * @type {Array.<Function>}\n\t\t */\n\t\tthis._pendingChanges = [];\n\n\t\t/**\n\t\t * The last created and currently used writer instance.\n\t\t *\n\t\t * @private\n\t\t * @member {module:engine/model/writer~Writer}\n\t\t */\n\t\tthis._currentWriter = null;\n\n\t\t[ 'insertContent', 'deleteContent', 'modifySelection', 'getSelectedContent', 'applyOperation' ]\n\t\t\t.forEach( methodName => this.decorate( methodName ) );\n\n\t\t// Adding operation validation with `highest` priority, so it is called before any other feature would like\n\t\t// to do anything with the operation. If the operation has incorrect parameters it should throw on the earliest occasion.\n\t\tthis.on( 'applyOperation', ( evt, args ) => {\n\t\t\tconst operation = args[ 0 ];\n\n\t\t\toperation._validate();\n\t\t}, { priority: 'highest' } );\n\n\t\t// Register some default abstract entities.\n\t\tthis.schema.register( '$root', {\n\t\t\tisLimit: true\n\t\t} );\n\t\tthis.schema.register( '$block', {\n\t\t\tallowIn: '$root',\n\t\t\tisBlock: true\n\t\t} );\n\t\tthis.schema.register( '$text', {\n\t\t\tallowIn: '$block',\n\t\t\tisInline: true\n\t\t} );\n\t\tthis.schema.register( '$clipboardHolder', {\n\t\t\tallowContentOf: '$root',\n\t\t\tisLimit: true\n\t\t} );\n\t\tthis.schema.extend( '$text', { allowIn: '$clipboardHolder' } );\n\n\t\t// An element needed by the `upcastElementToMarker` converter.\n\t\t// This element temporarily represents a marker boundary during the conversion process and is removed\n\t\t// at the end of the conversion. `UpcastDispatcher` or at least `Conversion` class looks like a\n\t\t// better place for this registration but both know nothing about `Schema`.\n\t\tthis.schema.register( '$marker' );\n\t\tthis.schema.addChildCheck( ( context, childDefinition ) => {\n\t\t\tif ( childDefinition.name === '$marker' ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} );\n\n\t\tinjectSelectionPostFixer( this );\n\n\t\t// @if CK_DEBUG_ENGINE // this.on( 'applyOperation', () => {\n\t\t// @if CK_DEBUG_ENGINE // \tdumpTrees( this.document, this.document.version );\n\t\t// @if CK_DEBUG_ENGINE // }, { priority: 'lowest' } );\n\t}\n\n\t/**\n\t * The `change()` method is the primary way of changing the model. You should use it to modify all document nodes\n\t * (including detached nodes – i.e. nodes not added to the {@link module:engine/model/model~Model#document model document}),\n\t * the {@link module:engine/model/document~Document#selection document's selection}, and\n\t * {@link module:engine/model/model~Model#markers model markers}.\n\t *\n\t *\t\tmodel.change( writer => {\n\t *\t\t\twriter.insertText( 'foo', paragraph, 'end' );\n\t *\t\t} );\n\t *\n\t * All changes inside the change block use the same {@link module:engine/model/batch~Batch} so they are combined\n\t * into a single undo step.\n\t *\n\t *\t\tmodel.change( writer => {\n\t *\t\t\twriter.insertText( 'foo', paragraph, 'end' ); // foo.\n\t *\n\t *\t\t\tmodel.change( writer => {\n\t *\t\t\t\twriter.insertText( 'bar', paragraph, 'end' ); // foobar.\n\t *\t\t\t} );\n\t *\n\t * \t\t\twriter.insertText( 'bom', paragraph, 'end' ); // foobarbom.\n\t *\t\t} );\n\t *\n\t * The callback of the `change()` block is executed synchronously.\n\t *\n\t * You can also return a value from the change block.\n\t *\n\t *\t\tconst img = model.change( writer => {\n\t *\t\t\treturn writer.createElement( 'img' );\n\t *\t\t} );\n\t *\n\t * @see #enqueueChange\n\t * @param {Function} callback Callback function which may modify the model.\n\t * @returns {*} Value returned by the callback.\n\t */\n\tchange( callback ) {\n\t\ttry {\n\t\t\tif ( this._pendingChanges.length === 0 ) {\n\t\t\t\t// If this is the outermost block, create a new batch and start `_runPendingChanges` execution flow.\n\t\t\t\tthis._pendingChanges.push( { batch: new Batch(), callback } );\n\n\t\t\t\treturn this._runPendingChanges()[ 0 ];\n\t\t\t} else {\n\t\t\t\t// If this is not the outermost block, just execute the callback.\n\t\t\t\treturn callback( this._currentWriter );\n\t\t\t}\n\t\t} catch ( err ) {\n\t\t\t// @if CK_DEBUG // throw err;\n\t\t\t/* istanbul ignore next */\n\t\t\tCKEditorError.rethrowUnexpectedError( err, this );\n\t\t}\n\t}\n\n\t/**\n\t * The `enqueueChange()` method performs similar task as the {@link #change `change()` method}, with two major differences.\n\t *\n\t * First, the callback of `enqueueChange()` is executed when all other enqueued changes are done. It might be executed\n\t * immediately if it is not nested in any other change block, but if it is nested in another (enqueue)change block,\n\t * it will be delayed and executed after the outermost block.\n\t *\n\t *\t\tmodel.change( writer => {\n\t *\t\t\tconsole.log( 1 );\n\t *\n\t *\t\t\tmodel.enqueueChange( writer => {\n\t *\t\t\t\tconsole.log( 2 );\n\t *\t\t\t} );\n\t *\n\t * \t\t\tconsole.log( 3 );\n\t *\t\t} ); // Will log: 1, 3, 2.\n\t *\n\t * Second, it lets you define the {@link module:engine/model/batch~Batch} into which you want to add your changes.\n\t * By default, a new batch is created. In the sample above, `change` and `enqueueChange` blocks use a different\n\t * batch (and different {@link module:engine/model/writer~Writer} since each of them operates on the separate batch).\n\t *\n\t * When using the `enqueueChange()` block you can also add some changes to the batch you used before.\n\t *\n\t *\t\tmodel.enqueueChange( batch, writer => {\n\t *\t\t\twriter.insertText( 'foo', paragraph, 'end' );\n\t *\t\t} );\n\t *\n\t * The batch instance can be obtained from {@link module:engine/model/writer~Writer#batch the writer}.\n\t *\n\t * @param {module:engine/model/batch~Batch|'transparent'|'default'} batchOrType Batch or batch type should be used in the callback.\n\t * If not defined, a new batch will be created.\n\t * @param {Function} callback Callback function which may modify the model.\n\t */\n\tenqueueChange( batchOrType, callback ) {\n\t\ttry {\n\t\t\tif ( typeof batchOrType === 'string' ) {\n\t\t\t\tbatchOrType = new Batch( batchOrType );\n\t\t\t} else if ( typeof batchOrType == 'function' ) {\n\t\t\t\tcallback = batchOrType;\n\t\t\t\tbatchOrType = new Batch();\n\t\t\t}\n\n\t\t\tthis._pendingChanges.push( { batch: batchOrType, callback } );\n\n\t\t\tif ( this._pendingChanges.length == 1 ) {\n\t\t\t\tthis._runPendingChanges();\n\t\t\t}\n\t\t} catch ( err ) {\n\t\t\t// @if CK_DEBUG // throw err;\n\t\t\t/* istanbul ignore next */\n\t\t\tCKEditorError.rethrowUnexpectedError( err, this );\n\t\t}\n\t}\n\n\t/**\n\t * {@link module:utils/observablemixin~ObservableMixin#decorate Decorated} function for applying\n\t * {@link module:engine/model/operation/operation~Operation operations} to the model.\n\t *\n\t * This is a low-level way of changing the model. It is exposed for very specific use cases (like the undo feature).\n\t * Normally, to modify the model, you will want to use {@link module:engine/model/writer~Writer `Writer`}.\n\t * See also {@glink framework/guides/architecture/editing-engine#changing-the-model Changing the model} section\n\t * of the {@glink framework/guides/architecture/editing-engine Editing architecture} guide.\n\t *\n\t * @param {module:engine/model/operation/operation~Operation} operation The operation to apply.\n\t */\n\tapplyOperation( operation ) {\n\t\t// @if CK_DEBUG_ENGINE // console.log( 'Applying ' + operation );\n\n\t\t// @if CK_DEBUG_ENGINE // if ( !this._operationLogs ) {\n\t\t// @if CK_DEBUG_ENGINE //\tthis._operationLogs = [];\n\t\t// @if CK_DEBUG_ENGINE // }\n\n\t\t// @if CK_DEBUG_ENGINE // this._operationLogs.push( JSON.stringify( operation ) );\n\n\t\t// @if CK_DEBUG_ENGINE //if ( !this._appliedOperations ) {\n\t\t// @if CK_DEBUG_ENGINE //\tthis._appliedOperations = [];\n\t\t// @if CK_DEBUG_ENGINE //}\n\n\t\t// @if CK_DEBUG_ENGINE //this._appliedOperations.push( operation );\n\n\t\toperation._execute();\n\t}\n\n\t// @if CK_DEBUG_ENGINE // getAppliedOperation() {\n\t// @if CK_DEBUG_ENGINE //\tif ( !this._appliedOperations ) {\n\t// @if CK_DEBUG_ENGINE //\t\treturn '';\n\t// @if CK_DEBUG_ENGINE //\t}\n\n\t// @if CK_DEBUG_ENGINE //\treturn this._appliedOperations.map( JSON.stringify ).join( '-------' );\n\t// @if CK_DEBUG_ENGINE // }\n\n\t// @if CK_DEBUG_ENGINE // createReplayer( stringifiedOperations ) {\n\t// @if CK_DEBUG_ENGINE //\treturn new OperationReplayer( this, '-------', stringifiedOperations );\n\t// @if CK_DEBUG_ENGINE // }\n\n\t/**\n\t * Inserts content at the position in the editor specified by the selection, as one would expect the paste\n\t * functionality to work.\n\t *\n\t * This is a high-level method. It takes the {@link #schema schema} into consideration when inserting\n\t * the content, clears the given selection's content before inserting nodes and moves the selection\n\t * to its target position at the end of the process.\n\t * It can split elements, merge them, wrap bare text nodes with paragraphs, etc. &mdash; just like the\n\t * pasting feature should do.\n\t *\n\t * For lower-level methods see {@link module:engine/model/writer~Writer `Writer`}.\n\t *\n\t * This method, unlike {@link module:engine/model/writer~Writer `Writer`}'s methods, does not have to be used\n\t * inside a {@link #change `change()` block}.\n\t *\n\t * # Conversion and schema\n\t *\n\t * Inserting elements and text nodes into the model is not enough to make CKEditor 5 render that content\n\t * to the user. CKEditor 5 implements a model-view-controller architecture and what `model.insertContent()` does\n\t * is only adding nodes to the model. Additionally, you need to define\n\t * {@glink framework/guides/architecture/editing-engine#conversion converters} between the model and view\n\t * and define those nodes in the {@glink framework/guides/architecture/editing-engine#schema schema}.\n\t *\n\t * So, while this method may seem similar to CKEditor 4 `editor.insertHtml()` (in fact, both methods\n\t * are used for paste-like content insertion), the CKEditor 5 method cannot be use to insert arbitrary HTML\n\t * unless converters are defined for all elements and attributes in that HTML.\n\t *\n\t * # Examples\n\t *\n\t * Using `insertContent()` with a manually created model structure:\n\t *\n\t *\t\t// Let's create a document fragment containing such content as:\n\t *\t\t//\n\t *\t\t// <paragraph>foo</paragraph>\n\t *\t\t// <blockQuote>\n\t *\t\t//    <paragraph>bar</paragraph>\n\t *\t\t// </blockQuote>\n\t *\t\tconst docFrag = editor.model.change( writer => {\n\t *\t\t\tconst p1 = writer.createElement( 'paragraph' );\n\t *\t\t\tconst p2 = writer.createElement( 'paragraph' );\n\t *\t\t\tconst blockQuote = writer.createElement( 'blockQuote' );\n\t *\t\t\tconst docFrag = writer.createDocumentFragment();\n\t *\n\t *\t\t\twriter.append( p1, docFrag );\n\t *\t\t\twriter.append( blockQuote, docFrag );\n\t *\t\t\twriter.append( p2, blockQuote );\n\t *\t\t\twriter.insertText( 'foo', p1 );\n\t *\t\t\twriter.insertText( 'bar', p2 );\n\t *\n\t *\t\t\treturn docFrag;\n\t *\t\t} );\n\t *\n\t *\t\t// insertContent() does not have to be used in a change() block. It can, though,\n\t *\t\t// so this code could be moved to the callback defined above.\n\t *\t\teditor.model.insertContent( docFrag );\n\t *\n\t * Using `insertContent()` with an HTML string converted to a model document fragment (similar to the pasting mechanism):\n\t *\n\t *\t\t// You can create your own HtmlDataProcessor instance or use editor.data.processor\n\t *\t\t// if you have not overridden the default one (which is the HtmlDataProcessor instance).\n\t *\t\tconst htmlDP = new HtmlDataProcessor();\n\t *\n\t *\t\t// Convert an HTML string to a view document fragment:\n\t *\t\tconst viewFragment = htmlDP.toView( htmlString );\n\t *\n\t *\t\t// Convert the view document fragment to a model document fragment\n\t *\t\t// in the context of $root. This conversion takes the schema into\n\t *\t\t// account so if, for example, the view document fragment contained a bare text node,\n\t *\t\t// this text node cannot be a child of $root, so it will be automatically\n\t *\t\t// wrapped with a <paragraph>. You can define the context yourself (in the second parameter),\n\t *\t\t// and e.g. convert the content like it would happen in a <paragraph>.\n\t *\t\t// Note: The clipboard feature uses a custom context called $clipboardHolder\n\t *\t\t// which has a loosened schema.\n\t *\t\tconst modelFragment = editor.data.toModel( viewFragment );\n\t *\n\t *\t\teditor.model.insertContent( modelFragment );\n\t *\n\t * By default this method will use the document selection but it can also be used with a position, range or selection instance.\n\t *\n\t *\t\t// Insert text at the current document selection position.\n\t *\t\teditor.model.change( writer => {\n\t *\t\t\teditor.model.insertContent( writer.createText( 'x' ) );\n\t *\t\t} );\n\t *\n\t *\t\t// Insert text at a given position - the document selection will not be modified.\n\t *\t\teditor.model.change( writer => {\n\t *\t\t\teditor.model.insertContent( writer.createText( 'x' ), doc.getRoot(), 2 );\n\t *\n\t *\t\t\t// Which is a shorthand for:\n\t *\t\t\teditor.model.insertContent( writer.createText( 'x' ), writer.createPositionAt( doc.getRoot(), 2 ) );\n\t *\t\t} );\n\t *\n\t * If an instance of {@link module:engine/model/selection~Selection} is passed as `selectable`\n\t * it will be moved to the target position (where the document selection should be moved after the insertion).\n\t *\n\t *\t\teditor.model.change( writer => {\n\t *\t\t\t// Insert text replacing the given selection instance.\n\t *\t\t\tconst selection = writer.createSelection( paragraph, 'in' );\n\t *\n\t *\t\t\teditor.model.insertContent( writer.createText( 'x' ), selection );\n\t *\n\t *\t\t\t// insertContent() modifies the passed selection instance so it can be used to set the document selection.\n\t *\t\t\t// Note: This is not necessary when you passed the document selection to insertContent().\n\t *\t\t\twriter.setSelection( selection );\n\t *\t\t} );\n\t *\n\t * @fires insertContent\n\t * @param {module:engine/model/documentfragment~DocumentFragment|module:engine/model/item~Item} content The content to insert.\n\t * @param {module:engine/model/selection~Selectable} [selectable=model.document.selection]\n\t * The selection into which the content should be inserted. If not provided the current model document selection will be used.\n\t * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] To be used when a model item was passed as `selectable`.\n\t * This param defines a position in relation to that item.\n\t * @returns {module:engine/model/range~Range} Range which contains all the performed changes. This is a range that, if removed,\n\t * would return the model to the state before the insertion. If no changes were preformed by `insertContent`, returns a range collapsed\n\t * at the insertion position.\n\t */\n\tinsertContent( content, selectable, placeOrOffset ) {\n\t\treturn insertContent( this, content, selectable, placeOrOffset );\n\t}\n\n\t/**\n\t * Deletes content of the selection and merge siblings. The resulting selection is always collapsed.\n\t *\n\t * **Note:** For the sake of predictability, the resulting selection should always be collapsed.\n\t * In cases where a feature wants to modify deleting behavior so selection isn't collapsed\n\t * (e.g. a table feature may want to keep row selection after pressing <kbd>Backspace</kbd>),\n\t * then that behavior should be implemented in the view's listener. At the same time, the table feature\n\t * will need to modify this method's behavior too, e.g. to \"delete contents and then collapse\n\t * the selection inside the last selected cell\" or \"delete the row and collapse selection somewhere near\".\n\t * That needs to be done in order to ensure that other features which use `deleteContent()` will work well with tables.\n\t *\n\t * @fires deleteContent\n\t * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n\t * Selection of which the content should be deleted.\n\t * @param {Object} [options]\n\t * @param {Boolean} [options.leaveUnmerged=false] Whether to merge elements after removing the content of the selection.\n\t *\n\t * For example `<heading1>x[x</heading1><paragraph>y]y</paragraph>` will become:\n\t *\n\t * * `<heading1>x^y</heading1>` with the option disabled (`leaveUnmerged == false`)\n\t * * `<heading1>x^</heading1><paragraph>y</paragraph>` with enabled (`leaveUnmerged == true`).\n\t *\n\t * Note: {@link module:engine/model/schema~Schema#isObject object} and {@link module:engine/model/schema~Schema#isLimit limit}\n\t * elements will not be merged.\n\t *\n\t * @param {Boolean} [options.doNotResetEntireContent=false] Whether to skip replacing the entire content with a\n\t * paragraph when the entire content was selected.\n\t *\n\t * For example `<heading1>[x</heading1><paragraph>y]</paragraph>` will become:\n\t *\n\t * * `<paragraph>^</paragraph>` with the option disabled (`doNotResetEntireContent == false`)\n\t * * `<heading1>^</heading1>` with enabled (`doNotResetEntireContent == true`)\n\t *\n\t * @param {Boolean} [options.doNotAutoparagraph=false] Whether to create a paragraph if after content deletion selection is moved\n\t * to a place where text cannot be inserted.\n\t *\n\t * For example `<paragraph>x</paragraph>[<image src=\"foo.jpg\"></image>]` will become:\n\t *\n\t * * `<paragraph>x</paragraph><paragraph>[]</paragraph>` with the option disabled (`doNotAutoparagraph == false`)\n\t * * `<paragraph>x[]</paragraph>` with the option enabled (`doNotAutoparagraph == true`).\n\t *\n\t * **Note:** if there is no valid position for the selection, the paragraph will always be created:\n\t *\n\t * `[<image src=\"foo.jpg\"></image>]` -> `<paragraph>[]</paragraph>`.\n\t */\n\tdeleteContent( selection, options ) {\n\t\tdeleteContent( this, selection, options );\n\t}\n\n\t/**\n\t * Modifies the selection. Currently, the supported modifications are:\n\t *\n\t * * Extending. The selection focus is moved in the specified `options.direction` with a step specified in `options.unit`.\n\t * Possible values for `unit` are:\n\t *  * `'character'` (default) - moves selection by one user-perceived character. In most cases this means moving by one\n\t *  character in `String` sense. However, unicode also defines \"combing marks\". These are special symbols, that combines\n\t *  with a symbol before it (\"base character\") to create one user-perceived character. For example, `q̣̇` is a normal\n\t *  letter `q` with two \"combining marks\": upper dot (`Ux0307`) and lower dot (`Ux0323`). For most actions, i.e. extending\n\t *  selection by one position, it is correct to include both \"base character\" and all of it's \"combining marks\". That is\n\t *  why `'character'` value is most natural and common method of modifying selection.\n\t *  * `'codePoint'` - moves selection by one unicode code point. In contrary to, `'character'` unit, this will insert\n\t *  selection between \"base character\" and \"combining mark\", because \"combining marks\" have their own unicode code points.\n\t *  However, for technical reasons, unicode code points with values above `UxFFFF` are represented in native `String` by\n\t *  two characters, called \"surrogate pairs\". Halves of \"surrogate pairs\" have a meaning only when placed next to each other.\n\t *  For example `𨭎` is represented in `String` by `\\uD862\\uDF4E`. Both `\\uD862` and `\\uDF4E` do not have any meaning\n\t *  outside the pair (are rendered as ? when alone). Position between them would be incorrect. In this case, selection\n\t *  extension will include whole \"surrogate pair\".\n\t *  * `'word'` - moves selection by a whole word.\n\t *\n\t * **Note:** if you extend a forward selection in a backward direction you will in fact shrink it.\n\t *\n\t * @fires modifySelection\n\t * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n\t * The selection to modify.\n\t * @param {Object} [options]\n\t * @param {'forward'|'backward'} [options.direction='forward'] The direction in which the selection should be modified.\n\t * @param {'character'|'codePoint'|'word'} [options.unit='character'] The unit by which selection should be modified.\n\t */\n\tmodifySelection( selection, options ) {\n\t\tmodifySelection( this, selection, options );\n\t}\n\n\t/**\n\t * Gets a clone of the selected content.\n\t *\n\t * For example, for the following selection:\n\t *\n\t * ```html\n\t * <paragraph>x</paragraph>\n\t * <blockQuote>\n\t *\t<paragraph>y</paragraph>\n\t *\t<heading1>fir[st</heading1>\n\t * </blockQuote>\n\t * <paragraph>se]cond</paragraph>\n\t * <paragraph>z</paragraph>\n\t * ```\n\t *\n\t * It will return a document fragment with such a content:\n\t *\n\t * ```html\n\t * <blockQuote>\n\t *\t<heading1>st</heading1>\n\t * </blockQuote>\n\t * <paragraph>se</paragraph>\n\t * ```\n\t *\n\t * @fires getSelectedContent\n\t * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection\n\t * The selection of which content will be returned.\n\t * @returns {module:engine/model/documentfragment~DocumentFragment}\n\t */\n\tgetSelectedContent( selection ) {\n\t\treturn getSelectedContent( this, selection );\n\t}\n\n\t/**\n\t * Checks whether the given {@link module:engine/model/range~Range range} or\n\t * {@link module:engine/model/element~Element element} has any meaningful content.\n\t *\n\t * Meaningful content is:\n\t *\n\t * * any text node (`options.ignoreWhitespaces` allows controlling whether this text node must also contain\n\t * any non-whitespace characters),\n\t * * or any {@link module:engine/model/schema~Schema#isObject object element},\n\t * * or any {@link module:engine/model/markercollection~Marker marker} which\n\t * {@link module:engine/model/markercollection~Marker#_affectsData affects data}.\n\t *\n\t * This means that a range containing an empty `<paragraph></paragraph>` is not considered to have a meaningful content.\n\t * However, a range containing an `<image></image>` (which would normally be marked in the schema as an object element)\n\t * is considered non-empty.\n\t *\n\t * @param {module:engine/model/range~Range|module:engine/model/element~Element} rangeOrElement Range or element to check.\n\t * @param {Object} [options]\n\t * @param {Boolean} [options.ignoreWhitespaces] Whether text node with whitespaces only should be considered empty.\n\t * @returns {Boolean}\n\t */\n\thasContent( rangeOrElement, options ) {\n\t\tconst range = rangeOrElement instanceof ModelElement ? ModelRange._createIn( rangeOrElement ) : rangeOrElement;\n\n\t\tif ( range.isCollapsed ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check if there are any markers which affects data in this given range.\n\t\tfor ( const intersectingMarker of this.markers.getMarkersIntersectingRange( range ) ) {\n\t\t\tif ( intersectingMarker.affectsData ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tconst { ignoreWhitespaces = false } = options || {};\n\n\t\tfor ( const item of range.getItems() ) {\n\t\t\tif ( item.is( 'textProxy' ) ) {\n\t\t\t\tif ( !ignoreWhitespaces ) {\n\t\t\t\t\treturn true;\n\t\t\t\t} else if ( item.data.search( /\\S/ ) !== -1 ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else if ( this.schema.isObject( item ) ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Creates a position from the given root and path in that root.\n\t *\n\t * Note: This method is also available as\n\t * {@link module:engine/model/writer~Writer#createPositionFromPath `Writer#createPositionFromPath()`}.\n\t *\n\t * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} root Root of the position.\n\t * @param {Array.<Number>} path Position path. See {@link module:engine/model/position~Position#path}.\n\t * @param {module:engine/model/position~PositionStickiness} [stickiness='toNone'] Position stickiness.\n\t * See {@link module:engine/model/position~PositionStickiness}.\n\t * @returns {module:engine/model/position~Position}\n\t */\n\tcreatePositionFromPath( root, path, stickiness ) {\n\t\treturn new ModelPosition( root, path, stickiness );\n\t}\n\n\t/**\n\t * Creates position at the given location. The location can be specified as:\n\t *\n\t * * a {@link module:engine/model/position~Position position},\n\t * * a parent element and offset in that element,\n\t * * a parent element and `'end'` (the position will be set at the end of that element),\n\t * * a {@link module:engine/model/item~Item model item} and `'before'` or `'after'`\n\t * (the position will be set before or after the given model item).\n\t *\n\t * This method is a shortcut to other factory methods such as:\n\t *\n\t * * {@link module:engine/model/model~Model#createPositionBefore `createPositionBefore()`},\n\t * * {@link module:engine/model/model~Model#createPositionAfter `createPositionAfter()`}.\n\t *\n\t * Note: This method is also available as\n\t * {@link module:engine/model/writer~Writer#createPositionAt `Writer#createPositionAt()`},\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition\n\t * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n\t * first parameter is a {@link module:engine/model/item~Item model item}.\n\t */\n\tcreatePositionAt( itemOrPosition, offset ) {\n\t\treturn ModelPosition._createAt( itemOrPosition, offset );\n\t}\n\n\t/**\n\t * Creates a new position after the given {@link module:engine/model/item~Item model item}.\n\t *\n\t * Note: This method is also available as\n\t * {@link module:engine/model/writer~Writer#createPositionAfter `Writer#createPositionAfter()`}.\n\t *\n\t * @param {module:engine/model/item~Item} item Item after which the position should be placed.\n\t * @returns {module:engine/model/position~Position}\n\t */\n\tcreatePositionAfter( item ) {\n\t\treturn ModelPosition._createAfter( item );\n\t}\n\n\t/**\n\t * Creates a new position before the given {@link module:engine/model/item~Item model item}.\n\t *\n\t * Note: This method is also available as\n\t * {@link module:engine/model/writer~Writer#createPositionBefore `Writer#createPositionBefore()`}.\n\t *\n\t * @param {module:engine/model/item~Item} item Item before which the position should be placed.\n\t * @returns {module:engine/model/position~Position}\n\t */\n\tcreatePositionBefore( item ) {\n\t\treturn ModelPosition._createBefore( item );\n\t}\n\n\t/**\n\t * Creates a range spanning from the `start` position to the `end` position.\n\t *\n\t * Note: This method is also available as\n\t * {@link module:engine/model/writer~Writer#createRange `Writer#createRange()`}:\n\t *\n\t *\t\tmodel.change( writer => {\n\t *\t\t\tconst range = writer.createRange( start, end );\n\t *\t\t} );\n\t *\n\t * @param {module:engine/model/position~Position} start Start position.\n\t * @param {module:engine/model/position~Position} [end] End position. If not set, the range will be collapsed\n\t * to the `start` position.\n\t * @returns {module:engine/model/range~Range}\n\t */\n\tcreateRange( start, end ) {\n\t\treturn new ModelRange( start, end );\n\t}\n\n\t/**\n\t * Creates a range inside the given element which starts before the first child of\n\t * that element and ends after the last child of that element.\n\t *\n\t * Note: This method is also available as\n\t * {@link module:engine/model/writer~Writer#createRangeIn `Writer#createRangeIn()`}:\n\t *\n\t *\t\tmodel.change( writer => {\n\t *\t\t\tconst range = writer.createRangeIn( paragraph );\n\t *\t\t} );\n\t *\n\t * @param {module:engine/model/element~Element} element Element which is a parent for the range.\n\t * @returns {module:engine/model/range~Range}\n\t */\n\tcreateRangeIn( element ) {\n\t\treturn ModelRange._createIn( element );\n\t}\n\n\t/**\n\t * Creates a range that starts before the given {@link module:engine/model/item~Item model item} and ends after it.\n\t *\n\t * Note: This method is also available on `writer` instance as\n\t * {@link module:engine/model/writer~Writer#createRangeOn `Writer.createRangeOn()`}:\n\t *\n\t *\t\tmodel.change( writer => {\n\t *\t\t\tconst range = writer.createRangeOn( paragraph );\n\t *\t\t} );\n\t *\n\t * @param {module:engine/model/item~Item} item\n\t * @returns {module:engine/model/range~Range}\n\t */\n\tcreateRangeOn( item ) {\n\t\treturn ModelRange._createOn( item );\n\t}\n\n\t/**\n\t * Creates a new selection instance based on the given {@link module:engine/model/selection~Selectable selectable}\n\t * or creates an empty selection if no arguments were passed.\n\t *\n\t * Note: This method is also available as\n\t * {@link module:engine/model/writer~Writer#createSelection `Writer#createSelection()`}.\n\t *\n\t *\t\t// Creates empty selection without ranges.\n\t *\t\tconst selection = writer.createSelection();\n\t *\n\t *\t\t// Creates selection at the given range.\n\t *\t\tconst range = writer.createRange( start, end );\n\t *\t\tconst selection = writer.createSelection( range );\n\t *\n\t *\t\t// Creates selection at the given ranges\n\t *\t\tconst ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];\n\t *\t\tconst selection = writer.createSelection( ranges );\n\t *\n\t *\t\t// Creates selection from the other selection.\n\t *\t\t// Note: It doesn't copies selection attributes.\n\t *\t\tconst otherSelection = writer.createSelection();\n\t *\t\tconst selection = writer.createSelection( otherSelection );\n\t *\n\t *\t\t// Creates selection from the given document selection.\n\t *\t\t// Note: It doesn't copies selection attributes.\n\t *\t\tconst documentSelection = model.document.selection;\n\t *\t\tconst selection = writer.createSelection( documentSelection );\n\t *\n\t *\t\t// Creates selection at the given position.\n\t *\t\tconst position = writer.createPositionFromPath( root, path );\n\t *\t\tconst selection = writer.createSelection( position );\n\t *\n\t *\t\t// Creates selection at the given offset in the given element.\n\t *\t\tconst paragraph = writer.createElement( 'paragraph' );\n\t *\t\tconst selection = writer.createSelection( paragraph, offset );\n\t *\n\t *\t\t// Creates a range inside an {@link module:engine/model/element~Element element} which starts before the\n\t *\t\t// first child of that element and ends after the last child of that element.\n\t *\t\tconst selection = writer.createSelection( paragraph, 'in' );\n\t *\n\t *\t\t// Creates a range on an {@link module:engine/model/item~Item item} which starts before the item and ends\n\t *\t\t// just after the item.\n\t *\t\tconst selection = writer.createSelection( paragraph, 'on' );\n\t *\n\t *\t\t// Additional options (`'backward'`) can be specified as the last argument.\n\t *\n\t *\t\t// Creates backward selection.\n\t *\t\tconst selection = writer.createSelection( range, { backward: true } );\n\t *\n\t * @param {module:engine/model/selection~Selectable} selectable\n\t * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n\t * @param {Object} [options]\n\t * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n\t * @returns {module:engine/model/selection~Selection}\n\t */\n\tcreateSelection( selectable, placeOrOffset, options ) {\n\t\treturn new ModelSelection( selectable, placeOrOffset, options );\n\t}\n\n\t/**\n\t * Creates a {@link module:engine/model/batch~Batch} instance.\n\t *\n\t * **Note:** In most cases creating a batch instance is not necessary as they are created when using:\n\t *\n\t * * {@link #change `change()`},\n\t * * {@link #enqueueChange `enqueueChange()`}.\n\t *\n\t * @param {'transparent'|'default'} [type='default'] The type of the batch.\n\t * @returns {module:engine/model/batch~Batch}\n\t */\n\tcreateBatch( type ) {\n\t\treturn new Batch( type );\n\t}\n\n\t/**\n\t * Removes all events listeners set by model instance and destroys {@link module:engine/model/document~Document}.\n\t */\n\tdestroy() {\n\t\tthis.document.destroy();\n\t\tthis.stopListening();\n\t}\n\n\t/**\n\t * Common part of {@link module:engine/model/model~Model#change} and {@link module:engine/model/model~Model#enqueueChange}\n\t * which calls callbacks and returns array of values returned by these callbacks.\n\t *\n\t * @private\n\t * @returns {Array.<*>} Array of values returned by callbacks.\n\t */\n\t_runPendingChanges() {\n\t\tconst ret = [];\n\n\t\tthis.fire( '_beforeChanges' );\n\n\t\twhile ( this._pendingChanges.length ) {\n\t\t\t// Create a new writer using batch instance created for this chain of changes.\n\t\t\tconst currentBatch = this._pendingChanges[ 0 ].batch;\n\t\t\tthis._currentWriter = new Writer( this, currentBatch );\n\n\t\t\t// Execute changes callback and gather the returned value.\n\t\t\tconst callbackReturnValue = this._pendingChanges[ 0 ].callback( this._currentWriter );\n\t\t\tret.push( callbackReturnValue );\n\n\t\t\tthis.document._handleChangeBlock( this._currentWriter );\n\n\t\t\tthis._pendingChanges.shift();\n\t\t\tthis._currentWriter = null;\n\t\t}\n\n\t\tthis.fire( '_afterChanges' );\n\n\t\treturn ret;\n\t}\n\n\t/**\n\t * Fired when entering the outermost {@link module:engine/model/model~Model#enqueueChange} or\n\t * {@link module:engine/model/model~Model#change} block.\n\t *\n\t * @protected\n\t * @event _beforeChanges\n\t */\n\n\t/**\n\t * Fired when leaving the outermost {@link module:engine/model/model~Model#enqueueChange} or\n\t * {@link module:engine/model/model~Model#change} block.\n\t *\n\t * @protected\n\t * @event _afterChanges\n\t */\n\n\t/**\n\t * Fired every time any {@link module:engine/model/operation/operation~Operation operation} is applied on the model\n\t * using {@link #applyOperation}.\n\t *\n\t * Note that this event is suitable only for very specific use-cases. Use it if you need to listen to every single operation\n\t * applied on the document. However, in most cases {@link module:engine/model/document~Document#event:change} should\n\t * be used.\n\t *\n\t * A few callbacks are already added to this event by engine internal classes:\n\t *\n\t * * with `highest` priority operation is validated,\n\t * * with `normal` priority operation is executed,\n\t * * with `low` priority the {@link module:engine/model/document~Document} updates its version,\n\t * * with `low` priority {@link module:engine/model/liveposition~LivePosition} and {@link module:engine/model/liverange~LiveRange}\n\t * update themselves.\n\t *\n\t * @event applyOperation\n\t * @param {Array} args Arguments of the `applyOperation` which is an array with a single element - applied\n\t * {@link module:engine/model/operation/operation~Operation operation}.\n\t */\n\n\t/**\n\t * Event fired when {@link #insertContent} method is called.\n\t *\n\t * The {@link #insertContent default action of that method} is implemented as a\n\t * listener to this event so it can be fully customized by the features.\n\t *\n\t * **Note** The `selectable` parameter for the {@link #insertContent} is optional. When `undefined` value is passed the method uses\n\t * `model.document.selection`.\n\t *\n\t * @event insertContent\n\t * @param {Array} args The arguments passed to the original method.\n\t */\n\n\t/**\n\t * Event fired when {@link #deleteContent} method is called.\n\t *\n\t * The {@link #deleteContent default action of that method} is implemented as a\n\t * listener to this event so it can be fully customized by the features.\n\t *\n\t * @event deleteContent\n\t * @param {Array} args The arguments passed to the original method.\n\t */\n\n\t/**\n\t * Event fired when {@link #modifySelection} method is called.\n\t *\n\t * The {@link #modifySelection default action of that method} is implemented as a\n\t * listener to this event so it can be fully customized by the features.\n\t *\n\t * @event modifySelection\n\t * @param {Array} args The arguments passed to the original method.\n\t */\n\n\t/**\n\t * Event fired when {@link #getSelectedContent} method is called.\n\t *\n\t * The {@link #getSelectedContent default action of that method} is implemented as a\n\t * listener to this event so it can be fully customized by the features.\n\t *\n\t * @event getSelectedContent\n\t * @param {Array} args The arguments passed to the original method.\n\t */\n}\n\nmix( Model, ObservableMixin );\n"]}]}