{"remainingRequest":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/babel-loader/lib/index.js!/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-engine/src/model/differ.js","dependencies":[{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-engine/src/model/differ.js","mtime":499162500000},{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js","mtime":499162500000},{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/babel-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:LyoqCiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDE5LCBDS1NvdXJjZSAtIEZyZWRlcmljbyBLbmFiYmVuLiBBbGwgcmlnaHRzIHJlc2VydmVkLgogKiBGb3IgbGljZW5zaW5nLCBzZWUgTElDRU5TRS5tZCBvciBodHRwczovL2NrZWRpdG9yLmNvbS9sZWdhbC9ja2VkaXRvci1vc3MtbGljZW5zZQogKi8KCi8qKgogKiBAbW9kdWxlIGVuZ2luZS9tb2RlbC9kaWZmZXIKICovCmltcG9ydCBQb3NpdGlvbiBmcm9tICcuL3Bvc2l0aW9uJzsKaW1wb3J0IFJhbmdlIGZyb20gJy4vcmFuZ2UnOwovKioKICogQ2FsY3VsYXRlcyB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHR3byBtb2RlbCBzdGF0ZXMuCiAqCiAqIFJlY2VpdmVzIG9wZXJhdGlvbnMgdGhhdCBhcmUgdG8gYmUgYXBwbGllZCBvbiB0aGUgbW9kZWwgZG9jdW1lbnQuIE1hcmtzIHBhcnRzIG9mIHRoZSBtb2RlbCBkb2N1bWVudCB0cmVlIHdoaWNoCiAqIGFyZSBjaGFuZ2VkIGFuZCBzYXZlcyB0aGUgc3RhdGUgb2YgdGhlc2UgZWxlbWVudHMgYmVmb3JlIHRoZSBjaGFuZ2UuIFRoZW4sIGl0IGNvbXBhcmVzIHNhdmVkIGVsZW1lbnRzIHdpdGggdGhlCiAqIGNoYW5nZWQgZWxlbWVudHMsIGFmdGVyIGFsbCBjaGFuZ2VzIGFyZSBhcHBsaWVkIG9uIHRoZSBtb2RlbCBkb2N1bWVudC4gQ2FsY3VsYXRlcyB0aGUgZGlmZiBiZXR3ZWVuIHNhdmVkCiAqIGVsZW1lbnRzIGFuZCBuZXcgb25lcyBhbmQgcmV0dXJucyBhIGNoYW5nZSBzZXQuCiAqLwoKZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGlmZmVyIHsKICAvKioKICAgKiBDcmVhdGVzIGEgYERpZmZlcmAgaW5zdGFuY2UuCiAgICoKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvbWFya2VyY29sbGVjdGlvbn5NYXJrZXJDb2xsZWN0aW9ufSBtYXJrZXJDb2xsZWN0aW9uIE1vZGVsJ3MgbWFya2VyIGNvbGxlY3Rpb24uCiAgICovCiAgY29uc3RydWN0b3IobWFya2VyQ29sbGVjdGlvbikgewogICAgLyoqCiAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIG1vZGVsJ3MgbWFya2VyIGNvbGxlY3Rpb24uCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEB0eXBlIHttb2R1bGU6ZW5naW5lL21vZGVsL21hcmtlcmNvbGxlY3Rpb25+TWFya2VyQ29sbGVjdGlvbn0KICAgICAqLwogICAgdGhpcy5fbWFya2VyQ29sbGVjdGlvbiA9IG1hcmtlckNvbGxlY3Rpb247CiAgICAvKioKICAgICAqIEEgbWFwIHRoYXQgc3RvcmVzIGNoYW5nZXMgdGhhdCBoYXBwZW5lZCBpbiBhIGdpdmVuIGVsZW1lbnQuCiAgICAgKgogICAgICogVGhlIGtleXMgb2YgdGhlIG1hcCBhcmUgcmVmZXJlbmNlcyB0byB0aGUgbW9kZWwgZWxlbWVudHMuCiAgICAgKiBUaGUgdmFsdWVzIG9mIHRoZSBtYXAgYXJlIGFycmF5cyB3aXRoIGNoYW5nZXMgdGhhdCB3ZXJlIGRvbmUgb24gdGhpcyBlbGVtZW50LgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAdHlwZSB7TWFwfQogICAgICovCgogICAgdGhpcy5fY2hhbmdlc0luRWxlbWVudCA9IG5ldyBNYXAoKTsKICAgIC8qKgogICAgICogQSBtYXAgdGhhdCBzdG9yZXMgImVsZW1lbnQncyBjaGlsZHJlbiBzbmFwc2hvdHMiLiBBIHNuYXBzaG90IGlzIHJlcHJlc2VudGluZyBjaGlsZHJlbiBvZiBhIGdpdmVuIGVsZW1lbnQgYmVmb3JlCiAgICAgKiB0aGUgZmlyc3QgY2hhbmdlIHdhcyBhcHBsaWVkIG9uIHRoYXQgZWxlbWVudC4gU25hcHNob3QgaXRlbXMgYXJlIG9iamVjdHMgd2l0aCB0d28gcHJvcGVydGllczogYG5hbWVgLAogICAgICogY29udGFpbmluZyB0aGUgZWxlbWVudCBuYW1lIChvciBgJyR0ZXh0J2AgZm9yIGEgdGV4dCBub2RlKSBhbmQgYGF0dHJpYnV0ZXNgIHdoaWNoIGlzIGEgbWFwIG9mIHRoZSBub2RlJ3MgYXR0cmlidXRlcy4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQHR5cGUge01hcH0KICAgICAqLwoKICAgIHRoaXMuX2VsZW1lbnRTbmFwc2hvdHMgPSBuZXcgTWFwKCk7CiAgICAvKioKICAgICAqIEEgbWFwIHRoYXQgc3RvcmVzIGFsbCBjaGFuZ2VkIG1hcmtlcnMuCiAgICAgKgogICAgICogVGhlIGtleXMgb2YgdGhlIG1hcCBhcmUgbWFya2VyIG5hbWVzLgogICAgICogVGhlIHZhbHVlcyBvZiB0aGUgbWFwIGFyZSBvYmplY3RzIHdpdGggdGhlIGBvbGRSYW5nZWAgYW5kIGBuZXdSYW5nZWAgcHJvcGVydGllcy4gVGhleSBzdG9yZSB0aGUgbWFya2VyIHJhbmdlCiAgICAgKiBzdGF0ZSBiZWZvcmUgYW5kIGFmdGVyIHRoZSBjaGFuZ2UuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEB0eXBlIHtNYXB9CiAgICAgKi8KCiAgICB0aGlzLl9jaGFuZ2VkTWFya2VycyA9IG5ldyBNYXAoKTsKICAgIC8qKgogICAgICogU3RvcmVzIHRoZSBudW1iZXIgb2YgY2hhbmdlcyB0aGF0IHdlcmUgcHJvY2Vzc2VkLiBVc2VkIHRvIG9yZGVyIHRoZSBjaGFuZ2VzIGNocm9ub2xvZ2ljYWxseS4gSXQgaXMgaW1wb3J0YW50CiAgICAgKiB3aGVuIGNoYW5nZXMgYXJlIHNvcnRlZC4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQHR5cGUge051bWJlcn0KICAgICAqLwoKICAgIHRoaXMuX2NoYW5nZUNvdW50ID0gMDsKICAgIC8qKgogICAgICogRm9yIGVmZmljaWVuY3kgcHVycG9zZXMsIGBEaWZmZXJgIHN0b3JlcyB0aGUgY2hhbmdlIHNldCByZXR1cm5lZCBieSB0aGUgZGlmZmVyIGFmdGVyIHtAbGluayAjZ2V0Q2hhbmdlc30gY2FsbC4KICAgICAqIENhY2hlIGlzIHJlc2V0IGVhY2ggdGltZSBhIG5ldyBvcGVyYXRpb24gaXMgYnVmZmVyZWQuIElmIHRoZSBjYWNoZSBoYXMgbm90IGJlZW4gcmVzZXQsIHtAbGluayAjZ2V0Q2hhbmdlc30gd2lsbAogICAgICogcmV0dXJuIHRoZSBjYWNoZWQgdmFsdWUgaW5zdGVhZCBvZiBjYWxjdWxhdGluZyBpdCBhZ2Fpbi4KICAgICAqCiAgICAgKiBUaGlzIHByb3BlcnR5IHN0b3JlcyB0aG9zZSBjaGFuZ2VzIHRoYXQgZGlkIG5vdCB0YWtlIHBsYWNlIGluIGdyYXZleWFyZCByb290LgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAdHlwZSB7QXJyYXkuPE9iamVjdD58bnVsbH0KICAgICAqLwoKICAgIHRoaXMuX2NhY2hlZENoYW5nZXMgPSBudWxsOwogICAgLyoqCiAgICAgKiBGb3IgZWZmaWNpZW5jeSBwdXJwb3NlcywgYERpZmZlcmAgc3RvcmVzIHRoZSBjaGFuZ2Ugc2V0IHJldHVybmVkIGJ5IHRoZSBkaWZmZXIgYWZ0ZXIgdGhlIHtAbGluayAjZ2V0Q2hhbmdlc30gY2FsbC4KICAgICAqIFRoZSBjYWNoZSBpcyByZXNldCBlYWNoIHRpbWUgYSBuZXcgb3BlcmF0aW9uIGlzIGJ1ZmZlcmVkLiBJZiB0aGUgY2FjaGUgaGFzIG5vdCBiZWVuIHJlc2V0LCB7QGxpbmsgI2dldENoYW5nZXN9IHdpbGwKICAgICAqIHJldHVybiB0aGUgY2FjaGVkIHZhbHVlIGluc3RlYWQgb2YgY2FsY3VsYXRpbmcgaXQgYWdhaW4uCiAgICAgKgogICAgICogVGhpcyBwcm9wZXJ0eSBzdG9yZXMgYWxsIGNoYW5nZXMgZXZhbHVhdGVkIGJ5IGBEaWZmZXJgLCBpbmNsdWRpbmcgdGhvc2UgdGhhdCB0b29rIHBsYWNlIGluIHRoZSBncmF2ZXlhcmQuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEB0eXBlIHtBcnJheS48T2JqZWN0PnxudWxsfQogICAgICovCgogICAgdGhpcy5fY2FjaGVkQ2hhbmdlc1dpdGhHcmF2ZXlhcmQgPSBudWxsOwogIH0KICAvKioKICAgKiBJbmZvcm1zIHdoZXRoZXIgdGhlcmUgYXJlIGFueSBjaGFuZ2VzIGJ1ZmZlcmVkIGluIGBEaWZmZXJgLgogICAqCiAgICogQHJlYWRvbmx5CiAgICogQHR5cGUge0Jvb2xlYW59CiAgICovCgoKICBnZXQgaXNFbXB0eSgpIHsKICAgIHJldHVybiB0aGlzLl9jaGFuZ2VzSW5FbGVtZW50LnNpemUgPT0gMCAmJiB0aGlzLl9jaGFuZ2VkTWFya2Vycy5zaXplID09IDA7CiAgfQogIC8qKgogICAqIE1hcmtzIGdpdmVuIGBpdGVtYCBpbiBkaWZmZXIgdG8gYmUgInJlZnJlc2hlZCIuIEl0IG1lYW5zIHRoYXQgdGhlIGl0ZW0gd2lsbCBiZSBtYXJrZWQgYXMgcmVtb3ZlZCBhbmQgaW5zZXJ0ZWQgaW4gdGhlIGRpZmZlciBjaGFuZ2VzCiAgICogc2V0LCBzbyBpdCB3aWxsIGJlIGVmZmVjdGl2ZWx5IHJlLWNvbnZlcnRlZCB3aGVuIGRpZmZlciBjaGFuZ2VzIHdpbGwgYmUgaGFuZGxlZCBieSBhIGRpc3BhdGNoZXIuCiAgICoKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtfSBpdGVtIEl0ZW0gdG8gcmVmcmVzaC4KICAgKi8KCgogIHJlZnJlc2hJdGVtKGl0ZW0pIHsKICAgIGlmICh0aGlzLl9pc0luSW5zZXJ0ZWRFbGVtZW50KGl0ZW0ucGFyZW50KSkgewogICAgICByZXR1cm47CiAgICB9CgogICAgdGhpcy5fbWFya1JlbW92ZShpdGVtLnBhcmVudCwgaXRlbS5zdGFydE9mZnNldCwgaXRlbS5vZmZzZXRTaXplKTsKCiAgICB0aGlzLl9tYXJrSW5zZXJ0KGl0ZW0ucGFyZW50LCBpdGVtLnN0YXJ0T2Zmc2V0LCBpdGVtLm9mZnNldFNpemUpOwoKICAgIGNvbnN0IHJhbmdlID0gUmFuZ2UuX2NyZWF0ZU9uKGl0ZW0pOwoKICAgIGZvciAoY29uc3QgbWFya2VyIG9mIHRoaXMuX21hcmtlckNvbGxlY3Rpb24uZ2V0TWFya2Vyc0ludGVyc2VjdGluZ1JhbmdlKHJhbmdlKSkgewogICAgICBjb25zdCBtYXJrZXJSYW5nZSA9IG1hcmtlci5nZXRSYW5nZSgpOwogICAgICB0aGlzLmJ1ZmZlck1hcmtlckNoYW5nZShtYXJrZXIubmFtZSwgbWFya2VyUmFuZ2UsIG1hcmtlclJhbmdlLCBtYXJrZXIuYWZmZWN0c0RhdGEpOwogICAgfSAvLyBDbGVhciBjYWNoZSBhZnRlciBlYWNoIGJ1ZmZlcmVkIG9wZXJhdGlvbiBhcyBpdCBpcyBubyBsb25nZXIgdmFsaWQuCgoKICAgIHRoaXMuX2NhY2hlZENoYW5nZXMgPSBudWxsOwogIH0KICAvKioKICAgKiBCdWZmZXJzIHRoZSBnaXZlbiBvcGVyYXRpb24uIEFuIG9wZXJhdGlvbiBoYXMgdG8gYmUgYnVmZmVyZWQgYmVmb3JlIGl0IGlzIGV4ZWN1dGVkLgogICAqCiAgICogT3BlcmF0aW9uIHR5cGUgaXMgY2hlY2tlZCBhbmQgaXQgaXMgY2hlY2tlZCB3aGljaCBub2RlcyBpdCB3aWxsIGFmZmVjdC4gVGhlc2Ugbm9kZXMgYXJlIHRoZW4gc3RvcmVkIGluIGBEaWZmZXJgCiAgICogaW4gdGhlIHN0YXRlIGJlZm9yZSB0aGUgb3BlcmF0aW9uIGlzIGV4ZWN1dGVkLgogICAqCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL29wZXJhdGlvbi9vcGVyYXRpb25+T3BlcmF0aW9ufSBvcGVyYXRpb24gQW4gb3BlcmF0aW9uIHRvIGJ1ZmZlci4KICAgKi8KCgogIGJ1ZmZlck9wZXJhdGlvbihvcGVyYXRpb24pIHsKICAgIC8vIEJlbG93IHdlIHRha2UgYW4gb3BlcmF0aW9uLCBjaGVjayBpdHMgdHlwZSwgdGhlbiB1c2UgaXRzIHBhcmFtZXRlcnMgaW4gbWFya2luZyAocHJpdmF0ZSkgbWV0aG9kcy4KICAgIC8vIFRoZSBnZW5lcmFsIHJ1bGUgaXMgdG8gbm90IG1hcmsgZWxlbWVudHMgaW5zaWRlIGluc2VydGVkIGVsZW1lbnQuIEFsbCBpbnNlcnRlZCBlbGVtZW50cyBhcmUgcmUtcmVuZGVyZWQuCiAgICAvLyBNYXJraW5nIGNoYW5nZXMgaW4gdGhlbSB3b3VsZCBjYXVzZSBhICJkb3VibGUiIGNoYW5naW5nIHRoZW4uCiAgICAvLwogICAgc3dpdGNoIChvcGVyYXRpb24udHlwZSkgewogICAgICBjYXNlICdpbnNlcnQnOgogICAgICAgIHsKICAgICAgICAgIGlmICh0aGlzLl9pc0luSW5zZXJ0ZWRFbGVtZW50KG9wZXJhdGlvbi5wb3NpdGlvbi5wYXJlbnQpKSB7CiAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgIH0KCiAgICAgICAgICB0aGlzLl9tYXJrSW5zZXJ0KG9wZXJhdGlvbi5wb3NpdGlvbi5wYXJlbnQsIG9wZXJhdGlvbi5wb3NpdGlvbi5vZmZzZXQsIG9wZXJhdGlvbi5ub2Rlcy5tYXhPZmZzZXQpOwoKICAgICAgICAgIGJyZWFrOwogICAgICAgIH0KCiAgICAgIGNhc2UgJ2FkZEF0dHJpYnV0ZSc6CiAgICAgIGNhc2UgJ3JlbW92ZUF0dHJpYnV0ZSc6CiAgICAgIGNhc2UgJ2NoYW5nZUF0dHJpYnV0ZSc6CiAgICAgICAgewogICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIG9wZXJhdGlvbi5yYW5nZS5nZXRJdGVtcyh7CiAgICAgICAgICAgIHNoYWxsb3c6IHRydWUKICAgICAgICAgIH0pKSB7CiAgICAgICAgICAgIGlmICh0aGlzLl9pc0luSW5zZXJ0ZWRFbGVtZW50KGl0ZW0ucGFyZW50KSkgewogICAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgICB9CgogICAgICAgICAgICB0aGlzLl9tYXJrQXR0cmlidXRlKGl0ZW0pOwogICAgICAgICAgfQoKICAgICAgICAgIGJyZWFrOwogICAgICAgIH0KCiAgICAgIGNhc2UgJ3JlbW92ZSc6CiAgICAgIGNhc2UgJ21vdmUnOgogICAgICBjYXNlICdyZWluc2VydCc6CiAgICAgICAgewogICAgICAgICAgLy8gV2hlbiByYW5nZSBpcyBtb3ZlZCB0byB0aGUgc2FtZSBwb3NpdGlvbiB0aGVuIG5vdCBtYXJrIGl0IGFzIGEgY2hhbmdlLgogICAgICAgICAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vY2tlZGl0b3IvY2tlZGl0b3I1LWVuZ2luZS9pc3N1ZXMvMTY2NC4KICAgICAgICAgIGlmIChvcGVyYXRpb24uc291cmNlUG9zaXRpb24uaXNFcXVhbChvcGVyYXRpb24udGFyZ2V0UG9zaXRpb24pIHx8IG9wZXJhdGlvbi5zb3VyY2VQb3NpdGlvbi5nZXRTaGlmdGVkQnkob3BlcmF0aW9uLmhvd01hbnkpLmlzRXF1YWwob3BlcmF0aW9uLnRhcmdldFBvc2l0aW9uKSkgewogICAgICAgICAgICByZXR1cm47CiAgICAgICAgICB9CgogICAgICAgICAgY29uc3Qgc291cmNlUGFyZW50SW5zZXJ0ZWQgPSB0aGlzLl9pc0luSW5zZXJ0ZWRFbGVtZW50KG9wZXJhdGlvbi5zb3VyY2VQb3NpdGlvbi5wYXJlbnQpOwoKICAgICAgICAgIGNvbnN0IHRhcmdldFBhcmVudEluc2VydGVkID0gdGhpcy5faXNJbkluc2VydGVkRWxlbWVudChvcGVyYXRpb24udGFyZ2V0UG9zaXRpb24ucGFyZW50KTsKCiAgICAgICAgICBpZiAoIXNvdXJjZVBhcmVudEluc2VydGVkKSB7CiAgICAgICAgICAgIHRoaXMuX21hcmtSZW1vdmUob3BlcmF0aW9uLnNvdXJjZVBvc2l0aW9uLnBhcmVudCwgb3BlcmF0aW9uLnNvdXJjZVBvc2l0aW9uLm9mZnNldCwgb3BlcmF0aW9uLmhvd01hbnkpOwogICAgICAgICAgfQoKICAgICAgICAgIGlmICghdGFyZ2V0UGFyZW50SW5zZXJ0ZWQpIHsKICAgICAgICAgICAgdGhpcy5fbWFya0luc2VydChvcGVyYXRpb24udGFyZ2V0UG9zaXRpb24ucGFyZW50LCBvcGVyYXRpb24uZ2V0TW92ZWRSYW5nZVN0YXJ0KCkub2Zmc2V0LCBvcGVyYXRpb24uaG93TWFueSk7CiAgICAgICAgICB9CgogICAgICAgICAgYnJlYWs7CiAgICAgICAgfQoKICAgICAgY2FzZSAncmVuYW1lJzoKICAgICAgICB7CiAgICAgICAgICBpZiAodGhpcy5faXNJbkluc2VydGVkRWxlbWVudChvcGVyYXRpb24ucG9zaXRpb24ucGFyZW50KSkgewogICAgICAgICAgICByZXR1cm47CiAgICAgICAgICB9CgogICAgICAgICAgdGhpcy5fbWFya1JlbW92ZShvcGVyYXRpb24ucG9zaXRpb24ucGFyZW50LCBvcGVyYXRpb24ucG9zaXRpb24ub2Zmc2V0LCAxKTsKCiAgICAgICAgICB0aGlzLl9tYXJrSW5zZXJ0KG9wZXJhdGlvbi5wb3NpdGlvbi5wYXJlbnQsIG9wZXJhdGlvbi5wb3NpdGlvbi5vZmZzZXQsIDEpOwoKICAgICAgICAgIGNvbnN0IHJhbmdlID0gUmFuZ2UuX2NyZWF0ZUZyb21Qb3NpdGlvbkFuZFNoaWZ0KG9wZXJhdGlvbi5wb3NpdGlvbiwgMSk7CgogICAgICAgICAgZm9yIChjb25zdCBtYXJrZXIgb2YgdGhpcy5fbWFya2VyQ29sbGVjdGlvbi5nZXRNYXJrZXJzSW50ZXJzZWN0aW5nUmFuZ2UocmFuZ2UpKSB7CiAgICAgICAgICAgIGNvbnN0IG1hcmtlclJhbmdlID0gbWFya2VyLmdldFJhbmdlKCk7CiAgICAgICAgICAgIHRoaXMuYnVmZmVyTWFya2VyQ2hhbmdlKG1hcmtlci5uYW1lLCBtYXJrZXJSYW5nZSwgbWFya2VyUmFuZ2UsIG1hcmtlci5hZmZlY3RzRGF0YSk7CiAgICAgICAgICB9CgogICAgICAgICAgYnJlYWs7CiAgICAgICAgfQoKICAgICAgY2FzZSAnc3BsaXQnOgogICAgICAgIHsKICAgICAgICAgIGNvbnN0IHNwbGl0RWxlbWVudCA9IG9wZXJhdGlvbi5zcGxpdFBvc2l0aW9uLnBhcmVudDsgLy8gTWFyayB0aGF0IGNoaWxkcmVuIG9mIHRoZSBzcGxpdCBlbGVtZW50IHdlcmUgcmVtb3ZlZC4KCiAgICAgICAgICBpZiAoIXRoaXMuX2lzSW5JbnNlcnRlZEVsZW1lbnQoc3BsaXRFbGVtZW50KSkgewogICAgICAgICAgICB0aGlzLl9tYXJrUmVtb3ZlKHNwbGl0RWxlbWVudCwgb3BlcmF0aW9uLnNwbGl0UG9zaXRpb24ub2Zmc2V0LCBvcGVyYXRpb24uaG93TWFueSk7CiAgICAgICAgICB9IC8vIE1hcmsgdGhhdCB0aGUgbmV3IGVsZW1lbnQgKHNwbGl0IGNvcHkpIHdhcyBpbnNlcnRlZC4KCgogICAgICAgICAgaWYgKCF0aGlzLl9pc0luSW5zZXJ0ZWRFbGVtZW50KG9wZXJhdGlvbi5pbnNlcnRpb25Qb3NpdGlvbi5wYXJlbnQpKSB7CiAgICAgICAgICAgIHRoaXMuX21hcmtJbnNlcnQob3BlcmF0aW9uLmluc2VydGlvblBvc2l0aW9uLnBhcmVudCwgb3BlcmF0aW9uLmluc2VydGlvblBvc2l0aW9uLm9mZnNldCwgMSk7CiAgICAgICAgICB9IC8vIElmIHRoZSBzcGxpdCB0b29rIHRoZSBlbGVtZW50IGZyb20gdGhlIGdyYXZleWFyZCwgbWFyayB0aGF0IHRoZSBlbGVtZW50IGZyb20gdGhlIGdyYXZleWFyZCB3YXMgcmVtb3ZlZC4KCgogICAgICAgICAgaWYgKG9wZXJhdGlvbi5ncmF2ZXlhcmRQb3NpdGlvbikgewogICAgICAgICAgICB0aGlzLl9tYXJrUmVtb3ZlKG9wZXJhdGlvbi5ncmF2ZXlhcmRQb3NpdGlvbi5wYXJlbnQsIG9wZXJhdGlvbi5ncmF2ZXlhcmRQb3NpdGlvbi5vZmZzZXQsIDEpOwogICAgICAgICAgfQoKICAgICAgICAgIGJyZWFrOwogICAgICAgIH0KCiAgICAgIGNhc2UgJ21lcmdlJzoKICAgICAgICB7CiAgICAgICAgICAvLyBNYXJrIHRoYXQgdGhlIG1lcmdlZCBlbGVtZW50IHdhcyByZW1vdmVkLgogICAgICAgICAgY29uc3QgbWVyZ2VkRWxlbWVudCA9IG9wZXJhdGlvbi5zb3VyY2VQb3NpdGlvbi5wYXJlbnQ7CgogICAgICAgICAgaWYgKCF0aGlzLl9pc0luSW5zZXJ0ZWRFbGVtZW50KG1lcmdlZEVsZW1lbnQucGFyZW50KSkgewogICAgICAgICAgICB0aGlzLl9tYXJrUmVtb3ZlKG1lcmdlZEVsZW1lbnQucGFyZW50LCBtZXJnZWRFbGVtZW50LnN0YXJ0T2Zmc2V0LCAxKTsKICAgICAgICAgIH0gLy8gTWFyayB0aGF0IHRoZSBtZXJnZWQgZWxlbWVudCB3YXMgaW5zZXJ0ZWQgaW50byBncmF2ZXlhcmQuCgoKICAgICAgICAgIGNvbnN0IGdyYXZleWFyZFBhcmVudCA9IG9wZXJhdGlvbi5ncmF2ZXlhcmRQb3NpdGlvbi5wYXJlbnQ7CgogICAgICAgICAgdGhpcy5fbWFya0luc2VydChncmF2ZXlhcmRQYXJlbnQsIG9wZXJhdGlvbi5ncmF2ZXlhcmRQb3NpdGlvbi5vZmZzZXQsIDEpOyAvLyBNYXJrIHRoYXQgY2hpbGRyZW4gb2YgbWVyZ2VkIGVsZW1lbnQgd2VyZSBpbnNlcnRlZCBhdCBuZXcgcGFyZW50LgoKCiAgICAgICAgICBjb25zdCBtZXJnZWRJbnRvRWxlbWVudCA9IG9wZXJhdGlvbi50YXJnZXRQb3NpdGlvbi5wYXJlbnQ7CgogICAgICAgICAgaWYgKCF0aGlzLl9pc0luSW5zZXJ0ZWRFbGVtZW50KG1lcmdlZEludG9FbGVtZW50KSkgewogICAgICAgICAgICB0aGlzLl9tYXJrSW5zZXJ0KG1lcmdlZEludG9FbGVtZW50LCBvcGVyYXRpb24udGFyZ2V0UG9zaXRpb24ub2Zmc2V0LCBtZXJnZWRFbGVtZW50Lm1heE9mZnNldCk7CiAgICAgICAgICB9CgogICAgICAgICAgYnJlYWs7CiAgICAgICAgfQogICAgfSAvLyBDbGVhciBjYWNoZSBhZnRlciBlYWNoIGJ1ZmZlcmVkIG9wZXJhdGlvbiBhcyBpdCBpcyBubyBsb25nZXIgdmFsaWQuCgoKICAgIHRoaXMuX2NhY2hlZENoYW5nZXMgPSBudWxsOwogIH0KICAvKioKICAgKiBCdWZmZXJzIGEgbWFya2VyIGNoYW5nZS4KICAgKgogICAqIEBwYXJhbSB7U3RyaW5nfSBtYXJrZXJOYW1lIFRoZSBuYW1lIG9mIHRoZSBtYXJrZXIgdGhhdCBjaGFuZ2VkLgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZXxudWxsfSBvbGRSYW5nZSBNYXJrZXIgcmFuZ2UgYmVmb3JlIHRoZSBjaGFuZ2Ugb3IgYG51bGxgIGlmIHRoZSBtYXJrZXIgaGFzIGp1c3QKICAgKiBiZWVuIGNyZWF0ZWQuCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlfG51bGx9IG5ld1JhbmdlIE1hcmtlciByYW5nZSBhZnRlciB0aGUgY2hhbmdlIG9yIGBudWxsYCBpZiB0aGUgbWFya2VyIHdhcyByZW1vdmVkLgogICAqIEBwYXJhbSB7Qm9vbGVhbn0gYWZmZWN0c0RhdGEgRmxhZyBpbmRpY2F0aW5nIHdoZXRoZXIgbWFya2VyIGFmZmVjdHMgdGhlIGVkaXRvciBkYXRhLgogICAqLwoKCiAgYnVmZmVyTWFya2VyQ2hhbmdlKG1hcmtlck5hbWUsIG9sZFJhbmdlLCBuZXdSYW5nZSwgYWZmZWN0c0RhdGEpIHsKICAgIGNvbnN0IGJ1ZmZlcmVkID0gdGhpcy5fY2hhbmdlZE1hcmtlcnMuZ2V0KG1hcmtlck5hbWUpOwoKICAgIGlmICghYnVmZmVyZWQpIHsKICAgICAgdGhpcy5fY2hhbmdlZE1hcmtlcnMuc2V0KG1hcmtlck5hbWUsIHsKICAgICAgICBvbGRSYW5nZSwKICAgICAgICBuZXdSYW5nZSwKICAgICAgICBhZmZlY3RzRGF0YQogICAgICB9KTsKICAgIH0gZWxzZSB7CiAgICAgIGJ1ZmZlcmVkLm5ld1JhbmdlID0gbmV3UmFuZ2U7CiAgICAgIGJ1ZmZlcmVkLmFmZmVjdHNEYXRhID0gYWZmZWN0c0RhdGE7CgogICAgICBpZiAoYnVmZmVyZWQub2xkUmFuZ2UgPT0gbnVsbCAmJiBidWZmZXJlZC5uZXdSYW5nZSA9PSBudWxsKSB7CiAgICAgICAgLy8gVGhlIG1hcmtlciBpcyBnb2luZyB0byBiZSByZW1vdmVkIChgbmV3UmFuZ2UgPT0gbnVsbGApIGJ1dCBpdCBkaWQgbm90IGV4aXN0IGJlZm9yZSB0aGUgZmlyc3QgYnVmZmVyZWQgY2hhbmdlCiAgICAgICAgLy8gKGBidWZmZXJlZC5vbGRSYW5nZSA9PSBudWxsYCkuIEluIHRoaXMgY2FzZSwgZG8gbm90IGtlZXAgdGhlIG1hcmtlciBpbiBidWZmZXIgYXQgYWxsLgogICAgICAgIHRoaXMuX2NoYW5nZWRNYXJrZXJzLmRlbGV0ZShtYXJrZXJOYW1lKTsKICAgICAgfQogICAgfQogIH0KICAvKioKICAgKiBSZXR1cm5zIGFsbCBtYXJrZXJzIHRoYXQgc2hvdWxkIGJlIHJlbW92ZWQgYXMgYSByZXN1bHQgb2YgYnVmZmVyZWQgY2hhbmdlcy4KICAgKgogICAqIEByZXR1cm5zIHtBcnJheS48T2JqZWN0Pn0gTWFya2VycyB0byByZW1vdmUuIEVhY2ggYXJyYXkgaXRlbSBpcyBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgYG5hbWVgIGFuZCBgcmFuZ2VgIHByb3BlcnRpZXMuCiAgICovCgoKICBnZXRNYXJrZXJzVG9SZW1vdmUoKSB7CiAgICBjb25zdCByZXN1bHQgPSBbXTsKCiAgICBmb3IgKGNvbnN0IFtuYW1lLCBjaGFuZ2VdIG9mIHRoaXMuX2NoYW5nZWRNYXJrZXJzKSB7CiAgICAgIGlmIChjaGFuZ2Uub2xkUmFuZ2UgIT0gbnVsbCkgewogICAgICAgIHJlc3VsdC5wdXNoKHsKICAgICAgICAgIG5hbWUsCiAgICAgICAgICByYW5nZTogY2hhbmdlLm9sZFJhbmdlCiAgICAgICAgfSk7CiAgICAgIH0KICAgIH0KCiAgICByZXR1cm4gcmVzdWx0OwogIH0KICAvKioKICAgKiBSZXR1cm5zIGFsbCBtYXJrZXJzIHdoaWNoIHNob3VsZCBiZSBhZGRlZCBhcyBhIHJlc3VsdCBvZiBidWZmZXJlZCBjaGFuZ2VzLgogICAqCiAgICogQHJldHVybnMge0FycmF5LjxPYmplY3Q+fSBNYXJrZXJzIHRvIGFkZC4gRWFjaCBhcnJheSBpdGVtIGlzIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBgbmFtZWAgYW5kIGByYW5nZWAgcHJvcGVydGllcy4KICAgKi8KCgogIGdldE1hcmtlcnNUb0FkZCgpIHsKICAgIGNvbnN0IHJlc3VsdCA9IFtdOwoKICAgIGZvciAoY29uc3QgW25hbWUsIGNoYW5nZV0gb2YgdGhpcy5fY2hhbmdlZE1hcmtlcnMpIHsKICAgICAgaWYgKGNoYW5nZS5uZXdSYW5nZSAhPSBudWxsKSB7CiAgICAgICAgcmVzdWx0LnB1c2goewogICAgICAgICAgbmFtZSwKICAgICAgICAgIHJhbmdlOiBjaGFuZ2UubmV3UmFuZ2UKICAgICAgICB9KTsKICAgICAgfQogICAgfQoKICAgIHJldHVybiByZXN1bHQ7CiAgfQogIC8qKgogICAqIFJldHVybnMgYWxsIG1hcmtlcnMgd2hpY2ggY2hhbmdlZC4KICAgKgogICAqIEByZXR1cm5zIHtBcnJheS48T2JqZWN0Pn0KICAgKi8KCgogIGdldENoYW5nZWRNYXJrZXJzKCkgewogICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5fY2hhbmdlZE1hcmtlcnMpLm1hcChpdGVtID0+ICh7CiAgICAgIG5hbWU6IGl0ZW1bMF0sCiAgICAgIGRhdGE6IHsKICAgICAgICBvbGRSYW5nZTogaXRlbVsxXS5vbGRSYW5nZSwKICAgICAgICBuZXdSYW5nZTogaXRlbVsxXS5uZXdSYW5nZQogICAgICB9CiAgICB9KSk7CiAgfQogIC8qKgogICAqIENoZWNrcyB3aGV0aGVyIHNvbWUgb2YgdGhlIGJ1ZmZlcmVkIGNoYW5nZXMgYWZmZWN0IHRoZSBlZGl0b3IgZGF0YS4KICAgKgogICAqIFR5cGVzIG9mIGNoYW5nZXMgd2hpY2ggYWZmZWN0IHRoZSBlZGl0b3IgZGF0YToKICAgKgogICAqICogbW9kZWwgc3RydWN0dXJlIGNoYW5nZXMsCiAgICogKiBhdHRyaWJ1dGUgY2hhbmdlcywKICAgKiAqIGNoYW5nZXMgb2YgbWFya2VycyB3aGljaCB3ZXJlIGRlZmluZWQgYXMgYGFmZmVjdGluZ0RhdGFgLgogICAqCiAgICogQHJldHVybnMge0Jvb2xlYW59CiAgICovCgoKICBoYXNEYXRhQ2hhbmdlcygpIHsKICAgIGZvciAoY29uc3QgWywgY2hhbmdlXSBvZiB0aGlzLl9jaGFuZ2VkTWFya2VycykgewogICAgICBpZiAoY2hhbmdlLmFmZmVjdHNEYXRhKSB7CiAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgIH0KICAgIH0gLy8gSWYgbWFya2VycyBkbyBub3QgYWZmZWN0IHRoZSBkYXRhLCBjaGVjayB3aGV0aGVyIHRoZXJlIGFyZSBzb21lIGNoYW5nZXMgaW4gZWxlbWVudHMuCgoKICAgIHJldHVybiB0aGlzLl9jaGFuZ2VzSW5FbGVtZW50LnNpemUgPiAwOwogIH0KICAvKioKICAgKiBDYWxjdWxhdGVzIHRoZSBkaWZmIGJldHdlZW4gdGhlIG9sZCBtb2RlbCB0cmVlIHN0YXRlICh0aGUgc3RhdGUgYmVmb3JlIHRoZSBmaXJzdCBidWZmZXJlZCBvcGVyYXRpb25zIHNpbmNlIHRoZSBsYXN0IHtAbGluayAjcmVzZXR9CiAgICogY2FsbCkgYW5kIHRoZSBuZXcgbW9kZWwgdHJlZSBzdGF0ZSAoYWN0dWFsIG9uZSkuIEl0IHNob3VsZCBiZSBjYWxsZWQgYWZ0ZXIgYWxsIGJ1ZmZlcmVkIG9wZXJhdGlvbnMgYXJlIGV4ZWN1dGVkLgogICAqCiAgICogVGhlIGRpZmYgc2V0IGlzIHJldHVybmVkIGFzIGFuIGFycmF5IG9mIGRpZmYgaXRlbXMsIGVhY2ggZGVzY3JpYmluZyBhIGNoYW5nZSBkb25lIG9uIHRoZSBtb2RlbC4gVGhlIGl0ZW1zIGFyZSBzb3J0ZWQgYnkKICAgKiB0aGUgcG9zaXRpb24gb24gd2hpY2ggdGhlIGNoYW5nZSBoYXBwZW5lZC4gSWYgYSBwb3NpdGlvbiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbiNpc0JlZm9yZSBpcyBiZWZvcmV9CiAgICogYW5vdGhlciBvbmUsIGl0IHdpbGwgYmUgb24gYW4gZWFybGllciBpbmRleCBpbiB0aGUgZGlmZiBzZXQuCiAgICoKICAgKiBCZWNhdXNlIGNhbGN1bGF0aW5nIHRoZSBkaWZmIGlzIGEgY29zdGx5IG9wZXJhdGlvbiwgdGhlIHJlc3VsdCBpcyBjYWNoZWQuIElmIG5vIG5ldyBvcGVyYXRpb24gd2FzIGJ1ZmZlcmVkIHNpbmNlIHRoZQogICAqIHByZXZpb3VzIHtAbGluayAjZ2V0Q2hhbmdlc30gY2FsbCwgdGhlIG5leHQgY2FsbCB3aWxsIHJldHVybiB0aGUgY2FjaGVkIHZhbHVlLgogICAqCiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQWRkaXRpb25hbCBvcHRpb25zLgogICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuaW5jbHVkZUNoYW5nZXNJbkdyYXZleWFyZD1mYWxzZV0gSWYgc2V0IHRvIGB0cnVlYCwgYWxzbyBjaGFuZ2VzIHRoYXQgaGFwcGVuZWQKICAgKiBpbiB0aGUgZ3JhdmV5YXJkIHJvb3Qgd2lsbCBiZSByZXR1cm5lZC4gQnkgZGVmYXVsdCwgY2hhbmdlcyBpbiB0aGUgZ3JhdmV5YXJkIHJvb3QgYXJlIG5vdCByZXR1cm5lZC4KICAgKiBAcmV0dXJucyB7QXJyYXkuPE9iamVjdD59IERpZmYgYmV0d2VlbiB0aGUgb2xkIGFuZCB0aGUgbmV3IG1vZGVsIHRyZWUgc3RhdGUuCiAgICovCgoKICBnZXRDaGFuZ2VzKG9wdGlvbnMgPSB7CiAgICBpbmNsdWRlQ2hhbmdlc0luR3JhdmV5YXJkOiBmYWxzZQogIH0pIHsKICAgIC8vIElmIHRoZXJlIGFyZSBjYWNoZWQgY2hhbmdlcywganVzdCByZXR1cm4gdGhlbSBpbnN0ZWFkIG9mIGNhbGN1bGF0aW5nIGNoYW5nZXMgYWdhaW4uCiAgICBpZiAodGhpcy5fY2FjaGVkQ2hhbmdlcykgewogICAgICBpZiAob3B0aW9ucy5pbmNsdWRlQ2hhbmdlc0luR3JhdmV5YXJkKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlZENoYW5nZXNXaXRoR3JhdmV5YXJkLnNsaWNlKCk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlZENoYW5nZXMuc2xpY2UoKTsKICAgICAgfQogICAgfSAvLyBXaWxsIGNvbnRhaW4gcmV0dXJuZWQgcmVzdWx0cy4KCgogICAgY29uc3QgZGlmZlNldCA9IFtdOyAvLyBDaGVjayBhbGwgY2hhbmdlZCBlbGVtZW50cy4KCiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdGhpcy5fY2hhbmdlc0luRWxlbWVudC5rZXlzKCkpIHsKICAgICAgLy8gR2V0IGNoYW5nZXMgZm9yIHRoaXMgZWxlbWVudCBhbmQgc29ydCB0aGVtLgogICAgICBjb25zdCBjaGFuZ2VzID0gdGhpcy5fY2hhbmdlc0luRWxlbWVudC5nZXQoZWxlbWVudCkuc29ydCgoYSwgYikgPT4gewogICAgICAgIGlmIChhLm9mZnNldCA9PT0gYi5vZmZzZXQpIHsKICAgICAgICAgIGlmIChhLnR5cGUgIT0gYi50eXBlKSB7CiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBtdWx0aXBsZSBjaGFuZ2VzIGF0IHRoZSBzYW1lIHBvc2l0aW9uLCAicmVtb3ZlIiBjaGFuZ2Ugc2hvdWxkIGJlIGZpcnN0LgogICAgICAgICAgICAvLyBJZiB0aGUgb3JkZXIgaXMgZGlmZmVyZW50LCBmb3IgZXhhbXBsZSwgd2Ugd291bGQgZmlyc3QgYWRkIHNvbWUgbm9kZXMgYW5kIHRoZW4gcmVtb3ZlZCB0aGVtCiAgICAgICAgICAgIC8vIChpbnN0ZWFkIG9mIHRoZSBub2RlcyB0aGF0IHdlIHNob3VsZCByZW1vdmUpLgogICAgICAgICAgICByZXR1cm4gYS50eXBlID09ICdyZW1vdmUnID8gLTEgOiAxOwogICAgICAgICAgfQoKICAgICAgICAgIHJldHVybiAwOwogICAgICAgIH0KCiAgICAgICAgcmV0dXJuIGEub2Zmc2V0IDwgYi5vZmZzZXQgPyAtMSA6IDE7CiAgICAgIH0pOyAvLyBHZXQgY2hpbGRyZW4gb2YgdGhpcyBlbGVtZW50IGJlZm9yZSBhbnkgY2hhbmdlIHdhcyBhcHBsaWVkIG9uIGl0LgoKCiAgICAgIGNvbnN0IHNuYXBzaG90Q2hpbGRyZW4gPSB0aGlzLl9lbGVtZW50U25hcHNob3RzLmdldChlbGVtZW50KTsgLy8gR2V0IHNuYXBzaG90IG9mIGN1cnJlbnQgZWxlbWVudCdzIGNoaWxkcmVuLgoKCiAgICAgIGNvbnN0IGVsZW1lbnRDaGlsZHJlbiA9IF9nZXRDaGlsZHJlblNuYXBzaG90KGVsZW1lbnQuZ2V0Q2hpbGRyZW4oKSk7IC8vIEdlbmVyYXRlIGFjdGlvbnMgYmFzaW5nIG9uIGNoYW5nZXMgZG9uZSBvbiBlbGVtZW50LgoKCiAgICAgIGNvbnN0IGFjdGlvbnMgPSBfZ2VuZXJhdGVBY3Rpb25zRnJvbUNoYW5nZXMoc25hcHNob3RDaGlsZHJlbi5sZW5ndGgsIGNoYW5nZXMpOwoKICAgICAgbGV0IGkgPSAwOyAvLyBJdGVyYXRvciBpbiBgZWxlbWVudENoaWxkcmVuYCBhcnJheSAtLSBpdGVyYXRlcyB0aHJvdWdoIGN1cnJlbnQgY2hpbGRyZW4gb2YgZWxlbWVudC4KCiAgICAgIGxldCBqID0gMDsgLy8gSXRlcmF0b3IgaW4gYHNuYXBzaG90Q2hpbGRyZW5gIGFycmF5IC0tIGl0ZXJhdGVzIHRocm91Z2ggb2xkIGNoaWxkcmVuIG9mIGVsZW1lbnQuCiAgICAgIC8vIFByb2Nlc3MgZXZlcnkgYWN0aW9uLgoKICAgICAgZm9yIChjb25zdCBhY3Rpb24gb2YgYWN0aW9ucykgewogICAgICAgIGlmIChhY3Rpb24gPT09ICdpJykgewogICAgICAgICAgLy8gR2VuZXJhdGUgZGlmZiBpdGVtIGZvciB0aGlzIGVsZW1lbnQgYW5kIGluc2VydCBpdCBpbnRvIHRoZSBkaWZmIHNldC4KICAgICAgICAgIGRpZmZTZXQucHVzaCh0aGlzLl9nZXRJbnNlcnREaWZmKGVsZW1lbnQsIGksIGVsZW1lbnRDaGlsZHJlbltpXS5uYW1lKSk7CiAgICAgICAgICBpKys7CiAgICAgICAgfSBlbHNlIGlmIChhY3Rpb24gPT09ICdyJykgewogICAgICAgICAgLy8gR2VuZXJhdGUgZGlmZiBpdGVtIGZvciB0aGlzIGVsZW1lbnQgYW5kIGluc2VydCBpdCBpbnRvIHRoZSBkaWZmIHNldC4KICAgICAgICAgIGRpZmZTZXQucHVzaCh0aGlzLl9nZXRSZW1vdmVEaWZmKGVsZW1lbnQsIGksIHNuYXBzaG90Q2hpbGRyZW5bal0ubmFtZSkpOwogICAgICAgICAgaisrOwogICAgICAgIH0gZWxzZSBpZiAoYWN0aW9uID09PSAnYScpIHsKICAgICAgICAgIC8vIFRha2UgYXR0cmlidXRlcyBmcm9tIHNhdmVkIGFuZCBjdXJyZW50IGNoaWxkcmVuLgogICAgICAgICAgY29uc3QgZWxlbWVudEF0dHJpYnV0ZXMgPSBlbGVtZW50Q2hpbGRyZW5baV0uYXR0cmlidXRlczsKICAgICAgICAgIGNvbnN0IHNuYXBzaG90QXR0cmlidXRlcyA9IHNuYXBzaG90Q2hpbGRyZW5bal0uYXR0cmlidXRlczsKICAgICAgICAgIGxldCByYW5nZTsKCiAgICAgICAgICBpZiAoZWxlbWVudENoaWxkcmVuW2ldLm5hbWUgPT0gJyR0ZXh0JykgewogICAgICAgICAgICByYW5nZSA9IG5ldyBSYW5nZShQb3NpdGlvbi5fY3JlYXRlQXQoZWxlbWVudCwgaSksIFBvc2l0aW9uLl9jcmVhdGVBdChlbGVtZW50LCBpICsgMSkpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgY29uc3QgaW5kZXggPSBlbGVtZW50Lm9mZnNldFRvSW5kZXgoaSk7CiAgICAgICAgICAgIHJhbmdlID0gbmV3IFJhbmdlKFBvc2l0aW9uLl9jcmVhdGVBdChlbGVtZW50LCBpKSwgUG9zaXRpb24uX2NyZWF0ZUF0KGVsZW1lbnQuZ2V0Q2hpbGQoaW5kZXgpLCAwKSk7CiAgICAgICAgICB9IC8vIEdlbmVyYXRlIGRpZmYgaXRlbXMgZm9yIHRoaXMgY2hhbmdlICh0aGVyZSBtaWdodCBiZSBtdWx0aXBsZSBhdHRyaWJ1dGVzIGNoYW5nZWQgYW5kCiAgICAgICAgICAvLyB0aGVyZSBpcyBhIHNpbmdsZSBkaWZmIGZvciBlYWNoIG9mIHRoZW0pIGFuZCBpbnNlcnQgdGhlbSBpbnRvIHRoZSBkaWZmIHNldC4KCgogICAgICAgICAgZGlmZlNldC5wdXNoKC4uLnRoaXMuX2dldEF0dHJpYnV0ZXNEaWZmKHJhbmdlLCBzbmFwc2hvdEF0dHJpYnV0ZXMsIGVsZW1lbnRBdHRyaWJ1dGVzKSk7CiAgICAgICAgICBpKys7CiAgICAgICAgICBqKys7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIC8vIGBhY3Rpb25gIGlzICdlcXVhbCcuIENoaWxkIG5vdCBjaGFuZ2VkLgogICAgICAgICAgaSsrOwogICAgICAgICAgaisrOwogICAgICAgIH0KICAgICAgfQogICAgfSAvLyBUaGVuLCBzb3J0IHRoZSBjaGFuZ2VzIGJ5IHRoZSBwb3NpdGlvbiAoY2hhbmdlIGF0IHBvc2l0aW9uIGJlZm9yZSBvdGhlciBjaGFuZ2VzIGlzIGZpcnN0KS4KCgogICAgZGlmZlNldC5zb3J0KChhLCBiKSA9PiB7CiAgICAgIC8vIElmIHRoZSBjaGFuZ2UgaXMgaW4gZGlmZmVyZW50IHJvb3QsIHdlIGRvbid0IGNhcmUgbXVjaCwgYnV0IHdlJ2QgbGlrZSB0byBoYXZlIGFsbCBjaGFuZ2VzIGluIGdpdmVuCiAgICAgIC8vIHJvb3QgInRvZ2V0aGVyIiBpbiB0aGUgYXJyYXkuIFNvIGxldCdzIGp1c3Qgc29ydCB0aGVtIGJ5IHRoZSByb290IG5hbWUuIEl0IGRvZXMgbm90IG1hdHRlciB3aGljaCByb290CiAgICAgIC8vIHdpbGwgYmUgcHJvY2Vzc2VkIGZpcnN0LgogICAgICBpZiAoYS5wb3NpdGlvbi5yb290ICE9IGIucG9zaXRpb24ucm9vdCkgewogICAgICAgIHJldHVybiBhLnBvc2l0aW9uLnJvb3Qucm9vdE5hbWUgPCBiLnBvc2l0aW9uLnJvb3Qucm9vdE5hbWUgPyAtMSA6IDE7CiAgICAgIH0gLy8gSWYgY2hhbmdlIGhhcHBlbnMgYXQgdGhlIHNhbWUgcG9zaXRpb24uLi4KCgogICAgICBpZiAoYS5wb3NpdGlvbi5pc0VxdWFsKGIucG9zaXRpb24pKSB7CiAgICAgICAgLy8gS2VlcCBjaHJvbm9sb2dpY2FsIG9yZGVyIG9mIG9wZXJhdGlvbnMuCiAgICAgICAgcmV0dXJuIGEuY2hhbmdlQ291bnQgLSBiLmNoYW5nZUNvdW50OwogICAgICB9IC8vIElmIHBvc2l0aW9ucyBkaWZmZXIsIHBvc2l0aW9uICJvbiB0aGUgbGVmdCIgc2hvdWxkIGJlIGVhcmxpZXIgaW4gdGhlIHJlc3VsdC4KCgogICAgICByZXR1cm4gYS5wb3NpdGlvbi5pc0JlZm9yZShiLnBvc2l0aW9uKSA/IC0xIDogMTsKICAgIH0pOyAvLyBHbHVlIHRvZ2V0aGVyIG11bHRpcGxlIGNoYW5nZXMgKG1vc3RseSBvbiB0ZXh0IG5vZGVzKS4KCiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGRpZmZTZXQubGVuZ3RoOyBpKyspIHsKICAgICAgY29uc3QgcHJldkRpZmYgPSBkaWZmU2V0W2kgLSAxXTsKICAgICAgY29uc3QgdGhpc0RpZmYgPSBkaWZmU2V0W2ldOyAvLyBHbHVlIHJlbW92ZSBjaGFuZ2VzIGlmIHRoZXkgaGFwcGVuIG9uIHRleHQgb24gc2FtZSBwb3NpdGlvbi4KCiAgICAgIGNvbnN0IGlzQ29uc2VjdXRpdmVUZXh0UmVtb3ZlID0gcHJldkRpZmYudHlwZSA9PSAncmVtb3ZlJyAmJiB0aGlzRGlmZi50eXBlID09ICdyZW1vdmUnICYmIHByZXZEaWZmLm5hbWUgPT0gJyR0ZXh0JyAmJiB0aGlzRGlmZi5uYW1lID09ICckdGV4dCcgJiYgcHJldkRpZmYucG9zaXRpb24uaXNFcXVhbCh0aGlzRGlmZi5wb3NpdGlvbik7IC8vIEdsdWUgaW5zZXJ0IGNoYW5nZXMgaWYgdGhleSBoYXBwZW4gb24gdGV4dCBvbiBjb25zZWN1dGl2ZSBmcmFnbWVudHMuCgogICAgICBjb25zdCBpc0NvbnNlY3V0aXZlVGV4dEFkZCA9IHByZXZEaWZmLnR5cGUgPT0gJ2luc2VydCcgJiYgdGhpc0RpZmYudHlwZSA9PSAnaW5zZXJ0JyAmJiBwcmV2RGlmZi5uYW1lID09ICckdGV4dCcgJiYgdGhpc0RpZmYubmFtZSA9PSAnJHRleHQnICYmIHByZXZEaWZmLnBvc2l0aW9uLnBhcmVudCA9PSB0aGlzRGlmZi5wb3NpdGlvbi5wYXJlbnQgJiYgcHJldkRpZmYucG9zaXRpb24ub2Zmc2V0ICsgcHJldkRpZmYubGVuZ3RoID09IHRoaXNEaWZmLnBvc2l0aW9uLm9mZnNldDsgLy8gR2x1ZSBhdHRyaWJ1dGUgY2hhbmdlcyBpZiB0aGV5IGhhcHBlbiBvbiBjb25zZWN1dGl2ZSBmcmFnbWVudHMgYW5kIGhhdmUgc2FtZSBrZXksIG9sZCB2YWx1ZSBhbmQgbmV3IHZhbHVlLgoKICAgICAgY29uc3QgaXNDb25zZWN1dGl2ZUF0dHJpYnV0ZUNoYW5nZSA9IHByZXZEaWZmLnR5cGUgPT0gJ2F0dHJpYnV0ZScgJiYgdGhpc0RpZmYudHlwZSA9PSAnYXR0cmlidXRlJyAmJiBwcmV2RGlmZi5wb3NpdGlvbi5wYXJlbnQgPT0gdGhpc0RpZmYucG9zaXRpb24ucGFyZW50ICYmIHByZXZEaWZmLnJhbmdlLmlzRmxhdCAmJiB0aGlzRGlmZi5yYW5nZS5pc0ZsYXQgJiYgcHJldkRpZmYucG9zaXRpb24ub2Zmc2V0ICsgcHJldkRpZmYubGVuZ3RoID09IHRoaXNEaWZmLnBvc2l0aW9uLm9mZnNldCAmJiBwcmV2RGlmZi5hdHRyaWJ1dGVLZXkgPT0gdGhpc0RpZmYuYXR0cmlidXRlS2V5ICYmIHByZXZEaWZmLmF0dHJpYnV0ZU9sZFZhbHVlID09IHRoaXNEaWZmLmF0dHJpYnV0ZU9sZFZhbHVlICYmIHByZXZEaWZmLmF0dHJpYnV0ZU5ld1ZhbHVlID09IHRoaXNEaWZmLmF0dHJpYnV0ZU5ld1ZhbHVlOwoKICAgICAgaWYgKGlzQ29uc2VjdXRpdmVUZXh0UmVtb3ZlIHx8IGlzQ29uc2VjdXRpdmVUZXh0QWRkIHx8IGlzQ29uc2VjdXRpdmVBdHRyaWJ1dGVDaGFuZ2UpIHsKICAgICAgICBkaWZmU2V0W2kgLSAxXS5sZW5ndGgrKzsKCiAgICAgICAgaWYgKGlzQ29uc2VjdXRpdmVBdHRyaWJ1dGVDaGFuZ2UpIHsKICAgICAgICAgIGRpZmZTZXRbaSAtIDFdLnJhbmdlLmVuZCA9IGRpZmZTZXRbaSAtIDFdLnJhbmdlLmVuZC5nZXRTaGlmdGVkQnkoMSk7CiAgICAgICAgfQoKICAgICAgICBkaWZmU2V0LnNwbGljZShpLCAxKTsKICAgICAgICBpLS07CiAgICAgIH0KICAgIH0gLy8gUmVtb3ZlIGBjaGFuZ2VDb3VudGAgcHJvcGVydHkgZnJvbSBkaWZmIGl0ZW1zLiBJdCBpcyB1c2VkIG9ubHkgZm9yIHNvcnRpbmcgYW5kIGlzIGludGVybmFsIHRoaW5nLgoKCiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgZGlmZlNldCkgewogICAgICBkZWxldGUgaXRlbS5jaGFuZ2VDb3VudDsKCiAgICAgIGlmIChpdGVtLnR5cGUgPT0gJ2F0dHJpYnV0ZScpIHsKICAgICAgICBkZWxldGUgaXRlbS5wb3NpdGlvbjsKICAgICAgICBkZWxldGUgaXRlbS5sZW5ndGg7CiAgICAgIH0KICAgIH0KCiAgICB0aGlzLl9jaGFuZ2VDb3VudCA9IDA7IC8vIENhY2hlIGNoYW5nZXMuCgogICAgdGhpcy5fY2FjaGVkQ2hhbmdlc1dpdGhHcmF2ZXlhcmQgPSBkaWZmU2V0LnNsaWNlKCk7CiAgICB0aGlzLl9jYWNoZWRDaGFuZ2VzID0gZGlmZlNldC5zbGljZSgpLmZpbHRlcihfY2hhbmdlc0luR3JhdmV5YXJkRmlsdGVyKTsKCiAgICBpZiAob3B0aW9ucy5pbmNsdWRlQ2hhbmdlc0luR3JhdmV5YXJkKSB7CiAgICAgIHJldHVybiB0aGlzLl9jYWNoZWRDaGFuZ2VzV2l0aEdyYXZleWFyZDsKICAgIH0gZWxzZSB7CiAgICAgIHJldHVybiB0aGlzLl9jYWNoZWRDaGFuZ2VzOwogICAgfQogIH0KICAvKioKICAgKiBSZXNldHMgYERpZmZlcmAuIFJlbW92ZXMgYWxsIGJ1ZmZlcmVkIGNoYW5nZXMuCiAgICovCgoKICByZXNldCgpIHsKICAgIHRoaXMuX2NoYW5nZXNJbkVsZW1lbnQuY2xlYXIoKTsKCiAgICB0aGlzLl9lbGVtZW50U25hcHNob3RzLmNsZWFyKCk7CgogICAgdGhpcy5fY2hhbmdlZE1hcmtlcnMuY2xlYXIoKTsKCiAgICB0aGlzLl9jYWNoZWRDaGFuZ2VzID0gbnVsbDsKICB9CiAgLyoqCiAgICogU2F2ZXMgYW5kIGhhbmRsZXMgYW4gaW5zZXJ0IGNoYW5nZS4KICAgKgogICAqIEBwcml2YXRlCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudH0gcGFyZW50CiAgICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldAogICAqIEBwYXJhbSB7TnVtYmVyfSBob3dNYW55CiAgICovCgoKICBfbWFya0luc2VydChwYXJlbnQsIG9mZnNldCwgaG93TWFueSkgewogICAgY29uc3QgY2hhbmdlSXRlbSA9IHsKICAgICAgdHlwZTogJ2luc2VydCcsCiAgICAgIG9mZnNldCwKICAgICAgaG93TWFueSwKICAgICAgY291bnQ6IHRoaXMuX2NoYW5nZUNvdW50KysKICAgIH07CgogICAgdGhpcy5fbWFya0NoYW5nZShwYXJlbnQsIGNoYW5nZUl0ZW0pOwogIH0KICAvKioKICAgKiBTYXZlcyBhbmQgaGFuZGxlcyBhIHJlbW92ZSBjaGFuZ2UuCiAgICoKICAgKiBAcHJpdmF0ZQogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR9IHBhcmVudAogICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQKICAgKiBAcGFyYW0ge051bWJlcn0gaG93TWFueQogICAqLwoKCiAgX21hcmtSZW1vdmUocGFyZW50LCBvZmZzZXQsIGhvd01hbnkpIHsKICAgIGNvbnN0IGNoYW5nZUl0ZW0gPSB7CiAgICAgIHR5cGU6ICdyZW1vdmUnLAogICAgICBvZmZzZXQsCiAgICAgIGhvd01hbnksCiAgICAgIGNvdW50OiB0aGlzLl9jaGFuZ2VDb3VudCsrCiAgICB9OwoKICAgIHRoaXMuX21hcmtDaGFuZ2UocGFyZW50LCBjaGFuZ2VJdGVtKTsKCiAgICB0aGlzLl9yZW1vdmVBbGxOZXN0ZWRDaGFuZ2VzKHBhcmVudCwgb2Zmc2V0LCBob3dNYW55KTsKICB9CiAgLyoqCiAgICogU2F2ZXMgYW5kIGhhbmRsZXMgYW4gYXR0cmlidXRlIGNoYW5nZS4KICAgKgogICAqIEBwcml2YXRlCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbX0gaXRlbQogICAqLwoKCiAgX21hcmtBdHRyaWJ1dGUoaXRlbSkgewogICAgY29uc3QgY2hhbmdlSXRlbSA9IHsKICAgICAgdHlwZTogJ2F0dHJpYnV0ZScsCiAgICAgIG9mZnNldDogaXRlbS5zdGFydE9mZnNldCwKICAgICAgaG93TWFueTogaXRlbS5vZmZzZXRTaXplLAogICAgICBjb3VudDogdGhpcy5fY2hhbmdlQ291bnQrKwogICAgfTsKCiAgICB0aGlzLl9tYXJrQ2hhbmdlKGl0ZW0ucGFyZW50LCBjaGFuZ2VJdGVtKTsKICB9CiAgLyoqCiAgICogU2F2ZXMgYW5kIGhhbmRsZXMgYSBtb2RlbCBjaGFuZ2UuCiAgICoKICAgKiBAcHJpdmF0ZQogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR9IHBhcmVudAogICAqIEBwYXJhbSB7T2JqZWN0fSBjaGFuZ2VJdGVtCiAgICovCgoKICBfbWFya0NoYW5nZShwYXJlbnQsIGNoYW5nZUl0ZW0pIHsKICAgIC8vIEZpcnN0LCBtYWtlIGEgc25hcHNob3Qgb2YgdGhpcyBwYXJlbnQncyBjaGlsZHJlbiAoaXQgd2lsbCBiZSBtYWRlIG9ubHkgaWYgaXQgd2FzIG5vdCBtYWRlIGJlZm9yZSkuCiAgICB0aGlzLl9tYWtlU25hcHNob3QocGFyZW50KTsgLy8gVGhlbiwgZ2V0IGFsbCBjaGFuZ2VzIHRoYXQgYWxyZWFkeSB3ZXJlIGRvbmUgb24gdGhlIGVsZW1lbnQgKGVtcHR5IGFycmF5IGlmIHRoaXMgaXMgdGhlIGZpcnN0IGNoYW5nZSkuCgoKICAgIGNvbnN0IGNoYW5nZXMgPSB0aGlzLl9nZXRDaGFuZ2VzRm9yRWxlbWVudChwYXJlbnQpOyAvLyBUaGVuLCBsb29rIHRocm91Z2ggYWxsIHRoZSBjaGFuZ2VzLCBhbmQgdHJhbnNmb3JtIHRoZW0gb3IgdGhlIG5ldyBjaGFuZ2UuCgoKICAgIHRoaXMuX2hhbmRsZUNoYW5nZShjaGFuZ2VJdGVtLCBjaGFuZ2VzKTsgLy8gQWRkIHRoZSBuZXcgY2hhbmdlLgoKCiAgICBjaGFuZ2VzLnB1c2goY2hhbmdlSXRlbSk7IC8vIFJlbW92ZSBpbmNvcnJlY3QgY2hhbmdlcy4gRHVyaW5nIHRyYW5zZm9ybWF0aW9uIHNvbWUgY2hhbmdlIG1pZ2h0IGJlLCBmb3IgZXhhbXBsZSwgaW5jbHVkZWQgaW4gYW5vdGhlci4KICAgIC8vIEluIHRoYXQgY2FzZSwgdGhlIGNoYW5nZSB3aWxsIGhhdmUgYGhvd01hbnlgIHByb3BlcnR5IHNldCB0byBgMGAgb3IgbGVzcy4gV2UgbmVlZCB0byByZW1vdmUgdGhvc2UgY2hhbmdlcy4KCiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYW5nZXMubGVuZ3RoOyBpKyspIHsKICAgICAgaWYgKGNoYW5nZXNbaV0uaG93TWFueSA8IDEpIHsKICAgICAgICBjaGFuZ2VzLnNwbGljZShpLCAxKTsKICAgICAgICBpLS07CiAgICAgIH0KICAgIH0KICB9CiAgLyoqCiAgICogR2V0cyBhbiBhcnJheSBvZiBjaGFuZ2VzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gc2F2ZWQgZm9yIGEgZ2l2ZW4gZWxlbWVudC4KICAgKgogICAqIEBwcml2YXRlCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudH0gZWxlbWVudAogICAqIEByZXR1cm5zIHtBcnJheS48T2JqZWN0Pn0KICAgKi8KCgogIF9nZXRDaGFuZ2VzRm9yRWxlbWVudChlbGVtZW50KSB7CiAgICBsZXQgY2hhbmdlczsKCiAgICBpZiAodGhpcy5fY2hhbmdlc0luRWxlbWVudC5oYXMoZWxlbWVudCkpIHsKICAgICAgY2hhbmdlcyA9IHRoaXMuX2NoYW5nZXNJbkVsZW1lbnQuZ2V0KGVsZW1lbnQpOwogICAgfSBlbHNlIHsKICAgICAgY2hhbmdlcyA9IFtdOwoKICAgICAgdGhpcy5fY2hhbmdlc0luRWxlbWVudC5zZXQoZWxlbWVudCwgY2hhbmdlcyk7CiAgICB9CgogICAgcmV0dXJuIGNoYW5nZXM7CiAgfQogIC8qKgogICAqIFNhdmVzIGEgY2hpbGRyZW4gc25hcHNob3QgZm9yIGEgZ2l2ZW4gZWxlbWVudC4KICAgKgogICAqIEBwcml2YXRlCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudH0gZWxlbWVudAogICAqLwoKCiAgX21ha2VTbmFwc2hvdChlbGVtZW50KSB7CiAgICBpZiAoIXRoaXMuX2VsZW1lbnRTbmFwc2hvdHMuaGFzKGVsZW1lbnQpKSB7CiAgICAgIHRoaXMuX2VsZW1lbnRTbmFwc2hvdHMuc2V0KGVsZW1lbnQsIF9nZXRDaGlsZHJlblNuYXBzaG90KGVsZW1lbnQuZ2V0Q2hpbGRyZW4oKSkpOwogICAgfQogIH0KICAvKioKICAgKiBGb3IgYSBnaXZlbiBuZXdseSBzYXZlZCBjaGFuZ2UsIGNvbXBhcmVzIGl0IHdpdGggYSBjaGFuZ2UgYWxyZWFkeSBkb25lIG9uIHRoZSBlbGVtZW50IGFuZCBtb2RpZmllcyB0aGUgaW5jb21pbmcKICAgKiBjaGFuZ2UgYW5kL29yIHRoZSBvbGQgY2hhbmdlLgogICAqCiAgICogQHByaXZhdGUKICAgKiBAcGFyYW0ge09iamVjdH0gaW5jIEluY29taW5nIChuZXcpIGNoYW5nZS4KICAgKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBjaGFuZ2VzIEFuIGFycmF5IGNvbnRhaW5pbmcgYWxsIHRoZSBjaGFuZ2VzIGRvbmUgb24gdGhhdCBlbGVtZW50LgogICAqLwoKCiAgX2hhbmRsZUNoYW5nZShpbmMsIGNoYW5nZXMpIHsKICAgIC8vIFdlIG5lZWQgYSBoZWxwZXIgdmFyaWFibGUgdGhhdCB3aWxsIHN0b3JlIGhvdyBtYW55IG5vZGVzIGFyZSB0byBiZSBzdGlsbCBoYW5kbGVkIGZvciB0aGlzIGNoYW5nZSBpdGVtLgogICAgLy8gYG5vZGVzVG9IYW5kbGVgIChob3cgbWFueSBub2RlcyBzdGlsbCBuZWVkIHRvIGJlIGhhbmRsZWQpIGFuZCBgaG93TWFueWAgKGhvdyBtYW55IG5vZGVzIHdlcmUgYWZmZWN0ZWQpCiAgICAvLyBuZWVkcyB0byBiZSBkaWZmZXJlbnRpYXRlZC4KICAgIC8vCiAgICAvLyBUaGlzIGNvbWVzIHVwIHdoZW4gdGhlcmUgYXJlIG11bHRpcGxlIGNoYW5nZXMgdGhhdCBhcmUgYWZmZWN0ZWQgYnkgYGluY2AgY2hhbmdlIGl0ZW0uCiAgICAvLwogICAgLy8gRm9yIGV4YW1wbGU6IGFzc3VtZSB0d28gaW5zZXJ0IGNoYW5nZXM6IGB7IG9mZnNldDogMiwgaG93TWFueTogMSB9YCBhbmQgYHsgb2Zmc2V0OiA1LCBob3dNYW55OiAxIH1gLgogICAgLy8gQXNzdW1lIHRoYXQgYGluY2AgY2hhbmdlIGlzIHJlbW92ZSBgeyBvZmZzZXQ6IDIsIGhvd01hbnk6IDIsIG5vZGVzVG9IYW5kbGU6IDIgfWAuCiAgICAvLwogICAgLy8gVGhlbiwgd2U6CiAgICAvLyAtICJmb3JnZXQiIGFib3V0IGZpcnN0IGluc2VydCBjaGFuZ2UgKGl0IGlzICJlYXRlbiIgYnkgcmVtb3ZlKSwKICAgIC8vIC0gYmVjYXVzZSBvZiB0aGF0LCBhdCB0aGUgZW5kIHdlIHdpbGwgd2FudCB0byByZW1vdmUgb25seSBvbmUgbm9kZSAoYG5vZGVzVG9IYW5kbGUgPSAxYCksCiAgICAvLyAtIGJ1dCBzdGlsbCB3ZSBoYXZlIHRvIGNoYW5nZSBvZmZzZXQgb2YgdGhlIHNlY29uZCBpbnNlcnQgY2hhbmdlIGZyb20gYDVgIHRvIGAzYCEKICAgIC8vCiAgICAvLyBTbywgYGhvd01hbnlgIGRvZXMgbm90IGNoYW5nZSB0aHJvdWdob3V0IGl0ZW1zIHRyYW5zZm9ybWF0aW9uIGFuZCBrZWVwcyBpbmZvcm1hdGlvbiBhYm91dCBob3cgbWFueSBub2RlcyB3ZXJlIGFmZmVjdGVkLAogICAgLy8gd2hpbGUgYG5vZGVzVG9IYW5kbGVgIG1lYW5zIGhvdyBtYW55IG5vZGVzIG5lZWQgdG8gYmUgaGFuZGxlZCBhZnRlciB0aGUgY2hhbmdlIGl0ZW0gaXMgdHJhbnNmb3JtZWQgYnkgb3RoZXIgY2hhbmdlcy4KICAgIGluYy5ub2Rlc1RvSGFuZGxlID0gaW5jLmhvd01hbnk7CgogICAgZm9yIChjb25zdCBvbGQgb2YgY2hhbmdlcykgewogICAgICBjb25zdCBpbmNFbmQgPSBpbmMub2Zmc2V0ICsgaW5jLmhvd01hbnk7CiAgICAgIGNvbnN0IG9sZEVuZCA9IG9sZC5vZmZzZXQgKyBvbGQuaG93TWFueTsKCiAgICAgIGlmIChpbmMudHlwZSA9PSAnaW5zZXJ0JykgewogICAgICAgIGlmIChvbGQudHlwZSA9PSAnaW5zZXJ0JykgewogICAgICAgICAgaWYgKGluYy5vZmZzZXQgPD0gb2xkLm9mZnNldCkgewogICAgICAgICAgICBvbGQub2Zmc2V0ICs9IGluYy5ob3dNYW55OwogICAgICAgICAgfSBlbHNlIGlmIChpbmMub2Zmc2V0IDwgb2xkRW5kKSB7CiAgICAgICAgICAgIG9sZC5ob3dNYW55ICs9IGluYy5ub2Rlc1RvSGFuZGxlOwogICAgICAgICAgICBpbmMubm9kZXNUb0hhbmRsZSA9IDA7CiAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICBpZiAob2xkLnR5cGUgPT0gJ3JlbW92ZScpIHsKICAgICAgICAgIGlmIChpbmMub2Zmc2V0IDwgb2xkLm9mZnNldCkgewogICAgICAgICAgICBvbGQub2Zmc2V0ICs9IGluYy5ob3dNYW55OwogICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgaWYgKG9sZC50eXBlID09ICdhdHRyaWJ1dGUnKSB7CiAgICAgICAgICBpZiAoaW5jLm9mZnNldCA8PSBvbGQub2Zmc2V0KSB7CiAgICAgICAgICAgIG9sZC5vZmZzZXQgKz0gaW5jLmhvd01hbnk7CiAgICAgICAgICB9IGVsc2UgaWYgKGluYy5vZmZzZXQgPCBvbGRFbmQpIHsKICAgICAgICAgICAgLy8gVGhpcyBjYXNlIGlzIG1vcmUgY29tcGxpY2F0ZWQsIGJlY2F1c2UgYXR0cmlidXRlIGNoYW5nZSBoYXMgdG8gYmUgc3BsaXQgaW50byB0d28uCiAgICAgICAgICAgIC8vIEV4YW1wbGUgKGFzc3VtZSB0aGF0IHVwcGVyY2FzZSBhbmQgbG93ZXJjYXNlIGxldHRlcnMgbWVhbiBkaWZmZXJlbnQgYXR0cmlidXRlcyk6CiAgICAgICAgICAgIC8vCiAgICAgICAgICAgIC8vIGluaXRpYWwgc3RhdGU6CQlhYmN4eXoKICAgICAgICAgICAgLy8gYXR0cmlidXRlIGNoYW5nZToJYUJDWFl6CiAgICAgICAgICAgIC8vIGluY29taW5nIGluc2VydDoJCWFCQ2Zvb1hZegogICAgICAgICAgICAvLwogICAgICAgICAgICAvLyBDaGFuZ2UgcmFuZ2VzIGNhbm5vdCBpbnRlcnNlY3QgYmVjYXVzZSBlYWNoIGl0ZW0gaGFzIHRvIGJlIGRlc2NyaWJlZCBleGFjdGx5IChpdCB3YXMgZWl0aGVyCiAgICAgICAgICAgIC8vIG5vdCBjaGFuZ2VkLCBpbnNlcnRlZCwgcmVtb3ZlZCwgb3IgaXRzIGF0dHJpYnV0ZSB3YXMgY2hhbmdlZCkuIFRoYXQncyB3aHkgb2xkIGF0dHJpYnV0ZQogICAgICAgICAgICAvLyBjaGFuZ2UgaGFzIHRvIGJlIHNwbGl0IGFuZCBib3RoIHBhcnRzIGhhcyB0byBiZSBoYW5kbGVkIHNlcGFyYXRlbHkgZnJvbSBub3cgb24uCiAgICAgICAgICAgIGNvbnN0IGhvd01hbnkgPSBvbGQuaG93TWFueTsKICAgICAgICAgICAgb2xkLmhvd01hbnkgPSBpbmMub2Zmc2V0IC0gb2xkLm9mZnNldDsgLy8gQWRkIHRoZSBzZWNvbmQgcGFydCBvZiBhdHRyaWJ1dGUgY2hhbmdlIHRvIHRoZSBiZWdpbm5pbmcgb2YgcHJvY2Vzc2VkIGFycmF5IHNvIGl0IHdvbid0CiAgICAgICAgICAgIC8vIGJlIHByb2Nlc3NlZCBhZ2FpbiBpbiB0aGlzIGxvb3AuCgogICAgICAgICAgICBjaGFuZ2VzLnVuc2hpZnQoewogICAgICAgICAgICAgIHR5cGU6ICdhdHRyaWJ1dGUnLAogICAgICAgICAgICAgIG9mZnNldDogaW5jRW5kLAogICAgICAgICAgICAgIGhvd01hbnk6IGhvd01hbnkgLSBvbGQuaG93TWFueSwKICAgICAgICAgICAgICBjb3VudDogdGhpcy5fY2hhbmdlQ291bnQrKwogICAgICAgICAgICB9KTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KCiAgICAgIGlmIChpbmMudHlwZSA9PSAncmVtb3ZlJykgewogICAgICAgIGlmIChvbGQudHlwZSA9PSAnaW5zZXJ0JykgewogICAgICAgICAgaWYgKGluY0VuZCA8PSBvbGQub2Zmc2V0KSB7CiAgICAgICAgICAgIG9sZC5vZmZzZXQgLT0gaW5jLmhvd01hbnk7CiAgICAgICAgICB9IGVsc2UgaWYgKGluY0VuZCA8PSBvbGRFbmQpIHsKICAgICAgICAgICAgaWYgKGluYy5vZmZzZXQgPCBvbGQub2Zmc2V0KSB7CiAgICAgICAgICAgICAgY29uc3QgaW50ZXJzZWN0aW9uTGVuZ3RoID0gaW5jRW5kIC0gb2xkLm9mZnNldDsKICAgICAgICAgICAgICBvbGQub2Zmc2V0ID0gaW5jLm9mZnNldDsKICAgICAgICAgICAgICBvbGQuaG93TWFueSAtPSBpbnRlcnNlY3Rpb25MZW5ndGg7CiAgICAgICAgICAgICAgaW5jLm5vZGVzVG9IYW5kbGUgLT0gaW50ZXJzZWN0aW9uTGVuZ3RoOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIG9sZC5ob3dNYW55IC09IGluYy5ub2Rlc1RvSGFuZGxlOwogICAgICAgICAgICAgIGluYy5ub2Rlc1RvSGFuZGxlID0gMDsKICAgICAgICAgICAgfQogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgaWYgKGluYy5vZmZzZXQgPD0gb2xkLm9mZnNldCkgewogICAgICAgICAgICAgIGluYy5ub2Rlc1RvSGFuZGxlIC09IG9sZC5ob3dNYW55OwogICAgICAgICAgICAgIG9sZC5ob3dNYW55ID0gMDsKICAgICAgICAgICAgfSBlbHNlIGlmIChpbmMub2Zmc2V0IDwgb2xkRW5kKSB7CiAgICAgICAgICAgICAgY29uc3QgaW50ZXJzZWN0aW9uTGVuZ3RoID0gb2xkRW5kIC0gaW5jLm9mZnNldDsKICAgICAgICAgICAgICBvbGQuaG93TWFueSAtPSBpbnRlcnNlY3Rpb25MZW5ndGg7CiAgICAgICAgICAgICAgaW5jLm5vZGVzVG9IYW5kbGUgLT0gaW50ZXJzZWN0aW9uTGVuZ3RoOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICBpZiAob2xkLnR5cGUgPT0gJ3JlbW92ZScpIHsKICAgICAgICAgIGlmIChpbmNFbmQgPD0gb2xkLm9mZnNldCkgewogICAgICAgICAgICBvbGQub2Zmc2V0IC09IGluYy5ob3dNYW55OwogICAgICAgICAgfSBlbHNlIGlmIChpbmMub2Zmc2V0IDwgb2xkLm9mZnNldCkgewogICAgICAgICAgICBpbmMubm9kZXNUb0hhbmRsZSArPSBvbGQuaG93TWFueTsKICAgICAgICAgICAgb2xkLmhvd01hbnkgPSAwOwogICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgaWYgKG9sZC50eXBlID09ICdhdHRyaWJ1dGUnKSB7CiAgICAgICAgICBpZiAoaW5jRW5kIDw9IG9sZC5vZmZzZXQpIHsKICAgICAgICAgICAgb2xkLm9mZnNldCAtPSBpbmMuaG93TWFueTsKICAgICAgICAgIH0gZWxzZSBpZiAoaW5jLm9mZnNldCA8IG9sZC5vZmZzZXQpIHsKICAgICAgICAgICAgY29uc3QgaW50ZXJzZWN0aW9uTGVuZ3RoID0gaW5jRW5kIC0gb2xkLm9mZnNldDsKICAgICAgICAgICAgb2xkLm9mZnNldCA9IGluYy5vZmZzZXQ7CiAgICAgICAgICAgIG9sZC5ob3dNYW55IC09IGludGVyc2VjdGlvbkxlbmd0aDsKICAgICAgICAgIH0gZWxzZSBpZiAoaW5jLm9mZnNldCA8IG9sZEVuZCkgewogICAgICAgICAgICBpZiAoaW5jRW5kIDw9IG9sZEVuZCkgewogICAgICAgICAgICAgIC8vIE9uIGZpcnN0IHNpZ2h0IGluIHRoaXMgY2FzZSB3ZSBkb24ndCBuZWVkIHRvIHNwbGl0IGF0dHJpYnV0ZSBvcGVyYXRpb24gaW50byB0d28uCiAgICAgICAgICAgICAgLy8gSG93ZXZlciB0aGUgY2hhbmdlcyBzZXQgaXMgbGF0ZXIgY29udmVydGVkIHRvIGFjdGlvbnMgKHNlZSBgX2dlbmVyYXRlQWN0aW9uc0Zyb21DaGFuZ2VzYCkuCiAgICAgICAgICAgICAgLy8gRm9yIHRoYXQgcmVhc29uLCBubyB0d28gY2hhbmdlcyBtYXkgaW50ZXJzZWN0LgogICAgICAgICAgICAgIC8vIFNvIHdlIGNhbm5vdCBoYXZlIGFuIGF0dHJpYnV0ZSBjaGFuZ2UgdGhhdCAiY29udGFpbnMiIHJlbW92ZSBjaGFuZ2UuCiAgICAgICAgICAgICAgLy8gQXR0cmlidXRlIGNoYW5nZSBuZWVkcyB0byBiZSBzcGxpdC4KICAgICAgICAgICAgICBjb25zdCBob3dNYW55ID0gb2xkLmhvd01hbnk7CiAgICAgICAgICAgICAgb2xkLmhvd01hbnkgPSBpbmMub2Zmc2V0IC0gb2xkLm9mZnNldDsKICAgICAgICAgICAgICBjb25zdCBob3dNYW55QWZ0ZXIgPSBob3dNYW55IC0gb2xkLmhvd01hbnkgLSBpbmMubm9kZXNUb0hhbmRsZTsgLy8gQWRkIHRoZSBzZWNvbmQgcGFydCBvZiBhdHRyaWJ1dGUgY2hhbmdlIHRvIHRoZSBiZWdpbm5pbmcgb2YgcHJvY2Vzc2VkIGFycmF5IHNvIGl0IHdvbid0CiAgICAgICAgICAgICAgLy8gYmUgcHJvY2Vzc2VkIGFnYWluIGluIHRoaXMgbG9vcC4KCiAgICAgICAgICAgICAgY2hhbmdlcy51bnNoaWZ0KHsKICAgICAgICAgICAgICAgIHR5cGU6ICdhdHRyaWJ1dGUnLAogICAgICAgICAgICAgICAgb2Zmc2V0OiBpbmMub2Zmc2V0LAogICAgICAgICAgICAgICAgaG93TWFueTogaG93TWFueUFmdGVyLAogICAgICAgICAgICAgICAgY291bnQ6IHRoaXMuX2NoYW5nZUNvdW50KysKICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBvbGQuaG93TWFueSAtPSBvbGRFbmQgLSBpbmMub2Zmc2V0OwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CgogICAgICBpZiAoaW5jLnR5cGUgPT0gJ2F0dHJpYnV0ZScpIHsKICAgICAgICAvLyBJbiBjYXNlIG9mIGF0dHJpYnV0ZSBjaGFuZ2UsIGBob3dNYW55YCBzaG91bGQgYmUga2VwdCBzYW1lIGFzIGBub2Rlc1RvSGFuZGxlYC4gSXQncyBub3QgYW4gZXJyb3IuCiAgICAgICAgaWYgKG9sZC50eXBlID09ICdpbnNlcnQnKSB7CiAgICAgICAgICBpZiAoaW5jLm9mZnNldCA8IG9sZC5vZmZzZXQgJiYgaW5jRW5kID4gb2xkLm9mZnNldCkgewogICAgICAgICAgICBpZiAoaW5jRW5kID4gb2xkRW5kKSB7CiAgICAgICAgICAgICAgLy8gVGhpcyBjYXNlIGlzIHNpbWlsYXIgdG8gYSBjYXNlIGRlc2NyaWJlZCB3aGVuIGluY29taW5nIGNoYW5nZSB3YXMgaW5zZXJ0IGFuZCBvbGQgY2hhbmdlIHdhcyBhdHRyaWJ1dGUuCiAgICAgICAgICAgICAgLy8gU2VlIGNvbW1lbnQgYWJvdmUuCiAgICAgICAgICAgICAgLy8KICAgICAgICAgICAgICAvLyBUaGlzIHRpbWUgaW5jb21pbmcgY2hhbmdlIGlzIGF0dHJpYnV0ZS4gV2UgbmVlZCB0byBzcGxpdCBpbmNvbWluZyBjaGFuZ2UgaW4gdGhpcyBjYXNlIHRvby4KICAgICAgICAgICAgICAvLyBIb3dldmVyIHRoaXMgdGltZSwgdGhlIHNlY29uZCBwYXJ0IG9mIHRoZSBhdHRyaWJ1dGUgY2hhbmdlIG5lZWRzIHRvIGJlIHByb2Nlc3NlZCBmdXJ0aGVyCiAgICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGVyZSBtaWdodCBiZSBvdGhlciBjaGFuZ2VzIHRoYXQgaXQgY29sbGlkZXMgd2l0aC4KICAgICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGVQYXJ0ID0gewogICAgICAgICAgICAgICAgdHlwZTogJ2F0dHJpYnV0ZScsCiAgICAgICAgICAgICAgICBvZmZzZXQ6IG9sZEVuZCwKICAgICAgICAgICAgICAgIGhvd01hbnk6IGluY0VuZCAtIG9sZEVuZCwKICAgICAgICAgICAgICAgIGNvdW50OiB0aGlzLl9jaGFuZ2VDb3VudCsrCiAgICAgICAgICAgICAgfTsKCiAgICAgICAgICAgICAgdGhpcy5faGFuZGxlQ2hhbmdlKGF0dHJpYnV0ZVBhcnQsIGNoYW5nZXMpOwoKICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2goYXR0cmlidXRlUGFydCk7CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGluYy5ub2Rlc1RvSGFuZGxlID0gb2xkLm9mZnNldCAtIGluYy5vZmZzZXQ7CiAgICAgICAgICAgIGluYy5ob3dNYW55ID0gaW5jLm5vZGVzVG9IYW5kbGU7CiAgICAgICAgICB9IGVsc2UgaWYgKGluYy5vZmZzZXQgPj0gb2xkLm9mZnNldCAmJiBpbmMub2Zmc2V0IDwgb2xkRW5kKSB7CiAgICAgICAgICAgIGlmIChpbmNFbmQgPiBvbGRFbmQpIHsKICAgICAgICAgICAgICBpbmMubm9kZXNUb0hhbmRsZSA9IGluY0VuZCAtIG9sZEVuZDsKICAgICAgICAgICAgICBpbmMub2Zmc2V0ID0gb2xkRW5kOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIGluYy5ub2Rlc1RvSGFuZGxlID0gMDsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgaWYgKG9sZC50eXBlID09ICdyZW1vdmUnKSB7CiAgICAgICAgICAvLyBUaGlzIGlzIGEgY2FzZSB3aGVuIGF0dHJpYnV0ZSBjaGFuZ2UgImNvbnRhaW5zIiByZW1vdmUgY2hhbmdlLgogICAgICAgICAgLy8gVGhlIGF0dHJpYnV0ZSBjaGFuZ2UgbmVlZHMgdG8gYmUgc3BsaXQgaW50byB0d28gYmVjYXVzZSBjaGFuZ2VzIGNhbm5vdCBpbnRlcnNlY3QuCiAgICAgICAgICBpZiAoaW5jLm9mZnNldCA8IG9sZC5vZmZzZXQgJiYgaW5jRW5kID4gb2xkLm9mZnNldCkgewogICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGVQYXJ0ID0gewogICAgICAgICAgICAgIHR5cGU6ICdhdHRyaWJ1dGUnLAogICAgICAgICAgICAgIG9mZnNldDogb2xkLm9mZnNldCwKICAgICAgICAgICAgICBob3dNYW55OiBpbmNFbmQgLSBvbGQub2Zmc2V0LAogICAgICAgICAgICAgIGNvdW50OiB0aGlzLl9jaGFuZ2VDb3VudCsrCiAgICAgICAgICAgIH07CgogICAgICAgICAgICB0aGlzLl9oYW5kbGVDaGFuZ2UoYXR0cmlidXRlUGFydCwgY2hhbmdlcyk7CgogICAgICAgICAgICBjaGFuZ2VzLnB1c2goYXR0cmlidXRlUGFydCk7CiAgICAgICAgICAgIGluYy5ub2Rlc1RvSGFuZGxlID0gb2xkLm9mZnNldCAtIGluYy5vZmZzZXQ7CiAgICAgICAgICAgIGluYy5ob3dNYW55ID0gaW5jLm5vZGVzVG9IYW5kbGU7CiAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICBpZiAob2xkLnR5cGUgPT0gJ2F0dHJpYnV0ZScpIHsKICAgICAgICAgIC8vIFRoZXJlIGFyZSBvbmx5IHR3byBjb25mbGljdGluZyBzY2VuYXJpb3MgcG9zc2libGUgaGVyZToKICAgICAgICAgIGlmIChpbmMub2Zmc2V0ID49IG9sZC5vZmZzZXQgJiYgaW5jRW5kIDw9IG9sZEVuZCkgewogICAgICAgICAgICAvLyBgb2xkYCBjaGFuZ2UgaW5jbHVkZXMgYGluY2AgY2hhbmdlLCBvciB0aGV5IGFyZSB0aGUgc2FtZS4KICAgICAgICAgICAgaW5jLm5vZGVzVG9IYW5kbGUgPSAwOwogICAgICAgICAgICBpbmMuaG93TWFueSA9IDA7CiAgICAgICAgICAgIGluYy5vZmZzZXQgPSAwOwogICAgICAgICAgfSBlbHNlIGlmIChpbmMub2Zmc2V0IDw9IG9sZC5vZmZzZXQgJiYgaW5jRW5kID49IG9sZEVuZCkgewogICAgICAgICAgICAvLyBgaW5jYCBjaGFuZ2UgaW5jbHVkZXMgYG9sZGAgY2hhbmdlLgogICAgICAgICAgICBvbGQuaG93TWFueSA9IDA7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICB9CgogICAgaW5jLmhvd01hbnkgPSBpbmMubm9kZXNUb0hhbmRsZTsKICAgIGRlbGV0ZSBpbmMubm9kZXNUb0hhbmRsZTsKICB9CiAgLyoqCiAgICogUmV0dXJucyBhbiBvYmplY3Qgd2l0aCBhIHNpbmdsZSBpbnNlcnQgY2hhbmdlIGRlc2NyaXB0aW9uLgogICAqCiAgICogQHByaXZhdGUKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50fSBwYXJlbnQgVGhlIGVsZW1lbnQgaW4gd2hpY2ggdGhlIGNoYW5nZSBoYXBwZW5lZC4KICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IFRoZSBvZmZzZXQgYXQgd2hpY2ggY2hhbmdlIGhhcHBlbmVkLgogICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSByZW1vdmVkIGVsZW1lbnQgb3IgYCckdGV4dCdgIGZvciBhIGNoYXJhY3Rlci4KICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGlmZiBpdGVtLgogICAqLwoKCiAgX2dldEluc2VydERpZmYocGFyZW50LCBvZmZzZXQsIG5hbWUpIHsKICAgIHJldHVybiB7CiAgICAgIHR5cGU6ICdpbnNlcnQnLAogICAgICBwb3NpdGlvbjogUG9zaXRpb24uX2NyZWF0ZUF0KHBhcmVudCwgb2Zmc2V0KSwKICAgICAgbmFtZSwKICAgICAgbGVuZ3RoOiAxLAogICAgICBjaGFuZ2VDb3VudDogdGhpcy5fY2hhbmdlQ291bnQrKwogICAgfTsKICB9CiAgLyoqCiAgICogUmV0dXJucyBhbiBvYmplY3Qgd2l0aCBhIHNpbmdsZSByZW1vdmUgY2hhbmdlIGRlc2NyaXB0aW9uLgogICAqCiAgICogQHByaXZhdGUKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50fSBwYXJlbnQgVGhlIGVsZW1lbnQgaW4gd2hpY2ggY2hhbmdlIGhhcHBlbmVkLgogICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgVGhlIG9mZnNldCBhdCB3aGljaCBjaGFuZ2UgaGFwcGVuZWQuCiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIHJlbW92ZWQgZWxlbWVudCBvciBgJyR0ZXh0J2AgZm9yIGEgY2hhcmFjdGVyLgogICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkaWZmIGl0ZW0uCiAgICovCgoKICBfZ2V0UmVtb3ZlRGlmZihwYXJlbnQsIG9mZnNldCwgbmFtZSkgewogICAgcmV0dXJuIHsKICAgICAgdHlwZTogJ3JlbW92ZScsCiAgICAgIHBvc2l0aW9uOiBQb3NpdGlvbi5fY3JlYXRlQXQocGFyZW50LCBvZmZzZXQpLAogICAgICBuYW1lLAogICAgICBsZW5ndGg6IDEsCiAgICAgIGNoYW5nZUNvdW50OiB0aGlzLl9jaGFuZ2VDb3VudCsrCiAgICB9OwogIH0KICAvKioKICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIG9iamVjdHMgd2hlcmUgZWFjaCBvbmUgaXMgYSBzaW5nbGUgYXR0cmlidXRlIGNoYW5nZSBkZXNjcmlwdGlvbi4KICAgKgogICAqIEBwcml2YXRlCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlfSByYW5nZSBUaGUgcmFuZ2Ugd2hlcmUgdGhlIGNoYW5nZSBoYXBwZW5lZC4KICAgKiBAcGFyYW0ge01hcH0gb2xkQXR0cmlidXRlcyBBIG1hcCwgbWFwIGl0ZXJhdG9yIG9yIGNvbXBhdGlibGUgb2JqZWN0IHRoYXQgY29udGFpbnMgYXR0cmlidXRlcyBiZWZvcmUgdGhlIGNoYW5nZS4KICAgKiBAcGFyYW0ge01hcH0gbmV3QXR0cmlidXRlcyBBIG1hcCwgbWFwIGl0ZXJhdG9yIG9yIGNvbXBhdGlibGUgb2JqZWN0IHRoYXQgY29udGFpbnMgYXR0cmlidXRlcyBhZnRlciB0aGUgY2hhbmdlLgogICAqIEByZXR1cm5zIHtBcnJheS48T2JqZWN0Pn0gQW4gYXJyYXkgY29udGFpbmluZyBvbmUgb3IgbW9yZSBkaWZmIGl0ZW1zLgogICAqLwoKCiAgX2dldEF0dHJpYnV0ZXNEaWZmKHJhbmdlLCBvbGRBdHRyaWJ1dGVzLCBuZXdBdHRyaWJ1dGVzKSB7CiAgICAvLyBSZXN1bHRzIGhvbGRlci4KICAgIGNvbnN0IGRpZmZzID0gW107IC8vIENsb25lIG5ldyBhdHRyaWJ1dGVzIGFzIHdlIHdpbGwgYmUgcGVyZm9ybWluZyBjaGFuZ2VzIG9uIHRoaXMgb2JqZWN0LgoKICAgIG5ld0F0dHJpYnV0ZXMgPSBuZXcgTWFwKG5ld0F0dHJpYnV0ZXMpOyAvLyBMb29rIHRocm91Z2ggb2xkIGF0dHJpYnV0ZXMuCgogICAgZm9yIChjb25zdCBba2V5LCBvbGRWYWx1ZV0gb2Ygb2xkQXR0cmlidXRlcykgewogICAgICAvLyBDaGVjayB3aGF0IGlzIHRoZSBuZXcgdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZSAob3IgaWYgaXQgd2FzIHJlbW92ZWQpLgogICAgICBjb25zdCBuZXdWYWx1ZSA9IG5ld0F0dHJpYnV0ZXMuaGFzKGtleSkgPyBuZXdBdHRyaWJ1dGVzLmdldChrZXkpIDogbnVsbDsgLy8gSWYgdmFsdWVzIGFyZSBkaWZmZXJlbnQgKG9yIGF0dHJpYnV0ZSB3YXMgcmVtb3ZlZCkuLi4KCiAgICAgIGlmIChuZXdWYWx1ZSAhPT0gb2xkVmFsdWUpIHsKICAgICAgICAvLyBBZGQgZGlmZiBpdGVtLgogICAgICAgIGRpZmZzLnB1c2goewogICAgICAgICAgdHlwZTogJ2F0dHJpYnV0ZScsCiAgICAgICAgICBwb3NpdGlvbjogcmFuZ2Uuc3RhcnQsCiAgICAgICAgICByYW5nZTogcmFuZ2UuY2xvbmUoKSwKICAgICAgICAgIGxlbmd0aDogMSwKICAgICAgICAgIGF0dHJpYnV0ZUtleToga2V5LAogICAgICAgICAgYXR0cmlidXRlT2xkVmFsdWU6IG9sZFZhbHVlLAogICAgICAgICAgYXR0cmlidXRlTmV3VmFsdWU6IG5ld1ZhbHVlLAogICAgICAgICAgY2hhbmdlQ291bnQ6IHRoaXMuX2NoYW5nZUNvdW50KysKICAgICAgICB9KTsKICAgICAgfSAvLyBQcmV2ZW50IHJldHVybmluZyB0d28gZGlmZiBpdGVtcyBmb3IgdGhlIHNhbWUgY2hhbmdlLgoKCiAgICAgIG5ld0F0dHJpYnV0ZXMuZGVsZXRlKGtleSk7CiAgICB9IC8vIExvb2sgdGhyb3VnaCBuZXcgYXR0cmlidXRlcyB0aGF0IHdlcmVuJ3QgaGFuZGxlZCBhYm92ZS4KCgogICAgZm9yIChjb25zdCBba2V5LCBuZXdWYWx1ZV0gb2YgbmV3QXR0cmlidXRlcykgewogICAgICAvLyBFYWNoIG9mIHRoZW0gaXMgYSBuZXcgYXR0cmlidXRlLiBBZGQgZGlmZiBpdGVtLgogICAgICBkaWZmcy5wdXNoKHsKICAgICAgICB0eXBlOiAnYXR0cmlidXRlJywKICAgICAgICBwb3NpdGlvbjogcmFuZ2Uuc3RhcnQsCiAgICAgICAgcmFuZ2U6IHJhbmdlLmNsb25lKCksCiAgICAgICAgbGVuZ3RoOiAxLAogICAgICAgIGF0dHJpYnV0ZUtleToga2V5LAogICAgICAgIGF0dHJpYnV0ZU9sZFZhbHVlOiBudWxsLAogICAgICAgIGF0dHJpYnV0ZU5ld1ZhbHVlOiBuZXdWYWx1ZSwKICAgICAgICBjaGFuZ2VDb3VudDogdGhpcy5fY2hhbmdlQ291bnQrKwogICAgICB9KTsKICAgIH0KCiAgICByZXR1cm4gZGlmZnM7CiAgfQogIC8qKgogICAqIENoZWNrcyB3aGV0aGVyIGdpdmVuIGVsZW1lbnQgb3IgYW55IG9mIGl0cyBwYXJlbnRzIGlzIGFuIGVsZW1lbnQgdGhhdCBpcyBidWZmZXJlZCBhcyBhbiBpbnNlcnRlZCBlbGVtZW50LgogICAqCiAgICogQHByaXZhdGUKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gY2hlY2suCiAgICogQHJldHVybnMge0Jvb2xlYW59CiAgICovCgoKICBfaXNJbkluc2VydGVkRWxlbWVudChlbGVtZW50KSB7CiAgICBjb25zdCBwYXJlbnQgPSBlbGVtZW50LnBhcmVudDsKCiAgICBpZiAoIXBhcmVudCkgewogICAgICByZXR1cm4gZmFsc2U7CiAgICB9CgogICAgY29uc3QgY2hhbmdlcyA9IHRoaXMuX2NoYW5nZXNJbkVsZW1lbnQuZ2V0KHBhcmVudCk7CgogICAgY29uc3Qgb2Zmc2V0ID0gZWxlbWVudC5zdGFydE9mZnNldDsKCiAgICBpZiAoY2hhbmdlcykgewogICAgICBmb3IgKGNvbnN0IGNoYW5nZSBvZiBjaGFuZ2VzKSB7CiAgICAgICAgaWYgKGNoYW5nZS50eXBlID09ICdpbnNlcnQnICYmIG9mZnNldCA+PSBjaGFuZ2Uub2Zmc2V0ICYmIG9mZnNldCA8IGNoYW5nZS5vZmZzZXQgKyBjaGFuZ2UuaG93TWFueSkgewogICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgfQogICAgICB9CiAgICB9CgogICAgcmV0dXJuIHRoaXMuX2lzSW5JbnNlcnRlZEVsZW1lbnQocGFyZW50KTsKICB9CiAgLyoqCiAgICogUmVtb3ZlcyBkZWVwbHkgYWxsIGJ1ZmZlcmVkIGNoYW5nZXMgdGhhdCBhcmUgcmVnaXN0ZXJlZCBpbiBlbGVtZW50cyBmcm9tIHJhbmdlIHNwZWNpZmllZCBieSBgcGFyZW50YCwgYG9mZnNldGAKICAgKiBhbmQgYGhvd01hbnlgLgogICAqCiAgICogQHByaXZhdGUKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50fSBwYXJlbnQKICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0CiAgICogQHBhcmFtIHtOdW1iZXJ9IGhvd01hbnkKICAgKi8KCgogIF9yZW1vdmVBbGxOZXN0ZWRDaGFuZ2VzKHBhcmVudCwgb2Zmc2V0LCBob3dNYW55KSB7CiAgICBjb25zdCByYW5nZSA9IG5ldyBSYW5nZShQb3NpdGlvbi5fY3JlYXRlQXQocGFyZW50LCBvZmZzZXQpLCBQb3NpdGlvbi5fY3JlYXRlQXQocGFyZW50LCBvZmZzZXQgKyBob3dNYW55KSk7CgogICAgZm9yIChjb25zdCBpdGVtIG9mIHJhbmdlLmdldEl0ZW1zKHsKICAgICAgc2hhbGxvdzogdHJ1ZQogICAgfSkpIHsKICAgICAgaWYgKGl0ZW0uaXMoJ2VsZW1lbnQnKSkgewogICAgICAgIHRoaXMuX2VsZW1lbnRTbmFwc2hvdHMuZGVsZXRlKGl0ZW0pOwoKICAgICAgICB0aGlzLl9jaGFuZ2VzSW5FbGVtZW50LmRlbGV0ZShpdGVtKTsKCiAgICAgICAgdGhpcy5fcmVtb3ZlQWxsTmVzdGVkQ2hhbmdlcyhpdGVtLCAwLCBpdGVtLm1heE9mZnNldCk7CiAgICAgIH0KICAgIH0KICB9Cgp9IC8vIFJldHVybnMgYW4gYXJyYXkgdGhhdCBpcyBhIGNvcHkgb2YgcGFzc2VkIGNoaWxkIGxpc3Qgd2l0aCB0aGUgZXhjZXB0aW9uIHRoYXQgdGV4dCBub2RlcyBhcmUgc3BsaXQgdG8gb25lIG9yIG1vcmUKLy8gb2JqZWN0cywgZWFjaCByZXByZXNlbnRpbmcgb25lIGNoYXJhY3RlciBhbmQgYXR0cmlidXRlcyBzZXQgb24gdGhhdCBjaGFyYWN0ZXIuCgpmdW5jdGlvbiBfZ2V0Q2hpbGRyZW5TbmFwc2hvdChjaGlsZHJlbikgewogIGNvbnN0IHNuYXBzaG90ID0gW107CgogIGZvciAoY29uc3QgY2hpbGQgb2YgY2hpbGRyZW4pIHsKICAgIGlmIChjaGlsZC5pcygndGV4dCcpKSB7CiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGQuZGF0YS5sZW5ndGg7IGkrKykgewogICAgICAgIHNuYXBzaG90LnB1c2goewogICAgICAgICAgbmFtZTogJyR0ZXh0JywKICAgICAgICAgIGF0dHJpYnV0ZXM6IG5ldyBNYXAoY2hpbGQuZ2V0QXR0cmlidXRlcygpKQogICAgICAgIH0pOwogICAgICB9CiAgICB9IGVsc2UgewogICAgICBzbmFwc2hvdC5wdXNoKHsKICAgICAgICBuYW1lOiBjaGlsZC5uYW1lLAogICAgICAgIGF0dHJpYnV0ZXM6IG5ldyBNYXAoY2hpbGQuZ2V0QXR0cmlidXRlcygpKQogICAgICB9KTsKICAgIH0KICB9CgogIHJldHVybiBzbmFwc2hvdDsKfSAvLyBHZW5lcmF0ZXMgYXJyYXkgb2YgYWN0aW9ucyBmb3IgZ2l2ZW4gY2hhbmdlcyBzZXQuCi8vIEl0IHNpbXVsYXRlcyB3aGF0IGBkaWZmYCBmdW5jdGlvbiBkb2VzLgovLyBHZW5lcmF0ZWQgYWN0aW9ucyBhcmU6Ci8vIC0gJ2UnIGZvciAnZXF1YWwnIC0gd2hlbiBpdGVtIGF0IHRoYXQgcG9zaXRpb24gZGlkIG5vdCBjaGFuZ2UsCi8vIC0gJ2knIGZvciAnaW5zZXJ0JyAtIHdoZW4gaXRlbSBhdCB0aGF0IHBvc2l0aW9uIHdhcyBpbnNlcnRlZCwKLy8gLSAncicgZm9yICdyZW1vdmUnIC0gd2hlbiBpdGVtIGF0IHRoYXQgcG9zaXRpb24gd2FzIHJlbW92ZWQsCi8vIC0gJ2EnIGZvciAnYXR0cmlidXRlJyAtIHdoZW4gaXRlbSBhdCB0aGF0IHBvc2l0aW9uIGhhcyBpdCBhdHRyaWJ1dGVzIGNoYW5nZWQuCi8vCi8vIEV4YW1wbGUgKGFzc3VtZSB0aGF0IHVwcGVyY2FzZSBsZXR0ZXJzIGhhdmUgYm9sZCBhdHRyaWJ1dGUsIGNvbXBhcmUgd2l0aCBmdW5jdGlvbiBjb2RlKToKLy8KLy8gY2hpbGRyZW4gYmVmb3JlOglmb29CQVIKLy8gY2hpbGRyZW4gYWZ0ZXI6CWZveHliQVIKLy8KLy8gY2hhbmdlczogdHlwZTogcmVtb3ZlLCBvZmZzZXQ6IDEsIGhvd01hbnk6IDEKLy8JCQl0eXBlOiBpbnNlcnQsIG9mZnNldDogMiwgaG93TWFueTogMgovLwkJCXR5cGU6IGF0dHJpYnV0ZSwgb2Zmc2V0OiA0LCBob3dNYW55OiAxCi8vCi8vIGV4cGVjdGVkIGFjdGlvbnM6IGVxdWFsIChmKSwgcmVtb3ZlIChvKSwgZXF1YWwgKG8pLCBpbnNlcnQgKHgpLCBpbnNlcnQgKHkpLCBhdHRyaWJ1dGUgKGIpLCBlcXVhbCAoQSksIGVxdWFsIChSKQovLwovLyBzdGVwcyB0YWtlbiBieSB0aCBzY3JpcHQ6Ci8vCi8vIDEuIGNoYW5nZSA9ICJ0eXBlOiByZW1vdmUsIG9mZnNldDogMSwgaG93TWFueTogMSI7IG9mZnNldCA9IDA7IG9sZENoaWxkcmVuSGFuZGxlZCA9IDAKLy8gICAgMS4xIGJldHdlZW4gdGhpcyBjaGFuZ2UgYW5kIHRoZSBiZWdpbm5pbmcgaXMgb25lIG5vdC1jaGFuZ2VkIG5vZGUsIGZpbGwgd2l0aCBvbmUgZXF1YWwgYWN0aW9uLCBvbmUgb2xkIGNoaWxkIGhhcyBiZWVuIGhhbmRsZWQKLy8gICAgMS4yIHRoaXMgY2hhbmdlIHJlbW92ZXMgb25lIG5vZGUsIGFkZCBvbmUgcmVtb3ZlIGFjdGlvbgovLyAgICAxLjMgY2hhbmdlIGxhc3QgdmlzaXRlZCBgb2Zmc2V0YCB0byAxCi8vICAgIDEuNCBzaW5jZSBhbiBvbGQgY2hpbGQgaGFzIGJlZW4gcmVtb3ZlZCwgb25lIG1vcmUgb2xkIGNoaWxkIGhhcyBiZWVuIGhhbmRsZWQKLy8gICAgMS41IGFjdGlvbnMgYXQgdGhpcyBwb2ludCBhcmU6IGVxdWFsLCByZW1vdmUKLy8KLy8gMi4gY2hhbmdlID0gInR5cGU6IGluc2VydCwgb2Zmc2V0OiAyLCBob3dNYW55OiAyIjsgb2Zmc2V0ID0gMTsgb2xkQ2hpbGRyZW5IYW5kbGVkID0gMgovLyAgICAyLjEgYmV0d2VlbiB0aGlzIGNoYW5nZSBhbmQgcHJldmlvdXMgY2hhbmdlIGlzIG9uZSBub3QtY2hhbmdlZCBub2RlLCBhZGQgZXF1YWwgYWN0aW9uLCBhbm90aGVyIG9uZSBvbGQgY2hpbGRyZW4gaGFzIGJlZW4gaGFuZGxlZAovLyAgICAyLjIgdGhpcyBjaGFuZ2UgaW5zZXJ0cyB0d28gbm9kZXMsIGFkZCB0d28gaW5zZXJ0IGFjdGlvbnMKLy8gICAgMi4zIGNoYW5nZSBsYXN0IHZpc2l0ZWQgb2Zmc2V0IHRvIHRoZSBlbmQgb2YgdGhlIGluc2VydGVkIHJhbmdlLCB0aGF0IGlzIDQKLy8gICAgMi40IGFjdGlvbnMgYXQgdGhpcyBwb2ludCBhcmU6IGVxdWFsLCByZW1vdmUsIGVxdWFsLCBpbnNlcnQsIGluc2VydAovLwovLyAzLiBjaGFuZ2UgPSAidHlwZTogYXR0cmlidXRlLCBvZmZzZXQ6IDQsIGhvd01hbnk6IDEiOyBvZmZzZXQgPSA0LCBvbGRDaGlsZHJlbkhhbmRsZWQgPSAzCi8vICAgIDMuMSBiZXR3ZWVuIHRoaXMgY2hhbmdlIGFuZCBwcmV2aW91cyBjaGFuZ2UgYXJlIG5vIG5vdC1jaGFuZ2VkIG5vZGVzCi8vICAgIDMuMiB0aGlzIGNoYW5nZSBjaGFuZ2VzIG9uZSBub2RlLCBhZGQgb25lIGF0dHJpYnV0ZSBhY3Rpb24KLy8gICAgMy4zIGNoYW5nZSBsYXN0IHZpc2l0ZWQgYG9mZnNldGAgdG8gdGhlIGVuZCBvZiBjaGFuZ2UgcmFuZ2UsIHRoYXQgaXMgNQovLyAgICAzLjQgc2luY2UgYW4gb2xkIGNoaWxkIGhhcyBiZWVuIGNoYW5nZWQsIG9uZSBtb3JlIG9sZCBjaGlsZCBoYXMgYmVlbiBoYW5kbGVkCi8vICAgIDMuNSBhY3Rpb25zIGF0IHRoaXMgcG9pbnQgYXJlOiBlcXVhbCwgcmVtb3ZlLCBlcXVhbCwgaW5zZXJ0LCBpbnNlcnQsIGF0dHJpYnV0ZQovLwovLyA0LiBhZnRlciBsb29wIG9sZENoaWxkcmVuSGFuZGxlZCA9IDQsIG9sZENoaWxkcmVuTGVuZ3RoID0gNiAoZm9vQkFSIGlzIDYgY2hhcmFjdGVycykKLy8gICAgNC4xIGZpbGwgdXAgd2l0aCB0d28gZXF1YWwgYWN0aW9ucwovLwovLyBUaGUgcmVzdWx0IGFjdGlvbnMgYXJlOiBlcXVhbCwgcmVtb3ZlLCBlcXVhbCwgaW5zZXJ0LCBpbnNlcnQsIGF0dHJpYnV0ZSwgZXF1YWwsIGVxdWFsLgoKCmZ1bmN0aW9uIF9nZW5lcmF0ZUFjdGlvbnNGcm9tQ2hhbmdlcyhvbGRDaGlsZHJlbkxlbmd0aCwgY2hhbmdlcykgewogIGNvbnN0IGFjdGlvbnMgPSBbXTsKICBsZXQgb2Zmc2V0ID0gMDsKICBsZXQgb2xkQ2hpbGRyZW5IYW5kbGVkID0gMDsgLy8gR28gdGhyb3VnaCBhbGwgYnVmZmVyZWQgY2hhbmdlcy4KCiAgZm9yIChjb25zdCBjaGFuZ2Ugb2YgY2hhbmdlcykgewogICAgLy8gRmlyc3QsIGZpbGwgImhvbGVzIiBiZXR3ZWVuIGNoYW5nZXMgd2l0aCAiZXF1YWwiIGFjdGlvbnMuCiAgICBpZiAoY2hhbmdlLm9mZnNldCA+IG9mZnNldCkgewogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYW5nZS5vZmZzZXQgLSBvZmZzZXQ7IGkrKykgewogICAgICAgIGFjdGlvbnMucHVzaCgnZScpOwogICAgICB9CgogICAgICBvbGRDaGlsZHJlbkhhbmRsZWQgKz0gY2hhbmdlLm9mZnNldCAtIG9mZnNldDsKICAgIH0gLy8gVGhlbiwgZmlsbCB1cCBhY3Rpb25zIGFjY29yZGluZ2x5IHRvIGNoYW5nZSB0eXBlLgoKCiAgICBpZiAoY2hhbmdlLnR5cGUgPT0gJ2luc2VydCcpIHsKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFuZ2UuaG93TWFueTsgaSsrKSB7CiAgICAgICAgYWN0aW9ucy5wdXNoKCdpJyk7CiAgICAgIH0gLy8gVGhlIGxhc3QgaGFuZGxlZCBvZmZzZXQgaXMgYWZ0ZXIgaW5zZXJ0ZWQgcmFuZ2UuCgoKICAgICAgb2Zmc2V0ID0gY2hhbmdlLm9mZnNldCArIGNoYW5nZS5ob3dNYW55OwogICAgfSBlbHNlIGlmIChjaGFuZ2UudHlwZSA9PSAncmVtb3ZlJykgewogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYW5nZS5ob3dNYW55OyBpKyspIHsKICAgICAgICBhY3Rpb25zLnB1c2goJ3InKTsKICAgICAgfSAvLyBUaGUgbGFzdCBoYW5kbGVkIG9mZnNldCBpcyBhdCB0aGUgcG9zaXRpb24gd2hlcmUgdGhlIG5vZGVzIHdlcmUgcmVtb3ZlZC4KCgogICAgICBvZmZzZXQgPSBjaGFuZ2Uub2Zmc2V0OyAvLyBXZSByZW1vdmVkIGBob3dNYW55YCBvbGQgbm9kZXMsIHVwZGF0ZSBgb2xkQ2hpbGRyZW5IYW5kbGVkYC4KCiAgICAgIG9sZENoaWxkcmVuSGFuZGxlZCArPSBjaGFuZ2UuaG93TWFueTsKICAgIH0gZWxzZSB7CiAgICAgIGFjdGlvbnMucHVzaCguLi4nYScucmVwZWF0KGNoYW5nZS5ob3dNYW55KS5zcGxpdCgnJykpOyAvLyBUaGUgbGFzdCBoYW5kbGVkIG9mZnNldCBpcyBhdCB0aGUgcG9zaXRpb24gYWZ0ZXIgdGhlIGNoYW5nZWQgcmFuZ2UuCgogICAgICBvZmZzZXQgPSBjaGFuZ2Uub2Zmc2V0ICsgY2hhbmdlLmhvd01hbnk7IC8vIFdlIGNoYW5nZWQgYGhvd01hbnlgIG9sZCBub2RlcywgdXBkYXRlIGBvbGRDaGlsZHJlbkhhbmRsZWRgLgoKICAgICAgb2xkQ2hpbGRyZW5IYW5kbGVkICs9IGNoYW5nZS5ob3dNYW55OwogICAgfQogIH0gLy8gRmlsbCAiZXF1YWwiIGFjdGlvbnMgYXQgdGhlIGVuZCBvZiBhY3Rpb25zIHNldC4gVXNlIGBvbGRDaGlsZHJlbkhhbmRsZWRgIHRvIHNlZSBob3cgbWFueSBjaGlsZHJlbgogIC8vIGhhcyBub3QgYmVlbiBjaGFuZ2VkIC8gcmVtb3ZlZCBhdCB0aGUgZW5kIG9mIHRoZWlyIHBhcmVudC4KCgogIGlmIChvbGRDaGlsZHJlbkhhbmRsZWQgPCBvbGRDaGlsZHJlbkxlbmd0aCkgewogICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvbGRDaGlsZHJlbkxlbmd0aCAtIG9sZENoaWxkcmVuSGFuZGxlZCAtIG9mZnNldDsgaSsrKSB7CiAgICAgIGFjdGlvbnMucHVzaCgnZScpOwogICAgfQogIH0KCiAgcmV0dXJuIGFjdGlvbnM7Cn0gLy8gRmlsdGVyIGNhbGxiYWNrIGZvciBBcnJheS5maWx0ZXIgdGhhdCBmaWx0ZXJzIG91dCBjaGFuZ2UgZW50cmllcyB0aGF0IGFyZSBpbiBncmF2ZXlhcmQuCgoKZnVuY3Rpb24gX2NoYW5nZXNJbkdyYXZleWFyZEZpbHRlcihlbnRyeSkgewogIGNvbnN0IHBvc0luR3kgPSBlbnRyeS5wb3NpdGlvbiAmJiBlbnRyeS5wb3NpdGlvbi5yb290LnJvb3ROYW1lID09ICckZ3JhdmV5YXJkJzsKICBjb25zdCByYW5nZUluR3kgPSBlbnRyeS5yYW5nZSAmJiBlbnRyeS5yYW5nZS5yb290LnJvb3ROYW1lID09ICckZ3JhdmV5YXJkJzsKICByZXR1cm4gIXBvc0luR3kgJiYgIXJhbmdlSW5HeTsKfQ=="},{"version":3,"sources":["/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-engine/src/model/differ.js"],"names":["Position","Range","Differ","constructor","markerCollection","_markerCollection","_changesInElement","Map","_elementSnapshots","_changedMarkers","_changeCount","_cachedChanges","_cachedChangesWithGraveyard","isEmpty","size","refreshItem","item","_isInInsertedElement","parent","_markRemove","startOffset","offsetSize","_markInsert","range","_createOn","marker","getMarkersIntersectingRange","markerRange","getRange","bufferMarkerChange","name","affectsData","bufferOperation","operation","type","position","offset","nodes","maxOffset","getItems","shallow","_markAttribute","sourcePosition","isEqual","targetPosition","getShiftedBy","howMany","sourceParentInserted","targetParentInserted","getMovedRangeStart","_createFromPositionAndShift","splitElement","splitPosition","insertionPosition","graveyardPosition","mergedElement","graveyardParent","mergedIntoElement","markerName","oldRange","newRange","buffered","get","set","delete","getMarkersToRemove","result","change","push","getMarkersToAdd","getChangedMarkers","Array","from","map","data","hasDataChanges","getChanges","options","includeChangesInGraveyard","slice","diffSet","element","keys","changes","sort","a","b","snapshotChildren","elementChildren","_getChildrenSnapshot","getChildren","actions","_generateActionsFromChanges","length","i","j","action","_getInsertDiff","_getRemoveDiff","elementAttributes","attributes","snapshotAttributes","_createAt","index","offsetToIndex","getChild","_getAttributesDiff","root","rootName","changeCount","isBefore","prevDiff","thisDiff","isConsecutiveTextRemove","isConsecutiveTextAdd","isConsecutiveAttributeChange","isFlat","attributeKey","attributeOldValue","attributeNewValue","end","splice","filter","_changesInGraveyardFilter","reset","clear","changeItem","count","_markChange","_removeAllNestedChanges","_makeSnapshot","_getChangesForElement","_handleChange","has","inc","nodesToHandle","old","incEnd","oldEnd","unshift","intersectionLength","howManyAfter","attributePart","oldAttributes","newAttributes","diffs","key","oldValue","newValue","start","clone","is","children","snapshot","child","getAttributes","oldChildrenLength","oldChildrenHandled","repeat","split","entry","posInGy","rangeInGy"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/model/differ\n */\n\nimport Position from './position';\nimport Range from './range';\n\n/**\n * Calculates the difference between two model states.\n *\n * Receives operations that are to be applied on the model document. Marks parts of the model document tree which\n * are changed and saves the state of these elements before the change. Then, it compares saved elements with the\n * changed elements, after all changes are applied on the model document. Calculates the diff between saved\n * elements and new ones and returns a change set.\n */\nexport default class Differ {\n\t/**\n\t * Creates a `Differ` instance.\n\t *\n\t * @param {module:engine/model/markercollection~MarkerCollection} markerCollection Model's marker collection.\n\t */\n\tconstructor( markerCollection ) {\n\t\t/**\n\t\t * Reference to the model's marker collection.\n\t\t *\n\t\t * @private\n\t\t * @type {module:engine/model/markercollection~MarkerCollection}\n\t\t */\n\t\tthis._markerCollection = markerCollection;\n\n\t\t/**\n\t\t * A map that stores changes that happened in a given element.\n\t\t *\n\t\t * The keys of the map are references to the model elements.\n\t\t * The values of the map are arrays with changes that were done on this element.\n\t\t *\n\t\t * @private\n\t\t * @type {Map}\n\t\t */\n\t\tthis._changesInElement = new Map();\n\n\t\t/**\n\t\t * A map that stores \"element's children snapshots\". A snapshot is representing children of a given element before\n\t\t * the first change was applied on that element. Snapshot items are objects with two properties: `name`,\n\t\t * containing the element name (or `'$text'` for a text node) and `attributes` which is a map of the node's attributes.\n\t\t *\n\t\t * @private\n\t\t * @type {Map}\n\t\t */\n\t\tthis._elementSnapshots = new Map();\n\n\t\t/**\n\t\t * A map that stores all changed markers.\n\t\t *\n\t\t * The keys of the map are marker names.\n\t\t * The values of the map are objects with the `oldRange` and `newRange` properties. They store the marker range\n\t\t * state before and after the change.\n\t\t *\n\t\t * @private\n\t\t * @type {Map}\n\t\t */\n\t\tthis._changedMarkers = new Map();\n\n\t\t/**\n\t\t * Stores the number of changes that were processed. Used to order the changes chronologically. It is important\n\t\t * when changes are sorted.\n\t\t *\n\t\t * @private\n\t\t * @type {Number}\n\t\t */\n\t\tthis._changeCount = 0;\n\n\t\t/**\n\t\t * For efficiency purposes, `Differ` stores the change set returned by the differ after {@link #getChanges} call.\n\t\t * Cache is reset each time a new operation is buffered. If the cache has not been reset, {@link #getChanges} will\n\t\t * return the cached value instead of calculating it again.\n\t\t *\n\t\t * This property stores those changes that did not take place in graveyard root.\n\t\t *\n\t\t * @private\n\t\t * @type {Array.<Object>|null}\n\t\t */\n\t\tthis._cachedChanges = null;\n\n\t\t/**\n\t\t * For efficiency purposes, `Differ` stores the change set returned by the differ after the {@link #getChanges} call.\n\t\t * The cache is reset each time a new operation is buffered. If the cache has not been reset, {@link #getChanges} will\n\t\t * return the cached value instead of calculating it again.\n\t\t *\n\t\t * This property stores all changes evaluated by `Differ`, including those that took place in the graveyard.\n\t\t *\n\t\t * @private\n\t\t * @type {Array.<Object>|null}\n\t\t */\n\t\tthis._cachedChangesWithGraveyard = null;\n\t}\n\n\t/**\n\t * Informs whether there are any changes buffered in `Differ`.\n\t *\n\t * @readonly\n\t * @type {Boolean}\n\t */\n\tget isEmpty() {\n\t\treturn this._changesInElement.size == 0 && this._changedMarkers.size == 0;\n\t}\n\n\t/**\n\t * Marks given `item` in differ to be \"refreshed\". It means that the item will be marked as removed and inserted in the differ changes\n\t * set, so it will be effectively re-converted when differ changes will be handled by a dispatcher.\n\t *\n\t * @param {module:engine/model/item~Item} item Item to refresh.\n\t */\n\trefreshItem( item ) {\n\t\tif ( this._isInInsertedElement( item.parent ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._markRemove( item.parent, item.startOffset, item.offsetSize );\n\t\tthis._markInsert( item.parent, item.startOffset, item.offsetSize );\n\n\t\tconst range = Range._createOn( item );\n\n\t\tfor ( const marker of this._markerCollection.getMarkersIntersectingRange( range ) ) {\n\t\t\tconst markerRange = marker.getRange();\n\n\t\t\tthis.bufferMarkerChange( marker.name, markerRange, markerRange, marker.affectsData );\n\t\t}\n\n\t\t// Clear cache after each buffered operation as it is no longer valid.\n\t\tthis._cachedChanges = null;\n\t}\n\n\t/**\n\t * Buffers the given operation. An operation has to be buffered before it is executed.\n\t *\n\t * Operation type is checked and it is checked which nodes it will affect. These nodes are then stored in `Differ`\n\t * in the state before the operation is executed.\n\t *\n\t * @param {module:engine/model/operation/operation~Operation} operation An operation to buffer.\n\t */\n\tbufferOperation( operation ) {\n\t\t// Below we take an operation, check its type, then use its parameters in marking (private) methods.\n\t\t// The general rule is to not mark elements inside inserted element. All inserted elements are re-rendered.\n\t\t// Marking changes in them would cause a \"double\" changing then.\n\t\t//\n\t\tswitch ( operation.type ) {\n\t\t\tcase 'insert': {\n\t\t\t\tif ( this._isInInsertedElement( operation.position.parent ) ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis._markInsert( operation.position.parent, operation.position.offset, operation.nodes.maxOffset );\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'addAttribute':\n\t\t\tcase 'removeAttribute':\n\t\t\tcase 'changeAttribute': {\n\t\t\t\tfor ( const item of operation.range.getItems( { shallow: true } ) ) {\n\t\t\t\t\tif ( this._isInInsertedElement( item.parent ) ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._markAttribute( item );\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'remove':\n\t\t\tcase 'move':\n\t\t\tcase 'reinsert': {\n\t\t\t\t// When range is moved to the same position then not mark it as a change.\n\t\t\t\t// See: https://github.com/ckeditor/ckeditor5-engine/issues/1664.\n\t\t\t\tif (\n\t\t\t\t\toperation.sourcePosition.isEqual( operation.targetPosition ) ||\n\t\t\t\t\toperation.sourcePosition.getShiftedBy( operation.howMany ).isEqual( operation.targetPosition )\n\t\t\t\t) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst sourceParentInserted = this._isInInsertedElement( operation.sourcePosition.parent );\n\t\t\t\tconst targetParentInserted = this._isInInsertedElement( operation.targetPosition.parent );\n\n\t\t\t\tif ( !sourceParentInserted ) {\n\t\t\t\t\tthis._markRemove( operation.sourcePosition.parent, operation.sourcePosition.offset, operation.howMany );\n\t\t\t\t}\n\n\t\t\t\tif ( !targetParentInserted ) {\n\t\t\t\t\tthis._markInsert( operation.targetPosition.parent, operation.getMovedRangeStart().offset, operation.howMany );\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'rename': {\n\t\t\t\tif ( this._isInInsertedElement( operation.position.parent ) ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis._markRemove( operation.position.parent, operation.position.offset, 1 );\n\t\t\t\tthis._markInsert( operation.position.parent, operation.position.offset, 1 );\n\n\t\t\t\tconst range = Range._createFromPositionAndShift( operation.position, 1 );\n\n\t\t\t\tfor ( const marker of this._markerCollection.getMarkersIntersectingRange( range ) ) {\n\t\t\t\t\tconst markerRange = marker.getRange();\n\n\t\t\t\t\tthis.bufferMarkerChange( marker.name, markerRange, markerRange, marker.affectsData );\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'split': {\n\t\t\t\tconst splitElement = operation.splitPosition.parent;\n\n\t\t\t\t// Mark that children of the split element were removed.\n\t\t\t\tif ( !this._isInInsertedElement( splitElement ) ) {\n\t\t\t\t\tthis._markRemove( splitElement, operation.splitPosition.offset, operation.howMany );\n\t\t\t\t}\n\n\t\t\t\t// Mark that the new element (split copy) was inserted.\n\t\t\t\tif ( !this._isInInsertedElement( operation.insertionPosition.parent ) ) {\n\t\t\t\t\tthis._markInsert( operation.insertionPosition.parent, operation.insertionPosition.offset, 1 );\n\t\t\t\t}\n\n\t\t\t\t// If the split took the element from the graveyard, mark that the element from the graveyard was removed.\n\t\t\t\tif ( operation.graveyardPosition ) {\n\t\t\t\t\tthis._markRemove( operation.graveyardPosition.parent, operation.graveyardPosition.offset, 1 );\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'merge': {\n\t\t\t\t// Mark that the merged element was removed.\n\t\t\t\tconst mergedElement = operation.sourcePosition.parent;\n\n\t\t\t\tif ( !this._isInInsertedElement( mergedElement.parent ) ) {\n\t\t\t\t\tthis._markRemove( mergedElement.parent, mergedElement.startOffset, 1 );\n\t\t\t\t}\n\n\t\t\t\t// Mark that the merged element was inserted into graveyard.\n\t\t\t\tconst graveyardParent = operation.graveyardPosition.parent;\n\n\t\t\t\tthis._markInsert( graveyardParent, operation.graveyardPosition.offset, 1 );\n\n\t\t\t\t// Mark that children of merged element were inserted at new parent.\n\t\t\t\tconst mergedIntoElement = operation.targetPosition.parent;\n\n\t\t\t\tif ( !this._isInInsertedElement( mergedIntoElement ) ) {\n\t\t\t\t\tthis._markInsert( mergedIntoElement, operation.targetPosition.offset, mergedElement.maxOffset );\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Clear cache after each buffered operation as it is no longer valid.\n\t\tthis._cachedChanges = null;\n\t}\n\n\t/**\n\t * Buffers a marker change.\n\t *\n\t * @param {String} markerName The name of the marker that changed.\n\t * @param {module:engine/model/range~Range|null} oldRange Marker range before the change or `null` if the marker has just\n\t * been created.\n\t * @param {module:engine/model/range~Range|null} newRange Marker range after the change or `null` if the marker was removed.\n\t * @param {Boolean} affectsData Flag indicating whether marker affects the editor data.\n\t */\n\tbufferMarkerChange( markerName, oldRange, newRange, affectsData ) {\n\t\tconst buffered = this._changedMarkers.get( markerName );\n\n\t\tif ( !buffered ) {\n\t\t\tthis._changedMarkers.set( markerName, {\n\t\t\t\toldRange,\n\t\t\t\tnewRange,\n\t\t\t\taffectsData\n\t\t\t} );\n\t\t} else {\n\t\t\tbuffered.newRange = newRange;\n\t\t\tbuffered.affectsData = affectsData;\n\n\t\t\tif ( buffered.oldRange == null && buffered.newRange == null ) {\n\t\t\t\t// The marker is going to be removed (`newRange == null`) but it did not exist before the first buffered change\n\t\t\t\t// (`buffered.oldRange == null`). In this case, do not keep the marker in buffer at all.\n\t\t\t\tthis._changedMarkers.delete( markerName );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Returns all markers that should be removed as a result of buffered changes.\n\t *\n\t * @returns {Array.<Object>} Markers to remove. Each array item is an object containing the `name` and `range` properties.\n\t */\n\tgetMarkersToRemove() {\n\t\tconst result = [];\n\n\t\tfor ( const [ name, change ] of this._changedMarkers ) {\n\t\t\tif ( change.oldRange != null ) {\n\t\t\t\tresult.push( { name, range: change.oldRange } );\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Returns all markers which should be added as a result of buffered changes.\n\t *\n\t * @returns {Array.<Object>} Markers to add. Each array item is an object containing the `name` and `range` properties.\n\t */\n\tgetMarkersToAdd() {\n\t\tconst result = [];\n\n\t\tfor ( const [ name, change ] of this._changedMarkers ) {\n\t\t\tif ( change.newRange != null ) {\n\t\t\t\tresult.push( { name, range: change.newRange } );\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Returns all markers which changed.\n\t *\n\t * @returns {Array.<Object>}\n\t */\n\tgetChangedMarkers() {\n\t\treturn Array.from( this._changedMarkers ).map( item => (\n\t\t\t{\n\t\t\t\tname: item[ 0 ],\n\t\t\t\tdata: {\n\t\t\t\t\toldRange: item[ 1 ].oldRange,\n\t\t\t\t\tnewRange: item[ 1 ].newRange\n\t\t\t\t}\n\t\t\t}\n\t\t) );\n\t}\n\n\t/**\n\t * Checks whether some of the buffered changes affect the editor data.\n\t *\n\t * Types of changes which affect the editor data:\n\t *\n\t * * model structure changes,\n\t * * attribute changes,\n\t * * changes of markers which were defined as `affectingData`.\n\t *\n\t * @returns {Boolean}\n\t */\n\thasDataChanges() {\n\t\tfor ( const [ , change ] of this._changedMarkers ) {\n\t\t\tif ( change.affectsData ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t// If markers do not affect the data, check whether there are some changes in elements.\n\t\treturn this._changesInElement.size > 0;\n\t}\n\n\t/**\n\t * Calculates the diff between the old model tree state (the state before the first buffered operations since the last {@link #reset}\n\t * call) and the new model tree state (actual one). It should be called after all buffered operations are executed.\n\t *\n\t * The diff set is returned as an array of diff items, each describing a change done on the model. The items are sorted by\n\t * the position on which the change happened. If a position {@link module:engine/model/position~Position#isBefore is before}\n\t * another one, it will be on an earlier index in the diff set.\n\t *\n\t * Because calculating the diff is a costly operation, the result is cached. If no new operation was buffered since the\n\t * previous {@link #getChanges} call, the next call will return the cached value.\n\t *\n\t * @param {Object} options Additional options.\n\t * @param {Boolean} [options.includeChangesInGraveyard=false] If set to `true`, also changes that happened\n\t * in the graveyard root will be returned. By default, changes in the graveyard root are not returned.\n\t * @returns {Array.<Object>} Diff between the old and the new model tree state.\n\t */\n\tgetChanges( options = { includeChangesInGraveyard: false } ) {\n\t\t// If there are cached changes, just return them instead of calculating changes again.\n\t\tif ( this._cachedChanges ) {\n\t\t\tif ( options.includeChangesInGraveyard ) {\n\t\t\t\treturn this._cachedChangesWithGraveyard.slice();\n\t\t\t} else {\n\t\t\t\treturn this._cachedChanges.slice();\n\t\t\t}\n\t\t}\n\n\t\t// Will contain returned results.\n\t\tconst diffSet = [];\n\n\t\t// Check all changed elements.\n\t\tfor ( const element of this._changesInElement.keys() ) {\n\t\t\t// Get changes for this element and sort them.\n\t\t\tconst changes = this._changesInElement.get( element ).sort( ( a, b ) => {\n\t\t\t\tif ( a.offset === b.offset ) {\n\t\t\t\t\tif ( a.type != b.type ) {\n\t\t\t\t\t\t// If there are multiple changes at the same position, \"remove\" change should be first.\n\t\t\t\t\t\t// If the order is different, for example, we would first add some nodes and then removed them\n\t\t\t\t\t\t// (instead of the nodes that we should remove).\n\t\t\t\t\t\treturn a.type == 'remove' ? -1 : 1;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\treturn a.offset < b.offset ? -1 : 1;\n\t\t\t} );\n\n\t\t\t// Get children of this element before any change was applied on it.\n\t\t\tconst snapshotChildren = this._elementSnapshots.get( element );\n\t\t\t// Get snapshot of current element's children.\n\t\t\tconst elementChildren = _getChildrenSnapshot( element.getChildren() );\n\n\t\t\t// Generate actions basing on changes done on element.\n\t\t\tconst actions = _generateActionsFromChanges( snapshotChildren.length, changes );\n\n\t\t\tlet i = 0; // Iterator in `elementChildren` array -- iterates through current children of element.\n\t\t\tlet j = 0; // Iterator in `snapshotChildren` array -- iterates through old children of element.\n\n\t\t\t// Process every action.\n\t\t\tfor ( const action of actions ) {\n\t\t\t\tif ( action === 'i' ) {\n\t\t\t\t\t// Generate diff item for this element and insert it into the diff set.\n\t\t\t\t\tdiffSet.push( this._getInsertDiff( element, i, elementChildren[ i ].name ) );\n\n\t\t\t\t\ti++;\n\t\t\t\t} else if ( action === 'r' ) {\n\t\t\t\t\t// Generate diff item for this element and insert it into the diff set.\n\t\t\t\t\tdiffSet.push( this._getRemoveDiff( element, i, snapshotChildren[ j ].name ) );\n\n\t\t\t\t\tj++;\n\t\t\t\t} else if ( action === 'a' ) {\n\t\t\t\t\t// Take attributes from saved and current children.\n\t\t\t\t\tconst elementAttributes = elementChildren[ i ].attributes;\n\t\t\t\t\tconst snapshotAttributes = snapshotChildren[ j ].attributes;\n\t\t\t\t\tlet range;\n\n\t\t\t\t\tif ( elementChildren[ i ].name == '$text' ) {\n\t\t\t\t\t\trange = new Range( Position._createAt( element, i ), Position._createAt( element, i + 1 ) );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst index = element.offsetToIndex( i );\n\t\t\t\t\t\trange = new Range( Position._createAt( element, i ), Position._createAt( element.getChild( index ), 0 ) );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Generate diff items for this change (there might be multiple attributes changed and\n\t\t\t\t\t// there is a single diff for each of them) and insert them into the diff set.\n\t\t\t\t\tdiffSet.push( ...this._getAttributesDiff( range, snapshotAttributes, elementAttributes ) );\n\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t} else {\n\t\t\t\t\t// `action` is 'equal'. Child not changed.\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Then, sort the changes by the position (change at position before other changes is first).\n\t\tdiffSet.sort( ( a, b ) => {\n\t\t\t// If the change is in different root, we don't care much, but we'd like to have all changes in given\n\t\t\t// root \"together\" in the array. So let's just sort them by the root name. It does not matter which root\n\t\t\t// will be processed first.\n\t\t\tif ( a.position.root != b.position.root ) {\n\t\t\t\treturn a.position.root.rootName < b.position.root.rootName ? -1 : 1;\n\t\t\t}\n\n\t\t\t// If change happens at the same position...\n\t\t\tif ( a.position.isEqual( b.position ) ) {\n\t\t\t\t// Keep chronological order of operations.\n\t\t\t\treturn a.changeCount - b.changeCount;\n\t\t\t}\n\n\t\t\t// If positions differ, position \"on the left\" should be earlier in the result.\n\t\t\treturn a.position.isBefore( b.position ) ? -1 : 1;\n\t\t} );\n\n\t\t// Glue together multiple changes (mostly on text nodes).\n\t\tfor ( let i = 1; i < diffSet.length; i++ ) {\n\t\t\tconst prevDiff = diffSet[ i - 1 ];\n\t\t\tconst thisDiff = diffSet[ i ];\n\n\t\t\t// Glue remove changes if they happen on text on same position.\n\t\t\tconst isConsecutiveTextRemove =\n\t\t\t\tprevDiff.type == 'remove' && thisDiff.type == 'remove' &&\n\t\t\t\tprevDiff.name == '$text' && thisDiff.name == '$text' &&\n\t\t\t\tprevDiff.position.isEqual( thisDiff.position );\n\n\t\t\t// Glue insert changes if they happen on text on consecutive fragments.\n\t\t\tconst isConsecutiveTextAdd =\n\t\t\t\tprevDiff.type == 'insert' && thisDiff.type == 'insert' &&\n\t\t\t\tprevDiff.name == '$text' && thisDiff.name == '$text' &&\n\t\t\t\tprevDiff.position.parent == thisDiff.position.parent &&\n\t\t\t\tprevDiff.position.offset + prevDiff.length == thisDiff.position.offset;\n\n\t\t\t// Glue attribute changes if they happen on consecutive fragments and have same key, old value and new value.\n\t\t\tconst isConsecutiveAttributeChange =\n\t\t\t\tprevDiff.type == 'attribute' && thisDiff.type == 'attribute' &&\n\t\t\t\tprevDiff.position.parent == thisDiff.position.parent &&\n\t\t\t\tprevDiff.range.isFlat && thisDiff.range.isFlat &&\n\t\t\t\tprevDiff.position.offset + prevDiff.length == thisDiff.position.offset &&\n\t\t\t\tprevDiff.attributeKey == thisDiff.attributeKey &&\n\t\t\t\tprevDiff.attributeOldValue == thisDiff.attributeOldValue &&\n\t\t\t\tprevDiff.attributeNewValue == thisDiff.attributeNewValue;\n\n\t\t\tif ( isConsecutiveTextRemove || isConsecutiveTextAdd || isConsecutiveAttributeChange ) {\n\t\t\t\tdiffSet[ i - 1 ].length++;\n\n\t\t\t\tif ( isConsecutiveAttributeChange ) {\n\t\t\t\t\tdiffSet[ i - 1 ].range.end = diffSet[ i - 1 ].range.end.getShiftedBy( 1 );\n\t\t\t\t}\n\n\t\t\t\tdiffSet.splice( i, 1 );\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\n\t\t// Remove `changeCount` property from diff items. It is used only for sorting and is internal thing.\n\t\tfor ( const item of diffSet ) {\n\t\t\tdelete item.changeCount;\n\n\t\t\tif ( item.type == 'attribute' ) {\n\t\t\t\tdelete item.position;\n\t\t\t\tdelete item.length;\n\t\t\t}\n\t\t}\n\n\t\tthis._changeCount = 0;\n\n\t\t// Cache changes.\n\t\tthis._cachedChangesWithGraveyard = diffSet.slice();\n\t\tthis._cachedChanges = diffSet.slice().filter( _changesInGraveyardFilter );\n\n\t\tif ( options.includeChangesInGraveyard ) {\n\t\t\treturn this._cachedChangesWithGraveyard;\n\t\t} else {\n\t\t\treturn this._cachedChanges;\n\t\t}\n\t}\n\n\t/**\n\t * Resets `Differ`. Removes all buffered changes.\n\t */\n\treset() {\n\t\tthis._changesInElement.clear();\n\t\tthis._elementSnapshots.clear();\n\t\tthis._changedMarkers.clear();\n\t\tthis._cachedChanges = null;\n\t}\n\n\t/**\n\t * Saves and handles an insert change.\n\t *\n\t * @private\n\t * @param {module:engine/model/element~Element} parent\n\t * @param {Number} offset\n\t * @param {Number} howMany\n\t */\n\t_markInsert( parent, offset, howMany ) {\n\t\tconst changeItem = { type: 'insert', offset, howMany, count: this._changeCount++ };\n\n\t\tthis._markChange( parent, changeItem );\n\t}\n\n\t/**\n\t * Saves and handles a remove change.\n\t *\n\t * @private\n\t * @param {module:engine/model/element~Element} parent\n\t * @param {Number} offset\n\t * @param {Number} howMany\n\t */\n\t_markRemove( parent, offset, howMany ) {\n\t\tconst changeItem = { type: 'remove', offset, howMany, count: this._changeCount++ };\n\n\t\tthis._markChange( parent, changeItem );\n\n\t\tthis._removeAllNestedChanges( parent, offset, howMany );\n\t}\n\n\t/**\n\t * Saves and handles an attribute change.\n\t *\n\t * @private\n\t * @param {module:engine/model/item~Item} item\n\t */\n\t_markAttribute( item ) {\n\t\tconst changeItem = { type: 'attribute', offset: item.startOffset, howMany: item.offsetSize, count: this._changeCount++ };\n\n\t\tthis._markChange( item.parent, changeItem );\n\t}\n\n\t/**\n\t * Saves and handles a model change.\n\t *\n\t * @private\n\t * @param {module:engine/model/element~Element} parent\n\t * @param {Object} changeItem\n\t */\n\t_markChange( parent, changeItem ) {\n\t\t// First, make a snapshot of this parent's children (it will be made only if it was not made before).\n\t\tthis._makeSnapshot( parent );\n\n\t\t// Then, get all changes that already were done on the element (empty array if this is the first change).\n\t\tconst changes = this._getChangesForElement( parent );\n\n\t\t// Then, look through all the changes, and transform them or the new change.\n\t\tthis._handleChange( changeItem, changes );\n\n\t\t// Add the new change.\n\t\tchanges.push( changeItem );\n\n\t\t// Remove incorrect changes. During transformation some change might be, for example, included in another.\n\t\t// In that case, the change will have `howMany` property set to `0` or less. We need to remove those changes.\n\t\tfor ( let i = 0; i < changes.length; i++ ) {\n\t\t\tif ( changes[ i ].howMany < 1 ) {\n\t\t\t\tchanges.splice( i, 1 );\n\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Gets an array of changes that have already been saved for a given element.\n\t *\n\t * @private\n\t * @param {module:engine/model/element~Element} element\n\t * @returns {Array.<Object>}\n\t */\n\t_getChangesForElement( element ) {\n\t\tlet changes;\n\n\t\tif ( this._changesInElement.has( element ) ) {\n\t\t\tchanges = this._changesInElement.get( element );\n\t\t} else {\n\t\t\tchanges = [];\n\n\t\t\tthis._changesInElement.set( element, changes );\n\t\t}\n\n\t\treturn changes;\n\t}\n\n\t/**\n\t * Saves a children snapshot for a given element.\n\t *\n\t * @private\n\t * @param {module:engine/model/element~Element} element\n\t */\n\t_makeSnapshot( element ) {\n\t\tif ( !this._elementSnapshots.has( element ) ) {\n\t\t\tthis._elementSnapshots.set( element, _getChildrenSnapshot( element.getChildren() ) );\n\t\t}\n\t}\n\n\t/**\n\t * For a given newly saved change, compares it with a change already done on the element and modifies the incoming\n\t * change and/or the old change.\n\t *\n\t * @private\n\t * @param {Object} inc Incoming (new) change.\n\t * @param {Array.<Object>} changes An array containing all the changes done on that element.\n\t */\n\t_handleChange( inc, changes ) {\n\t\t// We need a helper variable that will store how many nodes are to be still handled for this change item.\n\t\t// `nodesToHandle` (how many nodes still need to be handled) and `howMany` (how many nodes were affected)\n\t\t// needs to be differentiated.\n\t\t//\n\t\t// This comes up when there are multiple changes that are affected by `inc` change item.\n\t\t//\n\t\t// For example: assume two insert changes: `{ offset: 2, howMany: 1 }` and `{ offset: 5, howMany: 1 }`.\n\t\t// Assume that `inc` change is remove `{ offset: 2, howMany: 2, nodesToHandle: 2 }`.\n\t\t//\n\t\t// Then, we:\n\t\t// - \"forget\" about first insert change (it is \"eaten\" by remove),\n\t\t// - because of that, at the end we will want to remove only one node (`nodesToHandle = 1`),\n\t\t// - but still we have to change offset of the second insert change from `5` to `3`!\n\t\t//\n\t\t// So, `howMany` does not change throughout items transformation and keeps information about how many nodes were affected,\n\t\t// while `nodesToHandle` means how many nodes need to be handled after the change item is transformed by other changes.\n\t\tinc.nodesToHandle = inc.howMany;\n\n\t\tfor ( const old of changes ) {\n\t\t\tconst incEnd = inc.offset + inc.howMany;\n\t\t\tconst oldEnd = old.offset + old.howMany;\n\n\t\t\tif ( inc.type == 'insert' ) {\n\t\t\t\tif ( old.type == 'insert' ) {\n\t\t\t\t\tif ( inc.offset <= old.offset ) {\n\t\t\t\t\t\told.offset += inc.howMany;\n\t\t\t\t\t} else if ( inc.offset < oldEnd ) {\n\t\t\t\t\t\told.howMany += inc.nodesToHandle;\n\t\t\t\t\t\tinc.nodesToHandle = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( old.type == 'remove' ) {\n\t\t\t\t\tif ( inc.offset < old.offset ) {\n\t\t\t\t\t\told.offset += inc.howMany;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( old.type == 'attribute' ) {\n\t\t\t\t\tif ( inc.offset <= old.offset ) {\n\t\t\t\t\t\told.offset += inc.howMany;\n\t\t\t\t\t} else if ( inc.offset < oldEnd ) {\n\t\t\t\t\t\t// This case is more complicated, because attribute change has to be split into two.\n\t\t\t\t\t\t// Example (assume that uppercase and lowercase letters mean different attributes):\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// initial state:\t\tabcxyz\n\t\t\t\t\t\t// attribute change:\taBCXYz\n\t\t\t\t\t\t// incoming insert:\t\taBCfooXYz\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// Change ranges cannot intersect because each item has to be described exactly (it was either\n\t\t\t\t\t\t// not changed, inserted, removed, or its attribute was changed). That's why old attribute\n\t\t\t\t\t\t// change has to be split and both parts has to be handled separately from now on.\n\t\t\t\t\t\tconst howMany = old.howMany;\n\n\t\t\t\t\t\told.howMany = inc.offset - old.offset;\n\n\t\t\t\t\t\t// Add the second part of attribute change to the beginning of processed array so it won't\n\t\t\t\t\t\t// be processed again in this loop.\n\t\t\t\t\t\tchanges.unshift( {\n\t\t\t\t\t\t\ttype: 'attribute',\n\t\t\t\t\t\t\toffset: incEnd,\n\t\t\t\t\t\t\thowMany: howMany - old.howMany,\n\t\t\t\t\t\t\tcount: this._changeCount++\n\t\t\t\t\t\t} );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( inc.type == 'remove' ) {\n\t\t\t\tif ( old.type == 'insert' ) {\n\t\t\t\t\tif ( incEnd <= old.offset ) {\n\t\t\t\t\t\told.offset -= inc.howMany;\n\t\t\t\t\t} else if ( incEnd <= oldEnd ) {\n\t\t\t\t\t\tif ( inc.offset < old.offset ) {\n\t\t\t\t\t\t\tconst intersectionLength = incEnd - old.offset;\n\n\t\t\t\t\t\t\told.offset = inc.offset;\n\n\t\t\t\t\t\t\told.howMany -= intersectionLength;\n\t\t\t\t\t\t\tinc.nodesToHandle -= intersectionLength;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\told.howMany -= inc.nodesToHandle;\n\t\t\t\t\t\t\tinc.nodesToHandle = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif ( inc.offset <= old.offset ) {\n\t\t\t\t\t\t\tinc.nodesToHandle -= old.howMany;\n\t\t\t\t\t\t\told.howMany = 0;\n\t\t\t\t\t\t} else if ( inc.offset < oldEnd ) {\n\t\t\t\t\t\t\tconst intersectionLength = oldEnd - inc.offset;\n\n\t\t\t\t\t\t\told.howMany -= intersectionLength;\n\t\t\t\t\t\t\tinc.nodesToHandle -= intersectionLength;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( old.type == 'remove' ) {\n\t\t\t\t\tif ( incEnd <= old.offset ) {\n\t\t\t\t\t\told.offset -= inc.howMany;\n\t\t\t\t\t} else if ( inc.offset < old.offset ) {\n\t\t\t\t\t\tinc.nodesToHandle += old.howMany;\n\t\t\t\t\t\told.howMany = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( old.type == 'attribute' ) {\n\t\t\t\t\tif ( incEnd <= old.offset ) {\n\t\t\t\t\t\told.offset -= inc.howMany;\n\t\t\t\t\t} else if ( inc.offset < old.offset ) {\n\t\t\t\t\t\tconst intersectionLength = incEnd - old.offset;\n\n\t\t\t\t\t\told.offset = inc.offset;\n\t\t\t\t\t\told.howMany -= intersectionLength;\n\t\t\t\t\t} else if ( inc.offset < oldEnd ) {\n\t\t\t\t\t\tif ( incEnd <= oldEnd ) {\n\t\t\t\t\t\t\t// On first sight in this case we don't need to split attribute operation into two.\n\t\t\t\t\t\t\t// However the changes set is later converted to actions (see `_generateActionsFromChanges`).\n\t\t\t\t\t\t\t// For that reason, no two changes may intersect.\n\t\t\t\t\t\t\t// So we cannot have an attribute change that \"contains\" remove change.\n\t\t\t\t\t\t\t// Attribute change needs to be split.\n\t\t\t\t\t\t\tconst howMany = old.howMany;\n\n\t\t\t\t\t\t\told.howMany = inc.offset - old.offset;\n\n\t\t\t\t\t\t\tconst howManyAfter = howMany - old.howMany - inc.nodesToHandle;\n\n\t\t\t\t\t\t\t// Add the second part of attribute change to the beginning of processed array so it won't\n\t\t\t\t\t\t\t// be processed again in this loop.\n\t\t\t\t\t\t\tchanges.unshift( {\n\t\t\t\t\t\t\t\ttype: 'attribute',\n\t\t\t\t\t\t\t\toffset: inc.offset,\n\t\t\t\t\t\t\t\thowMany: howManyAfter,\n\t\t\t\t\t\t\t\tcount: this._changeCount++\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\told.howMany -= oldEnd - inc.offset;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( inc.type == 'attribute' ) {\n\t\t\t\t// In case of attribute change, `howMany` should be kept same as `nodesToHandle`. It's not an error.\n\t\t\t\tif ( old.type == 'insert' ) {\n\t\t\t\t\tif ( inc.offset < old.offset && incEnd > old.offset ) {\n\t\t\t\t\t\tif ( incEnd > oldEnd ) {\n\t\t\t\t\t\t\t// This case is similar to a case described when incoming change was insert and old change was attribute.\n\t\t\t\t\t\t\t// See comment above.\n\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t// This time incoming change is attribute. We need to split incoming change in this case too.\n\t\t\t\t\t\t\t// However this time, the second part of the attribute change needs to be processed further\n\t\t\t\t\t\t\t// because there might be other changes that it collides with.\n\t\t\t\t\t\t\tconst attributePart = {\n\t\t\t\t\t\t\t\ttype: 'attribute',\n\t\t\t\t\t\t\t\toffset: oldEnd,\n\t\t\t\t\t\t\t\thowMany: incEnd - oldEnd,\n\t\t\t\t\t\t\t\tcount: this._changeCount++\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tthis._handleChange( attributePart, changes );\n\n\t\t\t\t\t\t\tchanges.push( attributePart );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tinc.nodesToHandle = old.offset - inc.offset;\n\t\t\t\t\t\tinc.howMany = inc.nodesToHandle;\n\t\t\t\t\t} else if ( inc.offset >= old.offset && inc.offset < oldEnd ) {\n\t\t\t\t\t\tif ( incEnd > oldEnd ) {\n\t\t\t\t\t\t\tinc.nodesToHandle = incEnd - oldEnd;\n\t\t\t\t\t\t\tinc.offset = oldEnd;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tinc.nodesToHandle = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( old.type == 'remove' ) {\n\t\t\t\t\t// This is a case when attribute change \"contains\" remove change.\n\t\t\t\t\t// The attribute change needs to be split into two because changes cannot intersect.\n\t\t\t\t\tif ( inc.offset < old.offset && incEnd > old.offset ) {\n\t\t\t\t\t\tconst attributePart = {\n\t\t\t\t\t\t\ttype: 'attribute',\n\t\t\t\t\t\t\toffset: old.offset,\n\t\t\t\t\t\t\thowMany: incEnd - old.offset,\n\t\t\t\t\t\t\tcount: this._changeCount++\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tthis._handleChange( attributePart, changes );\n\n\t\t\t\t\t\tchanges.push( attributePart );\n\n\t\t\t\t\t\tinc.nodesToHandle = old.offset - inc.offset;\n\t\t\t\t\t\tinc.howMany = inc.nodesToHandle;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( old.type == 'attribute' ) {\n\t\t\t\t\t// There are only two conflicting scenarios possible here:\n\t\t\t\t\tif ( inc.offset >= old.offset && incEnd <= oldEnd ) {\n\t\t\t\t\t\t// `old` change includes `inc` change, or they are the same.\n\t\t\t\t\t\tinc.nodesToHandle = 0;\n\t\t\t\t\t\tinc.howMany = 0;\n\t\t\t\t\t\tinc.offset = 0;\n\t\t\t\t\t} else if ( inc.offset <= old.offset && incEnd >= oldEnd ) {\n\t\t\t\t\t\t// `inc` change includes `old` change.\n\t\t\t\t\t\told.howMany = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tinc.howMany = inc.nodesToHandle;\n\t\tdelete inc.nodesToHandle;\n\t}\n\n\t/**\n\t * Returns an object with a single insert change description.\n\t *\n\t * @private\n\t * @param {module:engine/model/element~Element} parent The element in which the change happened.\n\t * @param {Number} offset The offset at which change happened.\n\t * @param {String} name The name of the removed element or `'$text'` for a character.\n\t * @returns {Object} The diff item.\n\t */\n\t_getInsertDiff( parent, offset, name ) {\n\t\treturn {\n\t\t\ttype: 'insert',\n\t\t\tposition: Position._createAt( parent, offset ),\n\t\t\tname,\n\t\t\tlength: 1,\n\t\t\tchangeCount: this._changeCount++\n\t\t};\n\t}\n\n\t/**\n\t * Returns an object with a single remove change description.\n\t *\n\t * @private\n\t * @param {module:engine/model/element~Element} parent The element in which change happened.\n\t * @param {Number} offset The offset at which change happened.\n\t * @param {String} name The name of the removed element or `'$text'` for a character.\n\t * @returns {Object} The diff item.\n\t */\n\t_getRemoveDiff( parent, offset, name ) {\n\t\treturn {\n\t\t\ttype: 'remove',\n\t\t\tposition: Position._createAt( parent, offset ),\n\t\t\tname,\n\t\t\tlength: 1,\n\t\t\tchangeCount: this._changeCount++\n\t\t};\n\t}\n\n\t/**\n\t * Returns an array of objects where each one is a single attribute change description.\n\t *\n\t * @private\n\t * @param {module:engine/model/range~Range} range The range where the change happened.\n\t * @param {Map} oldAttributes A map, map iterator or compatible object that contains attributes before the change.\n\t * @param {Map} newAttributes A map, map iterator or compatible object that contains attributes after the change.\n\t * @returns {Array.<Object>} An array containing one or more diff items.\n\t */\n\t_getAttributesDiff( range, oldAttributes, newAttributes ) {\n\t\t// Results holder.\n\t\tconst diffs = [];\n\n\t\t// Clone new attributes as we will be performing changes on this object.\n\t\tnewAttributes = new Map( newAttributes );\n\n\t\t// Look through old attributes.\n\t\tfor ( const [ key, oldValue ] of oldAttributes ) {\n\t\t\t// Check what is the new value of the attribute (or if it was removed).\n\t\t\tconst newValue = newAttributes.has( key ) ? newAttributes.get( key ) : null;\n\n\t\t\t// If values are different (or attribute was removed)...\n\t\t\tif ( newValue !== oldValue ) {\n\t\t\t\t// Add diff item.\n\t\t\t\tdiffs.push( {\n\t\t\t\t\ttype: 'attribute',\n\t\t\t\t\tposition: range.start,\n\t\t\t\t\trange: range.clone(),\n\t\t\t\t\tlength: 1,\n\t\t\t\t\tattributeKey: key,\n\t\t\t\t\tattributeOldValue: oldValue,\n\t\t\t\t\tattributeNewValue: newValue,\n\t\t\t\t\tchangeCount: this._changeCount++\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\t// Prevent returning two diff items for the same change.\n\t\t\tnewAttributes.delete( key );\n\t\t}\n\n\t\t// Look through new attributes that weren't handled above.\n\t\tfor ( const [ key, newValue ] of newAttributes ) {\n\t\t\t// Each of them is a new attribute. Add diff item.\n\t\t\tdiffs.push( {\n\t\t\t\ttype: 'attribute',\n\t\t\t\tposition: range.start,\n\t\t\t\trange: range.clone(),\n\t\t\t\tlength: 1,\n\t\t\t\tattributeKey: key,\n\t\t\t\tattributeOldValue: null,\n\t\t\t\tattributeNewValue: newValue,\n\t\t\t\tchangeCount: this._changeCount++\n\t\t\t} );\n\t\t}\n\n\t\treturn diffs;\n\t}\n\n\t/**\n\t * Checks whether given element or any of its parents is an element that is buffered as an inserted element.\n\t *\n\t * @private\n\t * @param {module:engine/model/element~Element} element Element to check.\n\t * @returns {Boolean}\n\t */\n\t_isInInsertedElement( element ) {\n\t\tconst parent = element.parent;\n\n\t\tif ( !parent ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst changes = this._changesInElement.get( parent );\n\t\tconst offset = element.startOffset;\n\n\t\tif ( changes ) {\n\t\t\tfor ( const change of changes ) {\n\t\t\t\tif ( change.type == 'insert' && offset >= change.offset && offset < change.offset + change.howMany ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this._isInInsertedElement( parent );\n\t}\n\n\t/**\n\t * Removes deeply all buffered changes that are registered in elements from range specified by `parent`, `offset`\n\t * and `howMany`.\n\t *\n\t * @private\n\t * @param {module:engine/model/element~Element} parent\n\t * @param {Number} offset\n\t * @param {Number} howMany\n\t */\n\t_removeAllNestedChanges( parent, offset, howMany ) {\n\t\tconst range = new Range( Position._createAt( parent, offset ), Position._createAt( parent, offset + howMany ) );\n\n\t\tfor ( const item of range.getItems( { shallow: true } ) ) {\n\t\t\tif ( item.is( 'element' ) ) {\n\t\t\t\tthis._elementSnapshots.delete( item );\n\t\t\t\tthis._changesInElement.delete( item );\n\n\t\t\t\tthis._removeAllNestedChanges( item, 0, item.maxOffset );\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Returns an array that is a copy of passed child list with the exception that text nodes are split to one or more\n// objects, each representing one character and attributes set on that character.\nfunction _getChildrenSnapshot( children ) {\n\tconst snapshot = [];\n\n\tfor ( const child of children ) {\n\t\tif ( child.is( 'text' ) ) {\n\t\t\tfor ( let i = 0; i < child.data.length; i++ ) {\n\t\t\t\tsnapshot.push( {\n\t\t\t\t\tname: '$text',\n\t\t\t\t\tattributes: new Map( child.getAttributes() )\n\t\t\t\t} );\n\t\t\t}\n\t\t} else {\n\t\t\tsnapshot.push( {\n\t\t\t\tname: child.name,\n\t\t\t\tattributes: new Map( child.getAttributes() )\n\t\t\t} );\n\t\t}\n\t}\n\n\treturn snapshot;\n}\n\n// Generates array of actions for given changes set.\n// It simulates what `diff` function does.\n// Generated actions are:\n// - 'e' for 'equal' - when item at that position did not change,\n// - 'i' for 'insert' - when item at that position was inserted,\n// - 'r' for 'remove' - when item at that position was removed,\n// - 'a' for 'attribute' - when item at that position has it attributes changed.\n//\n// Example (assume that uppercase letters have bold attribute, compare with function code):\n//\n// children before:\tfooBAR\n// children after:\tfoxybAR\n//\n// changes: type: remove, offset: 1, howMany: 1\n//\t\t\ttype: insert, offset: 2, howMany: 2\n//\t\t\ttype: attribute, offset: 4, howMany: 1\n//\n// expected actions: equal (f), remove (o), equal (o), insert (x), insert (y), attribute (b), equal (A), equal (R)\n//\n// steps taken by th script:\n//\n// 1. change = \"type: remove, offset: 1, howMany: 1\"; offset = 0; oldChildrenHandled = 0\n//    1.1 between this change and the beginning is one not-changed node, fill with one equal action, one old child has been handled\n//    1.2 this change removes one node, add one remove action\n//    1.3 change last visited `offset` to 1\n//    1.4 since an old child has been removed, one more old child has been handled\n//    1.5 actions at this point are: equal, remove\n//\n// 2. change = \"type: insert, offset: 2, howMany: 2\"; offset = 1; oldChildrenHandled = 2\n//    2.1 between this change and previous change is one not-changed node, add equal action, another one old children has been handled\n//    2.2 this change inserts two nodes, add two insert actions\n//    2.3 change last visited offset to the end of the inserted range, that is 4\n//    2.4 actions at this point are: equal, remove, equal, insert, insert\n//\n// 3. change = \"type: attribute, offset: 4, howMany: 1\"; offset = 4, oldChildrenHandled = 3\n//    3.1 between this change and previous change are no not-changed nodes\n//    3.2 this change changes one node, add one attribute action\n//    3.3 change last visited `offset` to the end of change range, that is 5\n//    3.4 since an old child has been changed, one more old child has been handled\n//    3.5 actions at this point are: equal, remove, equal, insert, insert, attribute\n//\n// 4. after loop oldChildrenHandled = 4, oldChildrenLength = 6 (fooBAR is 6 characters)\n//    4.1 fill up with two equal actions\n//\n// The result actions are: equal, remove, equal, insert, insert, attribute, equal, equal.\nfunction _generateActionsFromChanges( oldChildrenLength, changes ) {\n\tconst actions = [];\n\n\tlet offset = 0;\n\tlet oldChildrenHandled = 0;\n\n\t// Go through all buffered changes.\n\tfor ( const change of changes ) {\n\t\t// First, fill \"holes\" between changes with \"equal\" actions.\n\t\tif ( change.offset > offset ) {\n\t\t\tfor ( let i = 0; i < change.offset - offset; i++ ) {\n\t\t\t\tactions.push( 'e' );\n\t\t\t}\n\n\t\t\toldChildrenHandled += change.offset - offset;\n\t\t}\n\n\t\t// Then, fill up actions accordingly to change type.\n\t\tif ( change.type == 'insert' ) {\n\t\t\tfor ( let i = 0; i < change.howMany; i++ ) {\n\t\t\t\tactions.push( 'i' );\n\t\t\t}\n\n\t\t\t// The last handled offset is after inserted range.\n\t\t\toffset = change.offset + change.howMany;\n\t\t} else if ( change.type == 'remove' ) {\n\t\t\tfor ( let i = 0; i < change.howMany; i++ ) {\n\t\t\t\tactions.push( 'r' );\n\t\t\t}\n\n\t\t\t// The last handled offset is at the position where the nodes were removed.\n\t\t\toffset = change.offset;\n\t\t\t// We removed `howMany` old nodes, update `oldChildrenHandled`.\n\t\t\toldChildrenHandled += change.howMany;\n\t\t} else {\n\t\t\tactions.push( ...'a'.repeat( change.howMany ).split( '' ) );\n\n\t\t\t// The last handled offset is at the position after the changed range.\n\t\t\toffset = change.offset + change.howMany;\n\t\t\t// We changed `howMany` old nodes, update `oldChildrenHandled`.\n\t\t\toldChildrenHandled += change.howMany;\n\t\t}\n\t}\n\n\t// Fill \"equal\" actions at the end of actions set. Use `oldChildrenHandled` to see how many children\n\t// has not been changed / removed at the end of their parent.\n\tif ( oldChildrenHandled < oldChildrenLength ) {\n\t\tfor ( let i = 0; i < oldChildrenLength - oldChildrenHandled - offset; i++ ) {\n\t\t\tactions.push( 'e' );\n\t\t}\n\t}\n\n\treturn actions;\n}\n\n// Filter callback for Array.filter that filters out change entries that are in graveyard.\nfunction _changesInGraveyardFilter( entry ) {\n\tconst posInGy = entry.position && entry.position.root.rootName == '$graveyard';\n\tconst rangeInGy = entry.range && entry.range.root.rootName == '$graveyard';\n\n\treturn !posInGy && !rangeInGy;\n}\n"]}]}