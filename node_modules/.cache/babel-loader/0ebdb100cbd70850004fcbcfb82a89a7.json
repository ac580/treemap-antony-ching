{"remainingRequest":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/babel-loader/lib/index.js!/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-engine/src/conversion/mapper.js","dependencies":[{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-engine/src/conversion/mapper.js","mtime":499162500000},{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js","mtime":499162500000},{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/babel-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:LyoqCiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDE5LCBDS1NvdXJjZSAtIEZyZWRlcmljbyBLbmFiYmVuLiBBbGwgcmlnaHRzIHJlc2VydmVkLgogKiBGb3IgbGljZW5zaW5nLCBzZWUgTElDRU5TRS5tZCBvciBodHRwczovL2NrZWRpdG9yLmNvbS9sZWdhbC9ja2VkaXRvci1vc3MtbGljZW5zZQogKi8KCi8qKgogKiBAbW9kdWxlIGVuZ2luZS9jb252ZXJzaW9uL21hcHBlcgogKi8KaW1wb3J0IE1vZGVsUG9zaXRpb24gZnJvbSAnLi4vbW9kZWwvcG9zaXRpb24nOwppbXBvcnQgTW9kZWxSYW5nZSBmcm9tICcuLi9tb2RlbC9yYW5nZSc7CmltcG9ydCBWaWV3UG9zaXRpb24gZnJvbSAnLi4vdmlldy9wb3NpdGlvbic7CmltcG9ydCBWaWV3UmFuZ2UgZnJvbSAnLi4vdmlldy9yYW5nZSc7CmltcG9ydCBWaWV3VGV4dCBmcm9tICcuLi92aWV3L3RleHQnOwppbXBvcnQgRW1pdHRlck1peGluIGZyb20gJ0Bja2VkaXRvci9ja2VkaXRvcjUtdXRpbHMvc3JjL2VtaXR0ZXJtaXhpbic7CmltcG9ydCBtaXggZnJvbSAnQGNrZWRpdG9yL2NrZWRpdG9yNS11dGlscy9zcmMvbWl4JzsKLyoqCiAqIE1hcHMgZWxlbWVudHMsIHBvc2l0aW9ucyBhbmQgbWFya2VycyBiZXR3ZWVuIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZG9jdW1lbnR+RG9jdW1lbnQgdGhlIHZpZXd9IGFuZAogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9tb2RlbCB0aGUgbW9kZWx9LgogKgogKiBUaGUgaW5zdGFuY2Ugb2YgdGhlIE1hcHBlciB1c2VkIGZvciB0aGUgZWRpdGluZyBwaXBlbGluZSBpcyBhdmFpbGFibGUgaW4KICoge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udHJvbGxlci9lZGl0aW5nY29udHJvbGxlcn5FZGl0aW5nQ29udHJvbGxlciNtYXBwZXIgYGVkaXRvci5lZGl0aW5nLm1hcHBlcmB9LgogKgogKiBNYXBwZXIgdXNlcyBib3VuZCBlbGVtZW50cyB0byBmaW5kIGNvcnJlc3BvbmRpbmcgZWxlbWVudHMgYW5kIHBvc2l0aW9ucywgc28sIHRvIGdldCBwcm9wZXIgcmVzdWx0cywKICogYWxsIG1vZGVsIGVsZW1lbnRzIHNob3VsZCBiZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL21hcHBlcn5NYXBwZXIjYmluZEVsZW1lbnRzIGJvdW5kfS4KICoKICogVG8gbWFwIGNvbXBsZXggbW9kZWwgdG8vZnJvbSB2aWV3IHJlbGF0aW9ucywgeW91IG1heSBwcm92aWRlIGN1c3RvbSBjYWxsYmFja3MgZm9yCiAqIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vbWFwcGVyfk1hcHBlciNldmVudDptb2RlbFRvVmlld1Bvc2l0aW9uIG1vZGVsVG9WaWV3UG9zaXRpb24gZXZlbnR9IGFuZAogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL21hcHBlcn5NYXBwZXIjZXZlbnQ6dmlld1RvTW9kZWxQb3NpdGlvbiB2aWV3VG9Nb2RlbFBvc2l0aW9uIGV2ZW50fSB0aGF0IGFyZSBmaXJlZCB3aGVuZXZlcgogKiBhIHBvc2l0aW9uIG1hcHBpbmcgcmVxdWVzdCBvY2N1cnMuCiAqIFRob3NlIGV2ZW50cyBhcmUgZmlyZWQgYnkge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi9tYXBwZXJ+TWFwcGVyI3RvVmlld1Bvc2l0aW9uIHRvVmlld1Bvc2l0aW9ufQogKiBhbmQge0BsaW5rIG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi9tYXBwZXJ+TWFwcGVyI3RvTW9kZWxQb3NpdGlvbiB0b01vZGVsUG9zaXRpb259IG1ldGhvZHMuIGBNYXBwZXJgIGFkZHMgaXQncyBvd24gZGVmYXVsdCBjYWxsYmFja3MKICogd2l0aCBgJ2xvd2VzdCdgIHByaW9yaXR5LiBUbyBvdmVycmlkZSBkZWZhdWx0IGBNYXBwZXJgIG1hcHBpbmcsIGFkZCBjdXN0b20gY2FsbGJhY2sgd2l0aCBoaWdoZXIgcHJpb3JpdHkgYW5kCiAqIHN0b3AgdGhlIGV2ZW50LgogKi8KCmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1hcHBlciB7CiAgLyoqCiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGUgbWFwcGVyLgogICAqLwogIGNvbnN0cnVjdG9yKCkgewogICAgLyoqCiAgICAgKiBNb2RlbCBlbGVtZW50IHRvIHZpZXcgZWxlbWVudCBtYXBwaW5nLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAbWVtYmVyIHtXZWFrTWFwfQogICAgICovCiAgICB0aGlzLl9tb2RlbFRvVmlld01hcHBpbmcgPSBuZXcgV2Vha01hcCgpOwogICAgLyoqCiAgICAgKiBWaWV3IGVsZW1lbnQgdG8gbW9kZWwgZWxlbWVudCBtYXBwaW5nLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAbWVtYmVyIHtXZWFrTWFwfQogICAgICovCgogICAgdGhpcy5fdmlld1RvTW9kZWxNYXBwaW5nID0gbmV3IFdlYWtNYXAoKTsKICAgIC8qKgogICAgICogQSBtYXAgY29udGFpbmluZyBjYWxsYmFja3MgYmV0d2VlbiB2aWV3IGVsZW1lbnQgbmFtZXMgYW5kIGZ1bmN0aW9ucyBldmFsdWF0aW5nIGxlbmd0aCBvZiB2aWV3IGVsZW1lbnRzCiAgICAgKiBpbiBtb2RlbC4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQG1lbWJlciB7TWFwfQogICAgICovCgogICAgdGhpcy5fdmlld1RvTW9kZWxMZW5ndGhDYWxsYmFja3MgPSBuZXcgTWFwKCk7CiAgICAvKioKICAgICAqIE1vZGVsIG1hcmtlciBuYW1lIHRvIHZpZXcgZWxlbWVudHMgbWFwcGluZy4KICAgICAqCiAgICAgKiBLZXlzIGFyZSBgU3RyaW5nYHMgd2hpbGUgdmFsdWVzIGFyZSBgU2V0YHMgd2l0aCB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudCB2aWV3IGVsZW1lbnRzfS4KICAgICAqIE9uZSBtYXJrZXIgKG5hbWUpIGNhbiBiZSBtYXBwZWQgdG8gbXVsdGlwbGUgZWxlbWVudHMuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEBtZW1iZXIge01hcH0KICAgICAqLwoKICAgIHRoaXMuX21hcmtlck5hbWVUb0VsZW1lbnRzID0gbmV3IE1hcCgpOwogICAgLyoqCiAgICAgKiBWaWV3IGVsZW1lbnQgdG8gbW9kZWwgbWFya2VyIG5hbWVzIG1hcHBpbmcuCiAgICAgKgogICAgICogVGhpcyBpcyByZXZlcnNlIHRvIHtAbGluayB+TWFwcGVyI19tYXJrZXJOYW1lVG9FbGVtZW50c30gbWFwLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAbWVtYmVyIHtNYXB9CiAgICAgKi8KCiAgICB0aGlzLl9lbGVtZW50VG9NYXJrZXJOYW1lcyA9IG5ldyBNYXAoKTsKICAgIC8qKgogICAgICogU3RvcmVzIG1hcmtlciBuYW1lcyBvZiBtYXJrZXJzIHdoaWNoIGhhcyBjaGFuZ2VkIGR1ZSB0byB1bmJpbmRpbmcgYSB2aWV3IGVsZW1lbnQgKHNvIGl0IGlzIGFzc3VtZWQgdGhhdCB0aGUgdmlldyBlbGVtZW50CiAgICAgKiBoYXMgYmVlbiByZW1vdmVkLCBtb3ZlZCBvciByZW5hbWVkKS4KICAgICAqCiAgICAgKiBAcHJpdmF0ZQogICAgICogQG1lbWJlciB7U2V0Ljxtb2R1bGU6ZW5naW5lL21vZGVsL21hcmtlcmNvbGxlY3Rpb25+TWFya2VyPn0KICAgICAqLwoKICAgIHRoaXMuX3VuYm91bmRNYXJrZXJOYW1lcyA9IG5ldyBTZXQoKTsgLy8gRGVmYXVsdCBtYXBwZXIgYWxnb3JpdGhtIGZvciBtYXBwaW5nIG1vZGVsIHBvc2l0aW9uIHRvIHZpZXcgcG9zaXRpb24uCgogICAgdGhpcy5vbignbW9kZWxUb1ZpZXdQb3NpdGlvbicsIChldnQsIGRhdGEpID0+IHsKICAgICAgaWYgKGRhdGEudmlld1Bvc2l0aW9uKSB7CiAgICAgICAgcmV0dXJuOwogICAgICB9CgogICAgICBjb25zdCB2aWV3Q29udGFpbmVyID0gdGhpcy5fbW9kZWxUb1ZpZXdNYXBwaW5nLmdldChkYXRhLm1vZGVsUG9zaXRpb24ucGFyZW50KTsKCiAgICAgIGRhdGEudmlld1Bvc2l0aW9uID0gdGhpcy5fZmluZFBvc2l0aW9uSW4odmlld0NvbnRhaW5lciwgZGF0YS5tb2RlbFBvc2l0aW9uLm9mZnNldCk7CiAgICB9LCB7CiAgICAgIHByaW9yaXR5OiAnbG93JwogICAgfSk7IC8vIERlZmF1bHQgbWFwcGVyIGFsZ29yaXRobSBmb3IgbWFwcGluZyB2aWV3IHBvc2l0aW9uIHRvIG1vZGVsIHBvc2l0aW9uLgoKICAgIHRoaXMub24oJ3ZpZXdUb01vZGVsUG9zaXRpb24nLCAoZXZ0LCBkYXRhKSA9PiB7CiAgICAgIGlmIChkYXRhLm1vZGVsUG9zaXRpb24pIHsKICAgICAgICByZXR1cm47CiAgICAgIH0KCiAgICAgIGNvbnN0IHZpZXdCbG9jayA9IHRoaXMuZmluZE1hcHBlZFZpZXdBbmNlc3RvcihkYXRhLnZpZXdQb3NpdGlvbik7CgogICAgICBjb25zdCBtb2RlbFBhcmVudCA9IHRoaXMuX3ZpZXdUb01vZGVsTWFwcGluZy5nZXQodmlld0Jsb2NrKTsKCiAgICAgIGNvbnN0IG1vZGVsT2Zmc2V0ID0gdGhpcy5fdG9Nb2RlbE9mZnNldChkYXRhLnZpZXdQb3NpdGlvbi5wYXJlbnQsIGRhdGEudmlld1Bvc2l0aW9uLm9mZnNldCwgdmlld0Jsb2NrKTsKCiAgICAgIGRhdGEubW9kZWxQb3NpdGlvbiA9IE1vZGVsUG9zaXRpb24uX2NyZWF0ZUF0KG1vZGVsUGFyZW50LCBtb2RlbE9mZnNldCk7CiAgICB9LCB7CiAgICAgIHByaW9yaXR5OiAnbG93JwogICAgfSk7CiAgfQogIC8qKgogICAqIE1hcmtzIG1vZGVsIGFuZCB2aWV3IGVsZW1lbnRzIGFzIGNvcnJlc3BvbmRpbmcuIENvcnJlc3BvbmRpbmcgZWxlbWVudHMgY2FuIGJlIHJldHJpZXZlZCBieSB1c2luZwogICAqIHRoZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL21hcHBlcn5NYXBwZXIjdG9Nb2RlbEVsZW1lbnQgdG9Nb2RlbEVsZW1lbnR9IGFuZAogICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vbWFwcGVyfk1hcHBlciN0b1ZpZXdFbGVtZW50IHRvVmlld0VsZW1lbnR9IG1ldGhvZHMuCiAgICogVGhlIGluZm9ybWF0aW9uIHRoYXQgZWxlbWVudHMgYXJlIGJvdW5kIGlzIGFsc28gdXNlZCB0byB0cmFuc2xhdGUgcG9zaXRpb25zLgogICAqCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2VsZW1lbnR+RWxlbWVudH0gbW9kZWxFbGVtZW50IE1vZGVsIGVsZW1lbnQuCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50fSB2aWV3RWxlbWVudCBWaWV3IGVsZW1lbnQuCiAgICovCgoKICBiaW5kRWxlbWVudHMobW9kZWxFbGVtZW50LCB2aWV3RWxlbWVudCkgewogICAgdGhpcy5fbW9kZWxUb1ZpZXdNYXBwaW5nLnNldChtb2RlbEVsZW1lbnQsIHZpZXdFbGVtZW50KTsKCiAgICB0aGlzLl92aWV3VG9Nb2RlbE1hcHBpbmcuc2V0KHZpZXdFbGVtZW50LCBtb2RlbEVsZW1lbnQpOwogIH0KICAvKioKICAgKiBVbmJpbmRzIGdpdmVuIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50IHZpZXcgZWxlbWVudH0gZnJvbSB0aGUgbWFwLgogICAqCiAgICogKipOb3RlOioqIHZpZXctdG8tbW9kZWwgYmluZGluZyB3aWxsIGJlIHJlbW92ZWQsIGlmIGl0IGV4aXN0ZWQuIEhvd2V2ZXIsIGNvcnJlc3BvbmRpbmcgbW9kZWwtdG8tdmlldyBiaW5kaW5nCiAgICogd2lsbCBiZSByZW1vdmVkIG9ubHkgaWYgbW9kZWwgZWxlbWVudCBpcyBzdGlsbCBib3VuZCB0byBwYXNzZWQgYHZpZXdFbGVtZW50YC4KICAgKgogICAqIFRoaXMgYmVoYXZpb3IgbGV0cyBmb3IgcmUtYmluZGluZyBtb2RlbCBlbGVtZW50IHRvIGFub3RoZXIgdmlldyBlbGVtZW50IHdpdGhvdXQgZmVhciBvZiBsb3NpbmcgdGhlIG5ldyBiaW5kaW5nCiAgICogd2hlbiB0aGUgcHJldmlvdXNseSBib3VuZCB2aWV3IGVsZW1lbnQgaXMgdW5ib3VuZC4KICAgKgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudH0gdmlld0VsZW1lbnQgVmlldyBlbGVtZW50IHRvIHVuYmluZC4KICAgKi8KCgogIHVuYmluZFZpZXdFbGVtZW50KHZpZXdFbGVtZW50KSB7CiAgICBjb25zdCBtb2RlbEVsZW1lbnQgPSB0aGlzLnRvTW9kZWxFbGVtZW50KHZpZXdFbGVtZW50KTsKCiAgICB0aGlzLl92aWV3VG9Nb2RlbE1hcHBpbmcuZGVsZXRlKHZpZXdFbGVtZW50KTsKCiAgICBpZiAodGhpcy5fZWxlbWVudFRvTWFya2VyTmFtZXMuaGFzKHZpZXdFbGVtZW50KSkgewogICAgICBmb3IgKGNvbnN0IG1hcmtlck5hbWUgb2YgdGhpcy5fZWxlbWVudFRvTWFya2VyTmFtZXMuZ2V0KHZpZXdFbGVtZW50KSkgewogICAgICAgIHRoaXMuX3VuYm91bmRNYXJrZXJOYW1lcy5hZGQobWFya2VyTmFtZSk7CiAgICAgIH0KICAgIH0KCiAgICBpZiAodGhpcy5fbW9kZWxUb1ZpZXdNYXBwaW5nLmdldChtb2RlbEVsZW1lbnQpID09IHZpZXdFbGVtZW50KSB7CiAgICAgIHRoaXMuX21vZGVsVG9WaWV3TWFwcGluZy5kZWxldGUobW9kZWxFbGVtZW50KTsKICAgIH0KICB9CiAgLyoqCiAgICogVW5iaW5kcyBnaXZlbiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnQgbW9kZWwgZWxlbWVudH0gZnJvbSB0aGUgbWFwLgogICAqCiAgICogKipOb3RlOioqIG1vZGVsLXRvLXZpZXcgYmluZGluZyB3aWxsIGJlIHJlbW92ZWQsIGlmIGl0IGV4aXN0ZWQuIEhvd2V2ZXIsIGNvcnJlc3BvbmRpbmcgdmlldy10by1tb2RlbCBiaW5kaW5nCiAgICogd2lsbCBiZSByZW1vdmVkIG9ubHkgaWYgdmlldyBlbGVtZW50IGlzIHN0aWxsIGJvdW5kIHRvIHBhc3NlZCBgbW9kZWxFbGVtZW50YC4KICAgKgogICAqIFRoaXMgYmVoYXZpb3IgbGV0cyBmb3IgcmUtYmluZGluZyB2aWV3IGVsZW1lbnQgdG8gYW5vdGhlciBtb2RlbCBlbGVtZW50IHdpdGhvdXQgZmVhciBvZiBsb3NpbmcgdGhlIG5ldyBiaW5kaW5nCiAgICogd2hlbiB0aGUgcHJldmlvdXNseSBib3VuZCBtb2RlbCBlbGVtZW50IGlzIHVuYm91bmQuCiAgICoKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50fSBtb2RlbEVsZW1lbnQgTW9kZWwgZWxlbWVudCB0byB1bmJpbmQuCiAgICovCgoKICB1bmJpbmRNb2RlbEVsZW1lbnQobW9kZWxFbGVtZW50KSB7CiAgICBjb25zdCB2aWV3RWxlbWVudCA9IHRoaXMudG9WaWV3RWxlbWVudChtb2RlbEVsZW1lbnQpOwoKICAgIHRoaXMuX21vZGVsVG9WaWV3TWFwcGluZy5kZWxldGUobW9kZWxFbGVtZW50KTsKCiAgICBpZiAodGhpcy5fdmlld1RvTW9kZWxNYXBwaW5nLmdldCh2aWV3RWxlbWVudCkgPT0gbW9kZWxFbGVtZW50KSB7CiAgICAgIHRoaXMuX3ZpZXdUb01vZGVsTWFwcGluZy5kZWxldGUodmlld0VsZW1lbnQpOwogICAgfQogIH0KICAvKioKICAgKiBCaW5kcyBnaXZlbiBtYXJrZXIgbmFtZSB3aXRoIGdpdmVuIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50IHZpZXcgZWxlbWVudH0uIFRoZSBlbGVtZW50CiAgICogd2lsbCBiZSBhZGRlZCB0byB0aGUgY3VycmVudCBzZXQgb2YgZWxlbWVudHMgYm91bmQgd2l0aCBnaXZlbiBtYXJrZXIgbmFtZS4KICAgKgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIGJpbmQuCiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgTWFya2VyIG5hbWUuCiAgICovCgoKICBiaW5kRWxlbWVudFRvTWFya2VyKGVsZW1lbnQsIG5hbWUpIHsKICAgIGNvbnN0IGVsZW1lbnRzID0gdGhpcy5fbWFya2VyTmFtZVRvRWxlbWVudHMuZ2V0KG5hbWUpIHx8IG5ldyBTZXQoKTsKICAgIGVsZW1lbnRzLmFkZChlbGVtZW50KTsKICAgIGNvbnN0IG5hbWVzID0gdGhpcy5fZWxlbWVudFRvTWFya2VyTmFtZXMuZ2V0KGVsZW1lbnQpIHx8IG5ldyBTZXQoKTsKICAgIG5hbWVzLmFkZChuYW1lKTsKCiAgICB0aGlzLl9tYXJrZXJOYW1lVG9FbGVtZW50cy5zZXQobmFtZSwgZWxlbWVudHMpOwoKICAgIHRoaXMuX2VsZW1lbnRUb01hcmtlck5hbWVzLnNldChlbGVtZW50LCBuYW1lcyk7CiAgfQogIC8qKgogICAqIFVuYmluZHMgYW4gZWxlbWVudCBmcm9tIGdpdmVuIG1hcmtlciBuYW1lLgogICAqCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gdW5iaW5kLgogICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIE1hcmtlciBuYW1lLgogICAqLwoKCiAgdW5iaW5kRWxlbWVudEZyb21NYXJrZXJOYW1lKGVsZW1lbnQsIG5hbWUpIHsKICAgIGNvbnN0IG5hbWVUb0VsZW1lbnRzID0gdGhpcy5fbWFya2VyTmFtZVRvRWxlbWVudHMuZ2V0KG5hbWUpOwoKICAgIGlmIChuYW1lVG9FbGVtZW50cykgewogICAgICBuYW1lVG9FbGVtZW50cy5kZWxldGUoZWxlbWVudCk7CgogICAgICBpZiAobmFtZVRvRWxlbWVudHMuc2l6ZSA9PSAwKSB7CiAgICAgICAgdGhpcy5fbWFya2VyTmFtZVRvRWxlbWVudHMuZGVsZXRlKG5hbWUpOwogICAgICB9CiAgICB9CgogICAgY29uc3QgZWxlbWVudFRvTmFtZXMgPSB0aGlzLl9lbGVtZW50VG9NYXJrZXJOYW1lcy5nZXQoZWxlbWVudCk7CgogICAgaWYgKGVsZW1lbnRUb05hbWVzKSB7CiAgICAgIGVsZW1lbnRUb05hbWVzLmRlbGV0ZShuYW1lKTsKCiAgICAgIGlmIChlbGVtZW50VG9OYW1lcy5zaXplID09IDApIHsKICAgICAgICB0aGlzLl9lbGVtZW50VG9NYXJrZXJOYW1lcy5kZWxldGUoZWxlbWVudCk7CiAgICAgIH0KICAgIH0KICB9CiAgLyoqCiAgICogUmV0dXJucyBhbGwgbWFya2VyIG5hbWVzIG9mIG1hcmtlcnMgd2hpY2ggaGFzIGNoYW5nZWQgZHVlIHRvIHVuYmluZGluZyBhIHZpZXcgZWxlbWVudCAoc28gaXQgaXMgYXNzdW1lZCB0aGF0IHRoZSB2aWV3IGVsZW1lbnQKICAgKiBoYXMgYmVlbiByZW1vdmVkLCBtb3ZlZCBvciByZW5hbWVkKSBzaW5jZSB0aGUgbGFzdCBmbHVzaC4gQWZ0ZXIgcmV0dXJuaW5nLCB0aGUgbWFya2VyIG5hbWVzIGxpc3QgaXMgY2xlYXJlZC4KICAgKgogICAqIEByZXR1cm5zIHtBcnJheS48U3RyaW5nPn0KICAgKi8KCgogIGZsdXNoVW5ib3VuZE1hcmtlck5hbWVzKCkgewogICAgY29uc3QgbWFya2VyTmFtZXMgPSBBcnJheS5mcm9tKHRoaXMuX3VuYm91bmRNYXJrZXJOYW1lcyk7CgogICAgdGhpcy5fdW5ib3VuZE1hcmtlck5hbWVzLmNsZWFyKCk7CgogICAgcmV0dXJuIG1hcmtlck5hbWVzOwogIH0KICAvKioKICAgKiBSZW1vdmVzIGFsbCBtb2RlbCB0byB2aWV3IGFuZCB2aWV3IHRvIG1vZGVsIGJpbmRpbmdzLgogICAqLwoKCiAgY2xlYXJCaW5kaW5ncygpIHsKICAgIHRoaXMuX21vZGVsVG9WaWV3TWFwcGluZyA9IG5ldyBXZWFrTWFwKCk7CiAgICB0aGlzLl92aWV3VG9Nb2RlbE1hcHBpbmcgPSBuZXcgV2Vha01hcCgpOwogICAgdGhpcy5fbWFya2VyTmFtZVRvRWxlbWVudHMgPSBuZXcgTWFwKCk7CiAgICB0aGlzLl9lbGVtZW50VG9NYXJrZXJOYW1lcyA9IG5ldyBNYXAoKTsKICAgIHRoaXMuX3VuYm91bmRNYXJrZXJOYW1lcyA9IG5ldyBTZXQoKTsKICB9CiAgLyoqCiAgICogR2V0cyB0aGUgY29ycmVzcG9uZGluZyBtb2RlbCBlbGVtZW50LgogICAqCiAgICogKipOb3RlOioqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdWllbGVtZW50flVJRWxlbWVudH0gZG9lcyBub3QgaGF2ZSBjb3JyZXNwb25kaW5nIGVsZW1lbnQgaW4gbW9kZWwuCiAgICoKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnR9IHZpZXdFbGVtZW50IFZpZXcgZWxlbWVudC4KICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS9tb2RlbC9lbGVtZW50fkVsZW1lbnR8dW5kZWZpbmVkfSBDb3JyZXNwb25kaW5nIG1vZGVsIGVsZW1lbnQgb3IgYHVuZGVmaW5lZGAgaWYgbm90IGZvdW5kLgogICAqLwoKCiAgdG9Nb2RlbEVsZW1lbnQodmlld0VsZW1lbnQpIHsKICAgIHJldHVybiB0aGlzLl92aWV3VG9Nb2RlbE1hcHBpbmcuZ2V0KHZpZXdFbGVtZW50KTsKICB9CiAgLyoqCiAgICogR2V0cyB0aGUgY29ycmVzcG9uZGluZyB2aWV3IGVsZW1lbnQuCiAgICoKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50fSBtb2RlbEVsZW1lbnQgTW9kZWwgZWxlbWVudC4KICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudHx1bmRlZmluZWR9IENvcnJlc3BvbmRpbmcgdmlldyBlbGVtZW50IG9yIGB1bmRlZmluZWRgIGlmIG5vdCBmb3VuZC4KICAgKi8KCgogIHRvVmlld0VsZW1lbnQobW9kZWxFbGVtZW50KSB7CiAgICByZXR1cm4gdGhpcy5fbW9kZWxUb1ZpZXdNYXBwaW5nLmdldChtb2RlbEVsZW1lbnQpOwogIH0KICAvKioKICAgKiBHZXRzIHRoZSBjb3JyZXNwb25kaW5nIG1vZGVsIHJhbmdlLgogICAqCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvcmFuZ2V+UmFuZ2V9IHZpZXdSYW5nZSBWaWV3IHJhbmdlLgogICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlfSBDb3JyZXNwb25kaW5nIG1vZGVsIHJhbmdlLgogICAqLwoKCiAgdG9Nb2RlbFJhbmdlKHZpZXdSYW5nZSkgewogICAgcmV0dXJuIG5ldyBNb2RlbFJhbmdlKHRoaXMudG9Nb2RlbFBvc2l0aW9uKHZpZXdSYW5nZS5zdGFydCksIHRoaXMudG9Nb2RlbFBvc2l0aW9uKHZpZXdSYW5nZS5lbmQpKTsKICB9CiAgLyoqCiAgICogR2V0cyB0aGUgY29ycmVzcG9uZGluZyB2aWV3IHJhbmdlLgogICAqCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlfSBtb2RlbFJhbmdlIE1vZGVsIHJhbmdlLgogICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL3ZpZXcvcmFuZ2V+UmFuZ2V9IENvcnJlc3BvbmRpbmcgdmlldyByYW5nZS4KICAgKi8KCgogIHRvVmlld1JhbmdlKG1vZGVsUmFuZ2UpIHsKICAgIHJldHVybiBuZXcgVmlld1JhbmdlKHRoaXMudG9WaWV3UG9zaXRpb24obW9kZWxSYW5nZS5zdGFydCksIHRoaXMudG9WaWV3UG9zaXRpb24obW9kZWxSYW5nZS5lbmQpKTsKICB9CiAgLyoqCiAgICogR2V0cyB0aGUgY29ycmVzcG9uZGluZyBtb2RlbCBwb3NpdGlvbi4KICAgKgogICAqIEBmaXJlcyB2aWV3VG9Nb2RlbFBvc2l0aW9uCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvcG9zaXRpb25+UG9zaXRpb259IHZpZXdQb3NpdGlvbiBWaWV3IHBvc2l0aW9uLgogICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufSBDb3JyZXNwb25kaW5nIG1vZGVsIHBvc2l0aW9uLgogICAqLwoKCiAgdG9Nb2RlbFBvc2l0aW9uKHZpZXdQb3NpdGlvbikgewogICAgY29uc3QgZGF0YSA9IHsKICAgICAgdmlld1Bvc2l0aW9uLAogICAgICBtYXBwZXI6IHRoaXMKICAgIH07CiAgICB0aGlzLmZpcmUoJ3ZpZXdUb01vZGVsUG9zaXRpb24nLCBkYXRhKTsKICAgIHJldHVybiBkYXRhLm1vZGVsUG9zaXRpb247CiAgfQogIC8qKgogICAqIEdldHMgdGhlIGNvcnJlc3BvbmRpbmcgdmlldyBwb3NpdGlvbi4KICAgKgogICAqIEBmaXJlcyBtb2RlbFRvVmlld1Bvc2l0aW9uCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9ufSBtb2RlbFBvc2l0aW9uIE1vZGVsIHBvc2l0aW9uLgogICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBvcHRpb25zIGZvciBwb3NpdGlvbiBtYXBwaW5nIHByb2Nlc3MuCiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5pc1BoYW50b209ZmFsc2VdIFNob3VsZCBiZSBzZXQgdG8gYHRydWVgIGlmIHRoZSBtb2RlbCBwb3NpdGlvbiB0byBtYXAgaXMgcG9pbnRpbmcgdG8gYSBwbGFjZQogICAqIGluIG1vZGVsIHRyZWUgd2hpY2ggbm8gbG9uZ2VyIGV4aXN0cy4gRm9yIGV4YW1wbGUsIGl0IGNvdWxkIGJlIGFuIGVuZCBvZiBhIHJlbW92ZWQgbW9kZWwgcmFuZ2UuCiAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbn0gQ29ycmVzcG9uZGluZyB2aWV3IHBvc2l0aW9uLgogICAqLwoKCiAgdG9WaWV3UG9zaXRpb24obW9kZWxQb3NpdGlvbiwgb3B0aW9ucyA9IHsKICAgIGlzUGhhbnRvbTogZmFsc2UKICB9KSB7CiAgICBjb25zdCBkYXRhID0gewogICAgICBtb2RlbFBvc2l0aW9uLAogICAgICBtYXBwZXI6IHRoaXMsCiAgICAgIGlzUGhhbnRvbTogb3B0aW9ucy5pc1BoYW50b20KICAgIH07CiAgICB0aGlzLmZpcmUoJ21vZGVsVG9WaWV3UG9zaXRpb24nLCBkYXRhKTsKICAgIHJldHVybiBkYXRhLnZpZXdQb3NpdGlvbjsKICB9CiAgLyoqCiAgICogR2V0cyBhbGwgdmlldyBlbGVtZW50cyBib3VuZCB0byB0aGUgZ2l2ZW4gbWFya2VyIG5hbWUuCiAgICoKICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBNYXJrZXIgbmFtZS4KICAgKiBAcmV0dXJucyB7U2V0Ljxtb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50PnxudWxsfSBWaWV3IGVsZW1lbnRzIGJvdW5kIHdpdGggZ2l2ZW4gbWFya2VyIG5hbWUgb3IgYG51bGxgCiAgICogaWYgbm8gZWxlbWVudHMgYXJlIGJvdW5kIHRvIGdpdmVuIG1hcmtlciBuYW1lLgogICAqLwoKCiAgbWFya2VyTmFtZVRvRWxlbWVudHMobmFtZSkgewogICAgY29uc3QgYm91bmRFbGVtZW50cyA9IHRoaXMuX21hcmtlck5hbWVUb0VsZW1lbnRzLmdldChuYW1lKTsKCiAgICBpZiAoIWJvdW5kRWxlbWVudHMpIHsKICAgICAgcmV0dXJuIG51bGw7CiAgICB9CgogICAgY29uc3QgZWxlbWVudHMgPSBuZXcgU2V0KCk7CgogICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGJvdW5kRWxlbWVudHMpIHsKICAgICAgaWYgKGVsZW1lbnQuaXMoJ2F0dHJpYnV0ZUVsZW1lbnQnKSkgewogICAgICAgIGZvciAoY29uc3QgY2xvbmUgb2YgZWxlbWVudC5nZXRFbGVtZW50c1dpdGhTYW1lSWQoKSkgewogICAgICAgICAgZWxlbWVudHMuYWRkKGNsb25lKTsKICAgICAgICB9CiAgICAgIH0gZWxzZSB7CiAgICAgICAgZWxlbWVudHMuYWRkKGVsZW1lbnQpOwogICAgICB9CiAgICB9CgogICAgcmV0dXJuIGVsZW1lbnRzOwogIH0KICAvKioKICAgKiBSZWdpc3RlcnMgYSBjYWxsYmFjayB0aGF0IGV2YWx1YXRlcyB0aGUgbGVuZ3RoIGluIHRoZSBtb2RlbCBvZiBhIHZpZXcgZWxlbWVudCB3aXRoIGdpdmVuIG5hbWUuCiAgICoKICAgKiBUaGUgY2FsbGJhY2sgaXMgZmlyZWQgd2l0aCBvbmUgYXJndW1lbnQsIHdoaWNoIGlzIGEgdmlldyBlbGVtZW50IGluc3RhbmNlLiBUaGUgY2FsbGJhY2sgaXMgZXhwZWN0ZWQgdG8gcmV0dXJuCiAgICogYSBudW1iZXIgcmVwcmVzZW50aW5nIHRoZSBsZW5ndGggb2YgdmlldyBlbGVtZW50IGluIG1vZGVsLgogICAqCiAgICoJCS8vIExpc3QgaXRlbSBpbiB2aWV3IG1heSBjb250YWluIG5lc3RlZCBsaXN0LCB3aGljaCBoYXZlIG90aGVyIGxpc3QgaXRlbXMuIEluIG1vZGVsIHRob3VnaCwKICAgKgkJLy8gdGhlIGxpc3RzIGFyZSByZXByZXNlbnRlZCBieSBmbGF0IHN0cnVjdHVyZS4gQmVjYXVzZSBvZiB0aG9zZSBkaWZmZXJlbmNlcywgbGVuZ3RoIG9mIGxpc3QgdmlldyBlbGVtZW50CiAgICoJCS8vIG1heSBiZSBncmVhdGVyIHRoYW4gb25lLiBJbiB0aGUgY2FsbGJhY2sgaXQncyBjaGVja2VkIGhvdyBtYW55IG5lc3RlZCBsaXN0IGl0ZW1zIGFyZSBpbiBldmFsdWF0ZWQgbGlzdCBpdGVtLgogICAqCiAgICoJCWZ1bmN0aW9uIGdldFZpZXdMaXN0SXRlbUxlbmd0aCggZWxlbWVudCApIHsKICAgKgkJCWxldCBsZW5ndGggPSAxOwogICAqCiAgICoJCQlmb3IgKCBsZXQgY2hpbGQgb2YgZWxlbWVudC5nZXRDaGlsZHJlbigpICkgewogICAqCQkJCWlmICggY2hpbGQubmFtZSA9PSAndWwnIHx8IGNoaWxkLm5hbWUgPT0gJ29sJyApIHsKICAgKgkJCQkJZm9yICggbGV0IGl0ZW0gb2YgY2hpbGQuZ2V0Q2hpbGRyZW4oKSApIHsKICAgKgkJCQkJCWxlbmd0aCArPSBnZXRWaWV3TGlzdEl0ZW1MZW5ndGgoIGl0ZW0gKTsKICAgKgkJCQkJfQogICAqCQkJCX0KICAgKgkJCX0KICAgKgogICAqCQkJcmV0dXJuIGxlbmd0aDsKICAgKgkJfQogICAqCiAgICoJCW1hcHBlci5yZWdpc3RlclZpZXdUb01vZGVsTGVuZ3RoKCAnbGknLCBnZXRWaWV3TGlzdEl0ZW1MZW5ndGggKTsKICAgKgogICAqIEBwYXJhbSB7U3RyaW5nfSB2aWV3RWxlbWVudE5hbWUgTmFtZSBvZiB2aWV3IGVsZW1lbnQgZm9yIHdoaWNoIGNhbGxiYWNrIGlzIHJlZ2lzdGVyZWQuCiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGVuZ3RoQ2FsbGJhY2sgRnVuY3Rpb24gcmV0dXJuIGEgbGVuZ3RoIG9mIHZpZXcgZWxlbWVudCBpbnN0YW5jZSBpbiBtb2RlbC4KICAgKi8KCgogIHJlZ2lzdGVyVmlld1RvTW9kZWxMZW5ndGgodmlld0VsZW1lbnROYW1lLCBsZW5ndGhDYWxsYmFjaykgewogICAgdGhpcy5fdmlld1RvTW9kZWxMZW5ndGhDYWxsYmFja3Muc2V0KHZpZXdFbGVtZW50TmFtZSwgbGVuZ3RoQ2FsbGJhY2spOwogIH0KICAvKioKICAgKiBGb3IgZ2l2ZW4gYHZpZXdQb3NpdGlvbmAsIGZpbmRzIGFuZCByZXR1cm5zIHRoZSBjbG9zZXN0IGFuY2VzdG9yIG9mIHRoaXMgcG9zaXRpb24gdGhhdCBoYXMgYSBtYXBwaW5nIHRvCiAgICogdGhlIG1vZGVsLgogICAqCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvcG9zaXRpb25+UG9zaXRpb259IHZpZXdQb3NpdGlvbiBQb3NpdGlvbiBmb3Igd2hpY2ggbWFwcGVkIGFuY2VzdG9yIHNob3VsZCBiZSBmb3VuZC4KICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudH0KICAgKi8KCgogIGZpbmRNYXBwZWRWaWV3QW5jZXN0b3Iodmlld1Bvc2l0aW9uKSB7CiAgICBsZXQgcGFyZW50ID0gdmlld1Bvc2l0aW9uLnBhcmVudDsKCiAgICB3aGlsZSAoIXRoaXMuX3ZpZXdUb01vZGVsTWFwcGluZy5oYXMocGFyZW50KSkgewogICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50OwogICAgfQoKICAgIHJldHVybiBwYXJlbnQ7CiAgfQogIC8qKgogICAqIENhbGN1bGF0ZXMgbW9kZWwgb2Zmc2V0IGJhc2VkIG9uIHRoZSB2aWV3IHBvc2l0aW9uIGFuZCB0aGUgYmxvY2sgZWxlbWVudC4KICAgKgogICAqIEV4YW1wbGU6CiAgICoKICAgKgkJPHA+Zm9vPGI+YmF8cjwvYj48L3A+IC8vIF90b01vZGVsT2Zmc2V0KCBiLCAyLCBwICkgLT4gNQogICAqCiAgICogSXMgYSBzdW0gb2Y6CiAgICoKICAgKgkJPHA+Zm9vfDxiPmJhcjwvYj48L3A+IC8vIF90b01vZGVsT2Zmc2V0KCBwLCAzLCBwICkgLT4gMwogICAqCQk8cD5mb288Yj5iYXxyPC9iPjwvcD4gLy8gX3RvTW9kZWxPZmZzZXQoIGIsIDIsIGIgKSAtPiAyCiAgICoKICAgKiBAcHJpdmF0ZQogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudH0gdmlld1BhcmVudCBQb3NpdGlvbiBwYXJlbnQuCiAgICogQHBhcmFtIHtOdW1iZXJ9IHZpZXdPZmZzZXQgUG9zaXRpb24gb2Zmc2V0LgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudH0gdmlld0Jsb2NrIEJsb2NrIHVzZWQgYXMgYSBiYXNlIHRvIGNhbGN1bGF0ZSBvZmZzZXQuCiAgICogQHJldHVybnMge051bWJlcn0gT2Zmc2V0IGluIHRoZSBtb2RlbC4KICAgKi8KCgogIF90b01vZGVsT2Zmc2V0KHZpZXdQYXJlbnQsIHZpZXdPZmZzZXQsIHZpZXdCbG9jaykgewogICAgaWYgKHZpZXdCbG9jayAhPSB2aWV3UGFyZW50KSB7CiAgICAgIC8vIFNlZSBleGFtcGxlLgogICAgICBjb25zdCBvZmZzZXRUb1BhcmVudFN0YXJ0ID0gdGhpcy5fdG9Nb2RlbE9mZnNldCh2aWV3UGFyZW50LnBhcmVudCwgdmlld1BhcmVudC5pbmRleCwgdmlld0Jsb2NrKTsKCiAgICAgIGNvbnN0IG9mZnNldEluUGFyZW50ID0gdGhpcy5fdG9Nb2RlbE9mZnNldCh2aWV3UGFyZW50LCB2aWV3T2Zmc2V0LCB2aWV3UGFyZW50KTsKCiAgICAgIHJldHVybiBvZmZzZXRUb1BhcmVudFN0YXJ0ICsgb2Zmc2V0SW5QYXJlbnQ7CiAgICB9IC8vIHZpZXdCbG9jayA9PSB2aWV3UGFyZW50LCBzbyB3ZSBuZWVkIHRvIGNhbGN1bGF0ZSB0aGUgb2Zmc2V0IGluIHRoZSBwYXJlbnQgZWxlbWVudC4KICAgIC8vIElmIHRoZSBwb3NpdGlvbiBpcyBhIHRleHQgaXQgaXMgc2ltcGxlICgiYmF8ciIgLT4gMikuCgoKICAgIGlmICh2aWV3UGFyZW50LmlzKCd0ZXh0JykpIHsKICAgICAgcmV0dXJuIHZpZXdPZmZzZXQ7CiAgICB9IC8vIElmIHRoZSBwb3NpdGlvbiBpcyBpbiBhbiBlbGVtZW50IHdlIG5lZWQgdG8gc3VtIGxlbmd0aHMgb2Ygc2libGluZ3MgKCA8Yj4gYmFyIDwvYj4gZm9vIHwgLT4gMyArIDMgPSA2ICkuCgoKICAgIGxldCBtb2RlbE9mZnNldCA9IDA7CgogICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2aWV3T2Zmc2V0OyBpKyspIHsKICAgICAgbW9kZWxPZmZzZXQgKz0gdGhpcy5nZXRNb2RlbExlbmd0aCh2aWV3UGFyZW50LmdldENoaWxkKGkpKTsKICAgIH0KCiAgICByZXR1cm4gbW9kZWxPZmZzZXQ7CiAgfQogIC8qKgogICAqIEdldHMgdGhlIGxlbmd0aCBvZiB0aGUgdmlldyBlbGVtZW50IGluIHRoZSBtb2RlbC4KICAgKgogICAqIFRoZSBsZW5ndGggaXMgY2FsY3VsYXRlZCBhcyBmb2xsb3dzOgogICAqICogaWYge0BsaW5rICNyZWdpc3RlclZpZXdUb01vZGVsTGVuZ3RoIGxlbmd0aCBtYXBwaW5nIGNhbGxiYWNrfSBpcyBwcm92aWRlZCBmb3IgZ2l2ZW4gYHZpZXdOb2RlYCBpdCBpcyB1c2VkIHRvCiAgICogZXZhbHVhdGUgbW9kZWwgbGVuZ3RoIChgdmlld05vZGVgIGlzIHVzZWQgYXMgZmlyc3QgYW5kIG9ubHkgcGFyYW1ldGVyIHBhc3NlZCB0byB0aGUgY2FsbGJhY2spLAogICAqICogbGVuZ3RoIG9mIGEge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy90ZXh0flRleHQgdGV4dCBub2RlfSBpcyBlcXVhbCB0byB0aGUgbGVuZ3RoIG9mIGl0J3MKICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3RleHR+VGV4dCNkYXRhIGRhdGF9LAogICAqICogbGVuZ3RoIG9mIGEge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy91aWVsZW1lbnR+VUlFbGVtZW50IHVpIGVsZW1lbnR9IGlzIGVxdWFsIHRvIDAsCiAgICogKiBsZW5ndGggb2YgYSBtYXBwZWQge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnQgZWxlbWVudH0gaXMgZXF1YWwgdG8gMSwKICAgKiAqIGxlbmd0aCBvZiBhIG5vdC1tYXBwZWQge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnQgZWxlbWVudH0gaXMgZXF1YWwgdG8gdGhlIGxlbmd0aCBvZiBpdCdzIGNoaWxkcmVuLgogICAqCiAgICogRXhhbXBsZXM6CiAgICoKICAgKgkJZm9vICAgICAgICAgICAgICAgICAgICAgICAgICAtPiAzIC8vIFRleHQgbGVuZ3RoIGlzIGVxdWFsIHRvIGl0J3MgZGF0YSBsZW5ndGguCiAgICoJCTxwPmZvbzwvcD4gICAgICAgICAgICAgICAgICAgLT4gMSAvLyBMZW5ndGggb2YgYW4gZWxlbWVudCB3aGljaCBpcyBtYXBwZWQgaXMgYnkgZGVmYXVsdCBlcXVhbCB0byAxLgogICAqCQk8Yj5mb288L2I+ICAgICAgICAgICAgICAgICAgIC0+IDMgLy8gTGVuZ3RoIG9mIGFuIGVsZW1lbnQgd2hpY2ggaXMgbm90IG1hcHBlZCBpcyBhIGxlbmd0aCBvZiBpdHMgY2hpbGRyZW4uCiAgICoJCTxkaXY+PHA+eDwvcD48cD55PC9wPjwvZGl2PiAgLT4gMiAvLyBBc3N1bWluZyB0aGF0IDxkaXY+IGlzIG5vdCBtYXBwZWQgYW5kIDxwPiBhcmUgbWFwcGVkLgogICAqCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50fSB2aWV3Tm9kZSBWaWV3IG5vZGUuCiAgICogQHJldHVybnMge051bWJlcn0gTGVuZ3RoIG9mIHRoZSBub2RlIGluIHRoZSB0cmVlIG1vZGVsLgogICAqLwoKCiAgZ2V0TW9kZWxMZW5ndGgodmlld05vZGUpIHsKICAgIGlmICh0aGlzLl92aWV3VG9Nb2RlbExlbmd0aENhbGxiYWNrcy5nZXQodmlld05vZGUubmFtZSkpIHsKICAgICAgY29uc3QgY2FsbGJhY2sgPSB0aGlzLl92aWV3VG9Nb2RlbExlbmd0aENhbGxiYWNrcy5nZXQodmlld05vZGUubmFtZSk7CgogICAgICByZXR1cm4gY2FsbGJhY2sodmlld05vZGUpOwogICAgfSBlbHNlIGlmICh0aGlzLl92aWV3VG9Nb2RlbE1hcHBpbmcuaGFzKHZpZXdOb2RlKSkgewogICAgICByZXR1cm4gMTsKICAgIH0gZWxzZSBpZiAodmlld05vZGUuaXMoJ3RleHQnKSkgewogICAgICByZXR1cm4gdmlld05vZGUuZGF0YS5sZW5ndGg7CiAgICB9IGVsc2UgaWYgKHZpZXdOb2RlLmlzKCd1aUVsZW1lbnQnKSkgewogICAgICByZXR1cm4gMDsKICAgIH0gZWxzZSB7CiAgICAgIGxldCBsZW4gPSAwOwoKICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiB2aWV3Tm9kZS5nZXRDaGlsZHJlbigpKSB7CiAgICAgICAgbGVuICs9IHRoaXMuZ2V0TW9kZWxMZW5ndGgoY2hpbGQpOwogICAgICB9CgogICAgICByZXR1cm4gbGVuOwogICAgfQogIH0KICAvKioKICAgKiBGaW5kcyB0aGUgcG9zaXRpb24gaW4gdGhlIHZpZXcgbm9kZSAob3IgaXRzIGNoaWxkcmVuKSB3aXRoIHRoZSBleHBlY3RlZCBtb2RlbCBvZmZzZXQuCiAgICoKICAgKiBFeGFtcGxlOgogICAqCiAgICoJCTxwPmZvPGI+YmFyPC9iPmJvbTwvcD4gLT4gZXhwZWN0ZWQgb2Zmc2V0OiA0CiAgICoKICAgKgkJX2ZpbmRQb3NpdGlvbkluKCBwLCA0ICk6CiAgICoJCTxwPnxmbzxiPmJhcjwvYj5ib208L3A+IC0+IGV4cGVjdGVkIG9mZnNldDogNCwgYWN0dWFsIG9mZnNldDogMAogICAqCQk8cD5mb3w8Yj5iYXI8L2I+Ym9tPC9wPiAtPiBleHBlY3RlZCBvZmZzZXQ6IDQsIGFjdHVhbCBvZmZzZXQ6IDIKICAgKgkJPHA+Zm88Yj5iYXI8L2I+fGJvbTwvcD4gLT4gZXhwZWN0ZWQgb2Zmc2V0OiA0LCBhY3R1YWwgb2Zmc2V0OiA1IC0+IHdlIGFyZSB0b28gZmFyCiAgICoKICAgKgkJX2ZpbmRQb3NpdGlvbkluKCBiLCA0IC0gKCA1IC0gMyApICk6CiAgICoJCTxwPmZvPGI+fGJhcjwvYj5ib208L3A+IC0+IGV4cGVjdGVkIG9mZnNldDogMiwgYWN0dWFsIG9mZnNldDogMAogICAqCQk8cD5mbzxiPmJhcnw8L2I+Ym9tPC9wPiAtPiBleHBlY3RlZCBvZmZzZXQ6IDIsIGFjdHVhbCBvZmZzZXQ6IDMgLT4gd2UgYXJlIHRvbyBmYXIKICAgKgogICAqCQlfZmluZFBvc2l0aW9uSW4oIGJhciwgMiAtICggMyAtIDMgKSApOgogICAqCQlXZSBhcmUgaW4gdGhlIHRleHQgbm9kZSBzbyB3ZSBjYW4gc2ltcGxlIGZpbmQgdGhlIG9mZnNldC4KICAgKgkJPHA+Zm88Yj5iYXxyPC9iPmJvbTwvcD4gLT4gZXhwZWN0ZWQgb2Zmc2V0OiAyLCBhY3R1YWwgb2Zmc2V0OiAyIC0+IHBvc2l0aW9uIGZvdW5kCiAgICoKICAgKiBAcHJpdmF0ZQogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudH0gdmlld1BhcmVudCBUcmVlIHZpZXcgZWxlbWVudCBpbiB3aGljaCB3ZSBhcmUgbG9va2luZyBmb3IgdGhlIHBvc2l0aW9uLgogICAqIEBwYXJhbSB7TnVtYmVyfSBleHBlY3RlZE9mZnNldCBFeHBlY3RlZCBvZmZzZXQuCiAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbn0gRm91bmQgcG9zaXRpb24uCiAgICovCgoKICBfZmluZFBvc2l0aW9uSW4odmlld1BhcmVudCwgZXhwZWN0ZWRPZmZzZXQpIHsKICAgIC8vIExhc3Qgc2Nhbm5lZCB2aWV3IG5vZGUuCiAgICBsZXQgdmlld05vZGU7IC8vIExlbmd0aCBvZiB0aGUgbGFzdCBzY2FubmVkIHZpZXcgbm9kZS4KCiAgICBsZXQgbGFzdExlbmd0aCA9IDA7CiAgICBsZXQgbW9kZWxPZmZzZXQgPSAwOwogICAgbGV0IHZpZXdPZmZzZXQgPSAwOyAvLyBJbiB0aGUgdGV4dCBub2RlIGl0IGlzIHNpbXBsZTogb2Zmc2V0IGluIHRoZSBtb2RlbCBlcXVhbHMgb2Zmc2V0IGluIHRoZSB0ZXh0LgoKICAgIGlmICh2aWV3UGFyZW50LmlzKCd0ZXh0JykpIHsKICAgICAgcmV0dXJuIG5ldyBWaWV3UG9zaXRpb24odmlld1BhcmVudCwgZXhwZWN0ZWRPZmZzZXQpOwogICAgfSAvLyBJbiBvdGhlciBjYXNlcyB3ZSBhZGQgbGVuZ3RocyBvZiBjaGlsZCBub2RlcyB0byBmaW5kIHRoZSBwcm9wZXIgb2Zmc2V0LgogICAgLy8gSWYgaXQgaXMgc21hbGxlciB3ZSBhZGQgdGhlIGxlbmd0aC4KCgogICAgd2hpbGUgKG1vZGVsT2Zmc2V0IDwgZXhwZWN0ZWRPZmZzZXQpIHsKICAgICAgdmlld05vZGUgPSB2aWV3UGFyZW50LmdldENoaWxkKHZpZXdPZmZzZXQpOwogICAgICBsYXN0TGVuZ3RoID0gdGhpcy5nZXRNb2RlbExlbmd0aCh2aWV3Tm9kZSk7CiAgICAgIG1vZGVsT2Zmc2V0ICs9IGxhc3RMZW5ndGg7CiAgICAgIHZpZXdPZmZzZXQrKzsKICAgIH0gLy8gSWYgaXQgZXF1YWxzIHdlIGZvdW5kIHRoZSBwb3NpdGlvbi4KCgogICAgaWYgKG1vZGVsT2Zmc2V0ID09IGV4cGVjdGVkT2Zmc2V0KSB7CiAgICAgIHJldHVybiB0aGlzLl9tb3ZlVmlld1Bvc2l0aW9uVG9UZXh0Tm9kZShuZXcgVmlld1Bvc2l0aW9uKHZpZXdQYXJlbnQsIHZpZXdPZmZzZXQpKTsKICAgIH0gLy8gSWYgaXQgaXMgaGlnaGVyIHdlIG5lZWQgdG8gZW50ZXIgbGFzdCBjaGlsZC4KICAgIGVsc2UgewogICAgICAgIC8vICggbW9kZWxPZmZzZXQgLSBsYXN0TGVuZ3RoICkgaXMgdGhlIG9mZnNldCB0byB0aGUgY2hpbGQgd2UgZW50ZXIsCiAgICAgICAgLy8gc28gd2Ugc3VidHJhY3QgaXQgZnJvbSB0aGUgZXhwZWN0ZWQgb2Zmc2V0IHRvIGZpbmUgdGhlIG9mZnNldCBpbiB0aGUgY2hpbGQuCiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbmRQb3NpdGlvbkluKHZpZXdOb2RlLCBleHBlY3RlZE9mZnNldCAtIChtb2RlbE9mZnNldCAtIGxhc3RMZW5ndGgpKTsKICAgICAgfQogIH0KICAvKioKICAgKiBCZWNhdXNlIHdlIHByZWZlciBwb3NpdGlvbnMgaW4gdGV4dCBub2RlcyBvdmVyIHBvc2l0aW9ucyBuZXh0IHRvIHRleHQgbm9kZSBtb3ZlcyB2aWV3IHBvc2l0aW9uIHRvIHRoZSB0ZXh0IG5vZGUKICAgKiBpZiBpdCB3YXMgbmV4dCB0byBpdC4KICAgKgogICAqCQk8cD5bXTxiPmZvbzwvYj48L3A+IC0+IDxwPltdPGI+Zm9vPC9iPjwvcD4gLy8gZG8gbm90IHRvdWNoIGlmIHBvc2l0aW9uIGlzIG5vdCBkaXJlY3RseSBuZXh0IHRvIHRleHQKICAgKgkJPHA+Zm9vW108Yj5mb288L2I+PC9wPiAtPiA8cD5mb297fTxiPmZvbzwvYj48L3A+IC8vIG1vdmUgdG8gdGV4dCBub2RlCiAgICoJCTxwPjxiPltdZm9vPC9iPjwvcD4gLT4gPHA+PGI+e31mb288L2I+PC9wPiAvLyBtb3ZlIHRvIHRleHQgbm9kZQogICAqCiAgICogQHByaXZhdGUKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbn0gdmlld1Bvc2l0aW9uIFBvc2l0aW9uIHBvdGVudGlhbGx5IG5leHQgdG8gdGV4dCBub2RlLgogICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL3ZpZXcvcG9zaXRpb25+UG9zaXRpb259IFBvc2l0aW9uIGluIHRleHQgbm9kZSBpZiBwb3NzaWJsZS4KICAgKi8KCgogIF9tb3ZlVmlld1Bvc2l0aW9uVG9UZXh0Tm9kZSh2aWV3UG9zaXRpb24pIHsKICAgIC8vIElmIHRoZSBwb3NpdGlvbiBpcyBqdXN0IGFmdGVyIHRleHQgbm9kZSwgcHV0IGl0IGF0IHRoZSBlbmQgb2YgdGhhdCB0ZXh0IG5vZGUuCiAgICAvLyBJZiB0aGUgcG9zaXRpb24gaXMganVzdCBiZWZvcmUgdGV4dCBub2RlLCBwdXQgaXQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGF0IHRleHQgbm9kZS4KICAgIGNvbnN0IG5vZGVCZWZvcmUgPSB2aWV3UG9zaXRpb24ubm9kZUJlZm9yZTsKICAgIGNvbnN0IG5vZGVBZnRlciA9IHZpZXdQb3NpdGlvbi5ub2RlQWZ0ZXI7CgogICAgaWYgKG5vZGVCZWZvcmUgaW5zdGFuY2VvZiBWaWV3VGV4dCkgewogICAgICByZXR1cm4gbmV3IFZpZXdQb3NpdGlvbihub2RlQmVmb3JlLCBub2RlQmVmb3JlLmRhdGEubGVuZ3RoKTsKICAgIH0gZWxzZSBpZiAobm9kZUFmdGVyIGluc3RhbmNlb2YgVmlld1RleHQpIHsKICAgICAgcmV0dXJuIG5ldyBWaWV3UG9zaXRpb24obm9kZUFmdGVyLCAwKTsKICAgIH0gLy8gT3RoZXJ3aXNlLCBqdXN0IHJldHVybiB0aGUgZ2l2ZW4gcG9zaXRpb24uCgoKICAgIHJldHVybiB2aWV3UG9zaXRpb247CiAgfQogIC8qKgogICAqIEZpcmVkIGZvciBlYWNoIG1vZGVsLXRvLXZpZXcgcG9zaXRpb24gbWFwcGluZyByZXF1ZXN0LiBUaGUgcHVycG9zZSBvZiB0aGlzIGV2ZW50IGlzIHRvIGVuYWJsZSBjdXN0b20gbW9kZWwtdG8tdmlldyBwb3NpdGlvbgogICAqIG1hcHBpbmcuIENhbGxiYWNrcyBhZGRlZCB0byB0aGlzIGV2ZW50IHRha2Uge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb24gbW9kZWwgcG9zaXRpb259IGFuZCBhcmUgZXhwZWN0ZWQgdG8KICAgKiBjYWxjdWxhdGUge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbiB2aWV3IHBvc2l0aW9ufS4gQ2FsY3VsYXRlZCB2aWV3IHBvc2l0aW9uIHNob3VsZCBiZSBhZGRlZCBhcyBgdmlld1Bvc2l0aW9uYAogICAqIHZhbHVlIGluIGBkYXRhYCBvYmplY3QgdGhhdCBpcyBwYXNzZWQgYXMgb25lIG9mIHBhcmFtZXRlcnMgdG8gdGhlIGV2ZW50IGNhbGxiYWNrLgogICAqCiAgICogCQkvLyBBc3N1bWUgdGhhdCAiY2FwdGlvbmVkSW1hZ2UiIG1vZGVsIGVsZW1lbnQgaXMgY29udmVydGVkIHRvIDxpbWc+IGFuZCBmb2xsb3dpbmcgPHNwYW4+IGVsZW1lbnRzIGluIHZpZXcsCiAgICogCQkvLyBhbmQgdGhlIG1vZGVsIGVsZW1lbnQgaXMgYm91bmQgdG8gPGltZz4gZWxlbWVudC4gRm9yY2UgbWFwcGluZyBtb2RlbCBwb3NpdGlvbnMgaW5zaWRlICJjYXB0aW9uZWRJbWFnZSIgdG8gdGhhdAogICAqIAkJLy8gPHNwYW4+IGVsZW1lbnQuCiAgICoJCW1hcHBlci5vbiggJ21vZGVsVG9WaWV3UG9zaXRpb24nLCAoIGV2dCwgZGF0YSApID0+IHsKICAgKgkJCWNvbnN0IHBvc2l0aW9uUGFyZW50ID0gbW9kZWxQb3NpdGlvbi5wYXJlbnQ7CiAgICoKICAgKgkJCWlmICggcG9zaXRpb25QYXJlbnQubmFtZSA9PSAnY2FwdGlvbmVkSW1hZ2UnICkgewogICAqCQkJCWNvbnN0IHZpZXdJbWcgPSBkYXRhLm1hcHBlci50b1ZpZXdFbGVtZW50KCBwb3NpdGlvblBhcmVudCApOwogICAqCQkJCWNvbnN0IHZpZXdDYXB0aW9uID0gdmlld0ltZy5uZXh0U2libGluZzsgLy8gVGhlIDxzcGFuPiBlbGVtZW50LgogICAqCiAgICoJCQkJZGF0YS52aWV3UG9zaXRpb24gPSBuZXcgVmlld1Bvc2l0aW9uKCB2aWV3Q2FwdGlvbiwgbW9kZWxQb3NpdGlvbi5vZmZzZXQgKTsKICAgKgogICAqCQkJCS8vIFN0b3AgdGhlIGV2ZW50IGlmIG90aGVyIGNhbGxiYWNrcyBzaG91bGQgbm90IG1vZGlmeSBjYWxjdWxhdGVkIHZhbHVlLgogICAqCQkJCWV2dC5zdG9wKCk7CiAgICoJCQl9CiAgICoJCX0gKTsKICAgKgogICAqICoqTm90ZToqKiBrZWVwIGluIG1pbmQgdGhhdCBzb21ldGltZXMgYSAicGhhbnRvbSIgbW9kZWwgcG9zaXRpb24gaXMgYmVpbmcgY29udmVydGVkLiAiUGhhbnRvbSIgbW9kZWwgcG9zaXRpb24gaXMKICAgKiBhIHBvc2l0aW9uIHRoYXQgcG9pbnRzIHRvIGEgbm9uLWV4aXN0aW5nIHBsYWNlIGluIG1vZGVsLiBTdWNoIHBvc2l0aW9uIG1pZ2h0IHN0aWxsIGJlIHZhbGlkIGZvciBjb252ZXJzaW9uLCB0aG91Z2gKICAgKiAoaXQgd291bGQgcG9pbnQgdG8gYSBjb3JyZWN0IHBsYWNlIGluIHZpZXcgd2hlbiBjb252ZXJ0ZWQpLiBPbmUgZXhhbXBsZSBvZiBzdWNoIHNpdHVhdGlvbiBpcyB3aGVuIGEgcmFuZ2UgaXMKICAgKiByZW1vdmVkIGZyb20gbW9kZWwsIHRoZXJlIG1heSBiZSBhIG5lZWQgdG8gbWFwIHRoZSByYW5nZSdzIGVuZCAod2hpY2ggaXMgbm8gbG9uZ2VyIHZhbGlkIG1vZGVsIHBvc2l0aW9uKS4gVG8KICAgKiBoYW5kbGUgc3VjaCBzaXR1YXRpb24sIGNoZWNrIGBkYXRhLmlzUGhhbnRvbWAgZmxhZzoKICAgKgogICAqIAkJLy8gQXNzdW1lIHRoYXQgdGhlcmUgaXMgImN1c3RvbUVsZW1lbnQiIG1vZGVsIGVsZW1lbnQgYW5kIHdoZW5ldmVyIHBvc2l0aW9uIGlzIGJlZm9yZSBpdCwgd2Ugd2FudCB0byBtb3ZlIGl0CiAgICogCQkvLyB0byB0aGUgaW5zaWRlIG9mIHRoZSB2aWV3IGVsZW1lbnQgYm91bmQgdG8gImN1c3RvbUVsZW1lbnQiLgogICAqCQltYXBwZXIub24oICdtb2RlbFRvVmlld1Bvc2l0aW9uJywgKCBldnQsIGRhdGEgKSA9PiB7CiAgICoJCQlpZiAoIGRhdGEuaXNQaGFudG9tICkgewogICAqCQkJCXJldHVybjsKICAgKgkJCX0KICAgKgogICAqCQkJLy8gQmVsb3cgbGluZSBtaWdodCBjcmFzaCBmb3IgcGhhbnRvbSBwb3NpdGlvbiB0aGF0IGRvZXMgbm90IGV4aXN0IGluIG1vZGVsLgogICAqCQkJY29uc3Qgc2libGluZyA9IGRhdGEubW9kZWxQb3NpdGlvbi5ub2RlQmVmb3JlOwogICAqCiAgICoJCQkvLyBDaGVjayBpZiB0aGlzIGlzIHRoZSBlbGVtZW50IHdlIGFyZSBpbnRlcmVzdGVkIGluLgogICAqCQkJaWYgKCAhc2libGluZy5pcyggJ2N1c3RvbUVsZW1lbnQnICkgKSB7CiAgICoJCQkJcmV0dXJuOwogICAqCQkJfQogICAqCiAgICoJCQljb25zdCB2aWV3RWxlbWVudCA9IGRhdGEubWFwcGVyLnRvVmlld0VsZW1lbnQoIHNpYmxpbmcgKTsKICAgKgogICAqCQkJZGF0YS52aWV3UG9zaXRpb24gPSBuZXcgVmlld1Bvc2l0aW9uKCBzaWJsaW5nLCAwICk7CiAgICoKICAgKgkJCWV2dC5zdG9wKCk7CiAgICoJCX0gKTsKICAgKgogICAqICoqTm90ZToqKiBkZWZhdWx0IG1hcHBpbmcgY2FsbGJhY2sgaXMgcHJvdmlkZWQgd2l0aCBgbG93YCBwcmlvcml0eSBzZXR0aW5nIGFuZCBkb2VzIG5vdCBjYW5jZWwgdGhlIGV2ZW50LCBzbyBpdCBpcyBwb3NzaWJsZSB0bwogICAqIGF0dGFjaCBhIGN1c3RvbSBjYWxsYmFjayBhZnRlciBkZWZhdWx0IGNhbGxiYWNrIGFuZCBhbHNvIHVzZSBgZGF0YS52aWV3UG9zaXRpb25gIGNhbGN1bGF0ZWQgYnkgZGVmYXVsdCBjYWxsYmFjawogICAqIChmb3IgZXhhbXBsZSB0byBmaXggaXQpLgogICAqCiAgICogKipOb3RlOioqIGRlZmF1bHQgbWFwcGluZyBjYWxsYmFjayB3aWxsIG5vdCBmaXJlIGlmIGBkYXRhLnZpZXdQb3NpdGlvbmAgaXMgYWxyZWFkeSBzZXQuCiAgICoKICAgKiAqKk5vdGU6KiogdGhlc2UgY2FsbGJhY2tzIGFyZSBjYWxsZWQgKip2ZXJ5IG9mdGVuKiouIEZvciBlZmZpY2llbmN5IHJlYXNvbnMsIGl0IGlzIGFkdmlzZWQgdG8gdXNlIHRoZW0gb25seSB3aGVuIHBvc2l0aW9uCiAgICogbWFwcGluZyBiZXR3ZWVuIGdpdmVuIG1vZGVsIGFuZCB2aWV3IGVsZW1lbnRzIGlzIHVuc29sdmFibGUgdXNpbmcganVzdCBlbGVtZW50cyBtYXBwaW5nIGFuZCBkZWZhdWx0IGFsZ29yaXRobS4gQWxzbywKICAgKiB0aGUgY29uZGl0aW9uIHRoYXQgY2hlY2tzIGlmIHNwZWNpYWwgY2FzZSBzY2VuYXJpbyBoYXBwZW5lZCBzaG91bGQgYmUgYXMgc2ltcGxlIGFzIHBvc3NpYmxlLgogICAqCiAgICogQGV2ZW50IG1vZGVsVG9WaWV3UG9zaXRpb24KICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBEYXRhIHBpcGVsaW5lIG9iamVjdCB0aGF0IGNhbiBzdG9yZSBhbmQgcGFzcyBkYXRhIGJldHdlZW4gY2FsbGJhY2tzLiBUaGUgY2FsbGJhY2sgc2hvdWxkIGFkZAogICAqIGB2aWV3UG9zaXRpb25gIHZhbHVlIHRvIHRoYXQgb2JqZWN0IHdpdGggY2FsY3VsYXRlZCB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3Bvc2l0aW9uflBvc2l0aW9uIHZpZXcgcG9zaXRpb259LgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL21hcHBlcn5NYXBwZXJ9IGRhdGEubWFwcGVyIE1hcHBlciBpbnN0YW5jZSB0aGF0IGZpcmVkIHRoZSBldmVudC4KICAgKi8KCiAgLyoqCiAgICogRmlyZWQgZm9yIGVhY2ggdmlldy10by1tb2RlbCBwb3NpdGlvbiBtYXBwaW5nIHJlcXVlc3QuIFNlZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL21hcHBlcn5NYXBwZXIjZXZlbnQ6bW9kZWxUb1ZpZXdQb3NpdGlvbn0uCiAgICoKICAgKiAJCS8vIFNlZSBleGFtcGxlIGluIGBtb2RlbFRvVmlld1Bvc2l0aW9uYCBldmVudCBkZXNjcmlwdGlvbi4KICAgKiAJCS8vIFRoaXMgY3VzdG9tIG1hcHBpbmcgd2lsbCBtYXAgcG9zaXRpb25zIGZyb20gPHNwYW4+IGVsZW1lbnQgbmV4dCB0byA8aW1nPiB0byB0aGUgImNhcHRpb25lZEltYWdlIiBlbGVtZW50LgogICAqCQltYXBwZXIub24oICd2aWV3VG9Nb2RlbFBvc2l0aW9uJywgKCBldnQsIGRhdGEgKSA9PiB7CiAgICoJCQljb25zdCBwb3NpdGlvblBhcmVudCA9IHZpZXdQb3NpdGlvbi5wYXJlbnQ7CiAgICoKICAgKgkJCWlmICggcG9zaXRpb25QYXJlbnQuaGFzQ2xhc3MoICdpbWFnZS1jYXB0aW9uJyApICkgewogICAqCQkJCWNvbnN0IHZpZXdJbWcgPSBwb3NpdGlvblBhcmVudC5wcmV2aW91c1NpYmxpbmc7CiAgICoJCQkJY29uc3QgbW9kZWxJbWcgPSBkYXRhLm1hcHBlci50b01vZGVsRWxlbWVudCggdmlld0ltZyApOwogICAqCiAgICoJCQkJZGF0YS5tb2RlbFBvc2l0aW9uID0gbmV3IE1vZGVsUG9zaXRpb24oIG1vZGVsSW1nLCB2aWV3UG9zaXRpb24ub2Zmc2V0ICk7CiAgICoJCQkJZXZ0LnN0b3AoKTsKICAgKgkJCX0KICAgKgkJfSApOwogICAqCiAgICogKipOb3RlOioqIGRlZmF1bHQgbWFwcGluZyBjYWxsYmFjayBpcyBwcm92aWRlZCB3aXRoIGBsb3dgIHByaW9yaXR5IHNldHRpbmcgYW5kIGRvZXMgbm90IGNhbmNlbCB0aGUgZXZlbnQsIHNvIGl0IGlzIHBvc3NpYmxlIHRvCiAgICogYXR0YWNoIGEgY3VzdG9tIGNhbGxiYWNrIGFmdGVyIGRlZmF1bHQgY2FsbGJhY2sgYW5kIGFsc28gdXNlIGBkYXRhLm1vZGVsUG9zaXRpb25gIGNhbGN1bGF0ZWQgYnkgZGVmYXVsdCBjYWxsYmFjawogICAqIChmb3IgZXhhbXBsZSB0byBmaXggaXQpLgogICAqCiAgICogKipOb3RlOioqIGRlZmF1bHQgbWFwcGluZyBjYWxsYmFjayB3aWxsIG5vdCBmaXJlIGlmIGBkYXRhLm1vZGVsUG9zaXRpb25gIGlzIGFscmVhZHkgc2V0LgogICAqCiAgICogKipOb3RlOioqIHRoZXNlIGNhbGxiYWNrcyBhcmUgY2FsbGVkICoqdmVyeSBvZnRlbioqLiBGb3IgZWZmaWNpZW5jeSByZWFzb25zLCBpdCBpcyBhZHZpc2VkIHRvIHVzZSB0aGVtIG9ubHkgd2hlbiBwb3NpdGlvbgogICAqIG1hcHBpbmcgYmV0d2VlbiBnaXZlbiBtb2RlbCBhbmQgdmlldyBlbGVtZW50cyBpcyB1bnNvbHZhYmxlIHVzaW5nIGp1c3QgZWxlbWVudHMgbWFwcGluZyBhbmQgZGVmYXVsdCBhbGdvcml0aG0uIEFsc28sCiAgICogdGhlIGNvbmRpdGlvbiB0aGF0IGNoZWNrcyBpZiBzcGVjaWFsIGNhc2Ugc2NlbmFyaW8gaGFwcGVuZWQgc2hvdWxkIGJlIGFzIHNpbXBsZSBhcyBwb3NzaWJsZS4KICAgKgogICAqIEBldmVudCB2aWV3VG9Nb2RlbFBvc2l0aW9uCiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgRGF0YSBwaXBlbGluZSBvYmplY3QgdGhhdCBjYW4gc3RvcmUgYW5kIHBhc3MgZGF0YSBiZXR3ZWVuIGNhbGxiYWNrcy4gVGhlIGNhbGxiYWNrIHNob3VsZCBhZGQKICAgKiBgbW9kZWxQb3NpdGlvbmAgdmFsdWUgdG8gdGhhdCBvYmplY3Qgd2l0aCBjYWxjdWxhdGVkIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3Bvc2l0aW9uflBvc2l0aW9uIG1vZGVsIHBvc2l0aW9ufS4KICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvY29udmVyc2lvbi9tYXBwZXJ+TWFwcGVyfSBkYXRhLm1hcHBlciBNYXBwZXIgaW5zdGFuY2UgdGhhdCBmaXJlZCB0aGUgZXZlbnQuCiAgICovCgoKfQptaXgoTWFwcGVyLCBFbWl0dGVyTWl4aW4pOw=="},{"version":3,"sources":["/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-engine/src/conversion/mapper.js"],"names":["ModelPosition","ModelRange","ViewPosition","ViewRange","ViewText","EmitterMixin","mix","Mapper","constructor","_modelToViewMapping","WeakMap","_viewToModelMapping","_viewToModelLengthCallbacks","Map","_markerNameToElements","_elementToMarkerNames","_unboundMarkerNames","Set","on","evt","data","viewPosition","viewContainer","get","modelPosition","parent","_findPositionIn","offset","priority","viewBlock","findMappedViewAncestor","modelParent","modelOffset","_toModelOffset","_createAt","bindElements","modelElement","viewElement","set","unbindViewElement","toModelElement","delete","has","markerName","add","unbindModelElement","toViewElement","bindElementToMarker","element","name","elements","names","unbindElementFromMarkerName","nameToElements","size","elementToNames","flushUnboundMarkerNames","markerNames","Array","from","clear","clearBindings","toModelRange","viewRange","toModelPosition","start","end","toViewRange","modelRange","toViewPosition","mapper","fire","options","isPhantom","markerNameToElements","boundElements","is","clone","getElementsWithSameId","registerViewToModelLength","viewElementName","lengthCallback","viewParent","viewOffset","offsetToParentStart","index","offsetInParent","i","getModelLength","getChild","viewNode","callback","length","len","child","getChildren","expectedOffset","lastLength","_moveViewPositionToTextNode","nodeBefore","nodeAfter"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/conversion/mapper\n */\n\nimport ModelPosition from '../model/position';\nimport ModelRange from '../model/range';\n\nimport ViewPosition from '../view/position';\nimport ViewRange from '../view/range';\nimport ViewText from '../view/text';\n\nimport EmitterMixin from '@ckeditor/ckeditor5-utils/src/emittermixin';\nimport mix from '@ckeditor/ckeditor5-utils/src/mix';\n\n/**\n * Maps elements, positions and markers between {@link module:engine/view/document~Document the view} and\n * {@link module:engine/model/model the model}.\n *\n * The instance of the Mapper used for the editing pipeline is available in\n * {@link module:engine/controller/editingcontroller~EditingController#mapper `editor.editing.mapper`}.\n *\n * Mapper uses bound elements to find corresponding elements and positions, so, to get proper results,\n * all model elements should be {@link module:engine/conversion/mapper~Mapper#bindElements bound}.\n *\n * To map complex model to/from view relations, you may provide custom callbacks for\n * {@link module:engine/conversion/mapper~Mapper#event:modelToViewPosition modelToViewPosition event} and\n * {@link module:engine/conversion/mapper~Mapper#event:viewToModelPosition viewToModelPosition event} that are fired whenever\n * a position mapping request occurs.\n * Those events are fired by {@link module:engine/conversion/mapper~Mapper#toViewPosition toViewPosition}\n * and {@link module:engine/conversion/mapper~Mapper#toModelPosition toModelPosition} methods. `Mapper` adds it's own default callbacks\n * with `'lowest'` priority. To override default `Mapper` mapping, add custom callback with higher priority and\n * stop the event.\n */\nexport default class Mapper {\n\t/**\n\t * Creates an instance of the mapper.\n\t */\n\tconstructor() {\n\t\t/**\n\t\t * Model element to view element mapping.\n\t\t *\n\t\t * @private\n\t\t * @member {WeakMap}\n\t\t */\n\t\tthis._modelToViewMapping = new WeakMap();\n\n\t\t/**\n\t\t * View element to model element mapping.\n\t\t *\n\t\t * @private\n\t\t * @member {WeakMap}\n\t\t */\n\t\tthis._viewToModelMapping = new WeakMap();\n\n\t\t/**\n\t\t * A map containing callbacks between view element names and functions evaluating length of view elements\n\t\t * in model.\n\t\t *\n\t\t * @private\n\t\t * @member {Map}\n\t\t */\n\t\tthis._viewToModelLengthCallbacks = new Map();\n\n\t\t/**\n\t\t * Model marker name to view elements mapping.\n\t\t *\n\t\t * Keys are `String`s while values are `Set`s with {@link module:engine/view/element~Element view elements}.\n\t\t * One marker (name) can be mapped to multiple elements.\n\t\t *\n\t\t * @private\n\t\t * @member {Map}\n\t\t */\n\t\tthis._markerNameToElements = new Map();\n\n\t\t/**\n\t\t * View element to model marker names mapping.\n\t\t *\n\t\t * This is reverse to {@link ~Mapper#_markerNameToElements} map.\n\t\t *\n\t\t * @private\n\t\t * @member {Map}\n\t\t */\n\t\tthis._elementToMarkerNames = new Map();\n\n\t\t/**\n\t\t * Stores marker names of markers which has changed due to unbinding a view element (so it is assumed that the view element\n\t\t * has been removed, moved or renamed).\n\t\t *\n\t\t * @private\n\t\t * @member {Set.<module:engine/model/markercollection~Marker>}\n\t\t */\n\t\tthis._unboundMarkerNames = new Set();\n\n\t\t// Default mapper algorithm for mapping model position to view position.\n\t\tthis.on( 'modelToViewPosition', ( evt, data ) => {\n\t\t\tif ( data.viewPosition ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst viewContainer = this._modelToViewMapping.get( data.modelPosition.parent );\n\n\t\t\tdata.viewPosition = this._findPositionIn( viewContainer, data.modelPosition.offset );\n\t\t}, { priority: 'low' } );\n\n\t\t// Default mapper algorithm for mapping view position to model position.\n\t\tthis.on( 'viewToModelPosition', ( evt, data ) => {\n\t\t\tif ( data.modelPosition ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst viewBlock = this.findMappedViewAncestor( data.viewPosition );\n\t\t\tconst modelParent = this._viewToModelMapping.get( viewBlock );\n\t\t\tconst modelOffset = this._toModelOffset( data.viewPosition.parent, data.viewPosition.offset, viewBlock );\n\n\t\t\tdata.modelPosition = ModelPosition._createAt( modelParent, modelOffset );\n\t\t}, { priority: 'low' } );\n\t}\n\n\t/**\n\t * Marks model and view elements as corresponding. Corresponding elements can be retrieved by using\n\t * the {@link module:engine/conversion/mapper~Mapper#toModelElement toModelElement} and\n\t * {@link module:engine/conversion/mapper~Mapper#toViewElement toViewElement} methods.\n\t * The information that elements are bound is also used to translate positions.\n\t *\n\t * @param {module:engine/model/element~Element} modelElement Model element.\n\t * @param {module:engine/view/element~Element} viewElement View element.\n\t */\n\tbindElements( modelElement, viewElement ) {\n\t\tthis._modelToViewMapping.set( modelElement, viewElement );\n\t\tthis._viewToModelMapping.set( viewElement, modelElement );\n\t}\n\n\t/**\n\t * Unbinds given {@link module:engine/view/element~Element view element} from the map.\n\t *\n\t * **Note:** view-to-model binding will be removed, if it existed. However, corresponding model-to-view binding\n\t * will be removed only if model element is still bound to passed `viewElement`.\n\t *\n\t * This behavior lets for re-binding model element to another view element without fear of losing the new binding\n\t * when the previously bound view element is unbound.\n\t *\n\t * @param {module:engine/view/element~Element} viewElement View element to unbind.\n\t */\n\tunbindViewElement( viewElement ) {\n\t\tconst modelElement = this.toModelElement( viewElement );\n\n\t\tthis._viewToModelMapping.delete( viewElement );\n\n\t\tif ( this._elementToMarkerNames.has( viewElement ) ) {\n\t\t\tfor ( const markerName of this._elementToMarkerNames.get( viewElement ) ) {\n\t\t\t\tthis._unboundMarkerNames.add( markerName );\n\t\t\t}\n\t\t}\n\n\t\tif ( this._modelToViewMapping.get( modelElement ) == viewElement ) {\n\t\t\tthis._modelToViewMapping.delete( modelElement );\n\t\t}\n\t}\n\n\t/**\n\t * Unbinds given {@link module:engine/model/element~Element model element} from the map.\n\t *\n\t * **Note:** model-to-view binding will be removed, if it existed. However, corresponding view-to-model binding\n\t * will be removed only if view element is still bound to passed `modelElement`.\n\t *\n\t * This behavior lets for re-binding view element to another model element without fear of losing the new binding\n\t * when the previously bound model element is unbound.\n\t *\n\t * @param {module:engine/model/element~Element} modelElement Model element to unbind.\n\t */\n\tunbindModelElement( modelElement ) {\n\t\tconst viewElement = this.toViewElement( modelElement );\n\n\t\tthis._modelToViewMapping.delete( modelElement );\n\n\t\tif ( this._viewToModelMapping.get( viewElement ) == modelElement ) {\n\t\t\tthis._viewToModelMapping.delete( viewElement );\n\t\t}\n\t}\n\n\t/**\n\t * Binds given marker name with given {@link module:engine/view/element~Element view element}. The element\n\t * will be added to the current set of elements bound with given marker name.\n\t *\n\t * @param {module:engine/view/element~Element} element Element to bind.\n\t * @param {String} name Marker name.\n\t */\n\tbindElementToMarker( element, name ) {\n\t\tconst elements = this._markerNameToElements.get( name ) || new Set();\n\t\telements.add( element );\n\n\t\tconst names = this._elementToMarkerNames.get( element ) || new Set();\n\t\tnames.add( name );\n\n\t\tthis._markerNameToElements.set( name, elements );\n\t\tthis._elementToMarkerNames.set( element, names );\n\t}\n\n\t/**\n\t * Unbinds an element from given marker name.\n\t *\n\t * @param {module:engine/view/element~Element} element Element to unbind.\n\t * @param {String} name Marker name.\n\t */\n\tunbindElementFromMarkerName( element, name ) {\n\t\tconst nameToElements = this._markerNameToElements.get( name );\n\n\t\tif ( nameToElements ) {\n\t\t\tnameToElements.delete( element );\n\n\t\t\tif ( nameToElements.size == 0 ) {\n\t\t\t\tthis._markerNameToElements.delete( name );\n\t\t\t}\n\t\t}\n\n\t\tconst elementToNames = this._elementToMarkerNames.get( element );\n\n\t\tif ( elementToNames ) {\n\t\t\telementToNames.delete( name );\n\n\t\t\tif ( elementToNames.size == 0 ) {\n\t\t\t\tthis._elementToMarkerNames.delete( element );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Returns all marker names of markers which has changed due to unbinding a view element (so it is assumed that the view element\n\t * has been removed, moved or renamed) since the last flush. After returning, the marker names list is cleared.\n\t *\n\t * @returns {Array.<String>}\n\t */\n\tflushUnboundMarkerNames() {\n\t\tconst markerNames = Array.from( this._unboundMarkerNames );\n\n\t\tthis._unboundMarkerNames.clear();\n\n\t\treturn markerNames;\n\t}\n\n\t/**\n\t * Removes all model to view and view to model bindings.\n\t */\n\tclearBindings() {\n\t\tthis._modelToViewMapping = new WeakMap();\n\t\tthis._viewToModelMapping = new WeakMap();\n\t\tthis._markerNameToElements = new Map();\n\t\tthis._elementToMarkerNames = new Map();\n\t\tthis._unboundMarkerNames = new Set();\n\t}\n\n\t/**\n\t * Gets the corresponding model element.\n\t *\n\t * **Note:** {@link module:engine/view/uielement~UIElement} does not have corresponding element in model.\n\t *\n\t * @param {module:engine/view/element~Element} viewElement View element.\n\t * @returns {module:engine/model/element~Element|undefined} Corresponding model element or `undefined` if not found.\n\t */\n\ttoModelElement( viewElement ) {\n\t\treturn this._viewToModelMapping.get( viewElement );\n\t}\n\n\t/**\n\t * Gets the corresponding view element.\n\t *\n\t * @param {module:engine/model/element~Element} modelElement Model element.\n\t * @returns {module:engine/view/element~Element|undefined} Corresponding view element or `undefined` if not found.\n\t */\n\ttoViewElement( modelElement ) {\n\t\treturn this._modelToViewMapping.get( modelElement );\n\t}\n\n\t/**\n\t * Gets the corresponding model range.\n\t *\n\t * @param {module:engine/view/range~Range} viewRange View range.\n\t * @returns {module:engine/model/range~Range} Corresponding model range.\n\t */\n\ttoModelRange( viewRange ) {\n\t\treturn new ModelRange( this.toModelPosition( viewRange.start ), this.toModelPosition( viewRange.end ) );\n\t}\n\n\t/**\n\t * Gets the corresponding view range.\n\t *\n\t * @param {module:engine/model/range~Range} modelRange Model range.\n\t * @returns {module:engine/view/range~Range} Corresponding view range.\n\t */\n\ttoViewRange( modelRange ) {\n\t\treturn new ViewRange( this.toViewPosition( modelRange.start ), this.toViewPosition( modelRange.end ) );\n\t}\n\n\t/**\n\t * Gets the corresponding model position.\n\t *\n\t * @fires viewToModelPosition\n\t * @param {module:engine/view/position~Position} viewPosition View position.\n\t * @returns {module:engine/model/position~Position} Corresponding model position.\n\t */\n\ttoModelPosition( viewPosition ) {\n\t\tconst data = {\n\t\t\tviewPosition,\n\t\t\tmapper: this\n\t\t};\n\n\t\tthis.fire( 'viewToModelPosition', data );\n\n\t\treturn data.modelPosition;\n\t}\n\n\t/**\n\t * Gets the corresponding view position.\n\t *\n\t * @fires modelToViewPosition\n\t * @param {module:engine/model/position~Position} modelPosition Model position.\n\t * @param {Object} [options] Additional options for position mapping process.\n\t * @param {Boolean} [options.isPhantom=false] Should be set to `true` if the model position to map is pointing to a place\n\t * in model tree which no longer exists. For example, it could be an end of a removed model range.\n\t * @returns {module:engine/view/position~Position} Corresponding view position.\n\t */\n\ttoViewPosition( modelPosition, options = { isPhantom: false } ) {\n\t\tconst data = {\n\t\t\tmodelPosition,\n\t\t\tmapper: this,\n\t\t\tisPhantom: options.isPhantom\n\t\t};\n\n\t\tthis.fire( 'modelToViewPosition', data );\n\n\t\treturn data.viewPosition;\n\t}\n\n\t/**\n\t * Gets all view elements bound to the given marker name.\n\t *\n\t * @param {String} name Marker name.\n\t * @returns {Set.<module:engine/view/element~Element>|null} View elements bound with given marker name or `null`\n\t * if no elements are bound to given marker name.\n\t */\n\tmarkerNameToElements( name ) {\n\t\tconst boundElements = this._markerNameToElements.get( name );\n\n\t\tif ( !boundElements ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst elements = new Set();\n\n\t\tfor ( const element of boundElements ) {\n\t\t\tif ( element.is( 'attributeElement' ) ) {\n\t\t\t\tfor ( const clone of element.getElementsWithSameId() ) {\n\t\t\t\t\telements.add( clone );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\telements.add( element );\n\t\t\t}\n\t\t}\n\n\t\treturn elements;\n\t}\n\n\t/**\n\t * Registers a callback that evaluates the length in the model of a view element with given name.\n\t *\n\t * The callback is fired with one argument, which is a view element instance. The callback is expected to return\n\t * a number representing the length of view element in model.\n\t *\n\t *\t\t// List item in view may contain nested list, which have other list items. In model though,\n\t *\t\t// the lists are represented by flat structure. Because of those differences, length of list view element\n\t *\t\t// may be greater than one. In the callback it's checked how many nested list items are in evaluated list item.\n\t *\n\t *\t\tfunction getViewListItemLength( element ) {\n\t *\t\t\tlet length = 1;\n\t *\n\t *\t\t\tfor ( let child of element.getChildren() ) {\n\t *\t\t\t\tif ( child.name == 'ul' || child.name == 'ol' ) {\n\t *\t\t\t\t\tfor ( let item of child.getChildren() ) {\n\t *\t\t\t\t\t\tlength += getViewListItemLength( item );\n\t *\t\t\t\t\t}\n\t *\t\t\t\t}\n\t *\t\t\t}\n\t *\n\t *\t\t\treturn length;\n\t *\t\t}\n\t *\n\t *\t\tmapper.registerViewToModelLength( 'li', getViewListItemLength );\n\t *\n\t * @param {String} viewElementName Name of view element for which callback is registered.\n\t * @param {Function} lengthCallback Function return a length of view element instance in model.\n\t */\n\tregisterViewToModelLength( viewElementName, lengthCallback ) {\n\t\tthis._viewToModelLengthCallbacks.set( viewElementName, lengthCallback );\n\t}\n\n\t/**\n\t * For given `viewPosition`, finds and returns the closest ancestor of this position that has a mapping to\n\t * the model.\n\t *\n\t * @param {module:engine/view/position~Position} viewPosition Position for which mapped ancestor should be found.\n\t * @returns {module:engine/view/element~Element}\n\t */\n\tfindMappedViewAncestor( viewPosition ) {\n\t\tlet parent = viewPosition.parent;\n\n\t\twhile ( !this._viewToModelMapping.has( parent ) ) {\n\t\t\tparent = parent.parent;\n\t\t}\n\n\t\treturn parent;\n\t}\n\n\t/**\n\t * Calculates model offset based on the view position and the block element.\n\t *\n\t * Example:\n\t *\n\t *\t\t<p>foo<b>ba|r</b></p> // _toModelOffset( b, 2, p ) -> 5\n\t *\n\t * Is a sum of:\n\t *\n\t *\t\t<p>foo|<b>bar</b></p> // _toModelOffset( p, 3, p ) -> 3\n\t *\t\t<p>foo<b>ba|r</b></p> // _toModelOffset( b, 2, b ) -> 2\n\t *\n\t * @private\n\t * @param {module:engine/view/element~Element} viewParent Position parent.\n\t * @param {Number} viewOffset Position offset.\n\t * @param {module:engine/view/element~Element} viewBlock Block used as a base to calculate offset.\n\t * @returns {Number} Offset in the model.\n\t */\n\t_toModelOffset( viewParent, viewOffset, viewBlock ) {\n\t\tif ( viewBlock != viewParent ) {\n\t\t\t// See example.\n\t\t\tconst offsetToParentStart = this._toModelOffset( viewParent.parent, viewParent.index, viewBlock );\n\t\t\tconst offsetInParent = this._toModelOffset( viewParent, viewOffset, viewParent );\n\n\t\t\treturn offsetToParentStart + offsetInParent;\n\t\t}\n\n\t\t// viewBlock == viewParent, so we need to calculate the offset in the parent element.\n\n\t\t// If the position is a text it is simple (\"ba|r\" -> 2).\n\t\tif ( viewParent.is( 'text' ) ) {\n\t\t\treturn viewOffset;\n\t\t}\n\n\t\t// If the position is in an element we need to sum lengths of siblings ( <b> bar </b> foo | -> 3 + 3 = 6 ).\n\t\tlet modelOffset = 0;\n\n\t\tfor ( let i = 0; i < viewOffset; i++ ) {\n\t\t\tmodelOffset += this.getModelLength( viewParent.getChild( i ) );\n\t\t}\n\n\t\treturn modelOffset;\n\t}\n\n\t/**\n\t * Gets the length of the view element in the model.\n\t *\n\t * The length is calculated as follows:\n\t * * if {@link #registerViewToModelLength length mapping callback} is provided for given `viewNode` it is used to\n\t * evaluate model length (`viewNode` is used as first and only parameter passed to the callback),\n\t * * length of a {@link module:engine/view/text~Text text node} is equal to the length of it's\n\t * {@link module:engine/view/text~Text#data data},\n\t * * length of a {@link module:engine/view/uielement~UIElement ui element} is equal to 0,\n\t * * length of a mapped {@link module:engine/view/element~Element element} is equal to 1,\n\t * * length of a not-mapped {@link module:engine/view/element~Element element} is equal to the length of it's children.\n\t *\n\t * Examples:\n\t *\n\t *\t\tfoo                          -> 3 // Text length is equal to it's data length.\n\t *\t\t<p>foo</p>                   -> 1 // Length of an element which is mapped is by default equal to 1.\n\t *\t\t<b>foo</b>                   -> 3 // Length of an element which is not mapped is a length of its children.\n\t *\t\t<div><p>x</p><p>y</p></div>  -> 2 // Assuming that <div> is not mapped and <p> are mapped.\n\t *\n\t * @param {module:engine/view/element~Element} viewNode View node.\n\t * @returns {Number} Length of the node in the tree model.\n\t */\n\tgetModelLength( viewNode ) {\n\t\tif ( this._viewToModelLengthCallbacks.get( viewNode.name ) ) {\n\t\t\tconst callback = this._viewToModelLengthCallbacks.get( viewNode.name );\n\n\t\t\treturn callback( viewNode );\n\t\t} else if ( this._viewToModelMapping.has( viewNode ) ) {\n\t\t\treturn 1;\n\t\t} else if ( viewNode.is( 'text' ) ) {\n\t\t\treturn viewNode.data.length;\n\t\t} else if ( viewNode.is( 'uiElement' ) ) {\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tlet len = 0;\n\n\t\t\tfor ( const child of viewNode.getChildren() ) {\n\t\t\t\tlen += this.getModelLength( child );\n\t\t\t}\n\n\t\t\treturn len;\n\t\t}\n\t}\n\n\t/**\n\t * Finds the position in the view node (or its children) with the expected model offset.\n\t *\n\t * Example:\n\t *\n\t *\t\t<p>fo<b>bar</b>bom</p> -> expected offset: 4\n\t *\n\t *\t\t_findPositionIn( p, 4 ):\n\t *\t\t<p>|fo<b>bar</b>bom</p> -> expected offset: 4, actual offset: 0\n\t *\t\t<p>fo|<b>bar</b>bom</p> -> expected offset: 4, actual offset: 2\n\t *\t\t<p>fo<b>bar</b>|bom</p> -> expected offset: 4, actual offset: 5 -> we are too far\n\t *\n\t *\t\t_findPositionIn( b, 4 - ( 5 - 3 ) ):\n\t *\t\t<p>fo<b>|bar</b>bom</p> -> expected offset: 2, actual offset: 0\n\t *\t\t<p>fo<b>bar|</b>bom</p> -> expected offset: 2, actual offset: 3 -> we are too far\n\t *\n\t *\t\t_findPositionIn( bar, 2 - ( 3 - 3 ) ):\n\t *\t\tWe are in the text node so we can simple find the offset.\n\t *\t\t<p>fo<b>ba|r</b>bom</p> -> expected offset: 2, actual offset: 2 -> position found\n\t *\n\t * @private\n\t * @param {module:engine/view/element~Element} viewParent Tree view element in which we are looking for the position.\n\t * @param {Number} expectedOffset Expected offset.\n\t * @returns {module:engine/view/position~Position} Found position.\n\t */\n\t_findPositionIn( viewParent, expectedOffset ) {\n\t\t// Last scanned view node.\n\t\tlet viewNode;\n\t\t// Length of the last scanned view node.\n\t\tlet lastLength = 0;\n\n\t\tlet modelOffset = 0;\n\t\tlet viewOffset = 0;\n\n\t\t// In the text node it is simple: offset in the model equals offset in the text.\n\t\tif ( viewParent.is( 'text' ) ) {\n\t\t\treturn new ViewPosition( viewParent, expectedOffset );\n\t\t}\n\n\t\t// In other cases we add lengths of child nodes to find the proper offset.\n\n\t\t// If it is smaller we add the length.\n\t\twhile ( modelOffset < expectedOffset ) {\n\t\t\tviewNode = viewParent.getChild( viewOffset );\n\t\t\tlastLength = this.getModelLength( viewNode );\n\t\t\tmodelOffset += lastLength;\n\t\t\tviewOffset++;\n\t\t}\n\n\t\t// If it equals we found the position.\n\t\tif ( modelOffset == expectedOffset ) {\n\t\t\treturn this._moveViewPositionToTextNode( new ViewPosition( viewParent, viewOffset ) );\n\t\t}\n\t\t// If it is higher we need to enter last child.\n\t\telse {\n\t\t\t// ( modelOffset - lastLength ) is the offset to the child we enter,\n\t\t\t// so we subtract it from the expected offset to fine the offset in the child.\n\t\t\treturn this._findPositionIn( viewNode, expectedOffset - ( modelOffset - lastLength ) );\n\t\t}\n\t}\n\n\t/**\n\t * Because we prefer positions in text nodes over positions next to text node moves view position to the text node\n\t * if it was next to it.\n\t *\n\t *\t\t<p>[]<b>foo</b></p> -> <p>[]<b>foo</b></p> // do not touch if position is not directly next to text\n\t *\t\t<p>foo[]<b>foo</b></p> -> <p>foo{}<b>foo</b></p> // move to text node\n\t *\t\t<p><b>[]foo</b></p> -> <p><b>{}foo</b></p> // move to text node\n\t *\n\t * @private\n\t * @param {module:engine/view/position~Position} viewPosition Position potentially next to text node.\n\t * @returns {module:engine/view/position~Position} Position in text node if possible.\n\t */\n\t_moveViewPositionToTextNode( viewPosition ) {\n\t\t// If the position is just after text node, put it at the end of that text node.\n\t\t// If the position is just before text node, put it at the beginning of that text node.\n\t\tconst nodeBefore = viewPosition.nodeBefore;\n\t\tconst nodeAfter = viewPosition.nodeAfter;\n\n\t\tif ( nodeBefore instanceof ViewText ) {\n\t\t\treturn new ViewPosition( nodeBefore, nodeBefore.data.length );\n\t\t} else if ( nodeAfter instanceof ViewText ) {\n\t\t\treturn new ViewPosition( nodeAfter, 0 );\n\t\t}\n\n\t\t// Otherwise, just return the given position.\n\t\treturn viewPosition;\n\t}\n\n\t/**\n\t * Fired for each model-to-view position mapping request. The purpose of this event is to enable custom model-to-view position\n\t * mapping. Callbacks added to this event take {@link module:engine/model/position~Position model position} and are expected to\n\t * calculate {@link module:engine/view/position~Position view position}. Calculated view position should be added as `viewPosition`\n\t * value in `data` object that is passed as one of parameters to the event callback.\n\t *\n\t * \t\t// Assume that \"captionedImage\" model element is converted to <img> and following <span> elements in view,\n\t * \t\t// and the model element is bound to <img> element. Force mapping model positions inside \"captionedImage\" to that\n\t * \t\t// <span> element.\n\t *\t\tmapper.on( 'modelToViewPosition', ( evt, data ) => {\n\t *\t\t\tconst positionParent = modelPosition.parent;\n\t *\n\t *\t\t\tif ( positionParent.name == 'captionedImage' ) {\n\t *\t\t\t\tconst viewImg = data.mapper.toViewElement( positionParent );\n\t *\t\t\t\tconst viewCaption = viewImg.nextSibling; // The <span> element.\n\t *\n\t *\t\t\t\tdata.viewPosition = new ViewPosition( viewCaption, modelPosition.offset );\n\t *\n\t *\t\t\t\t// Stop the event if other callbacks should not modify calculated value.\n\t *\t\t\t\tevt.stop();\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * **Note:** keep in mind that sometimes a \"phantom\" model position is being converted. \"Phantom\" model position is\n\t * a position that points to a non-existing place in model. Such position might still be valid for conversion, though\n\t * (it would point to a correct place in view when converted). One example of such situation is when a range is\n\t * removed from model, there may be a need to map the range's end (which is no longer valid model position). To\n\t * handle such situation, check `data.isPhantom` flag:\n\t *\n\t * \t\t// Assume that there is \"customElement\" model element and whenever position is before it, we want to move it\n\t * \t\t// to the inside of the view element bound to \"customElement\".\n\t *\t\tmapper.on( 'modelToViewPosition', ( evt, data ) => {\n\t *\t\t\tif ( data.isPhantom ) {\n\t *\t\t\t\treturn;\n\t *\t\t\t}\n\t *\n\t *\t\t\t// Below line might crash for phantom position that does not exist in model.\n\t *\t\t\tconst sibling = data.modelPosition.nodeBefore;\n\t *\n\t *\t\t\t// Check if this is the element we are interested in.\n\t *\t\t\tif ( !sibling.is( 'customElement' ) ) {\n\t *\t\t\t\treturn;\n\t *\t\t\t}\n\t *\n\t *\t\t\tconst viewElement = data.mapper.toViewElement( sibling );\n\t *\n\t *\t\t\tdata.viewPosition = new ViewPosition( sibling, 0 );\n\t *\n\t *\t\t\tevt.stop();\n\t *\t\t} );\n\t *\n\t * **Note:** default mapping callback is provided with `low` priority setting and does not cancel the event, so it is possible to\n\t * attach a custom callback after default callback and also use `data.viewPosition` calculated by default callback\n\t * (for example to fix it).\n\t *\n\t * **Note:** default mapping callback will not fire if `data.viewPosition` is already set.\n\t *\n\t * **Note:** these callbacks are called **very often**. For efficiency reasons, it is advised to use them only when position\n\t * mapping between given model and view elements is unsolvable using just elements mapping and default algorithm. Also,\n\t * the condition that checks if special case scenario happened should be as simple as possible.\n\t *\n\t * @event modelToViewPosition\n\t * @param {Object} data Data pipeline object that can store and pass data between callbacks. The callback should add\n\t * `viewPosition` value to that object with calculated {@link module:engine/view/position~Position view position}.\n\t * @param {module:engine/conversion/mapper~Mapper} data.mapper Mapper instance that fired the event.\n\t */\n\n\t/**\n\t * Fired for each view-to-model position mapping request. See {@link module:engine/conversion/mapper~Mapper#event:modelToViewPosition}.\n\t *\n\t * \t\t// See example in `modelToViewPosition` event description.\n\t * \t\t// This custom mapping will map positions from <span> element next to <img> to the \"captionedImage\" element.\n\t *\t\tmapper.on( 'viewToModelPosition', ( evt, data ) => {\n\t *\t\t\tconst positionParent = viewPosition.parent;\n\t *\n\t *\t\t\tif ( positionParent.hasClass( 'image-caption' ) ) {\n\t *\t\t\t\tconst viewImg = positionParent.previousSibling;\n\t *\t\t\t\tconst modelImg = data.mapper.toModelElement( viewImg );\n\t *\n\t *\t\t\t\tdata.modelPosition = new ModelPosition( modelImg, viewPosition.offset );\n\t *\t\t\t\tevt.stop();\n\t *\t\t\t}\n\t *\t\t} );\n\t *\n\t * **Note:** default mapping callback is provided with `low` priority setting and does not cancel the event, so it is possible to\n\t * attach a custom callback after default callback and also use `data.modelPosition` calculated by default callback\n\t * (for example to fix it).\n\t *\n\t * **Note:** default mapping callback will not fire if `data.modelPosition` is already set.\n\t *\n\t * **Note:** these callbacks are called **very often**. For efficiency reasons, it is advised to use them only when position\n\t * mapping between given model and view elements is unsolvable using just elements mapping and default algorithm. Also,\n\t * the condition that checks if special case scenario happened should be as simple as possible.\n\t *\n\t * @event viewToModelPosition\n\t * @param {Object} data Data pipeline object that can store and pass data between callbacks. The callback should add\n\t * `modelPosition` value to that object with calculated {@link module:engine/model/position~Position model position}.\n\t * @param {module:engine/conversion/mapper~Mapper} data.mapper Mapper instance that fired the event.\n\t */\n}\n\nmix( Mapper, EmitterMixin );\n"]}]}