{"remainingRequest":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/babel-loader/lib/index.js!/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-engine/src/model/operation/transform.js","dependencies":[{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-engine/src/model/operation/transform.js","mtime":499162500000},{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js","mtime":499162500000},{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/babel-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:LyoqCiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDE5LCBDS1NvdXJjZSAtIEZyZWRlcmljbyBLbmFiYmVuLiBBbGwgcmlnaHRzIHJlc2VydmVkLgogKiBGb3IgbGljZW5zaW5nLCBzZWUgTElDRU5TRS5tZCBvciBodHRwczovL2NrZWRpdG9yLmNvbS9sZWdhbC9ja2VkaXRvci1vc3MtbGljZW5zZQogKi8KaW1wb3J0IEluc2VydE9wZXJhdGlvbiBmcm9tICcuL2luc2VydG9wZXJhdGlvbic7CmltcG9ydCBBdHRyaWJ1dGVPcGVyYXRpb24gZnJvbSAnLi9hdHRyaWJ1dGVvcGVyYXRpb24nOwppbXBvcnQgUmVuYW1lT3BlcmF0aW9uIGZyb20gJy4vcmVuYW1lb3BlcmF0aW9uJzsKaW1wb3J0IE1hcmtlck9wZXJhdGlvbiBmcm9tICcuL21hcmtlcm9wZXJhdGlvbic7CmltcG9ydCBNb3ZlT3BlcmF0aW9uIGZyb20gJy4vbW92ZW9wZXJhdGlvbic7CmltcG9ydCBSb290QXR0cmlidXRlT3BlcmF0aW9uIGZyb20gJy4vcm9vdGF0dHJpYnV0ZW9wZXJhdGlvbic7CmltcG9ydCBNZXJnZU9wZXJhdGlvbiBmcm9tICcuL21lcmdlb3BlcmF0aW9uJzsKaW1wb3J0IFNwbGl0T3BlcmF0aW9uIGZyb20gJy4vc3BsaXRvcGVyYXRpb24nOwppbXBvcnQgTm9PcGVyYXRpb24gZnJvbSAnLi9ub29wZXJhdGlvbic7CmltcG9ydCBSYW5nZSBmcm9tICcuLi9yYW5nZSc7CmltcG9ydCBQb3NpdGlvbiBmcm9tICcuLi9wb3NpdGlvbic7CmltcG9ydCBjb21wYXJlQXJyYXlzIGZyb20gJ0Bja2VkaXRvci9ja2VkaXRvcjUtdXRpbHMvc3JjL2NvbXBhcmVhcnJheXMnOwpjb25zdCB0cmFuc2Zvcm1hdGlvbnMgPSBuZXcgTWFwKCk7Ci8qKgogKiBAbW9kdWxlIGVuZ2luZS9tb2RlbC9vcGVyYXRpb24vdHJhbnNmb3JtCiAqLwoKLyoqCiAqIFNldHMgYSB0cmFuc2Zvcm1hdGlvbiBmdW5jdGlvbiB0byBiZSBiZSB1c2VkIHRvIHRyYW5zZm9ybSBpbnN0YW5jZXMgb2YgY2xhc3MgYE9wZXJhdGlvbkFgIGJ5IGluc3RhbmNlcyBvZiBjbGFzcyBgT3BlcmF0aW9uQmAuCiAqCiAqIFRoZSBgdHJhbnNmb3JtYXRpb25GdW5jdGlvbmAgaXMgcGFzc2VkIHRocmVlIHBhcmFtZXRlcnM6CiAqCiAqICogYGFgIC0gb3BlcmF0aW9uIHRvIGJlIHRyYW5zZm9ybWVkLCBhbiBpbnN0YW5jZSBvZiBgT3BlcmF0aW9uQWAsCiAqICogYGJgIC0gb3BlcmF0aW9uIHRvIGJlIHRyYW5zZm9ybWVkIGJ5LCBhbiBpbnN0YW5jZSBvZiBgT3BlcmF0aW9uQmAsCiAqICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvb3BlcmF0aW9uL3RyYW5zZm9ybX5UcmFuc2Zvcm1hdGlvbkNvbnRleHQgYGNvbnRleHRgfSAtIG9iamVjdCB3aXRoIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQKICogdHJhbnNmb3JtYXRpb24gY29udGV4dC4KICoKICogVGhlIGB0cmFuc2Zvcm1hdGlvbkZ1bmN0aW9uYCBzaG91bGQgcmV0dXJuIHRyYW5zZm9ybWF0aW9uIHJlc3VsdCwgd2hpY2ggaXMgYW4gYXJyYXkgd2l0aCBvbmUgb3IgbXVsdGlwbGUKICoge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvb3BlcmF0aW9uL29wZXJhdGlvbn5PcGVyYXRpb24gb3BlcmF0aW9ufSBpbnN0YW5jZXMuCiAqCiAqIEBwcm90ZWN0ZWQKICogQHBhcmFtIHtGdW5jdGlvbn0gT3BlcmF0aW9uQQogKiBAcGFyYW0ge0Z1bmN0aW9ufSBPcGVyYXRpb25CCiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybWF0aW9uRnVuY3Rpb24gRnVuY3Rpb24gdG8gdXNlIGZvciB0cmFuc2Zvcm1pbmcuCiAqLwoKZnVuY3Rpb24gc2V0VHJhbnNmb3JtYXRpb24oT3BlcmF0aW9uQSwgT3BlcmF0aW9uQiwgdHJhbnNmb3JtYXRpb25GdW5jdGlvbikgewogIGxldCBhR3JvdXAgPSB0cmFuc2Zvcm1hdGlvbnMuZ2V0KE9wZXJhdGlvbkEpOwoKICBpZiAoIWFHcm91cCkgewogICAgYUdyb3VwID0gbmV3IE1hcCgpOwogICAgdHJhbnNmb3JtYXRpb25zLnNldChPcGVyYXRpb25BLCBhR3JvdXApOwogIH0KCiAgYUdyb3VwLnNldChPcGVyYXRpb25CLCB0cmFuc2Zvcm1hdGlvbkZ1bmN0aW9uKTsKfQovKioKICogUmV0dXJucyBhIHByZXZpb3VzbHkgc2V0IHRyYW5zZm9ybWF0aW9uIGZ1bmN0aW9uIGZvciB0cmFuc2Zvcm1pbmcgYW4gaW5zdGFuY2Ugb2YgYE9wZXJhdGlvbkFgIGJ5IGFuIGluc3RhbmNlIG9mIGBPcGVyYXRpb25CYC4KICoKICogSWYgbm8gdHJhbnNmb3JtYXRpb24gd2FzIHNldCBmb3IgZ2l2ZW4gcGFpciBvZiBvcGVyYXRpb25zLCB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9vcGVyYXRpb24vdHJhbnNmb3Jtfm5vVXBkYXRlVHJhbnNmb3JtYXRpb259CiAqIGlzIHJldHVybmVkLiBUaGlzIG1lYW5zIHRoYXQgaWYgbm8gdHJhbnNmb3JtYXRpb24gd2FzIHNldCwgdGhlIGBPcGVyYXRpb25BYCBpbnN0YW5jZSB3aWxsIG5vdCBjaGFuZ2Ugd2hlbiB0cmFuc2Zvcm1lZAogKiBieSB0aGUgYE9wZXJhdGlvbkJgIGluc3RhbmNlLgogKgogKiBAcHJpdmF0ZQogKiBAcGFyYW0ge0Z1bmN0aW9ufSBPcGVyYXRpb25BCiAqIEBwYXJhbSB7RnVuY3Rpb259IE9wZXJhdGlvbkIKICogQHJldHVybnMge0Z1bmN0aW9ufSBGdW5jdGlvbiBzZXQgdG8gdHJhbnNmb3JtIGFuIGluc3RhbmNlIG9mIGBPcGVyYXRpb25BYCBieSBhbiBpbnN0YW5jZSBvZiBgT3BlcmF0aW9uQmAuCiAqLwoKCmZ1bmN0aW9uIGdldFRyYW5zZm9ybWF0aW9uKE9wZXJhdGlvbkEsIE9wZXJhdGlvbkIpIHsKICBjb25zdCBhR3JvdXAgPSB0cmFuc2Zvcm1hdGlvbnMuZ2V0KE9wZXJhdGlvbkEpOwoKICBpZiAoYUdyb3VwICYmIGFHcm91cC5oYXMoT3BlcmF0aW9uQikpIHsKICAgIHJldHVybiBhR3JvdXAuZ2V0KE9wZXJhdGlvbkIpOwogIH0KCiAgcmV0dXJuIG5vVXBkYXRlVHJhbnNmb3JtYXRpb247Cn0KLyoqCiAqIEEgdHJhbnNmb3JtYXRpb24gZnVuY3Rpb24gdGhhdCBvbmx5IGNsb25lcyBvcGVyYXRpb24gdG8gdHJhbnNmb3JtLCB3aXRob3V0IGNoYW5naW5nIGl0LgogKgogKiBAcHJpdmF0ZQogKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvb3BlcmF0aW9uL29wZXJhdGlvbn5PcGVyYXRpb259IGEgT3BlcmF0aW9uIHRvIHRyYW5zZm9ybS4KICogQHJldHVybnMge0FycmF5Ljxtb2R1bGU6ZW5naW5lL21vZGVsL29wZXJhdGlvbi9vcGVyYXRpb25+T3BlcmF0aW9uPn0KICovCgoKZnVuY3Rpb24gbm9VcGRhdGVUcmFuc2Zvcm1hdGlvbihhKSB7CiAgcmV0dXJuIFthXTsKfQovKioKICogVHJhbnNmb3JtcyBvcGVyYXRpb24gYGFgIGJ5IG9wZXJhdGlvbiBgYmAuCiAqCiAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9vcGVyYXRpb24vb3BlcmF0aW9ufk9wZXJhdGlvbn0gYSBPcGVyYXRpb24gdG8gYmUgdHJhbnNmb3JtZWQuCiAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9vcGVyYXRpb24vb3BlcmF0aW9ufk9wZXJhdGlvbn0gYiBPcGVyYXRpb24gdG8gdHJhbnNmb3JtIGJ5LgogKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvb3BlcmF0aW9uL3RyYW5zZm9ybX5UcmFuc2Zvcm1hdGlvbkNvbnRleHR9IGNvbnRleHQgVHJhbnNmb3JtYXRpb24gY29udGV4dCBmb3IgdGhpcyB0cmFuc2Zvcm1hdGlvbi4KICogQHJldHVybnMge0FycmF5Ljxtb2R1bGU6ZW5naW5lL21vZGVsL29wZXJhdGlvbi9vcGVyYXRpb25+T3BlcmF0aW9uPn0gVHJhbnNmb3JtYXRpb24gcmVzdWx0LgogKi8KCgpleHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtKGEsIGIsIGNvbnRleHQgPSB7fSkgewogIGNvbnN0IHRyYW5zZm9ybWF0aW9uRnVuY3Rpb24gPSBnZXRUcmFuc2Zvcm1hdGlvbihhLmNvbnN0cnVjdG9yLCBiLmNvbnN0cnVjdG9yKTsKCiAgdHJ5IHsKICAgIGEgPSBhLmNsb25lKCk7CiAgICByZXR1cm4gdHJhbnNmb3JtYXRpb25GdW5jdGlvbihhLCBiLCBjb250ZXh0KTsKICB9IGNhdGNoIChlKSB7CiAgICAvLyBAaWYgQ0tfREVCVUcgLy8gY29uc29sZS53YXJuKCAnRXJyb3IgZHVyaW5nIG9wZXJhdGlvbiB0cmFuc2Zvcm1hdGlvbiEnLCBlLm1lc3NhZ2UgKTsKICAgIC8vIEBpZiBDS19ERUJVRyAvLyBjb25zb2xlLndhcm4oICdUcmFuc2Zvcm1lZCBvcGVyYXRpb24nLCBhICk7CiAgICAvLyBAaWYgQ0tfREVCVUcgLy8gY29uc29sZS53YXJuKCAnT3BlcmF0aW9uIHRyYW5zZm9ybWVkIGJ5JywgYiApOwogICAgLy8gQGlmIENLX0RFQlVHIC8vIGNvbnNvbGUud2FybiggJ2NvbnRleHQuYUlzU3Ryb25nJywgY29udGV4dC5hSXNTdHJvbmcgKTsKICAgIC8vIEBpZiBDS19ERUJVRyAvLyBjb25zb2xlLndhcm4oICdjb250ZXh0LmFXYXNVbmRvbmUnLCBjb250ZXh0LmFXYXNVbmRvbmUgKTsKICAgIC8vIEBpZiBDS19ERUJVRyAvLyBjb25zb2xlLndhcm4oICdjb250ZXh0LmJXYXNVbmRvbmUnLCBjb250ZXh0LmJXYXNVbmRvbmUgKTsKICAgIC8vIEBpZiBDS19ERUJVRyAvLyBjb25zb2xlLndhcm4oICdjb250ZXh0LmFiUmVsYXRpb24nLCBjb250ZXh0LmFiUmVsYXRpb24gKTsKICAgIC8vIEBpZiBDS19ERUJVRyAvLyBjb25zb2xlLndhcm4oICdjb250ZXh0LmJhUmVsYXRpb24nLCBjb250ZXh0LmJhUmVsYXRpb24gKTsKICAgIHRocm93IGU7CiAgfQp9Ci8qKgogKiBQZXJmb3JtcyBhIHRyYW5zZm9ybWF0aW9uIG9mIHR3byBzZXRzIG9mIG9wZXJhdGlvbnMgLSBgb3BlcmF0aW9uc0FgIGFuZCBgb3BlcmF0aW9uc0JgLiBUaGUgdHJhbnNmb3JtYXRpb24gaXMgdHdvLXdheSAtCiAqIGJvdGggdHJhbnNmb3JtZWQgYG9wZXJhdGlvbnNBYCBhbmQgdHJhbnNmb3JtZWQgYG9wZXJhdGlvbnNCYCBhcmUgcmV0dXJuZWQuCiAqCiAqIE5vdGUsIHRoYXQgdGhlIGZpcnN0IG9wZXJhdGlvbiBpbiBlYWNoIHNldCBzaG91bGQgYmFzZSBvbiB0aGUgc2FtZSBkb2N1bWVudCBzdGF0ZSAoCiAqIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2RvY3VtZW50fkRvY3VtZW50I3ZlcnNpb24gZG9jdW1lbnQgdmVyc2lvbn0pLgogKgogKiBJdCBpcyBhc3N1bWVkIHRoYXQgYG9wZXJhdGlvbnNBYCBhcmUgIm1vcmUgaW1wb3J0YW50IiBkdXJpbmcgY29uZmxpY3QgcmVzb2x1dGlvbiBiZXR3ZWVuIHR3byBvcGVyYXRpb25zLgogKgogKiBOZXcgY29waWVzIG9mIGJvdGggcGFzc2VkIGFycmF5cyBhbmQgb3BlcmF0aW9ucyBpbnNpZGUgdGhlbSBhcmUgcmV0dXJuZWQuIFBhc3NlZCBhcmd1bWVudHMgYXJlIG5vdCBhbHRlcmVkLgogKgogKiBCYXNlIHZlcnNpb25zIG9mIHRoZSB0cmFuc2Zvcm1lZCBvcGVyYXRpb25zIHNldHMgYXJlIHVwZGF0ZWQgYWNjb3JkaW5nbHkuIEZvciBleGFtcGxlLCBhc3N1bWUgdGhhdCBiYXNlIHZlcnNpb25zIGFyZSBgNGAKICogYW5kIHRoZXJlIGFyZSBgM2Agb3BlcmF0aW9ucyBpbiBgb3BlcmF0aW9uc0FgIGFuZCBgNWAgb3BlcmF0aW9ucyBpbiBgb3BlcmF0aW9uc0JgLiBUaGVuOgogKgogKiAqIHRyYW5zZm9ybWVkIGBvcGVyYXRpb25zQWAgd2lsbCBzdGFydCBmcm9tIGJhc2UgdmVyc2lvbiBgOWAgKGA0YCBiYXNlIHZlcnNpb24gKyBgNWAgb3BlcmF0aW9ucyBCKSwKICogKiB0cmFuc2Zvcm1lZCBgb3BlcmF0aW9uc0JgIHdpbGwgc3RhcnQgZnJvbSBiYXNlIHZlcnNpb24gYDdgIChgNGAgYmFzZSB2ZXJzaW9uICsgYDNgIG9wZXJhdGlvbnMgQSkuCiAqCiAqIElmIG5vIG9wZXJhdGlvbiB3YXMgYnJva2VuIGludG8gdHdvIGR1cmluZyB0cmFuc2Zvcm1hdGlvbiwgdGhlbiBib3RoIHNldHMgd2lsbCBlbmQgdXAgd2l0aCBhbiBvcGVyYXRpb24gdGhhdCBiYXNlcyBvbiB2ZXJzaW9uIGAxMWA6CiAqCiAqICogdHJhbnNmb3JtZWQgYG9wZXJhdGlvbnNBYCBzdGFydCBmcm9tIGA5YCBhbmQgdGhlcmUgYXJlIGAzYCBvZiB0aGVtLCBzbyB0aGUgbGFzdCB3aWxsIGhhdmUgYGJhc2VWZXJzaW9uYCBlcXVhbCB0byBgMTFgLAogKiAqIHRyYW5zZm9ybWVkIGBvcGVyYXRpb25zQmAgc3RhcnQgZnJvbSBgN2AgYW5kIHRoZXJlIGFyZSBgNWAgb2YgdGhlbSwgc28gdGhlIGxhc3Qgd2lsbCBoYXZlIGBiYXNlVmVyc2lvbmAgZXF1YWwgdG8gYDExYC4KICoKICogQHBhcmFtIHtBcnJheS48bW9kdWxlOmVuZ2luZS9tb2RlbC9vcGVyYXRpb24vb3BlcmF0aW9ufk9wZXJhdGlvbj59IG9wZXJhdGlvbnNBCiAqIEBwYXJhbSB7QXJyYXkuPG1vZHVsZTplbmdpbmUvbW9kZWwvb3BlcmF0aW9uL29wZXJhdGlvbn5PcGVyYXRpb24+fSBvcGVyYXRpb25zQgogKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBBZGRpdGlvbmFsIHRyYW5zZm9ybWF0aW9uIG9wdGlvbnMuCiAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudH5Eb2N1bWVudHxudWxsfSBvcHRpb25zLmRvY3VtZW50IERvY3VtZW50IHdoaWNoIHRoZSBvcGVyYXRpb25zIGNoYW5nZS4KICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy51c2VSZWxhdGlvbnM9ZmFsc2VdIFdoZXRoZXIgZHVyaW5nIHRyYW5zZm9ybWF0aW9uIHJlbGF0aW9ucyBzaG91bGQgYmUgdXNlZCAodXNlZCBkdXJpbmcgdW5kbyBmb3IKICogYmV0dGVyIGNvbmZsaWN0IHJlc29sdXRpb24pLgogKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnBhZFdpdGhOb09wcz1mYWxzZV0gV2hldGhlciBhZGRpdGlvbmFsIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL29wZXJhdGlvbi9ub29wZXJhdGlvbn5Ob09wZXJhdGlvbn1zCiAqIHNob3VsZCBiZSBhZGRlZCB0byB0aGUgdHJhbnNmb3JtYXRpb24gcmVzdWx0cyB0byBmb3JjZSB0aGUgc2FtZSBsYXN0IGJhc2UgdmVyc2lvbiBmb3IgYm90aCB0cmFuc2Zvcm1lZCBzZXRzIChpbiBjYXNlCiAqIGlmIHNvbWUgb3BlcmF0aW9ucyBnb3QgYnJva2VuIGludG8gbXVsdGlwbGUgb3BlcmF0aW9ucyBkdXJpbmcgdHJhbnNmb3JtYXRpb24pLgogKiBAcmV0dXJucyB7T2JqZWN0fSBUcmFuc2Zvcm1hdGlvbiByZXN1bHQuCiAqIEByZXR1cm5zIHtBcnJheS48bW9kdWxlOmVuZ2luZS9tb2RlbC9vcGVyYXRpb24vb3BlcmF0aW9ufk9wZXJhdGlvbj59IHJldHVybi5vcGVyYXRpb25zQSBUcmFuc2Zvcm1lZCBgb3BlcmF0aW9uc0FgLgogKiBAcmV0dXJucyB7QXJyYXkuPG1vZHVsZTplbmdpbmUvbW9kZWwvb3BlcmF0aW9uL29wZXJhdGlvbn5PcGVyYXRpb24+fSByZXR1cm4ub3BlcmF0aW9uc0IgVHJhbnNmb3JtZWQgYG9wZXJhdGlvbnNCYC4KICogQHJldHVybnMge01hcH0gcmV0dXJuLm9yaWdpbmFsT3BlcmF0aW9ucyBBIG1hcCB0aGF0IGxpbmtzIHRyYW5zZm9ybWVkIG9wZXJhdGlvbnMgdG8gb3JpZ2luYWwgb3BlcmF0aW9ucy4gVGhlIGtleXMgYXJlIHRoZSB0cmFuc2Zvcm1lZAogKiBvcGVyYXRpb25zIGFuZCB0aGUgdmFsdWVzIGFyZSB0aGUgb3JpZ2luYWwgb3BlcmF0aW9ucyBmcm9tIHRoZSBpbnB1dCAoYG9wZXJhdGlvbnNBYCBhbmQgYG9wZXJhdGlvbnNCYCkuCiAqLwoKZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybVNldHMob3BlcmF0aW9uc0EsIG9wZXJhdGlvbnNCLCBvcHRpb25zKSB7CiAgLy8gQ3JlYXRlIG5ldyBhcnJheXMgc28gdGhlIG9yaWdpbmFsbHkgcGFzc2VkIGFyZ3VtZW50cyBhcmUgbm90IGNoYW5nZWQuCiAgLy8gTm8gbmVlZCB0byBjbG9uZSBvcGVyYXRpb25zLCB0aGV5IGFyZSBjbG9uZWQgYXMgdGhleSBhcmUgdHJhbnNmb3JtZWQuCiAgb3BlcmF0aW9uc0EgPSBvcGVyYXRpb25zQS5zbGljZSgpOwogIG9wZXJhdGlvbnNCID0gb3BlcmF0aW9uc0Iuc2xpY2UoKTsKICBjb25zdCBjb250ZXh0RmFjdG9yeSA9IG5ldyBDb250ZXh0RmFjdG9yeShvcHRpb25zLmRvY3VtZW50LCBvcHRpb25zLnVzZVJlbGF0aW9ucywgb3B0aW9ucy5mb3JjZVdlYWtSZW1vdmUpOwogIGNvbnRleHRGYWN0b3J5LnNldE9yaWdpbmFsT3BlcmF0aW9ucyhvcGVyYXRpb25zQSk7CiAgY29udGV4dEZhY3Rvcnkuc2V0T3JpZ2luYWxPcGVyYXRpb25zKG9wZXJhdGlvbnNCKTsKICBjb25zdCBvcmlnaW5hbE9wZXJhdGlvbnMgPSBjb250ZXh0RmFjdG9yeS5vcmlnaW5hbE9wZXJhdGlvbnM7IC8vIElmIG9uZSBvZiBzZXRzIGlzIGVtcHR5IHRoZXJlIGlzIHNpbXBseSBub3RoaW5nIHRvIHRyYW5zZm9ybSwgc28gcmV0dXJuIHNldHMgYXMgdGhleSBhcmUuCgogIGlmIChvcGVyYXRpb25zQS5sZW5ndGggPT0gMCB8fCBvcGVyYXRpb25zQi5sZW5ndGggPT0gMCkgewogICAgcmV0dXJuIHsKICAgICAgb3BlcmF0aW9uc0EsCiAgICAgIG9wZXJhdGlvbnNCLAogICAgICBvcmlnaW5hbE9wZXJhdGlvbnMKICAgIH07CiAgfSAvLwogIC8vIEZvbGxvd2luZyBpcyBhIGRlc2NyaXB0aW9uIG9mIHRyYW5zZm9ybWF0aW9uIHByb2Nlc3M6CiAgLy8KICAvLyBUaGVyZSBhcmUgYG9wZXJhdGlvbnNBYCBhbmQgYG9wZXJhdGlvbnNCYCB0byBiZSB0cmFuc2Zvcm1lZCwgYm90aCBieSBib3RoLgogIC8vCiAgLy8gU28sIHN1cHBvc2Ugd2UgaGF2ZSBzZXRzIG9mIHR3byBvcGVyYXRpb25zIGVhY2g6IGBvcGVyYXRpb25zQWAgPSBgWyBhMSwgYTIgXWAsIGBvcGVyYXRpb25zQmAgPSBgWyBiMSwgYjIgXWAuCiAgLy8KICAvLyBSZW1lbWJlciwgdGhhdCB3ZSBjYW4gb25seSB0cmFuc2Zvcm0gb3BlcmF0aW9ucyB0aGF0IGJhc2Ugb24gdGhlIHNhbWUgY29udGV4dC4gV2UgYXNzZXJ0IHRoYXQgYGExYCBhbmQgYGIxYCBiYXNlIG9uCiAgLy8gdGhlIHNhbWUgY29udGV4dCBhbmQgd2UgdHJhbnNmb3JtIHRoZW0uIFRoZW4sIHdlIGdldCBgYTEnYCBhbmQgYGIxJ2AuIGBhMmAgYmFzZXMgb24gYSBjb250ZXh0IHdpdGggYGExYCAtLSBgYTJgCiAgLy8gaXMgYW4gb3BlcmF0aW9uIHRoYXQgZm9sbG93ZWQgYGExYC4gU2ltaWxhcmx5LCBgYjJgIGJhc2VzIG9uIGEgY29udGV4dCB3aXRoIGBiMWAuCiAgLy8KICAvLyBIb3dldmVyLCBzaW5jZSBgYTEnYCBpcyBhIHJlc3VsdCBvZiB0cmFuc2Zvcm1hdGlvbiBieSBgYjFgLCBgYTEnYCBub3cgYWxzbyBoYXMgYSBjb250ZXh0IHdpdGggYGIxYC4gVGhpcyBtZWFucyB0aGF0CiAgLy8gd2UgY2FuIHNhZmVseSB0cmFuc2Zvcm0gYGExJ2AgYnkgYGIyYC4gQXMgd2UgZmluaXNoIHRyYW5zZm9ybWluZyBgYTFgLCB3ZSBhbHNvIHRyYW5zZm9ybWVkIGFsbCBgb3BlcmF0aW9uc0JgLgogIC8vIEFsbCBgb3BlcmF0aW9uc0JgIGFsc28gaGF2ZSBjb250ZXh0IGluY2x1ZGluZyBgYTFgLiBOb3csIHdlIGNhbiBwcm9wZXJseSB0cmFuc2Zvcm0gYGEyYCBieSB0aG9zZSBvcGVyYXRpb25zLgogIC8vCiAgLy8gVGhlIHRyYW5zZm9ybWF0aW9uIHByb2Nlc3MgY2FuIGJlIHZpc3VhbGl6ZWQgb24gYSB0cmFuc2Zvcm1hdGlvbiBkaWFncmFtICgiZGlhbW9uZCBkaWFncmFtIik6CiAgLy8KICAvLyAgICAgICAgICBbdGhlIGluaXRpYWwgc3RhdGVdCiAgLy8gICAgICAgICBbY29tbW9uIGZvciBhMSBhbmQgYjFdCiAgLy8KICAvLyAgICAgICAgICAgICAgICAgICAqCiAgLy8gICAgICAgICAgICAgICAgICAvIFwKICAvLyAgICAgICAgICAgICAgICAgLyAgIFwKICAvLyAgICAgICAgICAgICAgIGIxICAgICBhMQogIC8vICAgICAgICAgICAgICAgLyAgICAgICBcCiAgLy8gICAgICAgICAgICAgIC8gICAgICAgICBcCiAgLy8gICAgICAgICAgICAgKiAgICAgICAgICAgKgogIC8vICAgICAgICAgICAgLyBcICAgICAgICAgLyBcCiAgLy8gICAgICAgICAgIC8gICBcICAgICAgIC8gICBcCiAgLy8gICAgICAgICBiMiAgICBhMScgICBiMScgICAgYTIKICAvLyAgICAgICAgIC8gICAgICAgXCAgIC8gICAgICAgXAogIC8vICAgICAgICAvICAgICAgICAgXCAvICAgICAgICAgXAogIC8vICAgICAgICogICAgICAgICAgICogICAgICAgICAgICoKICAvLyAgICAgICAgXCAgICAgICAgIC8gXCAgICAgICAgIC8KICAvLyAgICAgICAgIFwgICAgICAgLyAgIFwgICAgICAgLwogIC8vICAgICAgICBhMScnICAgYjInICAgYTInICAgYjEnJwogIC8vICAgICAgICAgICBcICAgLyAgICAgICBcICAgLwogIC8vICAgICAgICAgICAgXCAvICAgICAgICAgXCAvCiAgLy8gICAgICAgICAgICAgKiAgICAgICAgICAgKgogIC8vICAgICAgICAgICAgICBcICAgICAgICAgLwogIC8vICAgICAgICAgICAgICAgXCAgICAgICAvCiAgLy8gICAgICAgICAgICAgIGEyJycgICBiMicnCiAgLy8gICAgICAgICAgICAgICAgIFwgICAvCiAgLy8gICAgICAgICAgICAgICAgICBcIC8KICAvLyAgICAgICAgICAgICAgICAgICAqCiAgLy8KICAvLyAgICAgICAgICAgW3RoZSBmaW5hbCBzdGF0ZV0KICAvLwogIC8vIFRoZSBmaW5hbCBzdGF0ZSBjYW4gYmUgcmVhY2hlZCBmcm9tIHRoZSBpbml0aWFsIHN0YXRlIGJ5IGFwcGx5aW5nIGBhMWAsIGBhMmAsIGBiMScnYCBhbmQgYGIyJydgLCBhcyB3ZWxsIGFzIGJ5CiAgLy8gYXBwbHlpbmcgYGIxYCwgYGIyYCwgYGExJydgLCBgYTInJ2AuIE5vdGUgaG93IHRoZSBvcGVyYXRpb25zIGdldCB0byBhIHByb3BlciBjb21tb24gc3RhdGUgYmVmb3JlIGVhY2ggcGFpciBpcwogIC8vIHRyYW5zZm9ybWVkLgogIC8vCiAgLy8gQW5vdGhlciB0aGluZyB0byBjb25zaWRlciBpcyB0aGF0IGFuIG9wZXJhdGlvbiBkdXJpbmcgdHJhbnNmb3JtYXRpb24gY2FuIGJlIGJyb2tlbiBpbnRvIG11bHRpcGxlIG9wZXJhdGlvbnMuCiAgLy8gU3VwcG9zZSB0aGF0IGBhMWAgKiBgYjFgID0gYFsgYTExJywgYTEyJyBdYCAoaW5zdGVhZCBvZiBgYTEnYCB0aGF0IHdlIGNvbnNpZGVyZWQgcHJldmlvdXNseSkuCiAgLy8KICAvLyBJbiB0aGF0IGNhc2UsIHdlIGxlYXZlIGBhMTInYCBmb3IgbGF0ZXIgYW5kIHdlIGNvbnRpbnVlIHRyYW5zZm9ybWluZyBgYTExJ2AgdW50aWwgaXQgaXMgdHJhbnNmb3JtZWQgYnkgYWxsIGBvcGVyYXRpb25zQmAKICAvLyAoaW4gb3VyIGNhc2UgaXQgaXMganVzdCBgYjJgKS4gQXQgdGhpcyBwb2ludCwgYGIxYCBpcyB0cmFuc2Zvcm1lZCBieSAid2hvbGUiIGBhMWAsIHdoaWxlIGBiMmAgaXMgb25seSB0cmFuc2Zvcm1lZAogIC8vIGJ5IGBhMTEnYC4gU2ltaWxhcmx5LCBgYTEyJ2AgaXMgb25seSB0cmFuc2Zvcm1lZCBieSBgYjFgLiBUaGlzIGxlYWRzIHRvIGEgY29uY2x1c2lvbiB0aGF0IHdlIG5lZWQgdG8gc3RhcnQgdHJhbnNmb3JtaW5nIGBhMTInYAogIC8vIGZyb20gdGhlIG1vbWVudCBqdXN0IGFmdGVyIGl0IHdhcyBicm9rZW4uIFNvLCBgYTEyJ2AgaXMgdHJhbnNmb3JtZWQgYnkgYGIyYC4gTm93LCAidGhlIHdob2xlIiBgYTFgIGlzIHRyYW5zZm9ybWVkCiAgLy8gYnkgYG9wZXJhdGlvbnNCYCwgd2hpbGUgYWxsIGBvcGVyYXRpb25zQmAgYXJlIHRyYW5zZm9ybWVkIGJ5ICJ0aGUgd2hvbGUiIGBhMWAuIFRoaXMgbWVhbnMgdGhhdCB3ZSBjYW4gY29udGludWUgd2l0aAogIC8vIGZvbGxvd2luZyBgb3BlcmF0aW9uc0FgIChpbiBvdXIgY2FzZSBpdCBpcyBqdXN0IGBhMmApLgogIC8vCiAgLy8gT2YgY291cnNlLCBhbHNvIGBvcGVyYXRpb25zQmAgY2FuIGJlIGJyb2tlbi4gSG93ZXZlciwgc2luY2Ugd2UgZm9jdXMgb24gdHJhbnNmb3JtaW5nIG9wZXJhdGlvbiBgYWAgdG8gdGhlIGVuZCwKICAvLyB0aGUgb25seSB0aGluZyB0byBkbyBpcyB0byBzdG9yZSBib3RoIHBpZWNlcyBvZiBvcGVyYXRpb24gYGJgLCBzbyB0aGF0IHRoZSBuZXh0IHRyYW5zZm9ybWVkIG9wZXJhdGlvbiBgYWAgd2lsbAogIC8vIGJlIHRyYW5zZm9ybWVkIGJ5IGJvdGggb2YgdGhlbS4KICAvLwogIC8vICAgICAgICAgICAgICAgICAgICAgICAqCiAgLy8gICAgICAgICAgICAgICAgICAgICAgLyBcCiAgLy8gICAgICAgICAgICAgICAgICAgICAvICAgXAogIC8vICAgICAgICAgICAgICAgICAgICAvICAgICBcCiAgLy8gICAgICAgICAgICAgICAgICBiMSAgICAgICBhMQogIC8vICAgICAgICAgICAgICAgICAgLyAgICAgICAgIFwKICAvLyAgICAgICAgICAgICAgICAgLyAgICAgICAgICAgXAogIC8vICAgICAgICAgICAgICAgIC8gICAgICAgICAgICAgXAogIC8vICAgICAgICAgICAgICAgKiAgICAgICAgICAgICAgICoKICAvLyAgICAgICAgICAgICAgLyBcICAgICAgICAgICAgIC8gXAogIC8vICAgICAgICAgICAgIC8gIGExMScgICAgICAgICAvICAgXAogIC8vICAgICAgICAgICAgLyAgICAgXCAgICAgICAgIC8gICAgIFwKICAvLyAgICAgICAgICBiMiAgICAgICAqICAgICAgYjEnICAgICAgYTIKICAvLyAgICAgICAgICAvICAgICAgIC8gXCAgICAgLyAgICAgICAgIFwKICAvLyAgICAgICAgIC8gICAgICAgLyAgYTEyJyAvICAgICAgICAgICBcCiAgLy8gICAgICAgIC8gICAgICAgLyAgICAgXCAvICAgICAgICAgICAgIFwKICAvLyAgICAgICAqICAgICAgIGIyJyAgICAgKiAgICAgICAgICAgICAgICoKICAvLyAgICAgICAgXCAgICAgLyAgICAgICAvIFwgICAgICAgICAgICAgLwogIC8vICAgICAgIGExMScnIC8gICAgIGIyMScnIFwgICAgICAgICAgIC8KICAvLyAgICAgICAgICBcIC8gICAgICAgLyAgICAgXCAgICAgICAgIC8KICAvLyAgICAgICAgICAgKiAgICAgICAqICAgICAgYTInICAgICBiMScnCiAgLy8gICAgICAgICAgICBcICAgICAvIFwgICAgICAgXCAgICAgLwogIC8vICAgICAgICAgIGExMicnIGIyMicnXCAgICAgICBcICAgLwogIC8vICAgICAgICAgICAgICBcIC8gICAgIFwgICAgICAgXCAvCiAgLy8gICAgICAgICAgICAgICAqICAgICAgYTInJyAgICAgKgogIC8vICAgICAgICAgICAgICAgIFwgICAgICAgXCAgICAgLwogIC8vICAgICAgICAgICAgICAgICBcICAgICAgIFwgIGIyMScnJwogIC8vICAgICAgICAgICAgICAgICAgXCAgICAgICBcIC8KICAvLyAgICAgICAgICAgICAgICBhMicnJyAgICAgICoKICAvLyAgICAgICAgICAgICAgICAgICAgXCAgICAgLwogIC8vICAgICAgICAgICAgICAgICAgICAgXCAgYjIyJycnCiAgLy8gICAgICAgICAgICAgICAgICAgICAgXCAvCiAgLy8gICAgICAgICAgICAgICAgICAgICAgICoKICAvLwogIC8vIE5vdGUsIGhvdyBgYTFgIGlzIGJyb2tlbiBhbmQgdHJhbnNmb3JtZWQgaW50byBgYTExJ2AgYW5kIGBhMTInYCwgd2hpbGUgYGIyJ2AgZ290IGJyb2tlbiBhbmQgdHJhbnNmb3JtZWQgaW50byBgYjIxJydgIGFuZCBgYjIyJydgLgogIC8vCiAgLy8gSGF2aW5nIGFsbCB0aGF0IG9uIG1pbmQsIGhlcmUgaXMgYW4gb3V0bGluZSBmb3IgdGhlIHRyYW5zZm9ybWF0aW9uIHByb2Nlc3MgYWxnb3JpdGhtOgogIC8vCiAgLy8gMS4gV2UgaGF2ZSBgb3BlcmF0aW9uc0FgIGFuZCBgb3BlcmF0aW9uc0JgIGFycmF5LCB3aGljaCB3ZSBkeW5hbWljYWxseSB1cGRhdGUgYXMgdGhlIHRyYW5zZm9ybWF0aW9uIHByb2Nlc3MgZ29lcy4KICAvLwogIC8vIDIuIFdlIHRha2UgbmV4dCAob3IgZmlyc3QpIG9wZXJhdGlvbiBmcm9tIGBvcGVyYXRpb25zQWAgYW5kIGNoZWNrIGZyb20gd2hpY2ggb3BlcmF0aW9uIGBiYCB3ZSBuZWVkIHRvIHN0YXJ0IHRyYW5zZm9ybWluZyBpdC4KICAvLyBBbGwgb3JpZ2luYWwgYG9wZXJhdGlvbnNBYCBhcmUgc2V0IHRvIGJlIHRyYW5zZm9ybWVkIHN0YXJ0aW5nIGZyb20gdGhlIGZpcnN0IG9wZXJhdGlvbiBgYmAuCiAgLy8KICAvLyAzLiBXZSB0YWtlIG9wZXJhdGlvbnMgZnJvbSBgb3BlcmF0aW9uc0JgLCBvbmUgYnkgb25lLCBzdGFydGluZyBmcm9tIHRoZSBjb3JyZWN0IG9uZSwgYW5kIHRyYW5zZm9ybSBvcGVyYXRpb24gYGFgCiAgLy8gYnkgb3BlcmF0aW9uIGBiYCAoYW5kIHZpY2UgdmVyc2EpLiBXZSB1cGRhdGUgYG9wZXJhdGlvbnNBYCBhbmQgYG9wZXJhdGlvbnNCYCBieSByZXBsYWNpbmcgdGhlIG9yaWdpbmFsIG9wZXJhdGlvbnMKICAvLyB3aXRoIHRoZSB0cmFuc2Zvcm1hdGlvbiByZXN1bHRzLgogIC8vCiAgLy8gNC4gSWYgb3BlcmF0aW9uIGlzIGJyb2tlbiBpbnRvIG11bHRpcGxlIG9wZXJhdGlvbnMsIHdlIHNhdmUgYWxsIHRoZSBuZXcgb3BlcmF0aW9ucyBpbiB0aGUgcGxhY2Ugb2YgdGhlCiAgLy8gb3JpZ2luYWwgb3BlcmF0aW9uLgogIC8vCiAgLy8gNS4gQWRkaXRpb25hbGx5LCBpZiBvcGVyYXRpb24gYGFgIHdhcyBicm9rZW4sIGZvciB0aGUgIm5ldyIgb3BlcmF0aW9uLCB3ZSByZW1lbWJlciBmcm9tIHdoaWNoIG9wZXJhdGlvbiBgYmAgaXQgc2hvdWxkCiAgLy8gYmUgdHJhbnNmb3JtZWQgYnkuCiAgLy8KICAvLyA2LiBXZSBjb250aW51ZSB0cmFuc2Zvcm1pbmcgImN1cnJlbnQiIG9wZXJhdGlvbiBgYWAgdW50aWwgaXQgaXMgdHJhbnNmb3JtZWQgYnkgYWxsIGBvcGVyYXRpb25zQmAuIFRoZW4sIGdvIHRvIDIuCiAgLy8gdW5sZXNzIHRoZSBsYXN0IG9wZXJhdGlvbiBgYWAgd2FzIHRyYW5zZm9ybWVkLgogIC8vCiAgLy8gVGhlIGFjdHVhbCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgYWJvdmUgYWxnb3JpdGhtIGlzIHNsaWdodGx5IGRpZmZlcmVudCwgYXMgb25seSBvbmUgbG9vcCAod2hpbGUpIGlzIHVzZWQuCiAgLy8gVGhlIGRpZmZlcmVuY2UgaXMgdGhhdCB3ZSBoYXZlICJjdXJyZW50IiBgYWAgb3BlcmF0aW9uIHRvIHRyYW5zZm9ybSBhbmQgd2Ugc3RvcmUgdGhlIGluZGV4IG9mIHRoZSBuZXh0IGBiYCBvcGVyYXRpb24KICAvLyB0byB0cmFuc2Zvcm0gYnkuIEVhY2ggbG9vcCBvcGVyYXRlcyBvbiB0d28gaW5kZXhlcyB0aGVuOiBpbmRleCBwb2ludGluZyB0byBjdXJyZW50bHkgcHJvY2Vzc2VkIGBhYCBvcGVyYXRpb24gYW5kCiAgLy8gaW5kZXggcG9pbnRpbmcgdG8gbmV4dCBgYmAgb3BlcmF0aW9uLiBFYWNoIGxvb3AgaXMganVzdCBvbmUgYGEgKiBiYCArIGBiICogYWAgdHJhbnNmb3JtYXRpb24uIEFmdGVyIGVhY2ggbG9vcAogIC8vIG9wZXJhdGlvbiBgYmAgaW5kZXggaXMgdXBkYXRlZC4gSWYgYWxsIGBiYCBvcGVyYXRpb25zIHdlcmUgdmlzaXRlZCBmb3IgdGhlIGN1cnJlbnQgYGFgIG9wZXJhdGlvbiwgd2UgY2hhbmdlCiAgLy8gY3VycmVudCBgYWAgb3BlcmF0aW9uIGluZGV4IHRvIHRoZSBuZXh0IG9uZS4KICAvLwogIC8vIEZvciBlYWNoIG9wZXJhdGlvbiBgYWAsIGtlZXBzIGluZm9ybWF0aW9uIHdoYXQgaXMgdGhlIGluZGV4IGluIGBvcGVyYXRpb25zQmAgZnJvbSB3aGljaCB0aGUgdHJhbnNmb3JtYXRpb24gc2hvdWxkIHN0YXJ0LgoKCiAgY29uc3QgbmV4dFRyYW5zZm9ybUluZGV4ID0gbmV3IFdlYWtNYXAoKTsgLy8gRm9yIGFsbCB0aGUgb3JpZ2luYWwgYG9wZXJhdGlvbnNBYCwgc2V0IHRoYXQgdGhleSBzaG91bGQgYmUgdHJhbnNmb3JtZWQgc3RhcnRpbmcgZnJvbSB0aGUgZmlyc3Qgb2YgYG9wZXJhdGlvbnNCYC4KCiAgZm9yIChjb25zdCBvcCBvZiBvcGVyYXRpb25zQSkgewogICAgbmV4dFRyYW5zZm9ybUluZGV4LnNldChvcCwgMCk7CiAgfSAvLyBBZGRpdGlvbmFsIGRhdGEgdGhhdCBpcyB1c2VkIGZvciBzb21lIHBvc3Rwcm9jZXNzaW5nIGFmdGVyIHRoZSBtYWluIHRyYW5zZm9ybWF0aW9uIHByb2Nlc3MgaXMgZG9uZS4KCgogIGNvbnN0IGRhdGEgPSB7CiAgICBuZXh0QmFzZVZlcnNpb25BOiBvcGVyYXRpb25zQVtvcGVyYXRpb25zQS5sZW5ndGggLSAxXS5iYXNlVmVyc2lvbiArIDEsCiAgICBuZXh0QmFzZVZlcnNpb25COiBvcGVyYXRpb25zQltvcGVyYXRpb25zQi5sZW5ndGggLSAxXS5iYXNlVmVyc2lvbiArIDEsCiAgICBvcmlnaW5hbE9wZXJhdGlvbnNBQ291bnQ6IG9wZXJhdGlvbnNBLmxlbmd0aCwKICAgIG9yaWdpbmFsT3BlcmF0aW9uc0JDb3VudDogb3BlcmF0aW9uc0IubGVuZ3RoCiAgfTsgLy8gSW5kZXggb2YgY3VycmVudGx5IHRyYW5zZm9ybWVkIG9wZXJhdGlvbiBgYWAuCgogIGxldCBpID0gMDsgLy8gV2hpbGUgbm90IGFsbCBgb3BlcmF0aW9uc0FgIGFyZSB0cmFuc2Zvcm1lZC4uLgoKICB3aGlsZSAoaSA8IG9wZXJhdGlvbnNBLmxlbmd0aCkgewogICAgLy8gR2V0ICJjdXJyZW50IiBvcGVyYXRpb24gYGFgLgogICAgY29uc3Qgb3BBID0gb3BlcmF0aW9uc0FbaV07IC8vIEZvciB0aGUgImN1cnJlbnQiIG9wZXJhdGlvbiBgYWAsIGdldCB0aGUgaW5kZXggb2YgdGhlIG5leHQgb3BlcmF0aW9uIGBiYCB0byB0cmFuc2Zvcm0gYnkuCgogICAgY29uc3QgaW5kZXhCID0gbmV4dFRyYW5zZm9ybUluZGV4LmdldChvcEEpOyAvLyBJZiBvcGVyYXRpb24gYGFgIHdhcyBhbHJlYWR5IHRyYW5zZm9ybWVkIGJ5IGV2ZXJ5IG9wZXJhdGlvbiBgYmAsIGNoYW5nZSAiY3VycmVudCIgb3BlcmF0aW9uIGBhYCB0byB0aGUgbmV4dCBvbmUuCgogICAgaWYgKGluZGV4QiA9PSBvcGVyYXRpb25zQi5sZW5ndGgpIHsKICAgICAgaSsrOwogICAgICBjb250aW51ZTsKICAgIH0KCiAgICBjb25zdCBvcEIgPSBvcGVyYXRpb25zQltpbmRleEJdOyAvLyBUcmFuc2Zvcm0gYGFgIGJ5IGBiYCBhbmQgYGJgIGJ5IGBhYC4KCiAgICBjb25zdCBuZXdPcHNBID0gdHJhbnNmb3JtKG9wQSwgb3BCLCBjb250ZXh0RmFjdG9yeS5nZXRDb250ZXh0KG9wQSwgb3BCLCB0cnVlKSk7CiAgICBjb25zdCBuZXdPcHNCID0gdHJhbnNmb3JtKG9wQiwgb3BBLCBjb250ZXh0RmFjdG9yeS5nZXRDb250ZXh0KG9wQiwgb3BBLCBmYWxzZSkpOyAvLyBBcyBhIHJlc3VsdCB3ZSBnZXQgb25lIG9yIG1vcmUgYG5ld09wc0FgIGFuZCBvbmUgb3IgbW9yZSBgbmV3T3BzQmAgb3BlcmF0aW9ucy4KICAgIC8vIFVwZGF0ZSBjb250ZXh0dWFsIGluZm9ybWF0aW9uIGFib3V0IG9wZXJhdGlvbnMuCgogICAgY29udGV4dEZhY3RvcnkudXBkYXRlUmVsYXRpb24ob3BBLCBvcEIpOwogICAgY29udGV4dEZhY3Rvcnkuc2V0T3JpZ2luYWxPcGVyYXRpb25zKG5ld09wc0EsIG9wQSk7CiAgICBjb250ZXh0RmFjdG9yeS5zZXRPcmlnaW5hbE9wZXJhdGlvbnMobmV3T3BzQiwgb3BCKTsgLy8gRm9yIG5ldyBgYWAgb3BlcmF0aW9ucywgdXBkYXRlIHRoZWlyIGluZGV4IG9mIHRoZSBuZXh0IG9wZXJhdGlvbiBgYmAgdG8gdHJhbnNmb3JtIHRoZW0gYnkuCiAgICAvLwogICAgLy8gVGhpcyBpcyBuZWVkZWQgZXZlbiBpZiB0aGVyZSB3YXMgb25seSBvbmUgcmVzdWx0IChgYWAgd2FzIG5vdCBicm9rZW4pIGJlY2F1c2UgdGhhdCBpbmZvcm1hdGlvbiBpcyB1c2VkCiAgICAvLyBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoaXMgbG9vcCBldmVyeSB0aW1lLgoKICAgIGZvciAoY29uc3QgbmV3T3BBIG9mIG5ld09wc0EpIHsKICAgICAgLy8gQWNrbm93bGVkZ2UsIHRoYXQgb3BlcmF0aW9uIGBiYCBhbHNvIG1pZ2h0IGJlIGJyb2tlbiBpbnRvIG11bHRpcGxlIG9wZXJhdGlvbnMuCiAgICAgIC8vCiAgICAgIC8vIFRoaXMgaXMgd2h5IHdlIHJhaXNlIGBpbmRleEJgIG5vdCBqdXN0IGJ5IDEuIElmIGBuZXdPcHNCYCBhcmUgbXVsdGlwbGUgb3BlcmF0aW9ucywgdGhleSB3aWxsIGJlCiAgICAgIC8vIHNwbGljZWQgaW4gdGhlIHBsYWNlIG9mIGBvcEJgLiBTbyB3ZSBuZWVkIHRvIGNoYW5nZSBgdHJhbnNmb3JtQnlgIGFjY29yZGluZ2x5LCBzbyB0aGF0IGFuIG9wZXJhdGlvbiB3b24ndAogICAgICAvLyBiZSB0cmFuc2Zvcm1lZCBieSB0aGUgc2FtZSBvcGVyYXRpb24gKHBhcnQgb2YgaXQpIGFnYWluLgogICAgICBuZXh0VHJhbnNmb3JtSW5kZXguc2V0KG5ld09wQSwgaW5kZXhCICsgbmV3T3BzQi5sZW5ndGgpOwogICAgfSAvLyBVcGRhdGUgYG9wZXJhdGlvbnNBYCBhbmQgYG9wZXJhdGlvbnNCYCB3aXRoIHRoZSB0cmFuc2Zvcm1lZCB2ZXJzaW9ucy4KCgogICAgb3BlcmF0aW9uc0Euc3BsaWNlKGksIDEsIC4uLm5ld09wc0EpOwogICAgb3BlcmF0aW9uc0Iuc3BsaWNlKGluZGV4QiwgMSwgLi4ubmV3T3BzQik7CiAgfQoKICBpZiAob3B0aW9ucy5wYWRXaXRoTm9PcHMpIHsKICAgIC8vIElmIG5vLW9wZXJhdGlvbnMgcGFkZGluZyBpcyBlbmFibGVkLCBjb3VudCBob3cgbWFueSBleHRyYSBgYWAgYW5kIGBiYCBvcGVyYXRpb25zIHdlcmUgZ2VuZXJhdGVkLgogICAgY29uc3QgYnJva2VuT3BlcmF0aW9uc0FDb3VudCA9IG9wZXJhdGlvbnNBLmxlbmd0aCAtIGRhdGEub3JpZ2luYWxPcGVyYXRpb25zQUNvdW50OwogICAgY29uc3QgYnJva2VuT3BlcmF0aW9uc0JDb3VudCA9IG9wZXJhdGlvbnNCLmxlbmd0aCAtIGRhdGEub3JpZ2luYWxPcGVyYXRpb25zQkNvdW50OyAvLyBUaGVuLCBpZiB0aGF0IG51bWJlciBpcyBub3QgdGhlIHNhbWUsIHBhZCBgb3BlcmF0aW9uc0FgIG9yIGBvcGVyYXRpb25zQmAgd2l0aCBjb3JyZWN0IG51bWJlciBvZiBuby1vcHMgc28KICAgIC8vIHRoYXQgdGhlIGJhc2UgdmVyc2lvbnMgYXJlIGVxdWFsbGVkLgogICAgLy8KICAgIC8vIE5vdGUgdGhhdCBvbmx5IG9uZSBhcnJheSB3aWxsIGJlIHVwZGF0ZWQsIGFzIG9ubHkgb25lIG9mIHRob3NlIHN1YnRyYWN0aW9ucyBjYW4gYmUgZ3JlYXRlciB0aGFuIHplcm8uCgogICAgcGFkV2l0aE5vT3BzKG9wZXJhdGlvbnNBLCBicm9rZW5PcGVyYXRpb25zQkNvdW50IC0gYnJva2VuT3BlcmF0aW9uc0FDb3VudCk7CiAgICBwYWRXaXRoTm9PcHMob3BlcmF0aW9uc0IsIGJyb2tlbk9wZXJhdGlvbnNBQ291bnQgLSBicm9rZW5PcGVyYXRpb25zQkNvdW50KTsKICB9IC8vIEZpbmFsbHksIHVwZGF0ZSBiYXNlIHZlcnNpb25zIG9mIHRyYW5zZm9ybWVkIG9wZXJhdGlvbnMuCgoKICB1cGRhdGVCYXNlVmVyc2lvbnMob3BlcmF0aW9uc0EsIGRhdGEubmV4dEJhc2VWZXJzaW9uQik7CiAgdXBkYXRlQmFzZVZlcnNpb25zKG9wZXJhdGlvbnNCLCBkYXRhLm5leHRCYXNlVmVyc2lvbkEpOwogIHJldHVybiB7CiAgICBvcGVyYXRpb25zQSwKICAgIG9wZXJhdGlvbnNCLAogICAgb3JpZ2luYWxPcGVyYXRpb25zCiAgfTsKfSAvLyBHYXRoZXJzIGFkZGl0aW9uYWwgZGF0YSBhYm91dCBvcGVyYXRpb25zIHByb2Nlc3NlZCBkdXJpbmcgdHJhbnNmb3JtYXRpb24uIENhbiBiZSB1c2VkIHRvIG9idGFpbiBjb250ZXh0dWFsIGluZm9ybWF0aW9uCi8vIGFib3V0IHR3byBvcGVyYXRpb25zIHRoYXQgYXJlIGFib3V0IHRvIGJlIHRyYW5zZm9ybWVkLiBUaGlzIGNvbnRleHR1YWwgaW5mb3JtYXRpb24gY2FuIGJlIHVzZWQgZm9yIGJldHRlciBjb25mbGljdCByZXNvbHV0aW9uLgoKY2xhc3MgQ29udGV4dEZhY3RvcnkgewogIC8vIENyZWF0ZXMgYENvbnRleHRGYWN0b3J5YCBpbnN0YW5jZS4KICAvLwogIC8vIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9kb2N1bWVudH5Eb2N1bWVudH0gZG9jdW1lbnQgRG9jdW1lbnQgd2hpY2ggdGhlIG9wZXJhdGlvbnMgY2hhbmdlLgogIC8vIEBwYXJhbSB7Qm9vbGVhbn0gdXNlUmVsYXRpb25zIFdoZXRoZXIgZHVyaW5nIHRyYW5zZm9ybWF0aW9uIHJlbGF0aW9ucyBzaG91bGQgYmUgdXNlZCAodXNlZCBkdXJpbmcgdW5kbyBmb3IKICAvLyBiZXR0ZXIgY29uZmxpY3QgcmVzb2x1dGlvbikuCiAgLy8gQHBhcmFtIHtCb29sZWFufSBbZm9yY2VXZWFrUmVtb3ZlPWZhbHNlXSBJZiBzZXQgdG8gYGZhbHNlYCwgcmVtb3ZlIG9wZXJhdGlvbiB3aWxsIGJlIGFsd2F5cyBzdHJvbmdlciB0aGFuIG1vdmUgb3BlcmF0aW9uLAogIC8vIHNvIHRoZSByZW1vdmVkIG5vZGVzIHdvbid0IGVuZCB1cCBiYWNrIGluIHRoZSBkb2N1bWVudCByb290LiBXaGVuIHNldCB0byBgdHJ1ZWAsIGNvbnRleHQgZGF0YSB3aWxsIGJlIHVzZWQuCiAgY29uc3RydWN0b3IoZG9jdW1lbnQsIHVzZVJlbGF0aW9ucywgZm9yY2VXZWFrUmVtb3ZlID0gZmFsc2UpIHsKICAgIC8vIEZvciBlYWNoIG9wZXJhdGlvbiB0aGF0IGlzIGNyZWF0ZWQgZHVyaW5nIHRyYW5zZm9ybWF0aW9uIHByb2Nlc3MsIHdlIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIG9yaWdpbmFsIG9wZXJhdGlvbgogICAgLy8gd2hpY2ggaXQgY29tZXMgZnJvbS4gVGhlIG9yaWdpbmFsIG9wZXJhdGlvbiB3b3JrcyBhcyBhIGtpbmQgb2YgImlkZW50aWZpZXIiLiBFdmVyeSBjb250ZXh0dWFsIGluZm9ybWF0aW9uCiAgICAvLyBnYXRoZXJlZCBkdXJpbmcgdHJhbnNmb3JtYXRpb24gdGhhdCB3ZSB3YW50IHRvIHNhdmUgZm9yIGdpdmVuIG9wZXJhdGlvbiwgaXMgYWN0dWFsbHkgc2F2ZWQgZm9yIHRoZSBvcmlnaW5hbCBvcGVyYXRpb24uCiAgICAvLyBUaGlzIHdheSBubyBtYXR0ZXIgaWYgb3BlcmF0aW9uIGBhYCBpcyBjbG9uZWQsIHRoZW4gdHJhbnNmb3JtZWQsIGV2ZW4gYnJlYWtzLCB3ZSBzdGlsbCBoYXZlIGFjY2VzcyB0byB0aGUgcHJldmlvdXNseQogICAgLy8gZ2F0aGVyZWQgZGF0YSB0aHJvdWdoIG9yaWdpbmFsIG9wZXJhdGlvbiByZWZlcmVuY2UuCiAgICB0aGlzLm9yaWdpbmFsT3BlcmF0aW9ucyA9IG5ldyBNYXAoKTsgLy8gYG1vZGVsLkhpc3RvcnlgIGluc3RhbmNlIHdoaWNoIGluZm9ybWF0aW9uIGFib3V0IHVuZG9uZSBvcGVyYXRpb25zIHdpbGwgYmUgdGFrZW4gZnJvbS4KCiAgICB0aGlzLl9oaXN0b3J5ID0gZG9jdW1lbnQuaGlzdG9yeTsgLy8gV2hldGhlciBhZGRpdGlvbmFsIGNvbnRleHQgc2hvdWxkIGJlIHVzZWQuCgogICAgdGhpcy5fdXNlUmVsYXRpb25zID0gdXNlUmVsYXRpb25zOwogICAgdGhpcy5fZm9yY2VXZWFrUmVtb3ZlID0gISFmb3JjZVdlYWtSZW1vdmU7IC8vIFJlbGF0aW9ucyBpcyBhIGRvdWJsZS1tYXAgc3RydWN0dXJlIChtYXBzIGluIG1hcCkgd2hlcmUgZm9yIHR3byBvcGVyYXRpb25zIHdlIHN0b3JlIGhvdyB0aG9zZSBvcGVyYXRpb25zIHdlcmUgcmVsYXRlZAogICAgLy8gdG8gZWFjaCBvdGhlci4gVGhvc2UgcmVsYXRpb25zIGFyZSBldmFsdWF0ZWQgZHVyaW5nIHRyYW5zZm9ybWF0aW9uIHByb2Nlc3MuIEZvciBldmVyeSB0cmFuc2Zvcm1hdGVkIHBhaXIgb2Ygb3BlcmF0aW9ucwogICAgLy8gd2Uga2VlcCByZWxhdGlvbnMgYmV0d2VlbiB0aGVtLgoKICAgIHRoaXMuX3JlbGF0aW9ucyA9IG5ldyBNYXAoKTsKICB9IC8vIFNldHMgIm9yaWdpbmFsIG9wZXJhdGlvbiIgZm9yIGdpdmVuIG9wZXJhdGlvbnMuCiAgLy8KICAvLyBEdXJpbmcgdHJhbnNmb3JtYXRpb24gcHJvY2Vzcywgb3BlcmF0aW9ucyBhcmUgY2xvbmVkLCB0aGVuIGNoYW5nZWQsIHRoZW4gcHJvY2Vzc2VkIGFnYWluLCBzb21ldGltZXMgYnJva2VuIGludG8gdHdvCiAgLy8gb3IgbXVsdGlwbGUgb3BlcmF0aW9ucy4gV2hlbiBnYXRoZXJpbmcgYWRkaXRpb25hbCBkYXRhIGl0IGlzIGltcG9ydGFudCB0aGF0IGFsbCBvcGVyYXRpb25zIGNhbiBiZSBzb21laG93IGxpbmtlZAogIC8vIHNvIGEgY2xvbmVkIGFuZCB0cmFuc2Zvcm1lZCAidmVyc2lvbiIgc3RpbGwga2VwdCB0cmFjayBvZiB0aGUgZGF0YSBhc3NpZ25lZCBlYXJsaWVyIHRvIGl0LgogIC8vCiAgLy8gVGhlIG9yaWdpbmFsIG9wZXJhdGlvbiBvYmplY3Qgd2lsbCBiZSB1c2VkIGFzIHN1Y2ggYW4gdW5pdmVyc2FsIGxpbmtpbmcgaWQuIFRocm91Z2hvdXQgdGhlIHRyYW5zZm9ybWF0aW9uIHByb2Nlc3MKICAvLyBhbGwgY2xvbmVkIG9wZXJhdGlvbnMgd2lsbCByZWZlciB0byAidGhlIG9yaWdpbmFsIG9wZXJhdGlvbiIgd2hlbiBzdG9yaW5nIGFuZCByZWFkaW5nIGFkZGl0aW9uYWwgZGF0YS4KICAvLwogIC8vIElmIGB0YWtlRnJvbWAgaXMgbm90IHNldCwgZWFjaCBvcGVyYXRpb24gZnJvbSBgb3BlcmF0aW9uc2AgYXJyYXkgd2lsbCBiZSBhc3NpZ25lZCBpdHNlbGYgYXMgInRoZSBvcmlnaW5hbCBvcGVyYXRpb24iLgogIC8vIFRoaXMgc2hvdWxkIGJlIHVzZWQgYXMgYW4gaW5pdGlhbGl6YXRpb24gc3RlcC4KICAvLwogIC8vIElmIGB0YWtlRnJvbWAgaXMgc2V0LCBlYWNoIG9wZXJhdGlvbiBmcm9tIGBvcGVyYXRpb25zYCB3aWxsIGJlIGFzc2lnbmVkIHRoZSBzYW1lIG9yaWdpbmFsIG9wZXJhdGlvbiBhcyBhc3NpZ25lZAogIC8vIGZvciBgdGFrZUZyb21gIG9wZXJhdGlvbi4gVGhpcyBzaG91bGQgYmUgdXNlZCB0byB1cGRhdGUgb3JpZ2luYWwgb3BlcmF0aW9ucy4gSXQgc2hvdWxkIGJlIHVzZWQgaW4gYSB3YXkgdGhhdAogIC8vIGBvcGVyYXRpb25zYCBhcmUgdGhlIHJlc3VsdCBvZiBgdGFrZUZyb21gIHRyYW5zZm9ybWF0aW9uIHRvIGVuc3VyZSBwcm9wZXIgIm9yaWdpbmFsIG9wZXJhdGlvbiBwcm9wYWdhdGlvbiIuCiAgLy8KICAvLyBAcGFyYW0ge0FycmF5Ljxtb2R1bGU6ZW5naW5lL21vZGVsL29wZXJhdGlvbi9vcGVyYXRpb25+T3BlcmF0aW9uPn0gb3BlcmF0aW9ucwogIC8vIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9vcGVyYXRpb24vb3BlcmF0aW9ufk9wZXJhdGlvbnxudWxsfSBbdGFrZUZyb209bnVsbF0KCgogIHNldE9yaWdpbmFsT3BlcmF0aW9ucyhvcGVyYXRpb25zLCB0YWtlRnJvbSA9IG51bGwpIHsKICAgIGNvbnN0IG9yaWdpbmFsT3BlcmF0aW9uID0gdGFrZUZyb20gPyB0aGlzLm9yaWdpbmFsT3BlcmF0aW9ucy5nZXQodGFrZUZyb20pIDogbnVsbDsKCiAgICBmb3IgKGNvbnN0IG9wZXJhdGlvbiBvZiBvcGVyYXRpb25zKSB7CiAgICAgIHRoaXMub3JpZ2luYWxPcGVyYXRpb25zLnNldChvcGVyYXRpb24sIG9yaWdpbmFsT3BlcmF0aW9uIHx8IG9wZXJhdGlvbik7CiAgICB9CiAgfSAvLyBTYXZlcyBhIHJlbGF0aW9uIGJldHdlZW4gb3BlcmF0aW9ucyBgb3BBYCBhbmQgYG9wQmAuCiAgLy8KICAvLyBSZWxhdGlvbnMgYXJlIHRoZW4gbGF0ZXIgdXNlZCB0byBoZWxwIHNvbHZlIGNvbmZsaWN0cyB3aGVuIG9wZXJhdGlvbnMgYXJlIHRyYW5zZm9ybWVkLgogIC8vCiAgLy8gQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL29wZXJhdGlvbi9vcGVyYXRpb25+T3BlcmF0aW9ufSBvcEEKICAvLyBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvb3BlcmF0aW9uL29wZXJhdGlvbn5PcGVyYXRpb259IG9wQgoKCiAgdXBkYXRlUmVsYXRpb24ob3BBLCBvcEIpIHsKICAgIC8vIFRoZSB1c2Ugb2YgcmVsYXRpb25zIGlzIGRlc2NyaWJlZCBpbiBhIGJpZ2dlciBkZXRhaWwgaW4gdHJhbnNmb3JtYXRpb24gZnVuY3Rpb25zLgogICAgLy8KICAgIC8vIEluIGJyaWVmLCB0aGlzIGZ1bmN0aW9uLCBmb3Igc3BlY2lmaWVkIHBhaXJzIG9mIG9wZXJhdGlvbiB0eXBlcywgY2hlY2tzIGhvdyBwb3NpdGlvbnMgZGVmaW5lZCBpbiB0aG9zZSBvcGVyYXRpb25zIHJlbGF0ZS4KICAgIC8vIFRoZW4gdGhvc2UgcmVsYXRpb25zIGFyZSBzYXZlZC4gRm9yIGV4YW1wbGUsIGZvciB0d28gbW92ZSBvcGVyYXRpb25zLCBpdCBpcyBzYXZlZCBpZiBvbmUgb2YgdGhvc2Ugb3BlcmF0aW9ucyB0YXJnZXQKICAgIC8vIHBvc2l0aW9uIGlzIGJlZm9yZSB0aGUgb3RoZXIgb3BlcmF0aW9uIHNvdXJjZSBwb3NpdGlvbi4gVGhpcyBraW5kIG9mIGluZm9ybWF0aW9uIGdpdmVzIGNvbnRleHR1YWwgaW5mb3JtYXRpb24gd2hlbgogICAgLy8gdHJhbnNmb3JtYXRpb24gaXMgdXNlZCBkdXJpbmcgdW5kby4gU2ltaWxhciBjaGVja3MgYXJlIGRvbmUgZm9yIG90aGVyIHBhaXJzIG9mIG9wZXJhdGlvbnMuCiAgICAvLwogICAgc3dpdGNoIChvcEEuY29uc3RydWN0b3IpIHsKICAgICAgY2FzZSBNb3ZlT3BlcmF0aW9uOgogICAgICAgIHsKICAgICAgICAgIHN3aXRjaCAob3BCLmNvbnN0cnVjdG9yKSB7CiAgICAgICAgICAgIGNhc2UgTWVyZ2VPcGVyYXRpb246CiAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgaWYgKG9wQS50YXJnZXRQb3NpdGlvbi5pc0VxdWFsKG9wQi5zb3VyY2VQb3NpdGlvbikgfHwgb3BCLm1vdmVkUmFuZ2UuY29udGFpbnNQb3NpdGlvbihvcEEudGFyZ2V0UG9zaXRpb24pKSB7CiAgICAgICAgICAgICAgICAgIHRoaXMuX3NldFJlbGF0aW9uKG9wQSwgb3BCLCAnaW5zZXJ0QXRTb3VyY2UnKTsKICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob3BBLnRhcmdldFBvc2l0aW9uLmlzRXF1YWwob3BCLmRlbGV0aW9uUG9zaXRpb24pKSB7CiAgICAgICAgICAgICAgICAgIHRoaXMuX3NldFJlbGF0aW9uKG9wQSwgb3BCLCAnaW5zZXJ0QmV0d2VlbicpOwogICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvcEEudGFyZ2V0UG9zaXRpb24uaXNBZnRlcihvcEIuc291cmNlUG9zaXRpb24pKSB7CiAgICAgICAgICAgICAgICAgIHRoaXMuX3NldFJlbGF0aW9uKG9wQSwgb3BCLCAnbW92ZVRhcmdldEFmdGVyJyk7CiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgY2FzZSBNb3ZlT3BlcmF0aW9uOgogICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIGlmIChvcEEudGFyZ2V0UG9zaXRpb24uaXNFcXVhbChvcEIuc291cmNlUG9zaXRpb24pIHx8IG9wQS50YXJnZXRQb3NpdGlvbi5pc0JlZm9yZShvcEIuc291cmNlUG9zaXRpb24pKSB7CiAgICAgICAgICAgICAgICAgIHRoaXMuX3NldFJlbGF0aW9uKG9wQSwgb3BCLCAnaW5zZXJ0QmVmb3JlJyk7CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICB0aGlzLl9zZXRSZWxhdGlvbihvcEEsIG9wQiwgJ2luc2VydEFmdGVyJyk7CiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgfQogICAgICAgICAgfQoKICAgICAgICAgIGJyZWFrOwogICAgICAgIH0KCiAgICAgIGNhc2UgU3BsaXRPcGVyYXRpb246CiAgICAgICAgewogICAgICAgICAgc3dpdGNoIChvcEIuY29uc3RydWN0b3IpIHsKICAgICAgICAgICAgY2FzZSBNZXJnZU9wZXJhdGlvbjoKICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICBpZiAob3BBLnNwbGl0UG9zaXRpb24uaXNCZWZvcmUob3BCLnNvdXJjZVBvc2l0aW9uKSkgewogICAgICAgICAgICAgICAgICB0aGlzLl9zZXRSZWxhdGlvbihvcEEsIG9wQiwgJ3NwbGl0QmVmb3JlJyk7CiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgY2FzZSBNb3ZlT3BlcmF0aW9uOgogICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIGlmIChvcEEuc3BsaXRQb3NpdGlvbi5pc0VxdWFsKG9wQi5zb3VyY2VQb3NpdGlvbikgfHwgb3BBLnNwbGl0UG9zaXRpb24uaXNCZWZvcmUob3BCLnNvdXJjZVBvc2l0aW9uKSkgewogICAgICAgICAgICAgICAgICB0aGlzLl9zZXRSZWxhdGlvbihvcEEsIG9wQiwgJ3NwbGl0QmVmb3JlJyk7CiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgfQogICAgICAgICAgfQoKICAgICAgICAgIGJyZWFrOwogICAgICAgIH0KCiAgICAgIGNhc2UgTWVyZ2VPcGVyYXRpb246CiAgICAgICAgewogICAgICAgICAgc3dpdGNoIChvcEIuY29uc3RydWN0b3IpIHsKICAgICAgICAgICAgY2FzZSBNZXJnZU9wZXJhdGlvbjoKICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICBpZiAoIW9wQS50YXJnZXRQb3NpdGlvbi5pc0VxdWFsKG9wQi5zb3VyY2VQb3NpdGlvbikpIHsKICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0UmVsYXRpb24ob3BBLCBvcEIsICdtZXJnZVRhcmdldE5vdE1vdmVkJyk7CiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgaWYgKG9wQS5zb3VyY2VQb3NpdGlvbi5pc0VxdWFsKG9wQi50YXJnZXRQb3NpdGlvbikpIHsKICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0UmVsYXRpb24ob3BBLCBvcEIsICdtZXJnZVNvdXJjZU5vdE1vdmVkJyk7CiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgaWYgKG9wQS5zb3VyY2VQb3NpdGlvbi5pc0VxdWFsKG9wQi5zb3VyY2VQb3NpdGlvbikpIHsKICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0UmVsYXRpb24ob3BBLCBvcEIsICdtZXJnZVNhbWVFbGVtZW50Jyk7CiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgY2FzZSBTcGxpdE9wZXJhdGlvbjoKICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICBpZiAob3BBLnNvdXJjZVBvc2l0aW9uLmlzRXF1YWwob3BCLnNwbGl0UG9zaXRpb24pKSB7CiAgICAgICAgICAgICAgICAgIHRoaXMuX3NldFJlbGF0aW9uKG9wQSwgb3BCLCAnc3BsaXRBdFNvdXJjZScpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgIH0KCiAgICAgICAgICBicmVhazsKICAgICAgICB9CgogICAgICBjYXNlIE1hcmtlck9wZXJhdGlvbjoKICAgICAgICB7CiAgICAgICAgICBjb25zdCBtYXJrZXJSYW5nZSA9IG9wQS5uZXdSYW5nZTsKCiAgICAgICAgICBpZiAoIW1hcmtlclJhbmdlKSB7CiAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgIH0KCiAgICAgICAgICBzd2l0Y2ggKG9wQi5jb25zdHJ1Y3RvcikgewogICAgICAgICAgICBjYXNlIE1vdmVPcGVyYXRpb246CiAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgY29uc3QgbW92ZWRSYW5nZSA9IFJhbmdlLl9jcmVhdGVGcm9tUG9zaXRpb25BbmRTaGlmdChvcEIuc291cmNlUG9zaXRpb24sIG9wQi5ob3dNYW55KTsKCiAgICAgICAgICAgICAgICBjb25zdCBhZmZlY3RlZExlZnQgPSBtb3ZlZFJhbmdlLmNvbnRhaW5zUG9zaXRpb24obWFya2VyUmFuZ2Uuc3RhcnQpIHx8IG1vdmVkUmFuZ2Uuc3RhcnQuaXNFcXVhbChtYXJrZXJSYW5nZS5zdGFydCk7CiAgICAgICAgICAgICAgICBjb25zdCBhZmZlY3RlZFJpZ2h0ID0gbW92ZWRSYW5nZS5jb250YWluc1Bvc2l0aW9uKG1hcmtlclJhbmdlLmVuZCkgfHwgbW92ZWRSYW5nZS5lbmQuaXNFcXVhbChtYXJrZXJSYW5nZS5lbmQpOwoKICAgICAgICAgICAgICAgIGlmICgoYWZmZWN0ZWRMZWZ0IHx8IGFmZmVjdGVkUmlnaHQpICYmICFtb3ZlZFJhbmdlLmNvbnRhaW5zUmFuZ2UobWFya2VyUmFuZ2UpKSB7CiAgICAgICAgICAgICAgICAgIHRoaXMuX3NldFJlbGF0aW9uKG9wQSwgb3BCLCB7CiAgICAgICAgICAgICAgICAgICAgc2lkZTogYWZmZWN0ZWRMZWZ0ID8gJ2xlZnQnIDogJ3JpZ2h0JywKICAgICAgICAgICAgICAgICAgICBwYXRoOiBhZmZlY3RlZExlZnQgPyBtYXJrZXJSYW5nZS5zdGFydC5wYXRoLnNsaWNlKCkgOiBtYXJrZXJSYW5nZS5lbmQucGF0aC5zbGljZSgpCiAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGNhc2UgTWVyZ2VPcGVyYXRpb246CiAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgY29uc3Qgd2FzSW5MZWZ0RWxlbWVudCA9IG1hcmtlclJhbmdlLnN0YXJ0LmlzRXF1YWwob3BCLnRhcmdldFBvc2l0aW9uKTsKICAgICAgICAgICAgICAgIGNvbnN0IHdhc1N0YXJ0QmVmb3JlTWVyZ2VkRWxlbWVudCA9IG1hcmtlclJhbmdlLnN0YXJ0LmlzRXF1YWwob3BCLmRlbGV0aW9uUG9zaXRpb24pOwogICAgICAgICAgICAgICAgY29uc3Qgd2FzRW5kQmVmb3JlTWVyZ2VkRWxlbWVudCA9IG1hcmtlclJhbmdlLmVuZC5pc0VxdWFsKG9wQi5kZWxldGlvblBvc2l0aW9uKTsKICAgICAgICAgICAgICAgIGNvbnN0IHdhc0luUmlnaHRFbGVtZW50ID0gbWFya2VyUmFuZ2UuZW5kLmlzRXF1YWwob3BCLnNvdXJjZVBvc2l0aW9uKTsKCiAgICAgICAgICAgICAgICBpZiAod2FzSW5MZWZ0RWxlbWVudCB8fCB3YXNTdGFydEJlZm9yZU1lcmdlZEVsZW1lbnQgfHwgd2FzRW5kQmVmb3JlTWVyZ2VkRWxlbWVudCB8fCB3YXNJblJpZ2h0RWxlbWVudCkgewogICAgICAgICAgICAgICAgICB0aGlzLl9zZXRSZWxhdGlvbihvcEEsIG9wQiwgewogICAgICAgICAgICAgICAgICAgIHdhc0luTGVmdEVsZW1lbnQsCiAgICAgICAgICAgICAgICAgICAgd2FzU3RhcnRCZWZvcmVNZXJnZWRFbGVtZW50LAogICAgICAgICAgICAgICAgICAgIHdhc0VuZEJlZm9yZU1lcmdlZEVsZW1lbnQsCiAgICAgICAgICAgICAgICAgICAgd2FzSW5SaWdodEVsZW1lbnQKICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgfQogICAgICAgICAgfQoKICAgICAgICAgIGJyZWFrOwogICAgICAgIH0KICAgIH0KICB9IC8vIEV2YWx1YXRlcyBhbmQgcmV0dXJucyBjb250ZXh0dWFsIGluZm9ybWF0aW9uIGFib3V0IHR3byBnaXZlbiBvcGVyYXRpb25zIGBvcEFgIGFuZCBgb3BCYCB3aGljaCBhcmUgYWJvdXQgdG8gYmUgdHJhbnNmb3JtZWQuCiAgLy8KICAvLyBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvb3BlcmF0aW9uL29wZXJhdGlvbn5PcGVyYXRpb259IG9wQQogIC8vIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9vcGVyYXRpb24vb3BlcmF0aW9ufk9wZXJhdGlvbn0gb3BCCiAgLy8gQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvb3BlcmF0aW9uL3RyYW5zZm9ybX5UcmFuc2Zvcm1hdGlvbkNvbnRleHR9CgoKICBnZXRDb250ZXh0KG9wQSwgb3BCLCBhSXNTdHJvbmcpIHsKICAgIHJldHVybiB7CiAgICAgIGFJc1N0cm9uZywKICAgICAgYVdhc1VuZG9uZTogdGhpcy5fd2FzVW5kb25lKG9wQSksCiAgICAgIGJXYXNVbmRvbmU6IHRoaXMuX3dhc1VuZG9uZShvcEIpLAogICAgICBhYlJlbGF0aW9uOiB0aGlzLl91c2VSZWxhdGlvbnMgPyB0aGlzLl9nZXRSZWxhdGlvbihvcEEsIG9wQikgOiBudWxsLAogICAgICBiYVJlbGF0aW9uOiB0aGlzLl91c2VSZWxhdGlvbnMgPyB0aGlzLl9nZXRSZWxhdGlvbihvcEIsIG9wQSkgOiBudWxsLAogICAgICBmb3JjZVdlYWtSZW1vdmU6IHRoaXMuX2ZvcmNlV2Vha1JlbW92ZQogICAgfTsKICB9IC8vIFJldHVybnMgd2hldGhlciBnaXZlbiBvcGVyYXRpb24gYG9wYCBoYXMgYWxyZWFkeSBiZWVuIHVuZG9uZS4KICAvLwogIC8vIEluZm9ybWF0aW9uIHdoZXRoZXIgYW4gb3BlcmF0aW9uIHdhcyB1bmRvbmUgZ2l2ZXMgbW9yZSBjb250ZXh0IHdoZW4gbWFraW5nIGEgZGVjaXNpb24gd2hlbiB0d28gb3BlcmF0aW9ucyBhcmUgaW4gY29uZmxpY3QuCiAgLy8KICAvLyBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvb3BlcmF0aW9uL29wZXJhdGlvbn5PcGVyYXRpb259IG9wCiAgLy8gQHJldHVybnMge0Jvb2xlYW59CgoKICBfd2FzVW5kb25lKG9wKSB7CiAgICAvLyBGb3IgYG9wYCwgZ2V0IGl0cyBvcmlnaW5hbCBvcGVyYXRpb24uIEFmdGVyIGFsbCwgaWYgYG9wYCBpcyBhIGNsb25lIChvciBldmVuIHRyYW5zZm9ybWVkIGNsb25lKSBvZiBhbm90aGVyCiAgICAvLyBvcGVyYXRpb24sIGxpdGVyYWxseSBgb3BgIGNvdWxkbid0IGJlIHVuZG9uZS4gSXQgd2FzIGp1c3QgZ2VuZXJhdGVkLiBJZiBhbnl0aGluZywgaXQgd2FzIHRoZSBvcGVyYXRpb24gaXQgb3JpZ2lucwogICAgLy8gZnJvbSB3aGljaCB3YXMgdW5kb25lLiBTbyBnZXQgdGhhdCBvcmlnaW5hbCBvcGVyYXRpb24uCiAgICBjb25zdCBvcmlnaW5hbE9wID0gdGhpcy5vcmlnaW5hbE9wZXJhdGlvbnMuZ2V0KG9wKTsgLy8gQW5kIGNoZWNrIHdpdGggdGhlIGRvY3VtZW50IGlmIHRoZSBvcmlnaW5hbCBvcGVyYXRpb24gd2FzIHVuZG9uZS4KCiAgICByZXR1cm4gb3JpZ2luYWxPcC53YXNVbmRvbmUgfHwgdGhpcy5faGlzdG9yeS5pc1VuZG9uZU9wZXJhdGlvbihvcmlnaW5hbE9wKTsKICB9IC8vIFJldHVybnMgYSByZWxhdGlvbiBiZXR3ZWVuIGBvcEFgIGFuZCBhbiBvcGVyYXRpb24gd2hpY2ggaXMgdW5kb25lIGJ5IGBvcEJgLiBUaGlzIGNhbiBiZSBgU3RyaW5nYCB2YWx1ZSBpZiBhIHJlbGF0aW9uCiAgLy8gd2FzIHNldCBlYXJsaWVyIG9yIGBudWxsYCBpZiB0aGVyZSB3YXMgbm8gcmVsYXRpb24gYmV0d2VlbiB0aG9zZSBvcGVyYXRpb25zLgogIC8vCiAgLy8gVGhpcyBpcyBhIGxpdHRsZSB0cmlja3kgdG8gdW5kZXJzdGFuZCwgc28gbGV0J3MgY29tcGFyZSBpdCB0byBgQ29udGV4dEZhY3RvcnkjX3dhc1VuZG9uZWAuCiAgLy8KICAvLyBXaGVuIGB3YXNVbmRvbmUoIG9wQiApYCBpcyB1c2VkLCB3ZSBjaGVjayBpZiB0aGUgYG9wQmAgaGFzIGFscmVhZHkgYmVlbiB1bmRvbmUuIEl0IGlzIG9idmlvdXMsIHRoYXQgdGhlCiAgLy8gdW5kb2luZyBvcGVyYXRpb24gbXVzdCBoYXBwZW4gYWZ0ZXIgdGhlIHVuZG9uZSBvcGVyYXRpb24uIFNvLCBlc3NlbnRpYWxseSwgd2UgaGF2ZSBgb3BCYCwgd2UgdGFrZSBkb2N1bWVudCBoaXN0b3J5LAogIC8vIHdlIGxvb2sgZm9yd2FyZCBpbiB0aGUgZnV0dXJlIGFuZCBhc2sgaWYgaW4gdGhhdCBmdXR1cmUgYG9wQmAgd2FzIHVuZG9uZS4KICAvLwogIC8vIFJlbGF0aW9ucyBpcyBhIGJhY2t3YXJkIHByb2Nlc3MgdG8gYHdhc1VuZG9uZSgpYC4KICAvLwogIC8vIExvbmcgc3Rvcnkgc2hvcnQgLSB1c2luZyByZWxhdGlvbnMgaXMgYXNraW5nIHdoYXQgaGFwcGVuZWQgaW4gdGhlIHBhc3QuIExvb2tpbmcgYmFjay4gVGhpcyB0aW1lIHdlIGhhdmUgYW4gdW5kb2luZwogIC8vIG9wZXJhdGlvbiBgb3BCYCB3aGljaCBoYXMgdW5kb25lIHNvbWUgb3RoZXIgb3BlcmF0aW9uLiBXaGVuIHRoZXJlIGlzIGEgdHJhbnNmb3JtYXRpb24gYG9wQWAgeCBgb3BCYCBhbmQgdGhlcmUgaXMKICAvLyBhIGNvbmZsaWN0IHRvIHNvbHZlIGFuZCBgb3BCYCBpcyBhbiB1bmRvaW5nIG9wZXJhdGlvbiwgd2UgY2FuIGxvb2sgYmFjayBpbiB0aGUgaGlzdG9yeSBhbmQgc2VlIHdoYXQgd2FzIGEgcmVsYXRpb24KICAvLyBiZXR3ZWVuIGBvcEFgIGFuZCB0aGUgb3BlcmF0aW9uIHdoaWNoIGBvcEJgIHVuZG9uZS4gQmFzaW5nIG9uIHRoYXQgcmVsYXRpb24gZnJvbSB0aGUgcGFzdCwgd2UgY2FuIG5vdyBtYWtlCiAgLy8gYSBiZXR0ZXIgZGVjaXNpb24gd2hlbiByZXNvbHZpbmcgYSBjb25mbGljdCBiZXR3ZWVuIHR3byBvcGVyYXRpb25zLCBiZWNhdXNlIHdlIGtub3cgbW9yZSBhYm91dCB0aGUgY29udGV4dCBvZgogIC8vIHRob3NlIHR3byBvcGVyYXRpb25zLgogIC8vCiAgLy8gVGhpcyBpcyB3aHkgdGhpcyBmdW5jdGlvbiBkb2VzIG5vdCByZXR1cm4gYSByZWxhdGlvbiBkaXJlY3RseSBiZXR3ZWVuIGBvcEFgIGFuZCBgb3BCYCBiZWNhdXNlIHdlIG5lZWQgdG8gbG9vawogIC8vIGJhY2sgdG8gc2VhcmNoIGZvciBhIG1lYW5pbmdmdWwgY29udGV4dHVhbCBpbmZvcm1hdGlvbi4KICAvLwogIC8vIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9vcGVyYXRpb24vb3BlcmF0aW9ufk9wZXJhdGlvbn0gb3BBCiAgLy8gQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL29wZXJhdGlvbi9vcGVyYXRpb25+T3BlcmF0aW9ufSBvcEIKICAvLyBAcmV0dXJucyB7U3RyaW5nfG51bGx9CgoKICBfZ2V0UmVsYXRpb24ob3BBLCBvcEIpIHsKICAgIC8vIEdldCB0aGUgb3JpZ2luYWwgb3BlcmF0aW9uLiBTaW1pbGFybHkgYXMgaW4gYHdhc1VuZG9uZSgpYCBpdCBpcyB1c2VkIGFzIGFuIHVuaXZlcnNhbCBpZGVudGlmaWVyIGZvciBzdG9yZWQgZGF0YS4KICAgIGNvbnN0IG9yaWdCID0gdGhpcy5vcmlnaW5hbE9wZXJhdGlvbnMuZ2V0KG9wQik7CgogICAgY29uc3QgdW5kb25lQiA9IHRoaXMuX2hpc3RvcnkuZ2V0VW5kb25lT3BlcmF0aW9uKG9yaWdCKTsgLy8gSWYgYG9wQmAgaXMgbm90IHVuZG9pbmcgYW55IG9wZXJhdGlvbiwgdGhlcmUgaXMgbm8gcmVsYXRpb24uCgoKICAgIGlmICghdW5kb25lQikgewogICAgICByZXR1cm4gbnVsbDsKICAgIH0KCiAgICBjb25zdCBvcmlnQSA9IHRoaXMub3JpZ2luYWxPcGVyYXRpb25zLmdldChvcEEpOwoKICAgIGNvbnN0IHJlbGF0aW9uc0EgPSB0aGlzLl9yZWxhdGlvbnMuZ2V0KG9yaWdBKTsgLy8gR2V0IGFsbCByZWxhdGlvbnMgZm9yIGBvcEFgLCBhbmQgY2hlY2sgaWYgdGhlcmUgaXMgYSByZWxhdGlvbiB3aXRoIGBvcEJgLXVuZG9uZS1jb3VudGVycGFydC4gSWYgc28sIHJldHVybiBpdC4KCgogICAgaWYgKHJlbGF0aW9uc0EpIHsKICAgICAgcmV0dXJuIHJlbGF0aW9uc0EuZ2V0KHVuZG9uZUIpIHx8IG51bGw7CiAgICB9CgogICAgcmV0dXJuIG51bGw7CiAgfSAvLyBIZWxwZXIgZnVuY3Rpb24gZm9yIGBDb250ZXh0RmFjdG9yeSN1cGRhdGVSZWxhdGlvbnNgLgogIC8vCiAgLy8gQHByaXZhdGUKICAvLyBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvb3BlcmF0aW9uL29wZXJhdGlvbn5PcGVyYXRpb259IG9wQQogIC8vIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9vcGVyYXRpb24vb3BlcmF0aW9ufk9wZXJhdGlvbn0gb3BCCiAgLy8gQHBhcmFtIHtTdHJpbmd9IHJlbGF0aW9uCgoKICBfc2V0UmVsYXRpb24ob3BBLCBvcEIsIHJlbGF0aW9uKSB7CiAgICAvLyBBcyBhbHdheXMsIHNldHRpbmcgaXMgZm9yIG9yaWdpbmFsIG9wZXJhdGlvbnMsIG5vdCB0aGUgY2xvbmVzL3RyYW5zZm9ybWVkIG9wZXJhdGlvbnMuCiAgICBjb25zdCBvcmlnQSA9IHRoaXMub3JpZ2luYWxPcGVyYXRpb25zLmdldChvcEEpOwogICAgY29uc3Qgb3JpZ0IgPSB0aGlzLm9yaWdpbmFsT3BlcmF0aW9ucy5nZXQob3BCKTsKCiAgICBsZXQgcmVsYXRpb25zQSA9IHRoaXMuX3JlbGF0aW9ucy5nZXQob3JpZ0EpOwoKICAgIGlmICghcmVsYXRpb25zQSkgewogICAgICByZWxhdGlvbnNBID0gbmV3IE1hcCgpOwoKICAgICAgdGhpcy5fcmVsYXRpb25zLnNldChvcmlnQSwgcmVsYXRpb25zQSk7CiAgICB9CgogICAgcmVsYXRpb25zQS5zZXQob3JpZ0IsIHJlbGF0aW9uKTsKICB9Cgp9Ci8qKgogKiBIb2xkcyBhZGRpdGlvbmFsIGNvbnRleHR1YWwgaW5mb3JtYXRpb24gYWJvdXQgYSB0cmFuc2Zvcm1lZCBwYWlyIG9mIG9wZXJhdGlvbnMgKGBhYCBhbmQgYGJgKS4gVGhvc2UgaW5mb3JtYXRpb24KICogY2FuIGJlIHVzZWQgZm9yIGJldHRlciBjb25mbGljdCByZXNvbHZpbmcuCiAqCiAqIEB0eXBlZGVmIHtPYmplY3R9IG1vZHVsZTplbmdpbmUvbW9kZWwvb3BlcmF0aW9uL3RyYW5zZm9ybX5UcmFuc2Zvcm1hdGlvbkNvbnRleHQKICoKICogQHByb3BlcnR5IHtCb29sZWFufSBhSXNTdHJvbmcgV2hldGhlciBgYWAgaXMgc3Ryb25nIG9wZXJhdGlvbiBpbiB0aGlzIHRyYW5zZm9ybWF0aW9uLCBvciB3ZWFrLgogKiBAcHJvcGVydHkge0Jvb2xlYW59IGFXYXNVbmRvbmUgV2hldGhlciBgYWAgb3BlcmF0aW9uIHdhcyB1bmRvbmUuCiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gYldhc1VuZG9uZSBXaGV0aGVyIGBiYCBvcGVyYXRpb24gd2FzIHVuZG9uZS4KICogQHByb3BlcnR5IHtTdHJpbmd8bnVsbH0gYWJSZWxhdGlvbiBUaGUgcmVsYXRpb24gYmV0d2VlbiBgYWAgb3BlcmF0aW9uIGFuZCBhbiBvcGVyYXRpb24gdW5kb25lIGJ5IGBiYCBvcGVyYXRpb24uCiAqIEBwcm9wZXJ0eSB7U3RyaW5nfG51bGx9IGJhUmVsYXRpb24gVGhlIHJlbGF0aW9uIGJldHdlZW4gYGJgIG9wZXJhdGlvbiBhbmQgYW4gb3BlcmF0aW9uIHVuZG9uZSBieSBgYWAgb3BlcmF0aW9uLgogKi8KCi8qKgogKiBBbiB1dGlsaXR5IGZ1bmN0aW9uIHRoYXQgdXBkYXRlcyB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9vcGVyYXRpb24vb3BlcmF0aW9ufk9wZXJhdGlvbiNiYXNlVmVyc2lvbiBiYXNlIHZlcnNpb25zfQogKiBvZiBwYXNzZWQgb3BlcmF0aW9ucy4KICoKICogVGhlIGZ1bmN0aW9uIHNpbXBseSBzZXRzIGBiYXNlVmVyc2lvbmAgYXMgYSBiYXNlIHZlcnNpb24gb2YgdGhlIGZpcnN0IHBhc3NlZCBvcGVyYXRpb24gYW5kIHRoZW4gaW5jcmVtZW50cyBpdCBmb3IKICogZWFjaCBmb2xsb3dpbmcgb3BlcmF0aW9uIGluIGBvcGVyYXRpb25zYC4KICoKICogQHByaXZhdGUKICogQHBhcmFtIHtBcnJheS48bW9kdWxlOmVuZ2luZS9tb2RlbC9vcGVyYXRpb24vb3BlcmF0aW9ufk9wZXJhdGlvbj59IG9wZXJhdGlvbnMgT3BlcmF0aW9ucyB0byB1cGRhdGUuCiAqIEBwYXJhbSB7TnVtYmVyfSBiYXNlVmVyc2lvbiBCYXNlIHZlcnNpb24gdG8gc2V0IGZvciB0aGUgZmlyc3Qgb3BlcmF0aW9uIGluIGBvcGVyYXRpb25zYC4KICovCgoKZnVuY3Rpb24gdXBkYXRlQmFzZVZlcnNpb25zKG9wZXJhdGlvbnMsIGJhc2VWZXJzaW9uKSB7CiAgZm9yIChjb25zdCBvcGVyYXRpb24gb2Ygb3BlcmF0aW9ucykgewogICAgb3BlcmF0aW9uLmJhc2VWZXJzaW9uID0gYmFzZVZlcnNpb24rKzsKICB9Cn0KLyoqCiAqIEFkZHMgYGhvd01hbnlgIGluc3RhbmNlcyBvZiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC9vcGVyYXRpb24vbm9vcGVyYXRpb25+Tm9PcGVyYXRpb259IHRvIGBvcGVyYXRpb25zYCBzZXQuCiAqCiAqIEBwcml2YXRlCiAqIEBwYXJhbSB7QXJyYXkuPG1vZHVsZTplbmdpbmUvbW9kZWwvb3BlcmF0aW9uL29wZXJhdGlvbn5PcGVyYXRpb24+fSBvcGVyYXRpb25zCiAqIEBwYXJhbSB7TnVtYmVyfSBob3dNYW55CiAqLwoKCmZ1bmN0aW9uIHBhZFdpdGhOb09wcyhvcGVyYXRpb25zLCBob3dNYW55KSB7CiAgZm9yIChsZXQgaSA9IDA7IGkgPCBob3dNYW55OyBpKyspIHsKICAgIG9wZXJhdGlvbnMucHVzaChuZXcgTm9PcGVyYXRpb24oMCkpOwogIH0KfSAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKCnNldFRyYW5zZm9ybWF0aW9uKEF0dHJpYnV0ZU9wZXJhdGlvbiwgQXR0cmlidXRlT3BlcmF0aW9uLCAoYSwgYiwgY29udGV4dCkgPT4gewogIGlmIChhLmtleSA9PT0gYi5rZXkpIHsKICAgIC8vIElmIG9wZXJhdGlvbnMgYXR0cmlidXRlcyBhcmUgaW4gY29uZmxpY3QsIGNoZWNrIGlmIHRoZWlyIHJhbmdlcyBpbnRlcnNlY3QgYW5kIG1hbmFnZSB0aGVtIHByb3Blcmx5LgogICAgLy8gRmlyc3QsIHdlIHdhbnQgdG8gYXBwbHkgY2hhbmdlIHRvIHRoZSBwYXJ0IG9mIGEgcmFuZ2UgdGhhdCBoYXMgbm90IGJlZW4gY2hhbmdlZCBieSB0aGUgb3RoZXIgb3BlcmF0aW9uLgogICAgY29uc3Qgb3BlcmF0aW9ucyA9IGEucmFuZ2UuZ2V0RGlmZmVyZW5jZShiLnJhbmdlKS5tYXAocmFuZ2UgPT4gewogICAgICByZXR1cm4gbmV3IEF0dHJpYnV0ZU9wZXJhdGlvbihyYW5nZSwgYS5rZXksIGEub2xkVmFsdWUsIGEubmV3VmFsdWUsIDApOwogICAgfSk7IC8vIFRoZW4gd2UgdGFrZSBjYXJlIG9mIHRoZSBjb21tb24gcGFydCBvZiByYW5nZXMuCgogICAgY29uc3QgY29tbW9uID0gYS5yYW5nZS5nZXRJbnRlcnNlY3Rpb24oYi5yYW5nZSk7CgogICAgaWYgKGNvbW1vbikgewogICAgICAvLyBJZiB0aGlzIG9wZXJhdGlvbiBpcyBtb3JlIGltcG9ydGFudCwgd2UgYWxzbyB3YW50IHRvIGFwcGx5IGNoYW5nZSB0byB0aGUgcGFydCBvZiB0aGUKICAgICAgLy8gb3JpZ2luYWwgcmFuZ2UgdGhhdCBoYXMgYWxyZWFkeSBiZWVuIGNoYW5nZWQgYnkgdGhlIG90aGVyIG9wZXJhdGlvbi4gU2luY2UgdGhhdCByYW5nZQogICAgICAvLyBnb3QgY2hhbmdlZCB3ZSBhbHNvIGhhdmUgdG8gdXBkYXRlIGBvbGRWYWx1ZWAuCiAgICAgIGlmIChjb250ZXh0LmFJc1N0cm9uZykgewogICAgICAgIG9wZXJhdGlvbnMucHVzaChuZXcgQXR0cmlidXRlT3BlcmF0aW9uKGNvbW1vbiwgYi5rZXksIGIubmV3VmFsdWUsIGEubmV3VmFsdWUsIDApKTsKICAgICAgfQogICAgfQoKICAgIGlmIChvcGVyYXRpb25zLmxlbmd0aCA9PSAwKSB7CiAgICAgIHJldHVybiBbbmV3IE5vT3BlcmF0aW9uKDApXTsKICAgIH0KCiAgICByZXR1cm4gb3BlcmF0aW9uczsKICB9IGVsc2UgewogICAgLy8gSWYgb3BlcmF0aW9ucyBkb24ndCBjb25mbGljdCwgc2ltcGx5IHJldHVybiBhbiBhcnJheSBjb250YWluaW5nIGp1c3QgYSBjbG9uZSBvZiB0aGlzIG9wZXJhdGlvbi4KICAgIHJldHVybiBbYV07CiAgfQp9KTsKc2V0VHJhbnNmb3JtYXRpb24oQXR0cmlidXRlT3BlcmF0aW9uLCBJbnNlcnRPcGVyYXRpb24sIChhLCBiKSA9PiB7CiAgLy8gQ2FzZSAxOgogIC8vCiAgLy8gVGhlIGF0dHJpYnV0ZSBvcGVyYXRpb24gcmFuZ2UgaW5jbHVkZXMgdGhlIHBvc2l0aW9uIHdoZXJlIG5vZGVzIHdlcmUgaW5zZXJ0ZWQuCiAgLy8gVGhlcmUgYXJlIHR3byBwb3NzaWJsZSBzY2VuYXJpb3M6IHRoZSBpbnNlcnRlZCBub2RlcyB3ZXJlIHRleHQgYW5kIHRoZXkgc2hvdWxkIHJlY2VpdmUgYXR0cmlidXRlcyBvcgogIC8vIHRoZSBpbnNlcnRlZCBub2RlcyB3ZXJlIGVsZW1lbnRzIGFuZCB0aGV5IHNob3VsZCBub3QgcmVjZWl2ZSBhdHRyaWJ1dGVzLgogIC8vCiAgaWYgKGEucmFuZ2Uuc3RhcnQuaGFzU2FtZVBhcmVudEFzKGIucG9zaXRpb24pICYmIGEucmFuZ2UuY29udGFpbnNQb3NpdGlvbihiLnBvc2l0aW9uKSkgewogICAgLy8gSWYgbmV3IG5vZGVzIHNob3VsZCBub3QgcmVjZWl2ZSBhdHRyaWJ1dGVzLCB0d28gc2VwYXJhdGVkIHJhbmdlcyB3aWxsIGJlIHJldHVybmVkLgogICAgLy8gT3RoZXJ3aXNlLCBvbmUgZXhwYW5kZWQgcmFuZ2Ugd2lsbCBiZSByZXR1cm5lZC4KICAgIGNvbnN0IHJhbmdlID0gYS5yYW5nZS5fZ2V0VHJhbnNmb3JtZWRCeUluc2VydGlvbihiLnBvc2l0aW9uLCBiLmhvd01hbnksICFiLnNob3VsZFJlY2VpdmVBdHRyaWJ1dGVzKTsKCiAgICBjb25zdCByZXN1bHQgPSByYW5nZS5tYXAociA9PiB7CiAgICAgIHJldHVybiBuZXcgQXR0cmlidXRlT3BlcmF0aW9uKHIsIGEua2V5LCBhLm9sZFZhbHVlLCBhLm5ld1ZhbHVlLCBhLmJhc2VWZXJzaW9uKTsKICAgIH0pOwoKICAgIGlmIChiLnNob3VsZFJlY2VpdmVBdHRyaWJ1dGVzKSB7CiAgICAgIC8vIGBBdHRyaWJ1dGVPcGVyYXRpb24jcmFuZ2VgIGluY2x1ZGVzIHNvbWUgbmV3bHkgaW5zZXJ0ZWQgdGV4dC4KICAgICAgLy8gVGhlIG9wZXJhdGlvbiBzaG91bGQgYWxzbyBjaGFuZ2UgdGhlIGF0dHJpYnV0ZSBvZiB0aGF0IHRleHQuIEFuIGV4YW1wbGU6CiAgICAgIC8vCiAgICAgIC8vIEJvbGQgc2hvdWxkIGJlIGFwcGxpZWQgb24gdGhlIGZvbGxvd2luZyByYW5nZToKICAgICAgLy8gPHA+Rm9bemJdYXI8L3A+CiAgICAgIC8vCiAgICAgIC8vIEluIG1lYW50aW1lLCBuZXcgdGV4dCBpcyB0eXBlZDoKICAgICAgLy8gPHA+Rm96eHhiYXI8L3A+CiAgICAgIC8vCiAgICAgIC8vIEJvbGQgc2hvdWxkIGJlIGFwcGxpZWQgYWxzbyBvbiB0aGUgbmV3IHRleHQ6CiAgICAgIC8vIDxwPkZvW3p4eGJdYXI8L3A+CiAgICAgIC8vIDxwPkZvPCR0ZXh0IGJvbGQ9InRydWUiPnp4eGI8LyR0ZXh0PmFyPC9wPgogICAgICAvLwogICAgICAvLyBUaGVyZSBpcyBhIHNwZWNpYWwgY2FzZSB0byBjb25zaWRlciBoZXJlIHRvIGNvbnNpZGVyLgogICAgICAvLwogICAgICAvLyBDb25zaWRlciBzZXR0aW5nIGFuIGF0dHJpYnV0ZSB3aXRoIG11bHRpcGxlIHBvc3NpYmxlIHZhbHVlcywgZm9yIGV4YW1wbGUgYGhpZ2hsaWdodGAuIFRoZSBpbnNlcnRlZCB0ZXh0IG1pZ2h0CiAgICAgIC8vIGhhdmUgYWxyZWFkeSBhbiBhdHRyaWJ1dGUgdmFsdWUgYXBwbGllZCBhbmQgdGhlIGBvbGRWYWx1ZWAgcHJvcGVydHkgb2YgdGhlIGF0dHJpYnV0ZSBvcGVyYXRpb24gbWlnaHQgYmUgd3Jvbmc6CiAgICAgIC8vCiAgICAgIC8vIEF0dHJpYnV0ZSBgaGlnaGxpZ2h0PSJ5ZWxsb3ciYCBzaG91bGQgYmUgYXBwbGllZCBvbiB0aGUgZm9sbG93aW5nIHJhbmdlOgogICAgICAvLyA8cD5Gb1t6Yl1hcjxwPgogICAgICAvLwogICAgICAvLyBJbiBtZWFudGltZSwgY2hhcmFjdGVyIGB4YCB3aXRoIGBoaWdobGlnaHQ9InJlZCJgIGlzIHR5cGVkOgogICAgICAvLyA8cD5Gb1t6PCR0ZXh0IGhpZ2hsaWdodD0icmVkIj54PC8kdGV4dD5iXWFyPC9wPgogICAgICAvLwogICAgICAvLyBJbiB0aGlzIGNhc2Ugd2UgY2Fubm90IHNpbXBseSBhcHBseSBvcGVyYXRpb24gY2hhbmdpbmcgdGhlIGF0dHJpYnV0ZSB2YWx1ZSBmcm9tIGBudWxsYCB0byBgInllbGxvdyJgIGZvciB0aGUgd2hvbGUgcmFuZ2UKICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvdWxkIGxlYWQgdG8gYW4gZXhjZXB0aW9uIChgb2xkVmFsdWVgIGlzIGluY29ycmVjdCBmb3IgYHhgKS4KICAgICAgLy8KICAgICAgLy8gV2UgYWxzbyBjYW5ub3QgYnJlYWsgdGhlIG9yaWdpbmFsIHJhbmdlIGFzIHRoaXMgd291bGQgbWVzcyB1cCBhIHNjZW5hcmlvIHdoZW4gdGhlcmUgYXJlIG11bHRpcGxlIGZvbGxvd2luZwogICAgICAvLyBpbnNlcnQgb3BlcmF0aW9ucywgYmVjYXVzZSB0aGVuIG9ubHkgdGhlIGZpcnN0IGluc2VydGVkIGNoYXJhY3RlciBpcyBpbmNsdWRlZCBpbiB0aG9zZSByYW5nZXM6CiAgICAgIC8vIDxwPkZvW3pdW3hdW2JdYXI8L3A+ICAgLS0+ICAgPHA+Rm9bel1beF14W2JdYXI8L3A+ICAgLS0+ICAgPHA+Rm9bel1beF14eFtiXWFyPC9wPgogICAgICAvLwogICAgICAvLyBTbywgdGhlIGF0dHJpYnV0ZSByYW5nZSBuZWVkcyBiZSBleHBhbmRlZCwgbm8gbWF0dGVyIHdoYXQgYXR0cmlidXRlcyBhcmUgc2V0IG9uIHRoZSBpbnNlcnRlZCBub2RlczoKICAgICAgLy8KICAgICAgLy8gPHA+Rm9bejwkdGV4dCBoaWdobGlnaHQ9InJlZCI+eDwvJHRleHQ+Yl1hcjwvcD4gICAgICA8LS0tIENoYW5nZSBmcm9tIGBudWxsYCB0byBgeWVsbG93YCwgdGhyb3dpbmcgYW4gZXhjZXB0aW9uLgogICAgICAvLwogICAgICAvLyBCdXQgYmVmb3JlIHRoYXQgb3BlcmF0aW9uIHdvdWxkIGJlIGFwcGxpZWQsIHdlIHdpbGwgYWRkIGFuIGFkZGl0aW9uYWwgYXR0cmlidXRlIG9wZXJhdGlvbiB0aGF0IHdpbGwgY2hhbmdlCiAgICAgIC8vIGF0dHJpYnV0ZXMgb24gdGhlIGluc2VydGVkIG5vZGVzIGluIGEgd2F5IHdoaWNoIHdvdWxkIG1ha2UgdGhlIG9yaWdpbmFsIG9wZXJhdGlvbiBjb3JyZWN0OgogICAgICAvLwogICAgICAvLyA8cD5Gb1t6ezwkdGV4dCBoaWdobGlnaHQ9InJlZCI+fXg8LyR0ZXh0PmJdYXI8L3A+ICAgIDwtLS0gQ2hhbmdlIHJhbmdlIGB7fWAgZnJvbSBgcmVkYCB0byBgbnVsbGAuCiAgICAgIC8vIDxwPkZvW3p4Yl1hcjwvcD4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC0tLSBOb3cgY2hhbmdlIGZyb20gYG51bGxgIHRvIGB5ZWxsb3dgIGlzIGNvbXBsZXRlbHkgZmluZS4KICAgICAgLy8KICAgICAgLy8gR2VuZXJhdGUgY29tcGxlbWVudGFyeSBhdHRyaWJ1dGUgb3BlcmF0aW9uLiBCZSBzdXJlIHRvIGFkZCBpdCBiZWZvcmUgdGhlIG9yaWdpbmFsIG9wZXJhdGlvbi4KICAgICAgY29uc3Qgb3AgPSBfZ2V0Q29tcGxlbWVudGFyeUF0dHJpYnV0ZU9wZXJhdGlvbnMoYiwgYS5rZXksIGEub2xkVmFsdWUpOwoKICAgICAgaWYgKG9wKSB7CiAgICAgICAgcmVzdWx0LnVuc2hpZnQob3ApOwogICAgICB9CiAgICB9IC8vIElmIG5vZGVzIHNob3VsZCBub3QgcmVjZWl2ZSBuZXcgYXR0cmlidXRlLCB3ZSBhcmUgZG9uZSBoZXJlLgoKCiAgICByZXR1cm4gcmVzdWx0OwogIH0gLy8gSWYgaW5zZXJ0IG9wZXJhdGlvbiBpcyBub3QgZXhwYW5kaW5nIHRoZSBhdHRyaWJ1dGUgb3BlcmF0aW9uIHJhbmdlLCBzaW1wbHkgdHJhbnNmb3JtIHRoZSByYW5nZS4KCgogIGEucmFuZ2UgPSBhLnJhbmdlLl9nZXRUcmFuc2Zvcm1lZEJ5SW5zZXJ0aW9uKGIucG9zaXRpb24sIGIuaG93TWFueSwgZmFsc2UpWzBdOwogIHJldHVybiBbYV07Cn0pOwovKioKICogSGVscGVyIGZ1bmN0aW9uIGZvciBgQXR0cmlidXRlT3BlcmF0aW9uYCB4IGBJbnNlcnRPcGVyYXRpb25gIChhbmQgcmV2ZXJzZSkgdHJhbnNmb3JtYXRpb24uCiAqCiAqIEZvciBnaXZlbiBgaW5zZXJ0T3BlcmF0aW9uYCBpdCBjaGVja3MgdGhlIGluc2VydGVkIG5vZGUgaWYgaXQgaGFzIGFuIGF0dHJpYnV0ZSBga2V5YCBzZXQgdG8gYSB2YWx1ZSBkaWZmZXJlbnQKICogdGhhbiBgbmV3VmFsdWVgLiBJZiBzbywgaXQgZ2VuZXJhdGVzIGFuIGBBdHRyaWJ1dGVPcGVyYXRpb25gIHdoaWNoIGNoYW5nZXMgdGhlIHZhbHVlIG9mIGBrZXlgIGF0dHJpYnV0ZSB0byBgbmV3VmFsdWVgLgogKgogKiBAcHJpdmF0ZQogKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvb3BlcmF0aW9uL2luc2VydG9wZXJhdGlvbn5JbnNlcnRPcGVyYXRpb259IGluc2VydE9wZXJhdGlvbgogKiBAcGFyYW0ge1N0cmluZ30ga2V5CiAqIEBwYXJhbSB7Kn0gbmV3VmFsdWUKICogQHJldHVybnMge21vZHVsZTplbmdpbmUvbW9kZWwvb3BlcmF0aW9uL2F0dHJpYnV0ZW9wZXJhdGlvbn5BdHRyaWJ1dGVPcGVyYXRpb258bnVsbH0KICovCgpmdW5jdGlvbiBfZ2V0Q29tcGxlbWVudGFyeUF0dHJpYnV0ZU9wZXJhdGlvbnMoaW5zZXJ0T3BlcmF0aW9uLCBrZXksIG5ld1ZhbHVlKSB7CiAgY29uc3Qgbm9kZXMgPSBpbnNlcnRPcGVyYXRpb24ubm9kZXM7IC8vIEF0IHRoZSBiZWdpbm5pbmcgd2Ugc3RvcmUgdGhlIGF0dHJpYnV0ZSB2YWx1ZSBmcm9tIHRoZSBmaXJzdCBub2RlLgoKICBjb25zdCBpbnNlcnRWYWx1ZSA9IG5vZGVzLmdldE5vZGUoMCkuZ2V0QXR0cmlidXRlKGtleSk7CgogIGlmIChpbnNlcnRWYWx1ZSA9PSBuZXdWYWx1ZSkgewogICAgcmV0dXJuIG51bGw7CiAgfQoKICBjb25zdCByYW5nZSA9IG5ldyBSYW5nZShpbnNlcnRPcGVyYXRpb24ucG9zaXRpb24sIGluc2VydE9wZXJhdGlvbi5wb3NpdGlvbi5nZXRTaGlmdGVkQnkoaW5zZXJ0T3BlcmF0aW9uLmhvd01hbnkpKTsKICByZXR1cm4gbmV3IEF0dHJpYnV0ZU9wZXJhdGlvbihyYW5nZSwga2V5LCBpbnNlcnRWYWx1ZSwgbmV3VmFsdWUsIDApOwp9CgpzZXRUcmFuc2Zvcm1hdGlvbihBdHRyaWJ1dGVPcGVyYXRpb24sIE1lcmdlT3BlcmF0aW9uLCAoYSwgYikgPT4gewogIGNvbnN0IHJhbmdlcyA9IFtdOyAvLyBDYXNlIDE6CiAgLy8KICAvLyBBdHRyaWJ1dGUgY2hhbmdlIG9uIHRoZSBtZXJnZWQgZWxlbWVudC4gSW4gdGhpcyBjYXNlLCB0aGUgbWVyZ2VkIGVsZW1lbnQgd2FzIG1vdmVkIHRvIHRoZSBncmF2ZXlhcmQuCiAgLy8gQW4gYWRkaXRpb25hbCBhdHRyaWJ1dGUgb3BlcmF0aW9uIHRoYXQgd2lsbCBjaGFuZ2UgdGhlIChyZSltb3ZlZCBlbGVtZW50IG5lZWRzIHRvIGJlIGdlbmVyYXRlZC4KICAvLwoKICBpZiAoYS5yYW5nZS5zdGFydC5oYXNTYW1lUGFyZW50QXMoYi5kZWxldGlvblBvc2l0aW9uKSkgewogICAgaWYgKGEucmFuZ2UuY29udGFpbnNQb3NpdGlvbihiLmRlbGV0aW9uUG9zaXRpb24pIHx8IGEucmFuZ2Uuc3RhcnQuaXNFcXVhbChiLmRlbGV0aW9uUG9zaXRpb24pKSB7CiAgICAgIHJhbmdlcy5wdXNoKFJhbmdlLl9jcmVhdGVGcm9tUG9zaXRpb25BbmRTaGlmdChiLmdyYXZleWFyZFBvc2l0aW9uLCAxKSk7CiAgICB9CiAgfQoKICBjb25zdCByYW5nZSA9IGEucmFuZ2UuX2dldFRyYW5zZm9ybWVkQnlNZXJnZU9wZXJhdGlvbihiKTsgLy8gRG8gbm90IGFkZCBlbXB0eSAoY29sbGFwc2VkKSByYW5nZXMgdG8gdGhlIHJlc3VsdC4gYHJhbmdlYCBtYXkgYmUgY29sbGFwc2VkIGlmIGl0IGNvbnRhaW5lZCBvbmx5IHRoZSBtZXJnZWQgZWxlbWVudC4KCgogIGlmICghcmFuZ2UuaXNDb2xsYXBzZWQpIHsKICAgIHJhbmdlcy5wdXNoKHJhbmdlKTsKICB9IC8vIENyZWF0ZSBgQXR0cmlidXRlT3BlcmF0aW9uYHMgb3V0IG9mIHRoZSByYW5nZXMuCgoKICByZXR1cm4gcmFuZ2VzLm1hcChyYW5nZSA9PiB7CiAgICByZXR1cm4gbmV3IEF0dHJpYnV0ZU9wZXJhdGlvbihyYW5nZSwgYS5rZXksIGEub2xkVmFsdWUsIGEubmV3VmFsdWUsIGEuYmFzZVZlcnNpb24pOwogIH0pOwp9KTsKc2V0VHJhbnNmb3JtYXRpb24oQXR0cmlidXRlT3BlcmF0aW9uLCBNb3ZlT3BlcmF0aW9uLCAoYSwgYikgPT4gewogIGNvbnN0IHJhbmdlcyA9IF9icmVha1JhbmdlQnlNb3ZlT3BlcmF0aW9uKGEucmFuZ2UsIGIpOyAvLyBDcmVhdGUgYEF0dHJpYnV0ZU9wZXJhdGlvbmBzIG91dCBvZiB0aGUgcmFuZ2VzLgoKCiAgcmV0dXJuIHJhbmdlcy5tYXAocmFuZ2UgPT4gbmV3IEF0dHJpYnV0ZU9wZXJhdGlvbihyYW5nZSwgYS5rZXksIGEub2xkVmFsdWUsIGEubmV3VmFsdWUsIGEuYmFzZVZlcnNpb24pKTsKfSk7IC8vIEhlbHBlciBmdW5jdGlvbiBmb3IgYEF0dHJpYnV0ZU9wZXJhdGlvbmAgeCBgTW92ZU9wZXJhdGlvbmAgdHJhbnNmb3JtYXRpb24uCi8vCi8vIFRha2VzIHRoZSBwYXNzZWQgYHJhbmdlYCBhbmQgdHJhbnNmb3JtcyBpdCBieSBtb3ZlIG9wZXJhdGlvbiBgbW92ZU9wYCBpbiBhIHNwZWNpZmljIHdheS4gT25seSB0b3AtbGV2ZWwgbm9kZXMgb2YgYHJhbmdlYAovLyBhcmUgY29uc2lkZXJlZCB0byBiZSBpbiB0aGUgcmFuZ2UuIElmIG1vdmUgb3BlcmF0aW9uIG1vdmVzIG5vZGVzIGRlZXAgZnJvbSBpbnNpZGUgb2YgdGhlIHJhbmdlLCB0aG9zZSBub2RlcyB3b24ndAovLyBiZSBpbmNsdWRlZCBpbiB0aGUgcmVzdWx0LiBJbiBvdGhlciB3b3JkcywgdG9wLWxldmVsIG5vZGVzIG9mIHRoZSByYW5nZXMgZnJvbSB0aGUgcmVzdWx0IGFyZSBleGFjdGx5IHRoZSBzYW1lIGFzCi8vIHRvcC1sZXZlbCBub2RlcyBvZiB0aGUgb3JpZ2luYWwgYHJhbmdlYC4KLy8KLy8gVGhpcyBpcyBpbXBvcnRhbnQgZm9yIGBBdHRyaWJ1dGVPcGVyYXRpb25gIGJlY2F1c2UsIGZvciBpdHMgcmFuZ2UsIGl0IGNoYW5nZXMgb25seSB0aGUgdG9wLWxldmVsIG5vZGVzLiBTbyB3ZSBuZWVkIHRvCi8vIHRyYWNrIG9ubHkgaG93IHRob3NlIG5vZGVzIGhhdmUgYmVlbiBhZmZlY3RlZCBieSBgTW92ZU9wZXJhdGlvbmAuCi8vCi8vIEBwcml2YXRlCi8vIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZX0gcmFuZ2UKLy8gQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL29wZXJhdGlvbi9tb3Zlb3BlcmF0aW9ufk1vdmVPcGVyYXRpb259IG1vdmVPcAovLyBAcmV0dXJucyB7QXJyYXkuPG1vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2U+fQoKZnVuY3Rpb24gX2JyZWFrUmFuZ2VCeU1vdmVPcGVyYXRpb24ocmFuZ2UsIG1vdmVPcCkgewogIGNvbnN0IG1vdmVSYW5nZSA9IFJhbmdlLl9jcmVhdGVGcm9tUG9zaXRpb25BbmRTaGlmdChtb3ZlT3Auc291cmNlUG9zaXRpb24sIG1vdmVPcC5ob3dNYW55KTsgLy8gV2UgYXJlIHRyYW5zZm9ybWluZyBgcmFuZ2VgIChvcmlnaW5hbCByYW5nZSkgYnkgYG1vdmVSYW5nZWAgKHJhbmdlIG1vdmVkIGJ5IG1vdmUgb3BlcmF0aW9uKS4gQXMgdXN1YWwgd2hlbiBpdCBjb21lcyB0bwogIC8vIHRyYW5zZm9ybWluZyBhIHJhbmdlcywgd2UgbWF5IGhhdmUgYSBjb21tb24gcGFydCBvZiB0aGUgcmFuZ2VzIGFuZCB3ZSBtYXkgaGF2ZSBhIGRpZmZlcmVuY2UgcGFydCAoemVybyB0byB0d28gcmFuZ2VzKS4KCgogIGxldCBjb21tb24gPSBudWxsOwogIGxldCBkaWZmZXJlbmNlID0gW107IC8vIExldCdzIGNvbXBhcmUgdGhlIHJhbmdlcy4KCiAgaWYgKG1vdmVSYW5nZS5jb250YWluc1JhbmdlKHJhbmdlLCB0cnVlKSkgewogICAgLy8gSWYgdGhlIHdob2xlIG9yaWdpbmFsIHJhbmdlIGlzIG1vdmVkLCB0cmVhdCBpdCB3aG9sZSBhcyBhIGNvbW1vbiBwYXJ0LiBUaGVyZSdzIGFsc28gbm8gZGlmZmVyZW5jZSBwYXJ0LgogICAgY29tbW9uID0gcmFuZ2U7CiAgfSBlbHNlIGlmIChyYW5nZS5zdGFydC5oYXNTYW1lUGFyZW50QXMobW92ZVJhbmdlLnN0YXJ0KSkgewogICAgLy8gSWYgdGhlIHJhbmdlcyBhcmUgIm9uIHRoZSBzYW1lIGxldmVsIiAoaW4gdGhlIHNhbWUgcGFyZW50KSB0aGVuIG1vdmUgb3BlcmF0aW9uIG1heSBtb3ZlIGV4YWN0bHkgdGhvc2Ugbm9kZXMKICAgIC8vIHRoYXQgYXJlIGNoYW5nZWQgYnkgdGhlIGF0dHJpYnV0ZSBvcGVyYXRpb24uIEluIHRoaXMgY2FzZSB3ZSBnZXQgY29tbW9uIHBhcnQgYW5kIGRpZmZlcmVuY2UgcGFydCBpbiB0aGUgdXN1YWwgd2F5LgogICAgZGlmZmVyZW5jZSA9IHJhbmdlLmdldERpZmZlcmVuY2UobW92ZVJhbmdlKTsKICAgIGNvbW1vbiA9IHJhbmdlLmdldEludGVyc2VjdGlvbihtb3ZlUmFuZ2UpOwogIH0gZWxzZSB7CiAgICAvLyBJbiBhbnkgb3RoZXIgc2l0dWF0aW9uIHdlIGFzc3VtZSB0aGF0IG9yaWdpbmFsIHJhbmdlIGlzIGRpZmZlcmVudCB0aGFuIG1vdmUgcmFuZ2UsIHRoYXQgaXMgdGhhdCBtb3ZlIG9wZXJhdGlvbgogICAgLy8gbW92ZXMgb3RoZXIgbm9kZXMgdGhhdCBhdHRyaWJ1dGUgb3BlcmF0aW9uIGNoYW5nZS4gRXZlbiBpZiB0aGUgbW92ZWQgcmFuZ2UgaXMgZGVlcCBpbnNpZGUgaW4gdGhlIG9yaWdpbmFsIHJhbmdlLgogICAgLy8KICAgIC8vIE5vdGUgdGhhdCB0aGlzIGlzIGRpZmZlcmVudCB0aGFuIGluIGAuZ2V0SW50ZXJzZWN0aW9uYCAod2Ugd291bGQgZ2V0IGEgY29tbW9uIHBhcnQgaW4gdGhhdCBjYXNlKSBhbmQgZGlmZmVyZW50CiAgICAvLyB0aGFuIGAuZ2V0RGlmZmVyZW5jZWAgKHdlIHdvdWxkIGdldCB0d28gcmFuZ2VzKS4KICAgIGRpZmZlcmVuY2UgPSBbcmFuZ2VdOwogIH0KCiAgY29uc3QgcmVzdWx0ID0gW107IC8vIFRoZSBkZWZhdWx0IGJlaGF2aW91ciBvZiBgX2dldFRyYW5zZm9ybWVkQnlNb3ZlYCBtaWdodCBnZXQgd3JvbmcgcmVzdWx0cyBmb3IgZGlmZmVyZW5jZSBwYXJ0LCB0aG91Z2gsIHNvCiAgLy8gd2UgZG8gaXQgYnkgaGFuZC4KCiAgZm9yIChsZXQgZGlmZiBvZiBkaWZmZXJlbmNlKSB7CiAgICAvLyBGaXJzdCwgdHJhbnNmb3JtIHRoZSByYW5nZSBieSByZW1vdmluZyBtb3ZlZCBub2Rlcy4gU2luY2UgdGhpcyBpcyBhIGRpZmZlcmVuY2UsIHRoaXMgaXMgc2FmZSwgYG51bGxgIHdvbid0IGJlIHJldHVybmVkCiAgICAvLyBhcyB0aGUgcmFuZ2UgaXMgZGlmZmVyZW50IHRoYW4gdGhlIG1vdmVkIHJhbmdlLgogICAgZGlmZiA9IGRpZmYuX2dldFRyYW5zZm9ybWVkQnlEZWxldGlvbihtb3ZlT3Auc291cmNlUG9zaXRpb24sIG1vdmVPcC5ob3dNYW55KTsgLy8gVHJhbnNmb3JtIGFsc28gYHRhcmdldFBvc2l0aW9uYC4KCiAgICBjb25zdCB0YXJnZXRQb3NpdGlvbiA9IG1vdmVPcC5nZXRNb3ZlZFJhbmdlU3RhcnQoKTsgLy8gU3ByZWFkIHRoZSByYW5nZSBvbmx5IGlmIG1vdmVkIG5vZGVzIGFyZSBpbnNlcnRlZCBvbmx5IGJldHdlZW4gdGhlIHRvcC1sZXZlbCBub2RlcyBvZiB0aGUgYGRpZmZgIHJhbmdlLgoKICAgIGNvbnN0IHNwcmVhZCA9IGRpZmYuc3RhcnQuaGFzU2FtZVBhcmVudEFzKHRhcmdldFBvc2l0aW9uKTsgLy8gVHJhbnNmb3JtIGJ5IGluc2VydGlvbiBvZiBtb3ZlZCBub2Rlcy4KCiAgICBkaWZmID0gZGlmZi5fZ2V0VHJhbnNmb3JtZWRCeUluc2VydGlvbih0YXJnZXRQb3NpdGlvbiwgbW92ZU9wLmhvd01hbnksIHNwcmVhZCk7CiAgICByZXN1bHQucHVzaCguLi5kaWZmKTsKICB9IC8vIENvbW1vbiBwYXJ0IGNhbiBiZSBzaW1wbHkgdHJhbnNmb3JtZWQgYnkgdGhlIG1vdmUgb3BlcmF0aW9uLiBUaGlzIGlzIGJlY2F1c2UgbW92ZSBvcGVyYXRpb24gd2lsbCBub3QgdGFyZ2V0IHRvCiAgLy8gdGhhdCBjb21tb24gcGFydCAodGhlIG9wZXJhdGlvbiB3b3VsZCBoYXZlIHRvIHRhcmdldCBpbnNpZGUgaXRzIG93biBtb3ZlZCByYW5nZSkuCgoKICBpZiAoY29tbW9uKSB7CiAgICByZXN1bHQucHVzaChjb21tb24uX2dldFRyYW5zZm9ybWVkQnlNb3ZlKG1vdmVPcC5zb3VyY2VQb3NpdGlvbiwgbW92ZU9wLnRhcmdldFBvc2l0aW9uLCBtb3ZlT3AuaG93TWFueSwgZmFsc2UpWzBdKTsKICB9CgogIHJldHVybiByZXN1bHQ7Cn0KCnNldFRyYW5zZm9ybWF0aW9uKEF0dHJpYnV0ZU9wZXJhdGlvbiwgU3BsaXRPcGVyYXRpb24sIChhLCBiKSA9PiB7CiAgLy8gQ2FzZSAxOgogIC8vCiAgLy8gU3BsaXQgbm9kZSBpcyB0aGUgbGFzdCBub2RlIGluIGBBdHRyaWJ1dGVPcGVyYXRpb24jcmFuZ2VgLgogIC8vIGBBdHRyaWJ1dGVPcGVyYXRpb24jcmFuZ2VgIG5lZWRzIHRvIGJlIGV4cGFuZGVkIHRvIGluY2x1ZGUgdGhlIG5ldyAoc3BsaXQpIG5vZGUuCiAgLy8KICAvLyBBdHRyaWJ1dGUgYHR5cGVgIHRvIGJlIGNoYW5nZWQgdG8gYG51bWJlcmVkYCBidXQgdGhlIGBsaXN0SXRlbWAgaXMgc3BsaXQuCiAgLy8gPGxpc3RJdGVtIHR5cGU9ImJ1bGxldGVkIj5mb29iYXI8L2xpc3RJdGVtPgogIC8vCiAgLy8gQWZ0ZXIgc3BsaXQ6CiAgLy8gPGxpc3RJdGVtIHR5cGU9ImJ1bGxldGVkIj5mb288L2xpc3RJdGVtPjxsaXN0SXRlbSB0eXBlPSJidWxsZXRlZCI+YmFyPC9saXN0SXRlbT4KICAvLwogIC8vIEFmdGVyIGF0dHJpYnV0ZSBjaGFuZ2U6CiAgLy8gPGxpc3RJdGVtIHR5cGU9Im51bWJlcmVkIj5mb288L2xpc3RJdGVtPjxsaXN0SXRlbSB0eXBlPSJudW1iZXJlZCI+Zm9vPC9saXN0SXRlbT4KICAvLwogIGlmIChhLnJhbmdlLmVuZC5pc0VxdWFsKGIuaW5zZXJ0aW9uUG9zaXRpb24pKSB7CiAgICBpZiAoIWIuZ3JhdmV5YXJkUG9zaXRpb24pIHsKICAgICAgYS5yYW5nZS5lbmQub2Zmc2V0Kys7CiAgICB9CgogICAgcmV0dXJuIFthXTsKICB9IC8vIENhc2UgMjoKICAvLwogIC8vIFNwbGl0IHBvc2l0aW9uIGlzIGluc2lkZSBgQXR0cmlidXRlT3BlcmF0aW9uI3JhbmdlYCwgYXQgdGhlIHNhbWUgbGV2ZWwsIHNvIHRoZSBub2RlcyB0byBjaGFuZ2UgYXJlCiAgLy8gbm90IGdvaW5nIHRvIG1ha2UgYSBmbGF0IHJhbmdlLgogIC8vCiAgLy8gQ29udGVudCB3aXRoIHJhbmdlLXRvLWNoYW5nZSBhbmQgc3BsaXQgcG9zaXRpb246CiAgLy8gPHA+Rm9bemJeYV1yPC9wPgogIC8vCiAgLy8gQWZ0ZXIgc3BsaXQ6CiAgLy8gPHA+Rm96YjwvcD48cD5hcjwvcD4KICAvLwogIC8vIE1ha2UgdHdvIHNlcGFyYXRlIHJhbmdlcyBjb250YWluaW5nIGFsbCBub2RlcyB0byBjaGFuZ2U6CiAgLy8gPHA+Rm9bemJdPC9wPjxwPlthXXI8L3A+CiAgLy8KCgogIGlmIChhLnJhbmdlLnN0YXJ0Lmhhc1NhbWVQYXJlbnRBcyhiLnNwbGl0UG9zaXRpb24pICYmIGEucmFuZ2UuY29udGFpbnNQb3NpdGlvbihiLnNwbGl0UG9zaXRpb24pKSB7CiAgICBjb25zdCBzZWNvbmRQYXJ0ID0gYS5jbG9uZSgpOwogICAgc2Vjb25kUGFydC5yYW5nZSA9IG5ldyBSYW5nZShiLm1vdmVUYXJnZXRQb3NpdGlvbi5jbG9uZSgpLCBhLnJhbmdlLmVuZC5fZ2V0Q29tYmluZWQoYi5zcGxpdFBvc2l0aW9uLCBiLm1vdmVUYXJnZXRQb3NpdGlvbikpOwogICAgYS5yYW5nZS5lbmQgPSBiLnNwbGl0UG9zaXRpb24uY2xvbmUoKTsKICAgIGEucmFuZ2UuZW5kLnN0aWNraW5lc3MgPSAndG9QcmV2aW91cyc7CiAgICByZXR1cm4gW2EsIHNlY29uZFBhcnRdOwogIH0gLy8gVGhlIGRlZmF1bHQgY2FzZS4KICAvLwoKCiAgYS5yYW5nZSA9IGEucmFuZ2UuX2dldFRyYW5zZm9ybWVkQnlTcGxpdE9wZXJhdGlvbihiKTsKICByZXR1cm4gW2FdOwp9KTsKc2V0VHJhbnNmb3JtYXRpb24oSW5zZXJ0T3BlcmF0aW9uLCBBdHRyaWJ1dGVPcGVyYXRpb24sIChhLCBiKSA9PiB7CiAgY29uc3QgcmVzdWx0ID0gW2FdOyAvLyBDYXNlIDE6CiAgLy8KICAvLyBUaGUgYXR0cmlidXRlIG9wZXJhdGlvbiByYW5nZSBpbmNsdWRlcyB0aGUgcG9zaXRpb24gd2hlcmUgbm9kZXMgd2VyZSBpbnNlcnRlZC4KICAvLyBUaGVyZSBhcmUgdHdvIHBvc3NpYmxlIHNjZW5hcmlvczogdGhlIGluc2VydGVkIG5vZGVzIHdlcmUgdGV4dCBhbmQgdGhleSBzaG91bGQgcmVjZWl2ZSBhdHRyaWJ1dGVzIG9yCiAgLy8gdGhlIGluc2VydGVkIG5vZGVzIHdlcmUgZWxlbWVudHMgYW5kIHRoZXkgc2hvdWxkIG5vdCByZWNlaXZlIGF0dHJpYnV0ZXMuCiAgLy8KICAvLyBUaGlzIGlzIGEgbWlycm9yIHNjZW5hcmlvIHRvIHRoZSBvbmUgZGVzY3JpYmVkIGluIGBBdHRyaWJ1dGVPcGVyYXRpb25gIHggYEluc2VydE9wZXJhdGlvbmAgdHJhbnNmb3JtYXRpb24sCiAgLy8gYWx0aG91Z2ggdGhpcyBjYXNlIGlzIGEgbGl0dGxlIGxlc3MgY29tcGxpY2F0ZWQuIEluIHRoaXMgY2FzZSB3ZSBzaW1wbHkgbmVlZCB0byBjaGFuZ2UgYXR0cmlidXRlcyBvZiB0aGUKICAvLyBpbnNlcnRlZCBub2RlcyBhbmQgdGhhdCdzIGl0LgogIC8vCgogIGlmIChhLnNob3VsZFJlY2VpdmVBdHRyaWJ1dGVzICYmIGEucG9zaXRpb24uaGFzU2FtZVBhcmVudEFzKGIucmFuZ2Uuc3RhcnQpICYmIGIucmFuZ2UuY29udGFpbnNQb3NpdGlvbihhLnBvc2l0aW9uKSkgewogICAgY29uc3Qgb3AgPSBfZ2V0Q29tcGxlbWVudGFyeUF0dHJpYnV0ZU9wZXJhdGlvbnMoYSwgYi5rZXksIGIubmV3VmFsdWUpOwoKICAgIGlmIChvcCkgewogICAgICByZXN1bHQucHVzaChvcCk7CiAgICB9CiAgfSAvLyBUaGUgZGVmYXVsdCBjYXNlIGlzOiBkbyBub3RoaW5nLgogIC8vIGBBdHRyaWJ1dGVPcGVyYXRpb25gIGRvZXMgbm90IGNoYW5nZSB0aGUgbW9kZWwgdHJlZSBzdHJ1Y3R1cmUgc28gYEluc2VydE9wZXJhdGlvbmAgZG9lcyBub3QgbmVlZCB0byBiZSBjaGFuZ2VkLgogIC8vCgoKICByZXR1cm4gcmVzdWx0Owp9KTsKc2V0VHJhbnNmb3JtYXRpb24oSW5zZXJ0T3BlcmF0aW9uLCBJbnNlcnRPcGVyYXRpb24sIChhLCBiLCBjb250ZXh0KSA9PiB7CiAgLy8gQ2FzZSAxOgogIC8vCiAgLy8gVHdvIGluc2VydCBvcGVyYXRpb25zIGluc2VydCBub2RlcyBhdCB0aGUgc2FtZSBwb3NpdGlvbi4gU2luY2UgdGhleSBhcmUgdGhlIHNhbWUsIGl0IG5lZWRzIHRvIGJlIGRlY2lkZWQKICAvLyB3aGF0IHdpbGwgYmUgdGhlIG9yZGVyIG9mIGluc2VydGVkIG5vZGVzLiBIb3dldmVyLCB0aGVyZSBpcyBubyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHRvIGhlbHAgaW4gdGhhdAogIC8vIGRlY2lzaW9uLiBBbHNvLCB3aGVuIGBiYCB3aWxsIGJlIHRyYW5zZm9ybWVkIGJ5IGBhYCwgdGhlIHNhbWUgb3JkZXIgbXVzdCBiZSBtYWludGFpbmVkLgogIC8vCiAgLy8gVG8gYWNoaWV2ZSB0aGF0LCB3ZSB3aWxsIGNoZWNrIGlmIHRoZSBvcGVyYXRpb24gaXMgc3Ryb25nLgogIC8vIElmIGl0IGlzLCBpdCB3b24ndCBnZXQgdHJhbnNmb3JtZWQuIElmIGl0IGlzIG5vdCwgaXQgd2lsbCBiZSBtb3ZlZC4KICAvLwogIGlmIChhLnBvc2l0aW9uLmlzRXF1YWwoYi5wb3NpdGlvbikgJiYgY29udGV4dC5hSXNTdHJvbmcpIHsKICAgIHJldHVybiBbYV07CiAgfSAvLyBUaGUgZGVmYXVsdCBjYXNlLgogIC8vCgoKICBhLnBvc2l0aW9uID0gYS5wb3NpdGlvbi5fZ2V0VHJhbnNmb3JtZWRCeUluc2VydE9wZXJhdGlvbihiKTsKICByZXR1cm4gW2FdOwp9KTsKc2V0VHJhbnNmb3JtYXRpb24oSW5zZXJ0T3BlcmF0aW9uLCBNb3ZlT3BlcmF0aW9uLCAoYSwgYikgPT4gewogIC8vIFRoZSBkZWZhdWx0IGNhc2UuCiAgLy8KICBhLnBvc2l0aW9uID0gYS5wb3NpdGlvbi5fZ2V0VHJhbnNmb3JtZWRCeU1vdmVPcGVyYXRpb24oYik7CiAgcmV0dXJuIFthXTsKfSk7CnNldFRyYW5zZm9ybWF0aW9uKEluc2VydE9wZXJhdGlvbiwgU3BsaXRPcGVyYXRpb24sIChhLCBiKSA9PiB7CiAgLy8gVGhlIGRlZmF1bHQgY2FzZS4KICAvLwogIGEucG9zaXRpb24gPSBhLnBvc2l0aW9uLl9nZXRUcmFuc2Zvcm1lZEJ5U3BsaXRPcGVyYXRpb24oYik7CiAgcmV0dXJuIFthXTsKfSk7CnNldFRyYW5zZm9ybWF0aW9uKEluc2VydE9wZXJhdGlvbiwgTWVyZ2VPcGVyYXRpb24sIChhLCBiKSA9PiB7CiAgYS5wb3NpdGlvbiA9IGEucG9zaXRpb24uX2dldFRyYW5zZm9ybWVkQnlNZXJnZU9wZXJhdGlvbihiKTsKICByZXR1cm4gW2FdOwp9KTsgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCnNldFRyYW5zZm9ybWF0aW9uKE1hcmtlck9wZXJhdGlvbiwgSW5zZXJ0T3BlcmF0aW9uLCAoYSwgYikgPT4gewogIGlmIChhLm9sZFJhbmdlKSB7CiAgICBhLm9sZFJhbmdlID0gYS5vbGRSYW5nZS5fZ2V0VHJhbnNmb3JtZWRCeUluc2VydE9wZXJhdGlvbihiKVswXTsKICB9CgogIGlmIChhLm5ld1JhbmdlKSB7CiAgICBhLm5ld1JhbmdlID0gYS5uZXdSYW5nZS5fZ2V0VHJhbnNmb3JtZWRCeUluc2VydE9wZXJhdGlvbihiKVswXTsKICB9CgogIHJldHVybiBbYV07Cn0pOwpzZXRUcmFuc2Zvcm1hdGlvbihNYXJrZXJPcGVyYXRpb24sIE1hcmtlck9wZXJhdGlvbiwgKGEsIGIsIGNvbnRleHQpID0+IHsKICBpZiAoYS5uYW1lID09IGIubmFtZSkgewogICAgaWYgKGNvbnRleHQuYUlzU3Ryb25nKSB7CiAgICAgIGEub2xkUmFuZ2UgPSBiLm5ld1JhbmdlID8gYi5uZXdSYW5nZS5jbG9uZSgpIDogbnVsbDsKICAgIH0gZWxzZSB7CiAgICAgIHJldHVybiBbbmV3IE5vT3BlcmF0aW9uKDApXTsKICAgIH0KICB9CgogIHJldHVybiBbYV07Cn0pOwpzZXRUcmFuc2Zvcm1hdGlvbihNYXJrZXJPcGVyYXRpb24sIE1lcmdlT3BlcmF0aW9uLCAoYSwgYikgPT4gewogIGlmIChhLm9sZFJhbmdlKSB7CiAgICBhLm9sZFJhbmdlID0gYS5vbGRSYW5nZS5fZ2V0VHJhbnNmb3JtZWRCeU1lcmdlT3BlcmF0aW9uKGIpOwogIH0KCiAgaWYgKGEubmV3UmFuZ2UpIHsKICAgIGEubmV3UmFuZ2UgPSBhLm5ld1JhbmdlLl9nZXRUcmFuc2Zvcm1lZEJ5TWVyZ2VPcGVyYXRpb24oYik7CiAgfQoKICByZXR1cm4gW2FdOwp9KTsKc2V0VHJhbnNmb3JtYXRpb24oTWFya2VyT3BlcmF0aW9uLCBNb3ZlT3BlcmF0aW9uLCAoYSwgYiwgY29udGV4dCkgPT4gewogIGlmIChhLm9sZFJhbmdlKSB7CiAgICBhLm9sZFJhbmdlID0gUmFuZ2UuX2NyZWF0ZUZyb21SYW5nZXMoYS5vbGRSYW5nZS5fZ2V0VHJhbnNmb3JtZWRCeU1vdmVPcGVyYXRpb24oYikpOwogIH0KCiAgaWYgKGEubmV3UmFuZ2UpIHsKICAgIGlmIChjb250ZXh0LmFiUmVsYXRpb24pIHsKICAgICAgY29uc3QgYU5ld1JhbmdlID0gUmFuZ2UuX2NyZWF0ZUZyb21SYW5nZXMoYS5uZXdSYW5nZS5fZ2V0VHJhbnNmb3JtZWRCeU1vdmVPcGVyYXRpb24oYikpOwoKICAgICAgaWYgKGNvbnRleHQuYWJSZWxhdGlvbi5zaWRlID09ICdsZWZ0JyAmJiBiLnRhcmdldFBvc2l0aW9uLmlzRXF1YWwoYS5uZXdSYW5nZS5zdGFydCkpIHsKICAgICAgICBhLm5ld1JhbmdlLnN0YXJ0LnBhdGggPSBjb250ZXh0LmFiUmVsYXRpb24ucGF0aDsKICAgICAgICBhLm5ld1JhbmdlLmVuZCA9IGFOZXdSYW5nZS5lbmQ7CiAgICAgICAgcmV0dXJuIFthXTsKICAgICAgfSBlbHNlIGlmIChjb250ZXh0LmFiUmVsYXRpb24uc2lkZSA9PSAncmlnaHQnICYmIGIudGFyZ2V0UG9zaXRpb24uaXNFcXVhbChhLm5ld1JhbmdlLmVuZCkpIHsKICAgICAgICBhLm5ld1JhbmdlLnN0YXJ0ID0gYU5ld1JhbmdlLnN0YXJ0OwogICAgICAgIGEubmV3UmFuZ2UuZW5kLnBhdGggPSBjb250ZXh0LmFiUmVsYXRpb24ucGF0aDsKICAgICAgICByZXR1cm4gW2FdOwogICAgICB9CiAgICB9CgogICAgYS5uZXdSYW5nZSA9IFJhbmdlLl9jcmVhdGVGcm9tUmFuZ2VzKGEubmV3UmFuZ2UuX2dldFRyYW5zZm9ybWVkQnlNb3ZlT3BlcmF0aW9uKGIpKTsKICB9CgogIHJldHVybiBbYV07Cn0pOwpzZXRUcmFuc2Zvcm1hdGlvbihNYXJrZXJPcGVyYXRpb24sIFNwbGl0T3BlcmF0aW9uLCAoYSwgYiwgY29udGV4dCkgPT4gewogIGlmIChhLm9sZFJhbmdlKSB7CiAgICBhLm9sZFJhbmdlID0gYS5vbGRSYW5nZS5fZ2V0VHJhbnNmb3JtZWRCeVNwbGl0T3BlcmF0aW9uKGIpOwogIH0KCiAgaWYgKGEubmV3UmFuZ2UpIHsKICAgIGlmIChjb250ZXh0LmFiUmVsYXRpb24pIHsKICAgICAgY29uc3QgYU5ld1JhbmdlID0gYS5uZXdSYW5nZS5fZ2V0VHJhbnNmb3JtZWRCeVNwbGl0T3BlcmF0aW9uKGIpOwoKICAgICAgaWYgKGEubmV3UmFuZ2Uuc3RhcnQuaXNFcXVhbChiLnNwbGl0UG9zaXRpb24pICYmIGNvbnRleHQuYWJSZWxhdGlvbi53YXNTdGFydEJlZm9yZU1lcmdlZEVsZW1lbnQpIHsKICAgICAgICBhLm5ld1JhbmdlLnN0YXJ0ID0gUG9zaXRpb24uX2NyZWF0ZUF0KGIuaW5zZXJ0aW9uUG9zaXRpb24pOwogICAgICB9IGVsc2UgaWYgKGEubmV3UmFuZ2Uuc3RhcnQuaXNFcXVhbChiLnNwbGl0UG9zaXRpb24pICYmICFjb250ZXh0LmFiUmVsYXRpb24ud2FzSW5MZWZ0RWxlbWVudCkgewogICAgICAgIGEubmV3UmFuZ2Uuc3RhcnQgPSBQb3NpdGlvbi5fY3JlYXRlQXQoYi5tb3ZlVGFyZ2V0UG9zaXRpb24pOwogICAgICB9CgogICAgICBpZiAoYS5uZXdSYW5nZS5lbmQuaXNFcXVhbChiLnNwbGl0UG9zaXRpb24pICYmIGNvbnRleHQuYWJSZWxhdGlvbi53YXNJblJpZ2h0RWxlbWVudCkgewogICAgICAgIGEubmV3UmFuZ2UuZW5kID0gUG9zaXRpb24uX2NyZWF0ZUF0KGIubW92ZVRhcmdldFBvc2l0aW9uKTsKICAgICAgfSBlbHNlIGlmIChhLm5ld1JhbmdlLmVuZC5pc0VxdWFsKGIuc3BsaXRQb3NpdGlvbikgJiYgY29udGV4dC5hYlJlbGF0aW9uLndhc0VuZEJlZm9yZU1lcmdlZEVsZW1lbnQpIHsKICAgICAgICBhLm5ld1JhbmdlLmVuZCA9IFBvc2l0aW9uLl9jcmVhdGVBdChiLmluc2VydGlvblBvc2l0aW9uKTsKICAgICAgfSBlbHNlIHsKICAgICAgICBhLm5ld1JhbmdlLmVuZCA9IGFOZXdSYW5nZS5lbmQ7CiAgICAgIH0KCiAgICAgIHJldHVybiBbYV07CiAgICB9CgogICAgYS5uZXdSYW5nZSA9IGEubmV3UmFuZ2UuX2dldFRyYW5zZm9ybWVkQnlTcGxpdE9wZXJhdGlvbihiKTsKICB9CgogIHJldHVybiBbYV07Cn0pOyAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKc2V0VHJhbnNmb3JtYXRpb24oTWVyZ2VPcGVyYXRpb24sIEluc2VydE9wZXJhdGlvbiwgKGEsIGIpID0+IHsKICBpZiAoYS5zb3VyY2VQb3NpdGlvbi5oYXNTYW1lUGFyZW50QXMoYi5wb3NpdGlvbikpIHsKICAgIGEuaG93TWFueSArPSBiLmhvd01hbnk7CiAgfQoKICBhLnNvdXJjZVBvc2l0aW9uID0gYS5zb3VyY2VQb3NpdGlvbi5fZ2V0VHJhbnNmb3JtZWRCeUluc2VydE9wZXJhdGlvbihiKTsKICBhLnRhcmdldFBvc2l0aW9uID0gYS50YXJnZXRQb3NpdGlvbi5fZ2V0VHJhbnNmb3JtZWRCeUluc2VydE9wZXJhdGlvbihiKTsKICByZXR1cm4gW2FdOwp9KTsKc2V0VHJhbnNmb3JtYXRpb24oTWVyZ2VPcGVyYXRpb24sIE1lcmdlT3BlcmF0aW9uLCAoYSwgYiwgY29udGV4dCkgPT4gewogIC8vIENhc2UgMToKICAvLwogIC8vIFNhbWUgbWVyZ2Ugb3BlcmF0aW9ucy4KICAvLwogIC8vIEJvdGggb3BlcmF0aW9ucyBoYXZlIHNhbWUgc291cmNlIGFuZCB0YXJnZXQgcG9zaXRpb25zLiBTbyB0aGUgZWxlbWVudCBhbHJlYWR5IGdvdCBtZXJnZWQgYW5kIHRoZXJlIGlzCiAgLy8gdGhlb3JldGljYWxseSBub3RoaW5nIHRvIGRvLgogIC8vCiAgaWYgKGEuc291cmNlUG9zaXRpb24uaXNFcXVhbChiLnNvdXJjZVBvc2l0aW9uKSAmJiBhLnRhcmdldFBvc2l0aW9uLmlzRXF1YWwoYi50YXJnZXRQb3NpdGlvbikpIHsKICAgIC8vIFRoZXJlIGFyZSB0d28gd2F5cyB0aGF0IHdlIGNhbiBwcm92aWRlIGEgZG8tbm90aGluZyBvcGVyYXRpb24uCiAgICAvLwogICAgLy8gRmlyc3QgaXMgc2ltcGx5IGEgTm9PcGVyYXRpb24gaW5zdGFuY2UuIFdlIHdpbGwgdXNlIGl0IGlmIGBiYCBvcGVyYXRpb24gd2FzIG5vdCB1bmRvbmUuCiAgICAvLwogICAgLy8gU2Vjb25kIGlzIGEgbWVyZ2Ugb3BlcmF0aW9uIHRoYXQgaGFzIHRoZSBzb3VyY2Ugb3BlcmF0aW9uIGluIHRoZSBtZXJnZWQgZWxlbWVudCAtIGluIHRoZSBncmF2ZXlhcmQgLQogICAgLy8gc2FtZSB0YXJnZXQgcG9zaXRpb24gYW5kIGBob3dNYW55YCBlcXVhbCB0byBgMGAuIFNvIGl0IGlzIGJhc2ljYWxseSBtZXJnaW5nIGFuIGVtcHR5IGVsZW1lbnQgZnJvbSBncmF2ZXlhcmQKICAgIC8vIHdoaWNoIGlzIGFsbW9zdCB0aGUgc2FtZSBhcyBOb09wZXJhdGlvbi4KICAgIC8vCiAgICAvLyBUaGlzIHdheSB0aGUgbWVyZ2Ugb3BlcmF0aW9uIGNhbiBiZSBsYXRlciB0cmFuc2Zvcm1lZCBieSBzcGxpdCBvcGVyYXRpb24KICAgIC8vIHRvIHByb3ZpZGUgY29ycmVjdCB1bmRvLiBUaGlzIHdpbGwgYmUgdXNlZCBpZiBgYmAgb3BlcmF0aW9uIHdhcyB1bmRvbmUgKG9ubHkgdGhlbiBpdCBpcyBjb3JyZWN0KS4KICAgIC8vCiAgICBpZiAoIWNvbnRleHQuYldhc1VuZG9uZSkgewogICAgICByZXR1cm4gW25ldyBOb09wZXJhdGlvbigwKV07CiAgICB9IGVsc2UgewogICAgICBjb25zdCBwYXRoID0gYi5ncmF2ZXlhcmRQb3NpdGlvbi5wYXRoLnNsaWNlKCk7CiAgICAgIHBhdGgucHVzaCgwKTsKICAgICAgYS5zb3VyY2VQb3NpdGlvbiA9IG5ldyBQb3NpdGlvbihiLmdyYXZleWFyZFBvc2l0aW9uLnJvb3QsIHBhdGgpOwogICAgICBhLmhvd01hbnkgPSAwOwogICAgICByZXR1cm4gW2FdOwogICAgfQogIH0gLy8gQ2FzZSAyOgogIC8vCiAgLy8gU2FtZSBtZXJnZSBzb3VyY2UgcG9zaXRpb24gYnV0IGRpZmZlcmVudCB0YXJnZXQgcG9zaXRpb24uCiAgLy8KICAvLyBUaGlzIGNhbiBoYXBwZW4gZHVyaW5nIGNvbGxhYm9yYXRpb24uIEZvciBleGFtcGxlLCBpZiBvbmUgY2xpZW50IG1lcmdlZCBhIHBhcmFncmFwaCB0byB0aGUgcHJldmlvdXMgcGFyYWdyYXBoCiAgLy8gYW5kIHRoZSBvdGhlciBwZXJzb24gcmVtb3ZlZCB0aGF0IHBhcmFncmFwaCBhbmQgbWVyZ2VkIHRoZSBzYW1lIHBhcmFncmFwaCB0byBzb21ldGhpbmcgYmVmb3JlOgogIC8vCiAgLy8gQ2xpZW50IEE6CiAgLy8gPHA+Rm9vPC9wPjxwPkJhcjwvcD48cD5bXVh5ejwvcD4KICAvLyA8cD5Gb288L3A+PHA+QmFyWHl6PC9wPgogIC8vCiAgLy8gQ2xpZW50IEI6CiAgLy8gPHA+Rm9vPC9wPls8cD5CYXI8L3A+XTxwPlh5ejwvcD4KICAvLyA8cD5Gb288L3A+PHA+W11YeXo8L3A+CiAgLy8gPHA+Rm9vWHl6PC9wPgogIC8vCiAgLy8gSW4gdGhpcyBjYXNlIHdlIG5lZWQgdG8gZGVjaWRlIHdoZXJlIGZpbmFsbHkgIlh5eiIgd2lsbCBsYW5kOgogIC8vCiAgLy8gPHA+Rm9vWHl6PC9wPiAgICAgICAgICAgICAgIGdyYXZleWFyZDogPHA+QmFyPC9wPgogIC8vIDxwPkZvbzwvcD4gICAgICAgICAgICAgICAgICBncmF2ZXlhcmQ6IDxwPkJhclh5ejwvcD4KICAvLwogIC8vIExldCdzIG1vdmUgaXQgaW4gYSB3YXkgc28gdGhhdCBhIG1lcmdlIG9wZXJhdGlvbiB0aGF0IGRvZXMgbm90IHRhcmdldCB0byBncmF2ZXlhcmQgaXMgbW9yZSBpbXBvcnRhbnQgc28gdGhhdAogIC8vIG5vZGVzIGRvZXMgbm90IGVuZCB1cCBpbiB0aGUgZ3JhdmV5YXJkLiBJdCBtYWtlcyBzZW5zZS4gQm90aCBmb3IgQ2xpZW50IEEgYW5kIGZvciBDbGllbnQgQiAiWHl6IiBmaW5hbGx5IGRpZCBub3QKICAvLyBlbmQgdXAgaW4gdGhlIGdyYXZleWFyZCAoc2VlIGFib3ZlKS4KICAvLwogIC8vIElmIG5laXRoZXIgb3IgYm90aCBvcGVyYXRpb25zIHBvaW50IHRvIGdyYXZleWFyZCwgdGhlbiBsZXQgYGFJc1N0cm9uZ2AgZGVjaWRlLgogIC8vCgoKICBpZiAoYS5zb3VyY2VQb3NpdGlvbi5pc0VxdWFsKGIuc291cmNlUG9zaXRpb24pICYmICFhLnRhcmdldFBvc2l0aW9uLmlzRXF1YWwoYi50YXJnZXRQb3NpdGlvbikgJiYgIWNvbnRleHQuYldhc1VuZG9uZSAmJiBjb250ZXh0LmFiUmVsYXRpb24gIT0gJ3NwbGl0QXRTb3VyY2UnKSB7CiAgICBjb25zdCBhVG9HcmF2ZXlhcmQgPSBhLnRhcmdldFBvc2l0aW9uLnJvb3Qucm9vdE5hbWUgPT0gJyRncmF2ZXlhcmQnOwogICAgY29uc3QgYlRvR3JhdmV5YXJkID0gYi50YXJnZXRQb3NpdGlvbi5yb290LnJvb3ROYW1lID09ICckZ3JhdmV5YXJkJzsgLy8gSWYgYGFJc1dlYWtgIGl0IG1lYW5zIHRoYXQgYGFgIHBvaW50cyB0byBncmF2ZXlhcmQgd2hpbGUgYGJgIGRvZXNuJ3QuIERvbid0IG1vdmUgbm9kZXMgdGhlbi4KCiAgICBjb25zdCBhSXNXZWFrID0gYVRvR3JhdmV5YXJkICYmICFiVG9HcmF2ZXlhcmQ7IC8vIElmIGBiSXNXZWFrYCBpdCBtZWFucyB0aGF0IGBiYCBwb2ludHMgdG8gZ3JhdmV5YXJkIHdoaWxlIGBhYCBkb2Vzbid0LiBGb3JjZSBtb3Zpbmcgbm9kZXMgdGhlbi4KCiAgICBjb25zdCBiSXNXZWFrID0gYlRvR3JhdmV5YXJkICYmICFhVG9HcmF2ZXlhcmQ7IC8vIEZvcmNlIG1vdmUgaWYgYGJgIGlzIHdlYWsgb3IgbmVpdGhlciBvcGVyYXRpb24gaXMgd2VhayBidXQgYGFgIGlzIHN0cm9uZ2VyIHRocm91Z2ggYGNvbnRleHQuYUlzU3Ryb25nYC4KCiAgICBjb25zdCBmb3JjZU1vdmUgPSBiSXNXZWFrIHx8ICFhSXNXZWFrICYmIGNvbnRleHQuYUlzU3Ryb25nOwoKICAgIGlmIChmb3JjZU1vdmUpIHsKICAgICAgY29uc3Qgc291cmNlUG9zaXRpb24gPSBiLnRhcmdldFBvc2l0aW9uLl9nZXRUcmFuc2Zvcm1lZEJ5TWVyZ2VPcGVyYXRpb24oYik7CgogICAgICBjb25zdCB0YXJnZXRQb3NpdGlvbiA9IGEudGFyZ2V0UG9zaXRpb24uX2dldFRyYW5zZm9ybWVkQnlNZXJnZU9wZXJhdGlvbihiKTsKCiAgICAgIHJldHVybiBbbmV3IE1vdmVPcGVyYXRpb24oc291cmNlUG9zaXRpb24sIGEuaG93TWFueSwgdGFyZ2V0UG9zaXRpb24sIDApXTsKICAgIH0gZWxzZSB7CiAgICAgIHJldHVybiBbbmV3IE5vT3BlcmF0aW9uKDApXTsKICAgIH0KICB9IC8vIFRoZSBkZWZhdWx0IGNhc2UuCiAgLy8KCgogIGlmIChhLnNvdXJjZVBvc2l0aW9uLmhhc1NhbWVQYXJlbnRBcyhiLnRhcmdldFBvc2l0aW9uKSkgewogICAgYS5ob3dNYW55ICs9IGIuaG93TWFueTsKICB9CgogIGEuc291cmNlUG9zaXRpb24gPSBhLnNvdXJjZVBvc2l0aW9uLl9nZXRUcmFuc2Zvcm1lZEJ5TWVyZ2VPcGVyYXRpb24oYik7CiAgYS50YXJnZXRQb3NpdGlvbiA9IGEudGFyZ2V0UG9zaXRpb24uX2dldFRyYW5zZm9ybWVkQnlNZXJnZU9wZXJhdGlvbihiKTsgLy8gSGFuZGxlIHBvc2l0aW9ucyBpbiBncmF2ZXlhcmQuCiAgLy8gSWYgZ3JhdmV5YXJkIHBvc2l0aW9ucyBhcmUgc2FtZSBhbmQgYGFgIG9wZXJhdGlvbiBpcyBzdHJvbmcgLSBkbyBub3QgdHJhbnNmb3JtLgoKICBpZiAoIWEuZ3JhdmV5YXJkUG9zaXRpb24uaXNFcXVhbChiLmdyYXZleWFyZFBvc2l0aW9uKSB8fCAhY29udGV4dC5hSXNTdHJvbmcpIHsKICAgIGEuZ3JhdmV5YXJkUG9zaXRpb24gPSBhLmdyYXZleWFyZFBvc2l0aW9uLl9nZXRUcmFuc2Zvcm1lZEJ5TWVyZ2VPcGVyYXRpb24oYik7CiAgfQoKICByZXR1cm4gW2FdOwp9KTsKc2V0VHJhbnNmb3JtYXRpb24oTWVyZ2VPcGVyYXRpb24sIE1vdmVPcGVyYXRpb24sIChhLCBiLCBjb250ZXh0KSA9PiB7CiAgLy8gQ2FzZSAxOgogIC8vCiAgLy8gVGhlIGVsZW1lbnQgdG8gbWVyZ2UgZ290IHJlbW92ZWQuCiAgLy8KICAvLyBNZXJnZSBvcGVyYXRpb24gZG9lcyBzdXBwb3J0IG1lcmdpbmcgZWxlbWVudHMgd2hpY2ggYXJlIG5vdCBzaWJsaW5ncy4gU28gaXQgd291bGQgbm90IGJlIGEgcHJvYmxlbQogIC8vIGZyb20gdGVjaG5pY2FsIHBvaW50IG9mIHZpZXcuIEhvd2V2ZXIsIGlmIHRoZSBlbGVtZW50IHdhcyByZW1vdmVkLCB0aGUgaW50ZW50aW9uIG9mIHRoZSB1c2VyIGRlbGV0aW5nIGl0CiAgLy8gd2FzIHRvIGhhdmUgaXQgYWxsIGRlbGV0ZWQsIHRvZ2V0aGVyIHdpdGggaXRzIGNoaWxkcmVuLiBGcm9tIHVzZXIgZXhwZXJpZW5jZSBwb2ludCBvZiB2aWV3LCBtb3ZpbmcgYmFjayB0aGUKICAvLyByZW1vdmVkIG5vZGVzIG1pZ2h0IGJlIHVuZXhwZWN0ZWQuIFRoaXMgbWVhbnMgdGhhdCBpbiB0aGlzIHNjZW5hcmlvIHdlIHdpbGwgYmxvY2sgdGhlIG1lcmdpbmcuCiAgLy8KICAvLyBUaGUgZXhjZXB0aW9uIG9mIHRoaXMgcnVsZSB3b3VsZCBiZSBpZiB0aGUgcmVtb3ZlIG9wZXJhdGlvbiB3YXMgbGF0ZXIgdW5kb25lLgogIC8vCiAgY29uc3QgcmVtb3ZlZFJhbmdlID0gUmFuZ2UuX2NyZWF0ZUZyb21Qb3NpdGlvbkFuZFNoaWZ0KGIuc291cmNlUG9zaXRpb24sIGIuaG93TWFueSk7CgogIGlmIChiLnR5cGUgPT0gJ3JlbW92ZScgJiYgIWNvbnRleHQuYldhc1VuZG9uZSAmJiAhY29udGV4dC5mb3JjZVdlYWtSZW1vdmUpIHsKICAgIGlmIChhLmRlbGV0aW9uUG9zaXRpb24uaGFzU2FtZVBhcmVudEFzKGIuc291cmNlUG9zaXRpb24pICYmIHJlbW92ZWRSYW5nZS5jb250YWluc1Bvc2l0aW9uKGEuc291cmNlUG9zaXRpb24pKSB7CiAgICAgIHJldHVybiBbbmV3IE5vT3BlcmF0aW9uKDApXTsKICAgIH0KICB9IC8vIFRoZSBkZWZhdWx0IGNhc2UuCiAgLy8KCgogIGlmIChhLnNvdXJjZVBvc2l0aW9uLmhhc1NhbWVQYXJlbnRBcyhiLnRhcmdldFBvc2l0aW9uKSkgewogICAgYS5ob3dNYW55ICs9IGIuaG93TWFueTsKICB9CgogIGlmIChhLnNvdXJjZVBvc2l0aW9uLmhhc1NhbWVQYXJlbnRBcyhiLnNvdXJjZVBvc2l0aW9uKSkgewogICAgYS5ob3dNYW55IC09IGIuaG93TWFueTsKICB9CgogIGEuc291cmNlUG9zaXRpb24gPSBhLnNvdXJjZVBvc2l0aW9uLl9nZXRUcmFuc2Zvcm1lZEJ5TW92ZU9wZXJhdGlvbihiKTsKICBhLnRhcmdldFBvc2l0aW9uID0gYS50YXJnZXRQb3NpdGlvbi5fZ2V0VHJhbnNmb3JtZWRCeU1vdmVPcGVyYXRpb24oYik7IC8vIGBNZXJnZU9wZXJhdGlvbmAgZ3JhdmV5YXJkIHBvc2l0aW9uIGlzIGxpa2UgYE1vdmVPcGVyYXRpb25gIHRhcmdldCBwb3NpdGlvbi4gSXQgaXMgYSBwb3NpdGlvbiB3aGVyZSBlbGVtZW50KHMpIHdpbGwKICAvLyBiZSBtb3ZlZC4gTGlrZSBpbiBvdGhlciBzaW1pbGFyIGNhc2VzLCB3ZSBuZWVkIHRvIGNvbnNpZGVyIHRoZSBzY2VuYXJpbyB3aGVuIHRob3NlIHBvc2l0aW9ucyBhcmUgc2FtZS4KICAvLyBIZXJlLCB3ZSB3aWxsIHRyZWF0IGBNZXJnZU9wZXJhdGlvbmAgbGlrZSBpdCBpcyBhbHdheXMgc3Ryb25nIChzZWUgYEluc2VydE9wZXJhdGlvbmAgeCBgSW5zZXJ0T3BlcmF0aW9uYCBmb3IgY29tcGFyaXNvbikuCiAgLy8gVGhpcyBtZWFucyB0aGF0IHdlIHdvbid0IHRyYW5zZm9ybSBncmF2ZXlhcmQgcG9zaXRpb24gaWYgaXQgaXMgZXF1YWwgdG8gbW92ZSBvcGVyYXRpb24gdGFyZ2V0IHBvc2l0aW9uLgoKICBpZiAoIWEuZ3JhdmV5YXJkUG9zaXRpb24uaXNFcXVhbChiLnRhcmdldFBvc2l0aW9uKSkgewogICAgYS5ncmF2ZXlhcmRQb3NpdGlvbiA9IGEuZ3JhdmV5YXJkUG9zaXRpb24uX2dldFRyYW5zZm9ybWVkQnlNb3ZlT3BlcmF0aW9uKGIpOwogIH0KCiAgcmV0dXJuIFthXTsKfSk7CnNldFRyYW5zZm9ybWF0aW9uKE1lcmdlT3BlcmF0aW9uLCBTcGxpdE9wZXJhdGlvbiwgKGEsIGIsIGNvbnRleHQpID0+IHsKICBpZiAoYi5ncmF2ZXlhcmRQb3NpdGlvbikgewogICAgLy8gSWYgYGJgIG9wZXJhdGlvbiBkZWZpbmVzIGdyYXZleWFyZCBwb3NpdGlvbiwgYSBub2RlIGZyb20gZ3JhdmV5YXJkIHdpbGwgYmUgbW92ZWQuIFRoaXMgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvCiAgICAvLyB0cmFuc2Zvcm0gYGEuZ3JhdmV5YXJkUG9zaXRpb25gIGFjY29yZGluZ2x5LgogICAgYS5ncmF2ZXlhcmRQb3NpdGlvbiA9IGEuZ3JhdmV5YXJkUG9zaXRpb24uX2dldFRyYW5zZm9ybWVkQnlEZWxldGlvbihiLmdyYXZleWFyZFBvc2l0aW9uLCAxKTsgLy8gVGhpcyBpcyBhIHNjZW5hcmlvIGZvcmVzZWVuIGluIGBNZXJnZU9wZXJhdGlvbmAgeCBgTWVyZ2VPcGVyYXRpb25gLCB3aXRoIHR3byBpZGVudGljYWwgbWVyZ2Ugb3BlcmF0aW9ucy4KICAgIC8vCiAgICAvLyBTbywgdGhlcmUgd2FzIGBNZXJnZU9wZXJhdGlvbmAgeCBgTWVyZ2VPcGVyYXRpb25gIHRyYW5zZm9ybWF0aW9uIGVhcmxpZXIuIE5vdywgYGFgIGlzIGEgbWVyZ2Ugb3BlcmF0aW9uIHdoaWNoCiAgICAvLyBzb3VyY2UgcG9zaXRpb24gaXMgaW4gZ3JhdmV5YXJkLiBJbnRlcmVzdGluZ2x5LCBzcGxpdCBvcGVyYXRpb24gd2FudHMgdG8gdXNlIHRoZSBub2RlIHRvIGJlIG1lcmdlZCBieSBgYWAuIFRoaXMKICAgIC8vIG1lYW5zIHRoYXQgYGJgIGlzIHVuZG9pbmcgdGhhdCBtZXJnZSBvcGVyYXRpb24gZnJvbSBlYXJsaWVyLCB3aGljaCBjYXVzZWQgYGFgIHRvIGJlIGluIGdyYXZleWFyZC4KICAgIC8vCiAgICAvLyBJZiB0aGF0J3MgdGhlIGNhc2UsIGF0IHRoaXMgcG9pbnQsIHdlIHdpbGwgb25seSAiZml4IiBgYS5ob3dNYW55YC4gSXQgd2FzIGVhcmxpZXIgc2V0IHRvIGAwYCBpbgogICAgLy8gYE1lcmdlT3BlcmF0aW9uYCB4IGBNZXJnZU9wZXJhdGlvbmAgdHJhbnNmb3JtYXRpb24uIExhdGVyIHRyYW5zZm9ybWF0aW9ucyBpbiB0aGlzIGZ1bmN0aW9uIHdpbGwgY2hhbmdlIG90aGVyCiAgICAvLyBwcm9wZXJ0aWVzLgogICAgLy8KCiAgICBpZiAoYS5kZWxldGlvblBvc2l0aW9uLmlzRXF1YWwoYi5ncmF2ZXlhcmRQb3NpdGlvbikpIHsKICAgICAgYS5ob3dNYW55ID0gYi5ob3dNYW55OwogICAgfQogIH0gLy8gQ2FzZSAxOgogIC8vCiAgLy8gTWVyZ2Ugb3BlcmF0aW9uIG1vdmVzIG5vZGVzIHRvIHRoZSBwbGFjZSB3aGVyZSBzcGxpdCBoYXBwZW5zLgogIC8vIFRoaXMgaXMgYSBjbGFzc2ljIHNpdHVhdGlvbiB3aGVuIHRoZXJlIGFyZSB0d28gcGFyYWdyYXBocywgYW5kIHRoZXJlIGlzIGEgc3BsaXQgKGVudGVyKSBhZnRlciB0aGUgZmlyc3QKICAvLyBwYXJhZ3JhcGggYW5kIHRoZXJlIGlzIGEgbWVyZ2UgKGRlbGV0ZSkgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgc2Vjb25kIHBhcmFncmFwaDoKICAvLwogIC8vIDxwPkZvb3t9PC9wPjxwPltdQmFyPC9wPi4KICAvLwogIC8vIFNwbGl0IGlzIGFmdGVyIGBGb29gLCB3aGlsZSBtZXJnZSBpcyBmcm9tIGBCYXJgIHRvIHRoZSBlbmQgb2YgYEZvb2AuCiAgLy8KICAvLyBTdGF0ZSBhZnRlciBzcGxpdDoKICAvLyA8cD5Gb288L3A+PHA+PC9wPjxwPkJhcjwvcD4KICAvLwogIC8vIE5vdywgYEJhcmAgc2hvdWxkIGJlIG1lcmdlZCB0byB0aGUgbmV3IHBhcmFncmFwaDoKICAvLyA8cD5Gb288L3A+PHA+QmFyPC9wPgogIC8vCiAgLy8gSW5zdGVhZCBvZiBtZXJnaW5nIGl0IHRvIHRoZSBvcmlnaW5hbCBwYXJhZ3JhcGg6CiAgLy8gPHA+Rm9vQmFyPC9wPjxwPjwvcD4KICAvLwogIC8vIFRoaXMgbWVhbnMgdGhhdCBgdGFyZ2V0UG9zaXRpb25gIG5lZWRzIHRvIGJlIHRyYW5zZm9ybWVkLiBUaGlzIGlzIHRoZSBkZWZhdWx0IGNhc2UgdGhvdWdoLgogIC8vIEZvciBleGFtcGxlLCBpZiB0aGUgc3BsaXQgd291bGQgYmUgYWZ0ZXIgYEZgLCBgdGFyZ2V0UG9zaXRpb25gIHNob3VsZCBhbHNvIGJlIHRyYW5zZm9ybWVkLgogIC8vCiAgLy8gVGhlcmUgYXJlIHRocmVlIGV4Y2VwdGlvbnMsIHRob3VnaCwgd2hlbiB3ZSB3YW50IHRvIGtlZXAgYHRhcmdldFBvc2l0aW9uYCBhcyBpdCB3YXMuCiAgLy8KICAvLyBGaXJzdCBleGNlcHRpb24gaXMgd2hlbiB0aGUgbWVyZ2UgdGFyZ2V0IHBvc2l0aW9uIGlzIGluc2lkZSBhbiBlbGVtZW50IChub3QgYXQgdGhlIGVuZCwgYXMgdXN1YWwpLiBUaGlzCiAgLy8gaGFwcGVucyB3aGVuIHRoZSBtZXJnZSBvcGVyYXRpb24gZWFybGllciB3YXMgdHJhbnNmb3JtZWQgYnkgInRoZSBzYW1lIiBtZXJnZSBvcGVyYXRpb24uIElmIG1lcmdlIG9wZXJhdGlvbgogIC8vIHRhcmdldHMgaW5zaWRlIHRoZSBlbGVtZW50IHdlIHdhbnQgdG8ga2VlcCB0aGUgb3JpZ2luYWwgdGFyZ2V0IHBvc2l0aW9uIChhbmQgbm90IHRyYW5zZm9ybSBpdCkgYmVjYXVzZQogIC8vIHdlIGhhdmUgYWRkaXRpb25hbCBjb250ZXh0IHRlbGxpbmcgdXMgdGhhdCB3ZSB3YW50IHRvIG1lcmdlIHRvIHRoZSBvcmlnaW5hbCBlbGVtZW50LiBXZSBjYW4gY2hlY2sgaWYgdGhlCiAgLy8gbWVyZ2Ugb3BlcmF0aW9uIHBvaW50cyBpbnNpZGUgZWxlbWVudCBieSBjaGVja2luZyB3aGF0IGlzIGBTcGxpdE9wZXJhdGlvbiNob3dNYW55YC4gU2luY2UgbWVyZ2UgdGFyZ2V0IHBvc2l0aW9uCiAgLy8gaXMgc2FtZSBhcyBzcGxpdCBwb3NpdGlvbiwgaWYgYGhvd01hbnlgIGlzIG5vbi16ZXJvLCBpdCBtZWFucyB0aGF0IHRoZSBtZXJnZSB0YXJnZXQgcG9zaXRpb24gaXMgaW5zaWRlIGFuIGVsZW1lbnQuCiAgLy8KICAvLyBTZWNvbmQgZXhjZXB0aW9uIGlzIHdoZW4gdGhlIGVsZW1lbnQgdG8gbWVyZ2UgaXMgaW4gdGhlIGdyYXZleWFyZCBhbmQgc3BsaXQgb3BlcmF0aW9uIHVzZXMgaXQuIEluIHRoYXQgY2FzZQogIC8vIGlmIHRhcmdldCBwb3NpdGlvbiB3b3VsZCBiZSB0cmFuc2Zvcm1lZCwgdGhlIG1lcmdlIG9wZXJhdGlvbiB3b3VsZCB0YXJnZXQgYXQgdGhlIHNvdXJjZSBwb3NpdGlvbjoKICAvLwogIC8vIHJvb3Q6IDxwPkZvbzwvcD4JCQkJZ3JhdmV5YXJkOiA8cD48L3A+CiAgLy8KICAvLyBTcGxpdE9wZXJhdGlvbjogcm9vdCBbIDAsIDMgXSB1c2luZyBncmF2ZXlhcmQgWyAwIF0gKGhvd01hbnkgPSAwKQogIC8vIE1lcmdlT3BlcmF0aW9uOiBncmF2ZXlhcmQgWyAwLCAwIF0gLT4gcm9vdCBbIDAsIDMgXSAoaG93TWFueSA9IDApCiAgLy8KICAvLyBTaW5jZSBzcGxpdCBvcGVyYXRpb24gbW92ZXMgdGhlIGdyYXZleWFyZCBub2RlIGJhY2sgdG8gdGhlIHJvb3QsIHRoZSBtZXJnZSBvcGVyYXRpb24gc291cmNlIHBvc2l0aW9uIGNoYW5nZXMuCiAgLy8gV2Ugd291bGQgbGlrZSB0byBtZXJnZSBmcm9tIHRoZSBlbXB0eSA8cD4gdG8gdGhlICJGb28iIDxwPjoKICAvLwogIC8vIHJvb3Q6IDxwPkZvbzwvcD48cD48L3A+CQkJZ3JhdmV5YXJkOgogIC8vCiAgLy8gTWVyZ2VPcGVyYXRpb24jc291cmNlUG9zaXRpb24gPSByb290IFsgMSwgMCBdCiAgLy8KICAvLyBJZiBgdGFyZ2V0UG9zaXRpb25gIGlzIHRyYW5zZm9ybWVkLCBpdCB3b3VsZCBiZWNvbWUgcm9vdCBbIDEsIDAgXSBhcyB3ZWxsLiBJdCBoYXMgdG8gYmUga2VwdCBhcyBpdCB3YXMuCiAgLy8KICAvLyBUaGlyZCBleGNlcHRpb24gaXMgY29ubmVjdGVkIHdpdGggcmVsYXRpb25zLiBJZiB0aGlzIGhhcHBlbnMgZHVyaW5nIHVuZG8gYW5kIHdlIGhhdmUgZXhwbGljaXQgaW5mb3JtYXRpb24KICAvLyB0aGF0IHRhcmdldCBwb3NpdGlvbiBoYXMgbm90IGJlZW4gYWZmZWN0ZWQgYnkgdGhlIG9wZXJhdGlvbiB3aGljaCBpcyB1bmRvbmUgYnkgdGhpcyBzcGxpdCB0aGVuIHRoaXMgc3BsaXQgc2hvdWxkCiAgLy8gbm90IG1vdmUgdGhlIHRhcmdldCBwb3NpdGlvbiBlaXRoZXIuCiAgLy8KCgogIGlmIChhLnRhcmdldFBvc2l0aW9uLmlzRXF1YWwoYi5zcGxpdFBvc2l0aW9uKSkgewogICAgY29uc3QgbWVyZ2VJbnNpZGUgPSBiLmhvd01hbnkgIT0gMDsKICAgIGNvbnN0IG1lcmdlU3BsaXR0aW5nRWxlbWVudCA9IGIuZ3JhdmV5YXJkUG9zaXRpb24gJiYgYS5kZWxldGlvblBvc2l0aW9uLmlzRXF1YWwoYi5ncmF2ZXlhcmRQb3NpdGlvbik7CgogICAgaWYgKG1lcmdlSW5zaWRlIHx8IG1lcmdlU3BsaXR0aW5nRWxlbWVudCB8fCBjb250ZXh0LmFiUmVsYXRpb24gPT0gJ21lcmdlVGFyZ2V0Tm90TW92ZWQnKSB7CiAgICAgIGEuc291cmNlUG9zaXRpb24gPSBhLnNvdXJjZVBvc2l0aW9uLl9nZXRUcmFuc2Zvcm1lZEJ5U3BsaXRPcGVyYXRpb24oYik7CiAgICAgIHJldHVybiBbYV07CiAgICB9CiAgfSAvLyBDYXNlIDI6CiAgLy8KICAvLyBNZXJnZSBzb3VyY2UgaXMgYXQgdGhlIHNhbWUgcG9zaXRpb24gYXMgc3BsaXQgcG9zaXRpb24uIFRoaXMgc29tZXRpbWVzIGhhcHBlbiwgbW9zdGx5IGR1cmluZyB1bmRvLgogIC8vIFRoZSBkZWNpc2lvbiBoZXJlIGlzIG1vc3RseSB0byBjaG9vc2Ugd2hldGhlciBtZXJnZSBzb3VyY2UgcG9zaXRpb24gc2hvdWxkIHN0YXkgd2hlcmUgaXQgaXMgKHNvIGl0IHdpbGwgYmUgYXQgdGhlIGVuZCBvZiB0aGUKICAvLyBzcGxpdCBlbGVtZW50KSBvciBzaG91bGQgYmUgbW92ZSB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBuZXcgZWxlbWVudC4KICAvLwoKCiAgaWYgKGEuc291cmNlUG9zaXRpb24uaXNFcXVhbChiLnNwbGl0UG9zaXRpb24pKSB7CiAgICAvLyBVc2UgY29udGV4dCB0byBjaGVjayBpZiBgU3BsaXRPcGVyYXRpb25gIGlzIG5vdCB1bmRvaW5nIGEgbWVyZ2Ugb3BlcmF0aW9uLCB0aGF0IGRpZG4ndCBjaGFuZ2UgdGhlIGBhYCBvcGVyYXRpb24uCiAgICAvLyBUaGlzIHNjZW5hcmlvIGhhcHBlbnMgdGhlIHVuZG9uZSBtZXJnZSBvcGVyYXRpb24gbW92ZWQgbm9kZXMgYXQgdGhlIHNvdXJjZSBwb3NpdGlvbiBvZiBgYWAgb3BlcmF0aW9uLgogICAgLy8gSW4gdGhhdCBjYXNlIGBhYCBvcGVyYXRpb24gc291cmNlIHBvc2l0aW9uIHNob3VsZCBzdGF5IHdoZXJlIGl0IGlzLgogICAgaWYgKGNvbnRleHQuYWJSZWxhdGlvbiA9PSAnbWVyZ2VTb3VyY2VOb3RNb3ZlZCcpIHsKICAgICAgYS5ob3dNYW55ID0gMDsKICAgICAgYS50YXJnZXRQb3NpdGlvbiA9IGEudGFyZ2V0UG9zaXRpb24uX2dldFRyYW5zZm9ybWVkQnlTcGxpdE9wZXJhdGlvbihiKTsKICAgICAgcmV0dXJuIFthXTsKICAgIH0gLy8gVGhpcyBtZXJnZSBvcGVyYXRpb24gbWlnaHQgaGF2ZSBiZWVuIGVhcmxpZXIgdHJhbnNmb3JtZWQgYnkgYSBtZXJnZSBvcGVyYXRpb24gd2hpY2ggYm90aCBtZXJnZWQgdGhlIHNhbWUgZWxlbWVudC4KICAgIC8vIFNlZSB0aGF0IGNhc2UgaW4gYE1lcmdlT3BlcmF0aW9uYCB4IGBNZXJnZU9wZXJhdGlvbmAgdHJhbnNmb3JtYXRpb24uIEluIHRoYXQgc2NlbmFyaW8sIGlmIHRoZSBtZXJnZSBvcGVyYXRpb24gaGFzIGJlZW4gdW5kb25lLAogICAgLy8gdGhlIHNwZWNpYWwgY2FzZSBpcyBub3QgYXBwbGllZC4KICAgIC8vCiAgICAvLyBOb3csIHRoZSBtZXJnZSBvcGVyYXRpb24gaXMgdHJhbnNmb3JtZWQgYnkgdGhlIHNwbGl0IHdoaWNoIGhhcyB1bmRvbmUgdGhhdCBwcmV2aW91cyBtZXJnZSBvcGVyYXRpb24uCiAgICAvLyBTbyBub3cgd2UgYXJlIGZpeGluZyBzaXR1YXRpb24gd2hpY2ggd2FzIHNraXBwZWQgaW4gYE1lcmdlT3BlcmF0aW9uYCB4IGBNZXJnZU9wZXJhdGlvbmAgY2FzZS4KICAgIC8vCgoKICAgIGlmIChjb250ZXh0LmFiUmVsYXRpb24gPT0gJ21lcmdlU2FtZUVsZW1lbnQnIHx8IGEuc291cmNlUG9zaXRpb24ub2Zmc2V0ID4gMCkgewogICAgICBhLnNvdXJjZVBvc2l0aW9uID0gYi5tb3ZlVGFyZ2V0UG9zaXRpb24uY2xvbmUoKTsKICAgICAgYS50YXJnZXRQb3NpdGlvbiA9IGEudGFyZ2V0UG9zaXRpb24uX2dldFRyYW5zZm9ybWVkQnlTcGxpdE9wZXJhdGlvbihiKTsKICAgICAgcmV0dXJuIFthXTsKICAgIH0KICB9IC8vIFRoZSBkZWZhdWx0IGNhc2UuCiAgLy8KCgogIGlmIChhLnNvdXJjZVBvc2l0aW9uLmhhc1NhbWVQYXJlbnRBcyhiLnNwbGl0UG9zaXRpb24pKSB7CiAgICBhLmhvd01hbnkgPSBiLnNwbGl0UG9zaXRpb24ub2Zmc2V0OwogIH0KCiAgYS5zb3VyY2VQb3NpdGlvbiA9IGEuc291cmNlUG9zaXRpb24uX2dldFRyYW5zZm9ybWVkQnlTcGxpdE9wZXJhdGlvbihiKTsKICBhLnRhcmdldFBvc2l0aW9uID0gYS50YXJnZXRQb3NpdGlvbi5fZ2V0VHJhbnNmb3JtZWRCeVNwbGl0T3BlcmF0aW9uKGIpOwogIHJldHVybiBbYV07Cn0pOyAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKc2V0VHJhbnNmb3JtYXRpb24oTW92ZU9wZXJhdGlvbiwgSW5zZXJ0T3BlcmF0aW9uLCAoYSwgYikgPT4gewogIGNvbnN0IG1vdmVSYW5nZSA9IFJhbmdlLl9jcmVhdGVGcm9tUG9zaXRpb25BbmRTaGlmdChhLnNvdXJjZVBvc2l0aW9uLCBhLmhvd01hbnkpOwoKICBjb25zdCB0cmFuc2Zvcm1lZCA9IG1vdmVSYW5nZS5fZ2V0VHJhbnNmb3JtZWRCeUluc2VydE9wZXJhdGlvbihiLCBmYWxzZSlbMF07CgogIGEuc291cmNlUG9zaXRpb24gPSB0cmFuc2Zvcm1lZC5zdGFydDsKICBhLmhvd01hbnkgPSB0cmFuc2Zvcm1lZC5lbmQub2Zmc2V0IC0gdHJhbnNmb3JtZWQuc3RhcnQub2Zmc2V0OyAvLyBTZWUgYEluc2VydE9wZXJhdGlvbmAgeCBgTW92ZU9wZXJhdGlvbmAgdHJhbnNmb3JtYXRpb24gZm9yIGRldGFpbHMgb24gdGhpcyBjYXNlLgogIC8vCiAgLy8gSW4gc3VtbWFyeSwgYm90aCBvcGVyYXRpb25zIHBvaW50IHRvIHRoZSBzYW1lIHBsYWNlLCBzbyB0aGUgb3JkZXIgb2Ygbm9kZXMgbmVlZHMgdG8gYmUgZGVjaWRlZC4KICAvLyBgTW92ZU9wZXJhdGlvbmAgaXMgY29uc2lkZXJlZCB3ZWFrZXIsIHNvIGl0IGlzIGFsd2F5cyB0cmFuc2Zvcm1lZCwgdW5sZXNzIHRoZXJlIHdhcyBhIGNlcnRhaW4gcmVsYXRpb24KICAvLyBiZXR3ZWVuIG9wZXJhdGlvbnMuCiAgLy8KCiAgaWYgKCFhLnRhcmdldFBvc2l0aW9uLmlzRXF1YWwoYi5wb3NpdGlvbikpIHsKICAgIGEudGFyZ2V0UG9zaXRpb24gPSBhLnRhcmdldFBvc2l0aW9uLl9nZXRUcmFuc2Zvcm1lZEJ5SW5zZXJ0T3BlcmF0aW9uKGIpOwogIH0KCiAgcmV0dXJuIFthXTsKfSk7CnNldFRyYW5zZm9ybWF0aW9uKE1vdmVPcGVyYXRpb24sIE1vdmVPcGVyYXRpb24sIChhLCBiLCBjb250ZXh0KSA9PiB7CiAgLy8KICAvLyBTZXR0aW5nIGFuZCBldmFsdWF0aW5nIHNvbWUgdmFyaWFibGVzIHRoYXQgd2lsbCBiZSB1c2VkIGluIHNwZWNpYWwgY2FzZXMgYW5kIGRlZmF1bHQgYWxnb3JpdGhtLgogIC8vCiAgLy8gQ3JlYXRlIHJhbmdlcyBmcm9tIGBNb3ZlT3BlcmF0aW9uc2AgcHJvcGVydGllcy4KICBjb25zdCByYW5nZUEgPSBSYW5nZS5fY3JlYXRlRnJvbVBvc2l0aW9uQW5kU2hpZnQoYS5zb3VyY2VQb3NpdGlvbiwgYS5ob3dNYW55KTsKCiAgY29uc3QgcmFuZ2VCID0gUmFuZ2UuX2NyZWF0ZUZyb21Qb3NpdGlvbkFuZFNoaWZ0KGIuc291cmNlUG9zaXRpb24sIGIuaG93TWFueSk7IC8vIEFzc2lnbiBgY29udGV4dC5hSXNTdHJvbmdgIHRvIGEgZGlmZmVyZW50IHZhcmlhYmxlLCBiZWNhdXNlIHRoZSB2YWx1ZSBtYXkgY2hhbmdlIGR1cmluZyBleGVjdXRpb24gb2YKICAvLyB0aGlzIGFsZ29yaXRobSBhbmQgd2UgZG8gbm90IHdhbnQgdG8gb3ZlcnJpZGUgb3JpZ2luYWwgYGNvbnRleHQuYUlzU3Ryb25nYCB0aGF0IHdpbGwgYmUgdXNlZCBpbiBsYXRlciB0cmFuc2Zvcm1hdGlvbnMuCgoKICBsZXQgYUlzU3Ryb25nID0gY29udGV4dC5hSXNTdHJvbmc7IC8vIFRoaXMgd2lsbCBiZSB1c2VkIHRvIGRlY2lkZSB0aGUgb3JkZXIgb2Ygbm9kZXMgaWYgYm90aCBvcGVyYXRpb25zIHRhcmdldCBhdCB0aGUgc2FtZSBwb3NpdGlvbi4KICAvLyBCeSBkZWZhdWx0LCB1c2Ugc3Ryb25nL3dlYWsgb3BlcmF0aW9uIG1lY2hhbmlzbS4KCiAgbGV0IGluc2VydEJlZm9yZSA9ICFjb250ZXh0LmFJc1N0cm9uZzsgLy8gSWYgdGhlIHJlbGF0aW9uIGlzIHNldCwgdGhlbiB1c2UgaXQgdG8gZGVjaWRlIG5vZGVzIG9yZGVyLgoKICBpZiAoY29udGV4dC5hYlJlbGF0aW9uID09ICdpbnNlcnRCZWZvcmUnIHx8IGNvbnRleHQuYmFSZWxhdGlvbiA9PSAnaW5zZXJ0QWZ0ZXInKSB7CiAgICBpbnNlcnRCZWZvcmUgPSB0cnVlOwogIH0gZWxzZSBpZiAoY29udGV4dC5hYlJlbGF0aW9uID09ICdpbnNlcnRBZnRlcicgfHwgY29udGV4dC5iYVJlbGF0aW9uID09ICdpbnNlcnRCZWZvcmUnKSB7CiAgICBpbnNlcnRCZWZvcmUgPSBmYWxzZTsKICB9IC8vIGBhLnRhcmdldFBvc2l0aW9uYCBjb3VsZCBiZSBhZmZlY3RlZCBieSB0aGUgYGJgIG9wZXJhdGlvbi4gV2Ugd2lsbCB0cmFuc2Zvcm0gaXQuCgoKICBsZXQgbmV3VGFyZ2V0UG9zaXRpb247CgogIGlmIChhLnRhcmdldFBvc2l0aW9uLmlzRXF1YWwoYi50YXJnZXRQb3NpdGlvbikgJiYgaW5zZXJ0QmVmb3JlKSB7CiAgICBuZXdUYXJnZXRQb3NpdGlvbiA9IGEudGFyZ2V0UG9zaXRpb24uX2dldFRyYW5zZm9ybWVkQnlEZWxldGlvbihiLnNvdXJjZVBvc2l0aW9uLCBiLmhvd01hbnkpOwogIH0gZWxzZSB7CiAgICBuZXdUYXJnZXRQb3NpdGlvbiA9IGEudGFyZ2V0UG9zaXRpb24uX2dldFRyYW5zZm9ybWVkQnlNb3ZlKGIuc291cmNlUG9zaXRpb24sIGIudGFyZ2V0UG9zaXRpb24sIGIuaG93TWFueSk7CiAgfSAvLwogIC8vIFNwZWNpYWwgY2FzZSAjMSArIG1pcnJvci4KICAvLwogIC8vIFNwZWNpYWwgY2FzZSB3aGVuIGJvdGggbW92ZSBvcGVyYXRpb25zJyB0YXJnZXQgcG9zaXRpb25zIGFyZSBpbnNpZGUgbm9kZXMgdGhhdCBhcmUKICAvLyBiZWluZyBtb3ZlZCBieSB0aGUgb3RoZXIgbW92ZSBvcGVyYXRpb24uIFNvIGluIG90aGVyIHdvcmRzLCB3ZSBtb3ZlIHJhbmdlcyBpbnRvIGluc2lkZSBvZiBlYWNoIG90aGVyLgogIC8vIFRoaXMgY2FzZSBjYW4ndCBiZSBzb2x2ZWQgcmVhc29uYWJseSAob24gdGhlIG90aGVyIGhhbmQsIGl0IHNob3VsZCBub3QgaGFwcGVuIG9mdGVuKS4KCgogIGlmIChfbW92ZVRhcmdldEludG9Nb3ZlZFJhbmdlKGEsIGIpICYmIF9tb3ZlVGFyZ2V0SW50b01vdmVkUmFuZ2UoYiwgYSkpIHsKICAgIC8vIEluc3RlYWQgb2YgdHJhbnNmb3JtaW5nIG9wZXJhdGlvbiwgd2UgcmV0dXJuIGEgcmV2ZXJzZSBvZiB0aGUgb3BlcmF0aW9uIHRoYXQgd2UgdHJhbnNmb3JtIGJ5LgogICAgLy8gU28gd2hlbiB0aGUgcmVzdWx0cyBvZiB0aGlzICJ0cmFuc2Zvcm1hdGlvbiIgd2lsbCBiZSBhcHBsaWVkLCBgYmAgTW92ZU9wZXJhdGlvbiB3aWxsIGdldCByZXZlcnNlZC4KICAgIHJldHVybiBbYi5nZXRSZXZlcnNlZCgpXTsKICB9IC8vCiAgLy8gRW5kIG9mIHNwZWNpYWwgY2FzZSAjMS4KICAvLwogIC8vCiAgLy8gU3BlY2lhbCBjYXNlICMyLgogIC8vCiAgLy8gQ2hlY2sgaWYgYGJgIG9wZXJhdGlvbiB0YXJnZXRzIGluc2lkZSBgcmFuZ2VBYC4KCgogIGNvbnN0IGJUYXJnZXRzVG9BID0gcmFuZ2VBLmNvbnRhaW5zUG9zaXRpb24oYi50YXJnZXRQb3NpdGlvbik7IC8vIElmIGBiYCB0YXJnZXRzIHRvIGByYW5nZUFgIGFuZCBgcmFuZ2VBYCBjb250YWlucyBgcmFuZ2VCYCwgYGJgIG9wZXJhdGlvbiBoYXMgbm8gaW5mbHVlbmNlIG9uIGBhYCBvcGVyYXRpb24uCiAgLy8gWW91IG1pZ2h0IHNheSB0aGF0IG9wZXJhdGlvbiBgYmAgaXMgY2FwdHVyZWQgaW5zaWRlIG9wZXJhdGlvbiBgYWAuCgogIGlmIChiVGFyZ2V0c1RvQSAmJiByYW5nZUEuY29udGFpbnNSYW5nZShyYW5nZUIsIHRydWUpKSB7CiAgICAvLyBUaGVyZSBpcyBhIG1pbmktc3BlY2lhbCBjYXNlIGhlcmUsIHdoZXJlIGByYW5nZUJgIGlzIG9uIG90aGVyIGxldmVsIHRoYW4gYHJhbmdlQWAuIFRoYXQncyB3aHkKICAgIC8vIHdlIG5lZWQgdG8gdHJhbnNmb3JtIGBhYCBvcGVyYXRpb24gYW55d2F5LgogICAgcmFuZ2VBLnN0YXJ0ID0gcmFuZ2VBLnN0YXJ0Ll9nZXRUcmFuc2Zvcm1lZEJ5TW92ZShiLnNvdXJjZVBvc2l0aW9uLCBiLnRhcmdldFBvc2l0aW9uLCBiLmhvd01hbnkpOwogICAgcmFuZ2VBLmVuZCA9IHJhbmdlQS5lbmQuX2dldFRyYW5zZm9ybWVkQnlNb3ZlKGIuc291cmNlUG9zaXRpb24sIGIudGFyZ2V0UG9zaXRpb24sIGIuaG93TWFueSk7CiAgICByZXR1cm4gX21ha2VNb3ZlT3BlcmF0aW9uc0Zyb21SYW5nZXMoW3JhbmdlQV0sIG5ld1RhcmdldFBvc2l0aW9uKTsKICB9IC8vCiAgLy8gU3BlY2lhbCBjYXNlICMyIG1pcnJvci4KICAvLwoKCiAgY29uc3QgYVRhcmdldHNUb0IgPSByYW5nZUIuY29udGFpbnNQb3NpdGlvbihhLnRhcmdldFBvc2l0aW9uKTsKCiAgaWYgKGFUYXJnZXRzVG9CICYmIHJhbmdlQi5jb250YWluc1JhbmdlKHJhbmdlQSwgdHJ1ZSkpIHsKICAgIC8vIGBhYCBvcGVyYXRpb24gaXMgIm1vdmVkIHRvZ2V0aGVyIiB3aXRoIGBiYCBvcGVyYXRpb24uCiAgICAvLyBIZXJlLCBqdXN0IG1vdmUgYHJhbmdlQWAgImluc2lkZSIgYHJhbmdlQmAuCiAgICByYW5nZUEuc3RhcnQgPSByYW5nZUEuc3RhcnQuX2dldENvbWJpbmVkKGIuc291cmNlUG9zaXRpb24sIGIuZ2V0TW92ZWRSYW5nZVN0YXJ0KCkpOwogICAgcmFuZ2VBLmVuZCA9IHJhbmdlQS5lbmQuX2dldENvbWJpbmVkKGIuc291cmNlUG9zaXRpb24sIGIuZ2V0TW92ZWRSYW5nZVN0YXJ0KCkpOwogICAgcmV0dXJuIF9tYWtlTW92ZU9wZXJhdGlvbnNGcm9tUmFuZ2VzKFtyYW5nZUFdLCBuZXdUYXJnZXRQb3NpdGlvbik7CiAgfSAvLwogIC8vIEVuZCBvZiBzcGVjaWFsIGNhc2UgIzIuCiAgLy8KICAvLwogIC8vIFNwZWNpYWwgY2FzZSAjMyArIG1pcnJvci4KICAvLwogIC8vIGByYW5nZUFgIGhhcyBhIG5vZGUgd2hpY2ggaXMgYW4gYW5jZXN0b3Igb2YgYHJhbmdlQmAuIEluIG90aGVyIHdvcmRzLCBgcmFuZ2VCYCBpcyBpbnNpZGUgYHJhbmdlQWAKICAvLyBidXQgbm90IG9uIHRoZSBzYW1lIHRyZWUgbGV2ZWwuIEluIHN1Y2ggY2FzZSByYW5nZXMgaGF2ZSBjb21tb24gcGFydCBidXQgd2UgaGF2ZSB0byB0cmVhdCBpdAogIC8vIGRpZmZlcmVudGx5LCBiZWNhdXNlIGluIHN1Y2ggY2FzZSB0aG9zZSByYW5nZXMgYXJlIG5vdCByZWFsbHkgY29uZmxpY3RpbmcgYW5kIHNob3VsZCBiZSB0cmVhdGVkIGxpa2UKICAvLyB0d28gc2VwYXJhdGUgcmFuZ2VzLiBBbHNvIHdlIGhhdmUgdG8gZGlzY2FyZCB0d28gZGlmZmVyZW5jZSBwYXJ0cy4KCgogIGNvbnN0IGFDb21wQiA9IGNvbXBhcmVBcnJheXMoYS5zb3VyY2VQb3NpdGlvbi5nZXRQYXJlbnRQYXRoKCksIGIuc291cmNlUG9zaXRpb24uZ2V0UGFyZW50UGF0aCgpKTsKCiAgaWYgKGFDb21wQiA9PSAncHJlZml4JyB8fCBhQ29tcEIgPT0gJ2V4dGVuc2lvbicpIHsKICAgIC8vIFRyYW5zZm9ybSBgcmFuZ2VBYCBieSBgYmAgb3BlcmF0aW9uIGFuZCBtYWtlIG9wZXJhdGlvbiBvdXQgb2YgaXQsIGFuZCB0aGF0J3MgYWxsLgogICAgLy8gTm90ZSB0aGF0IHRoaXMgaXMgYSBzaW1wbGlmaWVkIHZlcnNpb24gb2YgZGVmYXVsdCBjYXNlLCBidXQgaGVyZSB3ZSB0cmVhdCB0aGUgY29tbW9uIHBhcnQgKHdob2xlIGByYW5nZUFgKQogICAgLy8gbGlrZSBhIG9uZSBkaWZmZXJlbmNlIHBhcnQuCiAgICByYW5nZUEuc3RhcnQgPSByYW5nZUEuc3RhcnQuX2dldFRyYW5zZm9ybWVkQnlNb3ZlKGIuc291cmNlUG9zaXRpb24sIGIudGFyZ2V0UG9zaXRpb24sIGIuaG93TWFueSk7CiAgICByYW5nZUEuZW5kID0gcmFuZ2VBLmVuZC5fZ2V0VHJhbnNmb3JtZWRCeU1vdmUoYi5zb3VyY2VQb3NpdGlvbiwgYi50YXJnZXRQb3NpdGlvbiwgYi5ob3dNYW55KTsKICAgIHJldHVybiBfbWFrZU1vdmVPcGVyYXRpb25zRnJvbVJhbmdlcyhbcmFuZ2VBXSwgbmV3VGFyZ2V0UG9zaXRpb24pOwogIH0gLy8KICAvLyBFbmQgb2Ygc3BlY2lhbCBjYXNlICMzLgogIC8vCiAgLy8KICAvLyBEZWZhdWx0IGNhc2UgLSByYW5nZXMgYXJlIG9uIHRoZSBzYW1lIGxldmVsIG9yIGFyZSBub3QgY29ubmVjdGVkIHdpdGggZWFjaCBvdGhlci4KICAvLwogIC8vIE1vZGlmaWVyIGZvciBkZWZhdWx0IGNhc2UuCiAgLy8gTW9kaWZpZXMgYGFJc1N0cm9uZ2AgZmxhZyBpbiBjZXJ0YWluIGNvbmRpdGlvbnMuCiAgLy8KICAvLyBJZiBvbmx5IG9uZSBvZiBvcGVyYXRpb25zIGlzIGEgcmVtb3ZlIG9wZXJhdGlvbiwgd2UgZm9yY2UgcmVtb3ZlIG9wZXJhdGlvbiB0byBiZSB0aGUgInN0cm9uZ2VyIiBvbmUKICAvLyB0byBwcm92aWRlIG1vcmUgZXhwZWN0ZWQgcmVzdWx0cy4KCgogIGlmIChhLnR5cGUgPT0gJ3JlbW92ZScgJiYgYi50eXBlICE9ICdyZW1vdmUnICYmICFjb250ZXh0LmFXYXNVbmRvbmUgJiYgIWNvbnRleHQuZm9yY2VXZWFrUmVtb3ZlKSB7CiAgICBhSXNTdHJvbmcgPSB0cnVlOwogIH0gZWxzZSBpZiAoYS50eXBlICE9ICdyZW1vdmUnICYmIGIudHlwZSA9PSAncmVtb3ZlJyAmJiAhY29udGV4dC5iV2FzVW5kb25lICYmICFjb250ZXh0LmZvcmNlV2Vha1JlbW92ZSkgewogICAgYUlzU3Ryb25nID0gZmFsc2U7CiAgfSAvLyBIYW5kbGUgb3BlcmF0aW9uJ3Mgc291cmNlIHJhbmdlcyAtIGNoZWNrIGhvdyBgcmFuZ2VBYCBpcyBhZmZlY3RlZCBieSBgYmAgb3BlcmF0aW9uLgogIC8vIFRoaXMgd2lsbCBhZ2dyZWdhdGUgdHJhbnNmb3JtZWQgcmFuZ2VzLgoKCiAgY29uc3QgcmFuZ2VzID0gW107IC8vIEdldCB0aGUgImRpZmZlcmVuY2UgcGFydCIgb2YgYGFgIG9wZXJhdGlvbiBzb3VyY2UgcmFuZ2UuCiAgLy8gVGhpcyBpcyBhbiBhcnJheSB3aXRoIG9uZSBvciB0d28gcmFuZ2VzLiBUd28gcmFuZ2VzIGlmIGByYW5nZUJgIGlzIGluc2lkZSBgcmFuZ2VBYC4KCiAgY29uc3QgZGlmZmVyZW5jZSA9IHJhbmdlQS5nZXREaWZmZXJlbmNlKHJhbmdlQik7CgogIGZvciAoY29uc3QgcmFuZ2Ugb2YgZGlmZmVyZW5jZSkgewogICAgLy8gVHJhbnNmb3JtIHRob3NlIHJhbmdlcyBieSBgYmAgb3BlcmF0aW9uLiBGb3IgZXhhbXBsZSBpZiBgYmAgbW92ZWQgcmFuZ2UgZnJvbSBiZWZvcmUgdGhvc2UgcmFuZ2VzLCBmaXggdGhvc2UgcmFuZ2VzLgogICAgcmFuZ2Uuc3RhcnQgPSByYW5nZS5zdGFydC5fZ2V0VHJhbnNmb3JtZWRCeURlbGV0aW9uKGIuc291cmNlUG9zaXRpb24sIGIuaG93TWFueSk7CiAgICByYW5nZS5lbmQgPSByYW5nZS5lbmQuX2dldFRyYW5zZm9ybWVkQnlEZWxldGlvbihiLnNvdXJjZVBvc2l0aW9uLCBiLmhvd01hbnkpOyAvLyBJZiBgYmAgb3BlcmF0aW9uIHRhcmdldHMgaW50byBgcmFuZ2VBYCBvbiB0aGUgc2FtZSBsZXZlbCwgc3ByZWFkIGByYW5nZUFgIGludG8gdHdvIHJhbmdlcy4KCiAgICBjb25zdCBzaG91bGRTcHJlYWQgPSBjb21wYXJlQXJyYXlzKHJhbmdlLnN0YXJ0LmdldFBhcmVudFBhdGgoKSwgYi5nZXRNb3ZlZFJhbmdlU3RhcnQoKS5nZXRQYXJlbnRQYXRoKCkpID09ICdzYW1lJzsKCiAgICBjb25zdCBuZXdSYW5nZXMgPSByYW5nZS5fZ2V0VHJhbnNmb3JtZWRCeUluc2VydGlvbihiLmdldE1vdmVkUmFuZ2VTdGFydCgpLCBiLmhvd01hbnksIHNob3VsZFNwcmVhZCk7CgogICAgcmFuZ2VzLnB1c2goLi4ubmV3UmFuZ2VzKTsKICB9IC8vIFRoZW4sIHdlIGhhdmUgdG8gbWFuYWdlIHRoZSAiY29tbW9uIHBhcnQiIG9mIGJvdGggbW92ZSByYW5nZXMuCgoKICBjb25zdCBjb21tb24gPSByYW5nZUEuZ2V0SW50ZXJzZWN0aW9uKHJhbmdlQik7CgogIGlmIChjb21tb24gIT09IG51bGwgJiYgYUlzU3Ryb25nKSB7CiAgICAvLyBDYWxjdWxhdGUgdGhlIG5ldyBwb3NpdGlvbiBvZiB0aGF0IHBhcnQgb2Ygb3JpZ2luYWwgcmFuZ2UuCiAgICBjb21tb24uc3RhcnQgPSBjb21tb24uc3RhcnQuX2dldENvbWJpbmVkKGIuc291cmNlUG9zaXRpb24sIGIuZ2V0TW92ZWRSYW5nZVN0YXJ0KCkpOwogICAgY29tbW9uLmVuZCA9IGNvbW1vbi5lbmQuX2dldENvbWJpbmVkKGIuc291cmNlUG9zaXRpb24sIGIuZ2V0TW92ZWRSYW5nZVN0YXJ0KCkpOyAvLyBUYWtlIGNhcmUgb2YgcHJvcGVyIHJhbmdlIG9yZGVyLgogICAgLy8KICAgIC8vIFB1dCBgY29tbW9uYCBhdCBhcHByb3ByaWF0ZSBwbGFjZS4gS2VlcCBpbiBtaW5kIHRoYXQgd2UgYXJlIGludGVyZXN0ZWQgaW4gb3JpZ2luYWwgb3JkZXIuCiAgICAvLyBCYXNpY2FsbHkgdGhlcmUgYXJlIG9ubHkgdGhyZWUgY2FzZXM6IHRoZXJlIGlzIHplcm8sIG9uZSBvciB0d28gZGlmZmVyZW5jZSByYW5nZXMuCiAgICAvLwogICAgLy8gSWYgdGhlcmUgaXMgemVybyBkaWZmZXJlbmNlIHJhbmdlcywganVzdCBwdXNoIGBjb21tb25gIGluIHRoZSBhcnJheS4KCiAgICBpZiAocmFuZ2VzLmxlbmd0aCA9PT0gMCkgewogICAgICByYW5nZXMucHVzaChjb21tb24pOwogICAgfSAvLyBJZiB0aGVyZSBpcyBvbmUgZGlmZmVyZW5jZSByYW5nZSwgd2UgbmVlZCB0byBjaGVjayB3aGV0aGVyIGNvbW1vbiBwYXJ0IHdhcyBiZWZvcmUgaXQgb3IgYWZ0ZXIgaXQuCiAgICBlbHNlIGlmIChyYW5nZXMubGVuZ3RoID09IDEpIHsKICAgICAgICBpZiAocmFuZ2VCLnN0YXJ0LmlzQmVmb3JlKHJhbmdlQS5zdGFydCkgfHwgcmFuZ2VCLnN0YXJ0LmlzRXF1YWwocmFuZ2VBLnN0YXJ0KSkgewogICAgICAgICAgcmFuZ2VzLnVuc2hpZnQoY29tbW9uKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgcmFuZ2VzLnB1c2goY29tbW9uKTsKICAgICAgICB9CiAgICAgIH0gLy8gSWYgdGhlcmUgYXJlIG1vcmUgcmFuZ2VzICh3aGljaCBtZWFucyB0d28pLCBwdXQgY29tbW9uIHBhcnQgYmV0d2VlbiB0aGVtLiBUaGlzIGlzIHRoZSBvbmx5IHNjZW5hcmlvCiAgICAgIC8vIHdoZXJlIHRoZXJlIGNvdWxkIGJlIHR3byBkaWZmZXJlbmNlIHJhbmdlcyBzbyB3ZSBkb24ndCBoYXZlIHRvIG1ha2UgYW55IGNvbXBhcmlzb25zLgogICAgICBlbHNlIHsKICAgICAgICAgIHJhbmdlcy5zcGxpY2UoMSwgMCwgY29tbW9uKTsKICAgICAgICB9CiAgfQoKICBpZiAocmFuZ2VzLmxlbmd0aCA9PT0gMCkgewogICAgLy8gSWYgdGhlcmUgYXJlIG5vICJzb3VyY2UgcmFuZ2VzIiwgbm90aGluZyBzaG91bGQgYmUgY2hhbmdlZC4KICAgIC8vIE5vdGUgdGhhdCB0aGlzIGNhbiBoYXBwZW4gb25seSBpZiBgYUlzU3Ryb25nID09IGZhbHNlYCBhbmQgYHJhbmdlQS5pc0VxdWFsKCByYW5nZUIgKWAuCiAgICByZXR1cm4gW25ldyBOb09wZXJhdGlvbihhLmJhc2VWZXJzaW9uKV07CiAgfQoKICByZXR1cm4gX21ha2VNb3ZlT3BlcmF0aW9uc0Zyb21SYW5nZXMocmFuZ2VzLCBuZXdUYXJnZXRQb3NpdGlvbik7Cn0pOwpzZXRUcmFuc2Zvcm1hdGlvbihNb3ZlT3BlcmF0aW9uLCBTcGxpdE9wZXJhdGlvbiwgKGEsIGIsIGNvbnRleHQpID0+IHsKICBsZXQgbmV3VGFyZ2V0UG9zaXRpb24gPSBhLnRhcmdldFBvc2l0aW9uLmNsb25lKCk7IC8vIERvIG5vdCB0cmFuc2Zvcm0gaWYgdGFyZ2V0IHBvc2l0aW9uIGlzIHNhbWUgYXMgc3BsaXQgaW5zZXJ0aW9uIHBvc2l0aW9uIGFuZCB0aGlzIHNwbGl0IGNvbWVzIGZyb20gdW5kby4KICAvLyBUaGlzIHNob3VsZCBiZSBkb25lIG9uIHJlbGF0aW9ucyBidXQgaXQgaXMgdG9vIG11Y2ggd29yayBmb3Igbm93IGFzIGl0IHdvdWxkIHJlcXVpcmUgcmVsYXRpb25zIHdvcmtpbmcgaW4gY29sbGFib3JhdGlvbi4KICAvLyBXZSBuZWVkIHRvIG1ha2UgYSBkZWNpc2lvbiBob3cgd2Ugd2lsbCByZXNvbHZlIHN1Y2ggY29uZmxpY3QgYW5kIHRoaXMgaXMgbGVzcyBoYXJtZnVsIHdheS4KCiAgaWYgKCFhLnRhcmdldFBvc2l0aW9uLmlzRXF1YWwoYi5pbnNlcnRpb25Qb3NpdGlvbikgfHwgIWIuZ3JhdmV5YXJkUG9zaXRpb24gfHwgY29udGV4dC5hYlJlbGF0aW9uID09ICdtb3ZlVGFyZ2V0QWZ0ZXInKSB7CiAgICBuZXdUYXJnZXRQb3NpdGlvbiA9IGEudGFyZ2V0UG9zaXRpb24uX2dldFRyYW5zZm9ybWVkQnlTcGxpdE9wZXJhdGlvbihiKTsKICB9IC8vIENhc2UgMToKICAvLwogIC8vIExhc3QgZWxlbWVudCBpbiB0aGUgbW92ZWQgcmFuZ2UgZ290IHNwbGl0LgogIC8vCiAgLy8gSW4gdGhpcyBjYXNlIHRoZSBkZWZhdWx0IHJhbmdlIHRyYW5zZm9ybWF0aW9uIHdpbGwgbm90IHdvcmsgY29ycmVjdGx5IGFzIHRoZSBlbGVtZW50IGNyZWF0ZWQgYnkKICAvLyBzcGxpdCBvcGVyYXRpb24gd291bGQgYmUgb3V0c2lkZSB0aGUgcmFuZ2UuIFRoZSByYW5nZSB0byBtb3ZlIG5lZWRzIHRvIGJlIGZpeGVkIG1hbnVhbGx5LgogIC8vCgoKICBjb25zdCBtb3ZlUmFuZ2UgPSBSYW5nZS5fY3JlYXRlRnJvbVBvc2l0aW9uQW5kU2hpZnQoYS5zb3VyY2VQb3NpdGlvbiwgYS5ob3dNYW55KTsKCiAgaWYgKG1vdmVSYW5nZS5lbmQuaXNFcXVhbChiLmluc2VydGlvblBvc2l0aW9uKSkgewogICAgLy8gRG8gaXQgb25seSBpZiB0aGlzIGlzIGEgIm5hdHVyYWwiIHNwbGl0LCBub3QgYSBvbmUgdGhhdCBjb21lcyBmcm9tIHVuZG8uCiAgICAvLyBJZiB0aGlzIGlzIHVuZG8gc3BsaXQsIG9ubHkgYHRhcmdldFBvc2l0aW9uYCBuZWVkcyB0byBiZSBjaGFuZ2VkIChpZiB0aGUgbW92ZSBpcyBhIHJlbW92ZSkuCiAgICBpZiAoIWIuZ3JhdmV5YXJkUG9zaXRpb24pIHsKICAgICAgYS5ob3dNYW55Kys7CiAgICB9CgogICAgYS50YXJnZXRQb3NpdGlvbiA9IG5ld1RhcmdldFBvc2l0aW9uOwogICAgcmV0dXJuIFthXTsKICB9IC8vIENhc2UgMjoKICAvLwogIC8vIFNwbGl0IGhhcHBlbmVkIGJldHdlZW4gdGhlIG1vdmVkIG5vZGVzLiBJbiB0aGlzIGNhc2UgdHdvIHJhbmdlcyB0byBtb3ZlIG5lZWQgdG8gYmUgZ2VuZXJhdGVkLgogIC8vCiAgLy8gQ2hhcmFjdGVycyBgb3piYWAgYXJlIG1vdmVkIHRvIHRoZSBlbmQgb2YgcGFyYWdyYXBoIGBYeXpgIGJ1dCBzcGxpdCBoYXBwZW5lZC4KICAvLyA8cD5GW296fGJhXXI8L3A+PHA+WHl6PC9wPgogIC8vCiAgLy8gQWZ0ZXIgc3BsaXQ6CiAgLy8gPHA+RltvejwvcD48cD5iYV1yPC9wPjxwPlh5ejwvcD4KICAvLwogIC8vIENvcnJlY3QgcmFuZ2VzOgogIC8vIDxwPkZbb3pdPC9wPjxwPltiYV1yPC9wPjxwPlh5ejwvcD4KICAvLwogIC8vIEFmdGVyIG1vdmU6CiAgLy8gPHA+RjwvcD48cD5yPC9wPjxwPlh5em96YmE8L3A+CiAgLy8KCgogIGlmIChtb3ZlUmFuZ2Uuc3RhcnQuaGFzU2FtZVBhcmVudEFzKGIuc3BsaXRQb3NpdGlvbikgJiYgbW92ZVJhbmdlLmNvbnRhaW5zUG9zaXRpb24oYi5zcGxpdFBvc2l0aW9uKSkgewogICAgbGV0IHJpZ2h0UmFuZ2UgPSBuZXcgUmFuZ2UoYi5zcGxpdFBvc2l0aW9uLCBtb3ZlUmFuZ2UuZW5kKTsKICAgIHJpZ2h0UmFuZ2UgPSByaWdodFJhbmdlLl9nZXRUcmFuc2Zvcm1lZEJ5U3BsaXRPcGVyYXRpb24oYik7CiAgICBjb25zdCByYW5nZXMgPSBbbmV3IFJhbmdlKG1vdmVSYW5nZS5zdGFydCwgYi5zcGxpdFBvc2l0aW9uKSwgcmlnaHRSYW5nZV07CiAgICByZXR1cm4gX21ha2VNb3ZlT3BlcmF0aW9uc0Zyb21SYW5nZXMocmFuZ2VzLCBuZXdUYXJnZXRQb3NpdGlvbik7CiAgfSAvLyBDYXNlIDM6CiAgLy8KICAvLyBNb3ZlIG9wZXJhdGlvbiB0YXJnZXRzIGF0IHRoZSBzcGxpdCBwb3NpdGlvbi4gV2UgbmVlZCB0byBkZWNpZGUgaWYgdGhlIG5vZGVzIHNob3VsZCBiZSBpbnNlcnRlZAogIC8vIGF0IHRoZSBlbmQgb2YgdGhlIHNwbGl0IGVsZW1lbnQgb3IgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgbmV3IGVsZW1lbnQuCiAgLy8KCgogIGlmIChhLnRhcmdldFBvc2l0aW9uLmlzRXF1YWwoYi5zcGxpdFBvc2l0aW9uKSAmJiBjb250ZXh0LmFiUmVsYXRpb24gPT0gJ2luc2VydEF0U291cmNlJykgewogICAgbmV3VGFyZ2V0UG9zaXRpb24gPSBiLm1vdmVUYXJnZXRQb3NpdGlvbjsKICB9IC8vIENhc2UgNDoKICAvLwogIC8vIE1vdmUgb3BlcmF0aW9uIHRhcmdldHMganVzdCBhZnRlciB0aGUgc3BsaXQgZWxlbWVudC4gV2UgbmVlZCB0byBkZWNpZGUgaWYgdGhlIG5vZGVzIHNob3VsZCBiZSBpbnNlcnRlZAogIC8vIGJldHdlZW4gdHdvIHBhcnRzIG9mIHNwbGl0IGVsZW1lbnQsIG9yIGFmdGVyIHRoZSBuZXcgZWxlbWVudC4KICAvLwogIC8vIFNwbGl0IGF0IGB8YCwgd2hpbGUgbW92ZSBvcGVyYXRpb24gbW92ZXMgYDxwPlh5ejwvcD5gIGFuZCB0YXJnZXRzIGF0IGBeYDoKICAvLyA8cD5Gb298YmFyPC9wPl48cD5iYXo8L3A+CiAgLy8gPHA+Rm9vPC9wPl48cD5iYXI8L3A+PHA+YmF6PC9wPiBvciA8cD5Gb288L3A+PHA+YmFyPC9wPl48cD5iYXo8L3A+PwogIC8vCiAgLy8gSWYgdGhlcmUgaXMgbm8gY29udGV4dHVhbCBpbmZvcm1hdGlvbiBiZXR3ZWVuIG9wZXJhdGlvbnMgKGZvciBleGFtcGxlLCB0aGV5IGNvbWUgZnJvbSBjb2xsYWJvcmF0aXZlCiAgLy8gZWRpdGluZyksIHdlIGRvbid0IHdhbnQgdG8gcHV0IHNvbWUgdW5yZWxhdGVkIGNvbnRlbnQgKG1vdmUpIGJldHdlZW4gcGFydHMgb2YgcmVsYXRlZCBjb250ZW50IChzcGxpdCBwYXJ0cykuCiAgLy8gSG93ZXZlciwgaWYgdGhlIHNwbGl0IGlzIGZyb20gdW5kbywgaW4gdGhlIHBhc3QsIHRoZSBtb3ZlZCBjb250ZW50IG1pZ2h0IGJlIHRhcmdldGluZyBiZXR3ZWVuIHRoZQogIC8vIHNwbGl0IHBhcnRzLCBtZWFuaW5nIHRoYXQgd2FzIGV4YWN0bHkgdXNlcidzIGludGVudGlvbjoKICAvLwogIC8vIDxwPkZvbzwvcD5ePHA+YmFyPC9wPgkJPC0tLSBvcmlnaW5hbCBzaXR1YXRpb24sIGluICJwYXN0Ii4KICAvLyA8cD5Gb29iYXI8L3A+XgkJCQk8LS0tIGFmdGVyIG1lcmdlIHRhcmdldCBwb3NpdGlvbiBpcyB0cmFuc2Zvcm1lZC4KICAvLyA8cD5Gb298YmFyPC9wPl4JCQkJPC0tLSB0aGVuIHRoZSBtZXJnZSBpcyB1bmRvbmUsIGFuZCBzcGxpdCBoYXBwZW5zLCB3aGljaCBsZWFkcyB1cyB0byBjdXJyZW50IHNpdHVhdGlvbi4KICAvLwogIC8vIEluIHRoaXMgY2FzZSBpdCBpcyBwcmV0dHkgY2xlYXIgdGhhdCB0aGUgaW50ZW50aW9uIHdhcyB0byBwdXQgbmV3IHBhcmFncmFwaCBiZXR3ZWVuIHRob3NlIG5vZGVzLAogIC8vIHNvIHdlIG5lZWQgdG8gdHJhbnNmb3JtIGFjY29yZGluZ2x5LiBXZSBjYW4gZGV0ZWN0IHRoaXMgc2NlbmFyaW8gdGhhbmtzIHRvIHJlbGF0aW9ucy4KICAvLwoKCiAgaWYgKGEudGFyZ2V0UG9zaXRpb24uaXNFcXVhbChiLmluc2VydGlvblBvc2l0aW9uKSAmJiBjb250ZXh0LmFiUmVsYXRpb24gPT0gJ2luc2VydEJldHdlZW4nKSB7CiAgICBuZXdUYXJnZXRQb3NpdGlvbiA9IGEudGFyZ2V0UG9zaXRpb247CiAgfSAvLyBUaGUgZGVmYXVsdCBjYXNlLgogIC8vCgoKICBjb25zdCB0cmFuc2Zvcm1lZCA9IG1vdmVSYW5nZS5fZ2V0VHJhbnNmb3JtZWRCeVNwbGl0T3BlcmF0aW9uKGIpOwoKICBjb25zdCByYW5nZXMgPSBbdHJhbnNmb3JtZWRdOyAvLyBDYXNlIDU6CiAgLy8KICAvLyBNb3ZlZCByYW5nZSBjb250YWlucyBncmF2ZXlhcmQgZWxlbWVudCB1c2VkIGJ5IHNwbGl0IG9wZXJhdGlvbi4gQWRkIGV4dHJhIG1vdmUgb3BlcmF0aW9uIHRvIHRoZSByZXN1bHQuCiAgLy8KCiAgaWYgKGIuZ3JhdmV5YXJkUG9zaXRpb24pIHsKICAgIGNvbnN0IG1vdmVzR3JhdmV5YXJkRWxlbWVudCA9IG1vdmVSYW5nZS5zdGFydC5pc0VxdWFsKGIuZ3JhdmV5YXJkUG9zaXRpb24pIHx8IG1vdmVSYW5nZS5jb250YWluc1Bvc2l0aW9uKGIuZ3JhdmV5YXJkUG9zaXRpb24pOwoKICAgIGlmIChhLmhvd01hbnkgPiAxICYmIG1vdmVzR3JhdmV5YXJkRWxlbWVudCAmJiAhY29udGV4dC5hV2FzVW5kb25lKSB7CiAgICAgIHJhbmdlcy5wdXNoKFJhbmdlLl9jcmVhdGVGcm9tUG9zaXRpb25BbmRTaGlmdChiLmluc2VydGlvblBvc2l0aW9uLCAxKSk7CiAgICB9CiAgfQoKICByZXR1cm4gX21ha2VNb3ZlT3BlcmF0aW9uc0Zyb21SYW5nZXMocmFuZ2VzLCBuZXdUYXJnZXRQb3NpdGlvbik7Cn0pOwpzZXRUcmFuc2Zvcm1hdGlvbihNb3ZlT3BlcmF0aW9uLCBNZXJnZU9wZXJhdGlvbiwgKGEsIGIsIGNvbnRleHQpID0+IHsKICBjb25zdCBtb3ZlZFJhbmdlID0gUmFuZ2UuX2NyZWF0ZUZyb21Qb3NpdGlvbkFuZFNoaWZ0KGEuc291cmNlUG9zaXRpb24sIGEuaG93TWFueSk7CgogIGlmIChiLmRlbGV0aW9uUG9zaXRpb24uaGFzU2FtZVBhcmVudEFzKGEuc291cmNlUG9zaXRpb24pICYmIG1vdmVkUmFuZ2UuY29udGFpbnNQb3NpdGlvbihiLnNvdXJjZVBvc2l0aW9uKSkgewogICAgaWYgKGEudHlwZSA9PSAncmVtb3ZlJyAmJiAhY29udGV4dC5mb3JjZVdlYWtSZW1vdmUpIHsKICAgICAgLy8gQ2FzZSAxOgogICAgICAvLwogICAgICAvLyBUaGUgZWxlbWVudCB0byByZW1vdmUgZ290IG1lcmdlZC4KICAgICAgLy8KICAgICAgLy8gTWVyZ2Ugb3BlcmF0aW9uIGRvZXMgc3VwcG9ydCBtZXJnaW5nIGVsZW1lbnRzIHdoaWNoIGFyZSBub3Qgc2libGluZ3MuIFNvIGl0IHdvdWxkIG5vdCBiZSBhIHByb2JsZW0KICAgICAgLy8gZnJvbSB0ZWNobmljYWwgcG9pbnQgb2Ygdmlldy4gSG93ZXZlciwgaWYgdGhlIGVsZW1lbnQgd2FzIHJlbW92ZWQsIHRoZSBpbnRlbnRpb24gb2YgdGhlIHVzZXIKICAgICAgLy8gZGVsZXRpbmcgaXQgd2FzIHRvIGhhdmUgaXQgYWxsIGRlbGV0ZWQuIEZyb20gdXNlciBleHBlcmllbmNlIHBvaW50IG9mIHZpZXcsIG1vdmluZyBiYWNrIHRoZQogICAgICAvLyByZW1vdmVkIG5vZGVzIG1pZ2h0IGJlIHVuZXhwZWN0ZWQuIFRoaXMgbWVhbnMgdGhhdCBpbiB0aGlzIHNjZW5hcmlvIHdlIHdpbGwgcmV2ZXJzZSBtZXJnaW5nIGFuZCByZW1vdmUgdGhlIGVsZW1lbnQuCiAgICAgIC8vCiAgICAgIGlmICghY29udGV4dC5hV2FzVW5kb25lKSB7CiAgICAgICAgY29uc3QgcmVzdWx0cyA9IFtdOwogICAgICAgIGxldCBneU1vdmVTb3VyY2UgPSBiLmdyYXZleWFyZFBvc2l0aW9uLmNsb25lKCk7CgogICAgICAgIGxldCBzcGxpdE5vZGVzTW92ZVNvdXJjZSA9IGIudGFyZ2V0UG9zaXRpb24uX2dldFRyYW5zZm9ybWVkQnlNZXJnZU9wZXJhdGlvbihiKTsKCiAgICAgICAgaWYgKGEuaG93TWFueSA+IDEpIHsKICAgICAgICAgIHJlc3VsdHMucHVzaChuZXcgTW92ZU9wZXJhdGlvbihhLnNvdXJjZVBvc2l0aW9uLCBhLmhvd01hbnkgLSAxLCBhLnRhcmdldFBvc2l0aW9uLCAwKSk7CiAgICAgICAgICBneU1vdmVTb3VyY2UgPSBneU1vdmVTb3VyY2UuX2dldFRyYW5zZm9ybWVkQnlNb3ZlKGEuc291cmNlUG9zaXRpb24sIGEudGFyZ2V0UG9zaXRpb24sIGEuaG93TWFueSAtIDEpOwogICAgICAgICAgc3BsaXROb2Rlc01vdmVTb3VyY2UgPSBzcGxpdE5vZGVzTW92ZVNvdXJjZS5fZ2V0VHJhbnNmb3JtZWRCeU1vdmUoYS5zb3VyY2VQb3NpdGlvbiwgYS50YXJnZXRQb3NpdGlvbiwgYS5ob3dNYW55IC0gMSk7CiAgICAgICAgfQoKICAgICAgICBjb25zdCBneU1vdmVUYXJnZXQgPSBiLmRlbGV0aW9uUG9zaXRpb24uX2dldENvbWJpbmVkKGEuc291cmNlUG9zaXRpb24sIGEudGFyZ2V0UG9zaXRpb24pOwoKICAgICAgICBjb25zdCBneU1vdmUgPSBuZXcgTW92ZU9wZXJhdGlvbihneU1vdmVTb3VyY2UsIDEsIGd5TW92ZVRhcmdldCwgMCk7CiAgICAgICAgY29uc3Qgc3BsaXROb2Rlc01vdmVUYXJnZXRQYXRoID0gZ3lNb3ZlLmdldE1vdmVkUmFuZ2VTdGFydCgpLnBhdGguc2xpY2UoKTsKICAgICAgICBzcGxpdE5vZGVzTW92ZVRhcmdldFBhdGgucHVzaCgwKTsKICAgICAgICBjb25zdCBzcGxpdE5vZGVzTW92ZVRhcmdldCA9IG5ldyBQb3NpdGlvbihneU1vdmUudGFyZ2V0UG9zaXRpb24ucm9vdCwgc3BsaXROb2Rlc01vdmVUYXJnZXRQYXRoKTsKICAgICAgICBzcGxpdE5vZGVzTW92ZVNvdXJjZSA9IHNwbGl0Tm9kZXNNb3ZlU291cmNlLl9nZXRUcmFuc2Zvcm1lZEJ5TW92ZShneU1vdmVTb3VyY2UsIGd5TW92ZVRhcmdldCwgMSk7CiAgICAgICAgY29uc3Qgc3BsaXROb2Rlc01vdmUgPSBuZXcgTW92ZU9wZXJhdGlvbihzcGxpdE5vZGVzTW92ZVNvdXJjZSwgYi5ob3dNYW55LCBzcGxpdE5vZGVzTW92ZVRhcmdldCwgMCk7CiAgICAgICAgcmVzdWx0cy5wdXNoKGd5TW92ZSk7CiAgICAgICAgcmVzdWx0cy5wdXNoKHNwbGl0Tm9kZXNNb3ZlKTsKICAgICAgICByZXR1cm4gcmVzdWx0czsKICAgICAgfQogICAgfSBlbHNlIHsKICAgICAgLy8gQ2FzZSAyOgogICAgICAvLwogICAgICAvLyBUaGUgZWxlbWVudCB0byBtb3ZlIGdvdCBtZXJnZWQgYW5kIGl0IHdhcyB0aGUgb25seSBlbGVtZW50IHRvIG1vdmUuCiAgICAgIC8vIEluIHRoaXMgY2FzZSBqdXN0IGRvbid0IGRvIGFueXRoaW5nLCBsZWF2ZSB0aGUgbm9kZSBpbiB0aGUgZ3JhdmV5YXJkLiBXaXRob3V0IHNwZWNpYWwgY2FzZQogICAgICAvLyBpdCB3b3VsZCBiZSBhIG1vdmUgb3BlcmF0aW9uIHRoYXQgbW92ZXMgMCBub2Rlcywgc28gbWF5YmUgaXQgaXMgYmV0dGVyIGp1c3QgdG8gcmV0dXJuIG5vLW9wLgogICAgICAvLwogICAgICBpZiAoYS5ob3dNYW55ID09IDEpIHsKICAgICAgICBpZiAoIWNvbnRleHQuYldhc1VuZG9uZSkgewogICAgICAgICAgcmV0dXJuIFtuZXcgTm9PcGVyYXRpb24oMCldOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBhLnNvdXJjZVBvc2l0aW9uID0gYi5ncmF2ZXlhcmRQb3NpdGlvbi5jbG9uZSgpOwogICAgICAgICAgYS50YXJnZXRQb3NpdGlvbiA9IGEudGFyZ2V0UG9zaXRpb24uX2dldFRyYW5zZm9ybWVkQnlNZXJnZU9wZXJhdGlvbihiKTsKICAgICAgICAgIHJldHVybiBbYV07CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgfSAvLyBUaGUgZGVmYXVsdCBjYXNlLgogIC8vCgoKICBjb25zdCBtb3ZlUmFuZ2UgPSBSYW5nZS5fY3JlYXRlRnJvbVBvc2l0aW9uQW5kU2hpZnQoYS5zb3VyY2VQb3NpdGlvbiwgYS5ob3dNYW55KTsKCiAgY29uc3QgdHJhbnNmb3JtZWQgPSBtb3ZlUmFuZ2UuX2dldFRyYW5zZm9ybWVkQnlNZXJnZU9wZXJhdGlvbihiKTsKCiAgYS5zb3VyY2VQb3NpdGlvbiA9IHRyYW5zZm9ybWVkLnN0YXJ0OwogIGEuaG93TWFueSA9IHRyYW5zZm9ybWVkLmVuZC5vZmZzZXQgLSB0cmFuc2Zvcm1lZC5zdGFydC5vZmZzZXQ7CiAgYS50YXJnZXRQb3NpdGlvbiA9IGEudGFyZ2V0UG9zaXRpb24uX2dldFRyYW5zZm9ybWVkQnlNZXJnZU9wZXJhdGlvbihiKTsKICByZXR1cm4gW2FdOwp9KTsgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCnNldFRyYW5zZm9ybWF0aW9uKFJlbmFtZU9wZXJhdGlvbiwgSW5zZXJ0T3BlcmF0aW9uLCAoYSwgYikgPT4gewogIGEucG9zaXRpb24gPSBhLnBvc2l0aW9uLl9nZXRUcmFuc2Zvcm1lZEJ5SW5zZXJ0T3BlcmF0aW9uKGIpOwogIHJldHVybiBbYV07Cn0pOwpzZXRUcmFuc2Zvcm1hdGlvbihSZW5hbWVPcGVyYXRpb24sIE1lcmdlT3BlcmF0aW9uLCAoYSwgYikgPT4gewogIC8vIENhc2UgMToKICAvLwogIC8vIEVsZW1lbnQgdG8gcmVuYW1lIGdvdCBtZXJnZWQsIHNvIGl0IHdhcyBtb3ZlZCB0byBgYi5ncmF2ZXlhcmRQb3NpdGlvbmAuCiAgLy8KICBpZiAoYS5wb3NpdGlvbi5pc0VxdWFsKGIuZGVsZXRpb25Qb3NpdGlvbikpIHsKICAgIGEucG9zaXRpb24gPSBiLmdyYXZleWFyZFBvc2l0aW9uLmNsb25lKCk7CiAgICBhLnBvc2l0aW9uLnN0aWNraW5lc3MgPSAndG9OZXh0JzsKICAgIHJldHVybiBbYV07CiAgfQoKICBhLnBvc2l0aW9uID0gYS5wb3NpdGlvbi5fZ2V0VHJhbnNmb3JtZWRCeU1lcmdlT3BlcmF0aW9uKGIpOwogIHJldHVybiBbYV07Cn0pOwpzZXRUcmFuc2Zvcm1hdGlvbihSZW5hbWVPcGVyYXRpb24sIE1vdmVPcGVyYXRpb24sIChhLCBiKSA9PiB7CiAgYS5wb3NpdGlvbiA9IGEucG9zaXRpb24uX2dldFRyYW5zZm9ybWVkQnlNb3ZlT3BlcmF0aW9uKGIpOwogIHJldHVybiBbYV07Cn0pOwpzZXRUcmFuc2Zvcm1hdGlvbihSZW5hbWVPcGVyYXRpb24sIFJlbmFtZU9wZXJhdGlvbiwgKGEsIGIsIGNvbnRleHQpID0+IHsKICBpZiAoYS5wb3NpdGlvbi5pc0VxdWFsKGIucG9zaXRpb24pKSB7CiAgICBpZiAoY29udGV4dC5hSXNTdHJvbmcpIHsKICAgICAgYS5vbGROYW1lID0gYi5uZXdOYW1lOwogICAgfSBlbHNlIHsKICAgICAgcmV0dXJuIFtuZXcgTm9PcGVyYXRpb24oMCldOwogICAgfQogIH0KCiAgcmV0dXJuIFthXTsKfSk7CnNldFRyYW5zZm9ybWF0aW9uKFJlbmFtZU9wZXJhdGlvbiwgU3BsaXRPcGVyYXRpb24sIChhLCBiKSA9PiB7CiAgLy8gQ2FzZSAxOgogIC8vCiAgLy8gVGhlIGVsZW1lbnQgdG8gcmVuYW1lIGhhcyBiZWVuIHNwbGl0LiBJbiB0aGlzIGNhc2UsIHRoZSBuZXcgZWxlbWVudCBzaG91bGQgYmUgYWxzbyByZW5hbWVkLgogIC8vCiAgLy8gVXNlciBkZWNpZGVzIHRvIGNoYW5nZSB0aGUgcGFyYWdyYXBoIHRvIGEgbGlzdCBpdGVtOgogIC8vIDxwYXJhZ3JhcGg+Rm9vYmFyPC9wYXJhZ3JhcGg+CiAgLy8KICAvLyBIb3dldmVyLCBpbiBtZWFudGltZSwgc3BsaXQgaGFwcGVuczoKICAvLyA8cGFyYWdyYXBoPkZvbzwvcGFyYWdyYXBoPjxwYXJhZ3JhcGg+YmFyPC9wYXJhZ3JhcGg+CiAgLy8KICAvLyBBcyBhIHJlc3VsdCwgcmVuYW1lIGJvdGggZWxlbWVudHM6CiAgLy8gPGxpc3RJdGVtPkZvbzwvbGlzdEl0ZW0+PGxpc3RJdGVtPmJhcjwvbGlzdEl0ZW0+CiAgLy8KICBjb25zdCByZW5hbWVQYXRoID0gYS5wb3NpdGlvbi5wYXRoOwogIGNvbnN0IHNwbGl0UGF0aCA9IGIuc3BsaXRQb3NpdGlvbi5nZXRQYXJlbnRQYXRoKCk7CgogIGlmIChjb21wYXJlQXJyYXlzKHJlbmFtZVBhdGgsIHNwbGl0UGF0aCkgPT0gJ3NhbWUnICYmICFiLmdyYXZleWFyZFBvc2l0aW9uKSB7CiAgICBjb25zdCBleHRyYVJlbmFtZSA9IG5ldyBSZW5hbWVPcGVyYXRpb24oYS5wb3NpdGlvbi5nZXRTaGlmdGVkQnkoMSksIGEub2xkTmFtZSwgYS5uZXdOYW1lLCAwKTsKICAgIHJldHVybiBbYSwgZXh0cmFSZW5hbWVdOwogIH0gLy8gVGhlIGRlZmF1bHQgY2FzZS4KICAvLwoKCiAgYS5wb3NpdGlvbiA9IGEucG9zaXRpb24uX2dldFRyYW5zZm9ybWVkQnlTcGxpdE9wZXJhdGlvbihiKTsKICByZXR1cm4gW2FdOwp9KTsgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCnNldFRyYW5zZm9ybWF0aW9uKFJvb3RBdHRyaWJ1dGVPcGVyYXRpb24sIFJvb3RBdHRyaWJ1dGVPcGVyYXRpb24sIChhLCBiLCBjb250ZXh0KSA9PiB7CiAgaWYgKGEucm9vdCA9PT0gYi5yb290ICYmIGEua2V5ID09PSBiLmtleSkgewogICAgaWYgKCFjb250ZXh0LmFJc1N0cm9uZyB8fCBhLm5ld1ZhbHVlID09PSBiLm5ld1ZhbHVlKSB7CiAgICAgIHJldHVybiBbbmV3IE5vT3BlcmF0aW9uKDApXTsKICAgIH0gZWxzZSB7CiAgICAgIGEub2xkVmFsdWUgPSBiLm5ld1ZhbHVlOwogICAgfQogIH0KCiAgcmV0dXJuIFthXTsKfSk7IC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgpzZXRUcmFuc2Zvcm1hdGlvbihTcGxpdE9wZXJhdGlvbiwgSW5zZXJ0T3BlcmF0aW9uLCAoYSwgYikgPT4gewogIC8vIFRoZSBkZWZhdWx0IGNhc2UuCiAgLy8KICBpZiAoYS5zcGxpdFBvc2l0aW9uLmhhc1NhbWVQYXJlbnRBcyhiLnBvc2l0aW9uKSAmJiBhLnNwbGl0UG9zaXRpb24ub2Zmc2V0IDwgYi5wb3NpdGlvbi5vZmZzZXQpIHsKICAgIGEuaG93TWFueSArPSBiLmhvd01hbnk7CiAgfQoKICBhLnNwbGl0UG9zaXRpb24gPSBhLnNwbGl0UG9zaXRpb24uX2dldFRyYW5zZm9ybWVkQnlJbnNlcnRPcGVyYXRpb24oYik7CiAgYS5pbnNlcnRpb25Qb3NpdGlvbiA9IFNwbGl0T3BlcmF0aW9uLmdldEluc2VydGlvblBvc2l0aW9uKGEuc3BsaXRQb3NpdGlvbik7CiAgcmV0dXJuIFthXTsKfSk7CnNldFRyYW5zZm9ybWF0aW9uKFNwbGl0T3BlcmF0aW9uLCBNZXJnZU9wZXJhdGlvbiwgKGEsIGIsIGNvbnRleHQpID0+IHsKICAvLyBDYXNlIDE6CiAgLy8KICAvLyBTcGxpdCBlbGVtZW50IGdvdCBtZXJnZWQuIElmIHR3byBkaWZmZXJlbnQgZWxlbWVudHMgd2VyZSBtZXJnZWQsIGNsaWVudHMgd2lsbCBoYXZlIGRpZmZlcmVudCBjb250ZW50LgogIC8vCiAgLy8gRXhhbXBsZS4gTWVyZ2UgYXQgYHt9YCwgc3BsaXQgYXQgYFtdYDoKICAvLyA8aGVhZGluZz5Gb288L2hlYWRpbmc+e308cGFyYWdyYXBoPkJbXWFyPC9wYXJhZ3JhcGg+CiAgLy8KICAvLyBPbiBtZXJnZSBzaWRlIGl0IHdpbGwgbG9vayBsaWtlIHRoaXM6CiAgLy8gPGhlYWRpbmc+Rm9vQltdYXI8L2hlYWRpbmc+CiAgLy8gPGhlYWRpbmc+Rm9vQjwvaGVhZGluZz48aGVhZGluZz5hcjwvaGVhZGluZz4KICAvLwogIC8vIE9uIHNwbGl0IHNpZGUgaXQgd2lsbCBsb29rIGxpa2UgdGhpczoKICAvLyA8aGVhZGluZz5Gb288L2hlYWRpbmc+e308cGFyYWdyYXBoPkI8L3BhcmFncmFwaD48cGFyYWdyYXBoPmFyPC9wYXJhZ3JhcGg+CiAgLy8gPGhlYWRpbmc+Rm9vQjwvaGVhZGluZz48cGFyYWdyYXBoPmFyPC9wYXJhZ3JhcGg+CiAgLy8KICAvLyBDbGVhcmx5LCB0aGUgc2Vjb25kIGVsZW1lbnQgaXMgZGlmZmVyZW50IGZvciBib3RoIGNsaWVudHMuCiAgLy8KICAvLyBXZSBjb3VsZCB1c2UgdGhlIHJlbW92ZWQgbWVyZ2UgZWxlbWVudCBmcm9tIGdyYXZleWFyZCBhcyBhIHNwbGl0IGVsZW1lbnQgYnV0IHRoZW4gY2xpZW50cyB3b3VsZCBoYXZlIGEgZGlmZmVyZW50CiAgLy8gbW9kZWwgc3RhdGUgKGluIGdyYXZleWFyZCksIGJlY2F1c2UgdGhlIHNwbGl0IHNpZGUgY2xpZW50IHdvdWxkIHN0aWxsIGhhdmUgYW4gZWxlbWVudCBpbiBncmF2ZXlhcmQgKHJlbW92ZWQgYnkgbWVyZ2UpLgogIC8vCiAgLy8gVG8gb3ZlcmNvbWUgdGhpcywgaW4gYFNwbGl0T3BlcmF0aW9uYCB4IGBNZXJnZU9wZXJhdGlvbmAgdHJhbnNmb3JtYXRpb24gd2Ugd2lsbCBhZGQgYWRkaXRpb25hbCBgU3BsaXRPcGVyYXRpb25gCiAgLy8gaW4gdGhlIGdyYXZleWFyZCwgd2hpY2ggd2lsbCBhY3R1YWxseSBjbG9uZSB0aGUgbWVyZ2VkLWFuZC1kZWxldGVkIGVsZW1lbnQuIFRoZW4sIHRoYXQgY2xvbmVkIGVsZW1lbnQgd2lsbCBiZQogIC8vIHVzZWQgZm9yIHNwbGl0dGluZy4gRXhhbXBsZSBiZWxvdy4KICAvLwogIC8vIE9yaWdpbmFsIHN0YXRlOgogIC8vIDxoZWFkaW5nPkZvbzwvaGVhZGluZz57fTxwYXJhZ3JhcGg+QltdYXI8L3BhcmFncmFwaD4KICAvLwogIC8vIE1lcmdlIHNpZGUgY2xpZW50OgogIC8vCiAgLy8gQWZ0ZXIgbWVyZ2U6CiAgLy8gPGhlYWRpbmc+Rm9vQltdYXI8L2hlYWRpbmc+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JhdmV5YXJkOiA8cGFyYWdyYXBoPjwvcGFyYWdyYXBoPgogIC8vCiAgLy8gRXh0cmEgc3BsaXQ6CiAgLy8gPGhlYWRpbmc+Rm9vQltdYXI8L2hlYWRpbmc+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JhdmV5YXJkOiA8cGFyYWdyYXBoPjwvcGFyYWdyYXBoPjxwYXJhZ3JhcGg+PC9wYXJhZ3JhcGg+CiAgLy8KICAvLyBVc2UgdGhlICJjbG9uZWQiIGVsZW1lbnQgZnJvbSBncmF2ZXlhcmQ6CiAgLy8gPGhlYWRpbmc+Rm9vQjwvaGVhZGluZz48cGFyYWdyYXBoPmFyPC9wYXJhZ3JhcGg+ICAgICAgICAgICAgZ3JhdmV5YXJkOiA8cGFyYWdyYXBoPjwvcGFyYWdyYXBoPgogIC8vCiAgLy8gU3BsaXQgc2lkZSBjbGllbnQ6CiAgLy8KICAvLyBBZnRlciBzcGxpdDoKICAvLyA8aGVhZGluZz5Gb288L2hlYWRpbmc+e308cGFyYWdyYXBoPkI8L3BhcmFncmFwaD48cGFyYWdyYXBoPmFyPC9wYXJhZ3JhcGg+CiAgLy8KICAvLyBBZnRlciBtZXJnZToKICAvLyA8aGVhZGluZz5Gb29CPC9oZWFkaW5nPjxwYXJhZ3JhcGg+YXI8L3BhcmFncmFwaD4gICAgICAgICAgICBncmF2ZXlhcmQ6IDxwYXJhZ3JhcGg+PC9wYXJhZ3JhcGg+CiAgLy8KICAvLyBUaGlzIHNwZWNpYWwgY2FzZSBzY2VuYXJpbyBvbmx5IGFwcGxpZXMgaWYgdGhlIG9yaWdpbmFsIHNwbGl0IG9wZXJhdGlvbiBjbG9uZXMgdGhlIHNwbGl0IGVsZW1lbnQuCiAgLy8gSWYgdGhlIG9yaWdpbmFsIHNwbGl0IG9wZXJhdGlvbiBoYXMgYGdyYXZleWFyZFBvc2l0aW9uYCBzZXQsIGl0IGFsbCBkb2Vzbid0IGhhdmUgc2Vuc2UgYmVjYXVzZSBzcGxpdCBvcGVyYXRpb24KICAvLyBrbm93cyBleGFjdGx5IHdoaWNoIGVsZW1lbnQgaXQgc2hvdWxkIHVzZS4gU28gdGhlcmUgd291bGQgYmUgbm8gb3JpZ2luYWwgcHJvYmxlbSB3aXRoIGRpZmZlcmVudCBjb250ZW50cy4KICAvLwogIC8vIEFkZGl0aW9uYWxseSwgdGhlIHNwZWNpYWwgY2FzZSBhcHBsaWVzIG9ubHkgaWYgdGhlIG1lcmdlIHdhc24ndCBhbHJlYWR5IHVuZG9uZS4KICAvLwogIGlmICghYS5ncmF2ZXlhcmRQb3NpdGlvbiAmJiAhY29udGV4dC5iV2FzVW5kb25lICYmIGEuc3BsaXRQb3NpdGlvbi5oYXNTYW1lUGFyZW50QXMoYi5zb3VyY2VQb3NpdGlvbikpIHsKICAgIGNvbnN0IHNwbGl0UGF0aCA9IGIuZ3JhdmV5YXJkUG9zaXRpb24ucGF0aC5zbGljZSgpOwogICAgc3BsaXRQYXRoLnB1c2goMCk7CiAgICBjb25zdCBzcGxpdFBvc2l0aW9uID0gbmV3IFBvc2l0aW9uKGIuZ3JhdmV5YXJkUG9zaXRpb24ucm9vdCwgc3BsaXRQYXRoKTsKICAgIGNvbnN0IGluc2VydGlvblBvc2l0aW9uID0gU3BsaXRPcGVyYXRpb24uZ2V0SW5zZXJ0aW9uUG9zaXRpb24obmV3IFBvc2l0aW9uKGIuZ3JhdmV5YXJkUG9zaXRpb24ucm9vdCwgc3BsaXRQYXRoKSk7CiAgICBjb25zdCBhZGRpdGlvbmFsU3BsaXQgPSBuZXcgU3BsaXRPcGVyYXRpb24oc3BsaXRQb3NpdGlvbiwgMCwgbnVsbCwgMCk7CiAgICBhZGRpdGlvbmFsU3BsaXQuaW5zZXJ0aW9uUG9zaXRpb24gPSBpbnNlcnRpb25Qb3NpdGlvbjsKICAgIGEuc3BsaXRQb3NpdGlvbiA9IGEuc3BsaXRQb3NpdGlvbi5fZ2V0VHJhbnNmb3JtZWRCeU1lcmdlT3BlcmF0aW9uKGIpOwogICAgYS5pbnNlcnRpb25Qb3NpdGlvbiA9IFNwbGl0T3BlcmF0aW9uLmdldEluc2VydGlvblBvc2l0aW9uKGEuc3BsaXRQb3NpdGlvbik7CiAgICBhLmdyYXZleWFyZFBvc2l0aW9uID0gYWRkaXRpb25hbFNwbGl0Lmluc2VydGlvblBvc2l0aW9uLmNsb25lKCk7CiAgICBhLmdyYXZleWFyZFBvc2l0aW9uLnN0aWNraW5lc3MgPSAndG9OZXh0JzsKICAgIHJldHVybiBbYWRkaXRpb25hbFNwbGl0LCBhXTsKICB9IC8vIFRoZSBkZWZhdWx0IGNhc2UuCiAgLy8KCgogIGlmIChhLnNwbGl0UG9zaXRpb24uaGFzU2FtZVBhcmVudEFzKGIuZGVsZXRpb25Qb3NpdGlvbikgJiYgIWEuc3BsaXRQb3NpdGlvbi5pc0FmdGVyKGIuZGVsZXRpb25Qb3NpdGlvbikpIHsKICAgIGEuaG93TWFueS0tOwogIH0KCiAgaWYgKGEuc3BsaXRQb3NpdGlvbi5oYXNTYW1lUGFyZW50QXMoYi50YXJnZXRQb3NpdGlvbikpIHsKICAgIGEuaG93TWFueSArPSBiLmhvd01hbnk7CiAgfQoKICBhLnNwbGl0UG9zaXRpb24gPSBhLnNwbGl0UG9zaXRpb24uX2dldFRyYW5zZm9ybWVkQnlNZXJnZU9wZXJhdGlvbihiKTsKICBhLmluc2VydGlvblBvc2l0aW9uID0gU3BsaXRPcGVyYXRpb24uZ2V0SW5zZXJ0aW9uUG9zaXRpb24oYS5zcGxpdFBvc2l0aW9uKTsKCiAgaWYgKGEuZ3JhdmV5YXJkUG9zaXRpb24pIHsKICAgIGEuZ3JhdmV5YXJkUG9zaXRpb24gPSBhLmdyYXZleWFyZFBvc2l0aW9uLl9nZXRUcmFuc2Zvcm1lZEJ5TWVyZ2VPcGVyYXRpb24oYik7CiAgfQoKICByZXR1cm4gW2FdOwp9KTsKc2V0VHJhbnNmb3JtYXRpb24oU3BsaXRPcGVyYXRpb24sIE1vdmVPcGVyYXRpb24sIChhLCBiLCBjb250ZXh0KSA9PiB7CiAgY29uc3QgcmFuZ2VUb01vdmUgPSBSYW5nZS5fY3JlYXRlRnJvbVBvc2l0aW9uQW5kU2hpZnQoYi5zb3VyY2VQb3NpdGlvbiwgYi5ob3dNYW55KTsKCiAgaWYgKGEuZ3JhdmV5YXJkUG9zaXRpb24pIHsKICAgIC8vIENhc2UgMToKICAgIC8vCiAgICAvLyBTcGxpdCBvcGVyYXRpb24gZ3JhdmV5YXJkIG5vZGUgd2FzIG1vdmVkLiBJbiB0aGlzIGNhc2UgbW92ZSBvcGVyYXRpb24gaXMgc3Ryb25nZXIuIFNpbmNlIGdyYXZleWFyZCBlbGVtZW50CiAgICAvLyBpcyBhbHJlYWR5IG1vdmVkIHRvIHRoZSBjb3JyZWN0IHBvc2l0aW9uLCB3ZSBuZWVkIHRvIG9ubHkgbW92ZSB0aGUgbm9kZXMgYWZ0ZXIgdGhlIHNwbGl0IHBvc2l0aW9uLgogICAgLy8gVGhpcyB3aWxsIGJlIGRvbmUgYnkgYE1vdmVPcGVyYXRpb25gIGluc3RlYWQgb2YgYFNwbGl0T3BlcmF0aW9uYC4KICAgIC8vCiAgICBjb25zdCBneUVsZW1lbnRNb3ZlZCA9IHJhbmdlVG9Nb3ZlLnN0YXJ0LmlzRXF1YWwoYS5ncmF2ZXlhcmRQb3NpdGlvbikgfHwgcmFuZ2VUb01vdmUuY29udGFpbnNQb3NpdGlvbihhLmdyYXZleWFyZFBvc2l0aW9uKTsKCiAgICBpZiAoIWNvbnRleHQuYldhc1VuZG9uZSAmJiBneUVsZW1lbnRNb3ZlZCkgewogICAgICBjb25zdCBzb3VyY2VQb3NpdGlvbiA9IGEuc3BsaXRQb3NpdGlvbi5fZ2V0VHJhbnNmb3JtZWRCeU1vdmVPcGVyYXRpb24oYik7CgogICAgICBjb25zdCBuZXdQYXJlbnRQb3NpdGlvbiA9IGEuZ3JhdmV5YXJkUG9zaXRpb24uX2dldFRyYW5zZm9ybWVkQnlNb3ZlT3BlcmF0aW9uKGIpOwoKICAgICAgY29uc3QgbmV3VGFyZ2V0UGF0aCA9IG5ld1BhcmVudFBvc2l0aW9uLnBhdGguc2xpY2UoKTsKICAgICAgbmV3VGFyZ2V0UGF0aC5wdXNoKDApOwogICAgICBjb25zdCBuZXdUYXJnZXRQb3NpdGlvbiA9IG5ldyBQb3NpdGlvbihuZXdQYXJlbnRQb3NpdGlvbi5yb290LCBuZXdUYXJnZXRQYXRoKTsKICAgICAgY29uc3QgbW92ZU9wID0gbmV3IE1vdmVPcGVyYXRpb24oc291cmNlUG9zaXRpb24sIGEuaG93TWFueSwgbmV3VGFyZ2V0UG9zaXRpb24sIDApOwogICAgICByZXR1cm4gW21vdmVPcF07CiAgICB9CgogICAgYS5ncmF2ZXlhcmRQb3NpdGlvbiA9IGEuZ3JhdmV5YXJkUG9zaXRpb24uX2dldFRyYW5zZm9ybWVkQnlNb3ZlT3BlcmF0aW9uKGIpOwogIH0gLy8gQ2FzZSAyOgogIC8vCiAgLy8gSWYgdGhlIHNwbGl0IHBvc2l0aW9uIGlzIGluc2lkZSB0aGUgbW92ZWQgcmFuZ2UsIHdlIG5lZWQgdG8gc2hpZnQgdGhlIHNwbGl0IHBvc2l0aW9uIHRvIGEgcHJvcGVyIHBsYWNlLgogIC8vIFRoZSBwb3NpdGlvbiBjYW5ub3QgYmUgbW92ZWQgdG9nZXRoZXIgd2l0aCBtb3ZlZCByYW5nZSBiZWNhdXNlIHRoYXQgd291bGQgcmVzdWx0IGluIHNwbGl0dGluZyBvZiBhbiBpbmNvcnJlY3QgZWxlbWVudC4KICAvLwogIC8vIENoYXJhY3RlcnMgYGJjYCBzaG91bGQgYmUgbW92ZWQgdG8gdGhlIHNlY29uZCBwYXJhZ3JhcGggd2hpbGUgc3BsaXQgcG9zaXRpb24gaXMgYmV0d2VlbiB0aGVtOgogIC8vIDxwYXJhZ3JhcGg+QVtifGNdZDwvcGFyYWdyYXBoPjxwYXJhZ3JhcGg+WHl6PC9wYXJhZ3JhcGg+CiAgLy8KICAvLyBBZnRlciBtb3ZlLCBuZXcgc3BsaXQgcG9zaXRpb24gaXMgaW5jb3JyZWN0OgogIC8vIDxwYXJhZ3JhcGg+QWQ8L3BhcmFncmFwaD48cGFyYWdyYXBoPlhifGN5ejwvcGFyYWdyYXBoPgogIC8vCiAgLy8gQ29ycmVjdCBzcGxpdCBwb3NpdGlvbjoKICAvLyA8cGFyYWdyYXBoPkF8ZDwvcGFyYWdyYXBoPjxwYXJhZ3JhcGg+WGJjeXo8L3BhcmFncmFwaD4KICAvLwogIC8vIEFmdGVyIHNwbGl0OgogIC8vIDxwYXJhZ3JhcGg+QTwvcGFyYWdyYXBoPjxwYXJhZ3JhcGg+ZDwvcGFyYWdyYXBoPjxwYXJhZ3JhcGg+WGJjeXo8L3BhcmFncmFwaD4KICAvLwoKCiAgaWYgKGEuc3BsaXRQb3NpdGlvbi5oYXNTYW1lUGFyZW50QXMoYi5zb3VyY2VQb3NpdGlvbikgJiYgcmFuZ2VUb01vdmUuY29udGFpbnNQb3NpdGlvbihhLnNwbGl0UG9zaXRpb24pKSB7CiAgICBjb25zdCBob3dNYW55UmVtb3ZlZCA9IGIuaG93TWFueSAtIChhLnNwbGl0UG9zaXRpb24ub2Zmc2V0IC0gYi5zb3VyY2VQb3NpdGlvbi5vZmZzZXQpOwogICAgYS5ob3dNYW55IC09IGhvd01hbnlSZW1vdmVkOwoKICAgIGlmIChhLnNwbGl0UG9zaXRpb24uaGFzU2FtZVBhcmVudEFzKGIudGFyZ2V0UG9zaXRpb24pICYmIGEuc3BsaXRQb3NpdGlvbi5vZmZzZXQgPCBiLnRhcmdldFBvc2l0aW9uLm9mZnNldCkgewogICAgICBhLmhvd01hbnkgKz0gYi5ob3dNYW55OwogICAgfQoKICAgIGEuc3BsaXRQb3NpdGlvbiA9IGIuc291cmNlUG9zaXRpb24uY2xvbmUoKTsKICAgIGEuaW5zZXJ0aW9uUG9zaXRpb24gPSBTcGxpdE9wZXJhdGlvbi5nZXRJbnNlcnRpb25Qb3NpdGlvbihhLnNwbGl0UG9zaXRpb24pOwogICAgcmV0dXJuIFthXTsKICB9IC8vIENhc2UgMzoKICAvLwogIC8vIFNwbGl0IGlzIGF0IGEgcG9zaXRpb24gd2hlcmUgbm9kZXMgd2VyZSBtb3ZlZC4KICAvLwogIC8vIFRoaXMgaXMgYSBzY2VuYXJpbyBkZXNjcmliZWQgaW4gYE1vdmVPcGVyYXRpb25gIHggYFNwbGl0T3BlcmF0aW9uYCB0cmFuc2Zvcm1hdGlvbiBidXQgZnJvbSB0aGUKICAvLyAic3BsaXQgb3BlcmF0aW9uIHBvaW50IG9mIHZpZXciLgogIC8vCgoKICBjb25zdCBzcGxpdEF0VGFyZ2V0ID0gYS5zcGxpdFBvc2l0aW9uLmlzRXF1YWwoYi50YXJnZXRQb3NpdGlvbik7CgogIGlmIChzcGxpdEF0VGFyZ2V0ICYmIChjb250ZXh0LmJhUmVsYXRpb24gPT0gJ2luc2VydEF0U291cmNlJyB8fCBjb250ZXh0LmFiUmVsYXRpb24gPT0gJ3NwbGl0QmVmb3JlJykpIHsKICAgIGEuaG93TWFueSArPSBiLmhvd01hbnk7CiAgICBhLnNwbGl0UG9zaXRpb24gPSBhLnNwbGl0UG9zaXRpb24uX2dldFRyYW5zZm9ybWVkQnlEZWxldGlvbihiLnNvdXJjZVBvc2l0aW9uLCBiLmhvd01hbnkpOwogICAgYS5pbnNlcnRpb25Qb3NpdGlvbiA9IFNwbGl0T3BlcmF0aW9uLmdldEluc2VydGlvblBvc2l0aW9uKGEuc3BsaXRQb3NpdGlvbik7CiAgICByZXR1cm4gW2FdOwogIH0gLy8gVGhlIGRlZmF1bHQgY2FzZS4KICAvLyBEb24ndCBjaGFuZ2UgYGhvd01hbnlgIGlmIG1vdmUgb3BlcmF0aW9uIGRvZXMgbm90IHJlYWxseSBtb3ZlIGFueXRoaW5nLgogIC8vCgoKICBpZiAoIWIuc291cmNlUG9zaXRpb24uaXNFcXVhbChiLnRhcmdldFBvc2l0aW9uKSkgewogICAgaWYgKGEuc3BsaXRQb3NpdGlvbi5oYXNTYW1lUGFyZW50QXMoYi5zb3VyY2VQb3NpdGlvbikgJiYgYS5zcGxpdFBvc2l0aW9uLm9mZnNldCA8PSBiLnNvdXJjZVBvc2l0aW9uLm9mZnNldCkgewogICAgICBhLmhvd01hbnkgLT0gYi5ob3dNYW55OwogICAgfQoKICAgIGlmIChhLnNwbGl0UG9zaXRpb24uaGFzU2FtZVBhcmVudEFzKGIudGFyZ2V0UG9zaXRpb24pICYmIGEuc3BsaXRQb3NpdGlvbi5vZmZzZXQgPCBiLnRhcmdldFBvc2l0aW9uLm9mZnNldCkgewogICAgICBhLmhvd01hbnkgKz0gYi5ob3dNYW55OwogICAgfQogIH0gLy8gQ2hhbmdlIHBvc2l0aW9uIHN0aWNraW5lc3MgdG8gZm9yY2UgYSBjb3JyZWN0IHRyYW5zZm9ybWF0aW9uLgoKCiAgYS5zcGxpdFBvc2l0aW9uLnN0aWNraW5lc3MgPSAndG9Ob25lJzsKICBhLnNwbGl0UG9zaXRpb24gPSBhLnNwbGl0UG9zaXRpb24uX2dldFRyYW5zZm9ybWVkQnlNb3ZlT3BlcmF0aW9uKGIpOwogIGEuc3BsaXRQb3NpdGlvbi5zdGlja2luZXNzID0gJ3RvTmV4dCc7CgogIGlmIChhLmdyYXZleWFyZFBvc2l0aW9uKSB7CiAgICBhLmluc2VydGlvblBvc2l0aW9uID0gYS5pbnNlcnRpb25Qb3NpdGlvbi5fZ2V0VHJhbnNmb3JtZWRCeU1vdmVPcGVyYXRpb24oYik7CiAgfSBlbHNlIHsKICAgIGEuaW5zZXJ0aW9uUG9zaXRpb24gPSBTcGxpdE9wZXJhdGlvbi5nZXRJbnNlcnRpb25Qb3NpdGlvbihhLnNwbGl0UG9zaXRpb24pOwogIH0KCiAgcmV0dXJuIFthXTsKfSk7CnNldFRyYW5zZm9ybWF0aW9uKFNwbGl0T3BlcmF0aW9uLCBTcGxpdE9wZXJhdGlvbiwgKGEsIGIsIGNvbnRleHQpID0+IHsKICAvLyBDYXNlIDE6CiAgLy8KICAvLyBTcGxpdCBhdCB0aGUgc2FtZSBwb3NpdGlvbi4KICAvLwogIC8vIElmIHRoZXJlIGFscmVhZHkgd2FzIGEgc3BsaXQgYXQgdGhlIHNhbWUgcG9zaXRpb24gYXMgaW4gYGFgIG9wZXJhdGlvbiwgaXQgbWVhbnMgdGhhdCB0aGUgaW50ZW50aW9uCiAgLy8gY29udmV5ZWQgYnkgYGFgIG9wZXJhdGlvbiBoYXMgYWxyZWFkeSBiZWVuIGZ1bGZpbGxlZCBhbmQgYGFgIHNob3VsZCBub3QgZG8gYW55dGhpbmcgKHRvIGF2b2lkIGRvdWJsZSBzcGxpdCkuCiAgLy8KICAvLyBIb3dldmVyLCB0aGVyZSBpcyBhIGRpZmZlcmVuY2UgaWYgdGhlc2UgYXJlIG5ldyBzcGxpdHMgb3Igc3BsaXRzIGNyZWF0ZWQgYnkgdW5kby4gVGhlc2UgaGF2ZSBkaWZmZXJlbnQKICAvLyBpbnRlbnRpb25zLiBBbHNvIHNwbGl0cyBtb3ZpbmcgYmFjayBkaWZmZXJlbnQgZWxlbWVudHMgZnJvbSBncmF2ZXlhcmQgaGF2ZSBkaWZmZXJlbnQgaW50ZW50aW9ucy4gVGhleQogIC8vIGFyZSBqdXN0IGRpZmZlcmVudCBvcGVyYXRpb25zLgogIC8vCiAgLy8gU28gd2UgY2FuY2VsIHNwbGl0IG9wZXJhdGlvbiBvbmx5IGlmIGl0IHdhcyByZWFsbHkgaWRlbnRpY2FsLgogIC8vCiAgLy8gQWxzbywgdGhlcmUgaXMgYWRkaXRpb25hbCBjYXNlLCB3aGVyZSBzcGxpdCBvcGVyYXRpb25zIGFyZW4ndCBpZGVudGljYWwgYW5kIHNob3VsZCBub3QgYmUgY2FuY2VsbGVkLCBob3dldmVyIHRoZQogIC8vIGRlZmF1bHQgdHJhbnNmb3JtYXRpb24gaXMgaW5jb3JyZWN0IHRvby4KICAvLwogIGlmIChhLnNwbGl0UG9zaXRpb24uaXNFcXVhbChiLnNwbGl0UG9zaXRpb24pKSB7CiAgICBpZiAoIWEuZ3JhdmV5YXJkUG9zaXRpb24gJiYgIWIuZ3JhdmV5YXJkUG9zaXRpb24pIHsKICAgICAgcmV0dXJuIFtuZXcgTm9PcGVyYXRpb24oMCldOwogICAgfQoKICAgIGlmIChhLmdyYXZleWFyZFBvc2l0aW9uICYmIGIuZ3JhdmV5YXJkUG9zaXRpb24gJiYgYS5ncmF2ZXlhcmRQb3NpdGlvbi5pc0VxdWFsKGIuZ3JhdmV5YXJkUG9zaXRpb24pKSB7CiAgICAgIHJldHVybiBbbmV3IE5vT3BlcmF0aW9uKDApXTsKICAgIH0gLy8gVXNlIGNvbnRleHQgdG8ga25vdyB0aGF0IHRoZSBgYS5zcGxpdFBvc2l0aW9uYCBzaG91bGQgc3RheSB3aGVyZSBpdCBpcy4KICAgIC8vIFRoaXMgaGFwcGVucyBkdXJpbmcgdW5kbyB3aGVuIGZpcnN0IGEgbWVyZ2Ugb3BlcmF0aW9uIG1vdmVkIG5vZGVzIHRvIGBhLnNwbGl0UG9zaXRpb25gIGFuZCBub3cgYGJgIG9wZXJhdGlvbiB1bmRvZXMgdGhhdCBtZXJnZS4KCgogICAgaWYgKGNvbnRleHQuYWJSZWxhdGlvbiA9PSAnc3BsaXRCZWZvcmUnKSB7CiAgICAgIC8vIFNpbmNlIHNwbGl0IGlzIGF0IHRoZSBzYW1lIHBvc2l0aW9uLCB0aGVyZSBhcmUgbm8gbm9kZXMgbGVmdCB0byBzcGxpdC4KICAgICAgYS5ob3dNYW55ID0gMDsgLy8gTm90ZTogdGhlcmUgd2FzIGBpZiAoIGEuZ3JhdmV5YXJkUG9zaXRpb24gKWAgaGVyZSBidXQgaXQgd2FzIHVuY292ZXJlZCBpbiB0ZXN0cyBhbmQgSSBjb3VsZG4ndCBmaW5kIGFueSBzY2VuYXJpb3MgZm9yIG5vdy4KICAgICAgLy8gVGhhdCB3b3VsZCBoYXZlIHRvIGJlIGEgYFNwbGl0T3BlcmF0aW9uYCB0aGF0IGRpZG4ndCBjb21lIGZyb20gdW5kbyBidXQgaXMgdHJhbnNmb3JtZWQgYnkgb3BlcmF0aW9ucyB0aGF0IHdlcmUgdW5kb25lLgogICAgICAvLyBJdCBjb3VsZCBoYXBwZW4gaWYgYGNvbnRleHRgIGlzIGVuYWJsZWQgaW4gY29sbGFib3JhdGlvbi4KCiAgICAgIGEuZ3JhdmV5YXJkUG9zaXRpb24gPSBhLmdyYXZleWFyZFBvc2l0aW9uLl9nZXRUcmFuc2Zvcm1lZEJ5U3BsaXRPcGVyYXRpb24oYik7CiAgICAgIHJldHVybiBbYV07CiAgICB9CiAgfSAvLyBDYXNlIDI6CiAgLy8KICAvLyBTYW1lIG5vZGUgaXMgdXNpbmcgdG8gc3BsaXQgZGlmZmVyZW50IGVsZW1lbnRzLiBUaGlzIGhhcHBlbnMgaW4gdW5kbyB3aGVuIHByZXZpb3VzbHkgc2FtZSBlbGVtZW50IHdhcyBtZXJnZWQgdG8KICAvLyB0d28gZGlmZmVyZW50IGVsZW1lbnRzLiBUaGlzIGlzIGRlc2NyaWJlZCBpbiBgTWVyZ2VPcGVyYXRpb25gIHggYE1lcmdlT3BlcmF0aW9uYCB0cmFuc2Zvcm1hdGlvbi4KICAvLwogIC8vIEluIHRoaXMgY2FzZSB3ZSB3aWxsIGZvbGxvdyB0aGUgc2FtZSBsb2dpYy4gV2Ugd2lsbCBhc3N1bWUgdGhhdCBgaW5zZXJ0aW9uUG9zaXRpb25gIGlzIHNhbWUgZm9yIGJvdGgKICAvLyBzcGxpdCBvcGVyYXRpb25zLiBUaGlzIG1pZ2h0IG5vdCBhbHdheXMgYmUgdHJ1ZSBidXQgaW4gdGhlIHJlYWwgY2FzZXMgdGhhdCB3ZXJlIGV4cGVyaWVuY2VkIGl0IHdhcy4gQWZ0ZXIgYWxsLAogIC8vIGlmIHRoZXNlIHNwbGl0cyBhcmUgcmV2ZXJzZXMgb2YgbWVyZ2Ugb3BlcmF0aW9ucyB0aGF0IHdlcmUgbWVyZ2luZyB0aGUgc2FtZSBlbGVtZW50LCB0aGVuIHRoZSBgaW5zZXJ0aW9uUG9zaXRpb25gCiAgLy8gc2hvdWxkIGJlIHNhbWUgZm9yIGJvdGggb2YgdGhvc2Ugc3BsaXRzLgogIC8vCiAgLy8gQWdhaW4sIHdlIHdpbGwgZGVjaWRlIHdoaWNoIG9wZXJhdGlvbiBpcyBzdHJvbmdlciBieSBjaGVja2luZyBpZiBzcGxpdCBoYXBwZW5zIGluIGdyYXZleWFyZCBvciBpbiBub24tZ3JhdmV5YXJkIHJvb3QuCiAgLy8KCgogIGlmIChhLmdyYXZleWFyZFBvc2l0aW9uICYmIGIuZ3JhdmV5YXJkUG9zaXRpb24gJiYgYS5ncmF2ZXlhcmRQb3NpdGlvbi5pc0VxdWFsKGIuZ3JhdmV5YXJkUG9zaXRpb24pKSB7CiAgICBjb25zdCBhSW5HcmF2ZXlhcmQgPSBhLnNwbGl0UG9zaXRpb24ucm9vdC5yb290TmFtZSA9PSAnJGdyYXZleWFyZCc7CiAgICBjb25zdCBiSW5HcmF2ZXlhcmQgPSBiLnNwbGl0UG9zaXRpb24ucm9vdC5yb290TmFtZSA9PSAnJGdyYXZleWFyZCc7IC8vIElmIGBhSXNXZWFrYCBpdCBtZWFucyB0aGF0IGBhYCBwb2ludHMgdG8gZ3JhdmV5YXJkIHdoaWxlIGBiYCBkb2Vzbid0LiBEb24ndCBtb3ZlIG5vZGVzIHRoZW4uCgogICAgY29uc3QgYUlzV2VhayA9IGFJbkdyYXZleWFyZCAmJiAhYkluR3JhdmV5YXJkOyAvLyBJZiBgYklzV2Vha2AgaXQgbWVhbnMgdGhhdCBgYmAgcG9pbnRzIHRvIGdyYXZleWFyZCB3aGlsZSBgYWAgZG9lc24ndC4gRm9yY2UgbW92aW5nIG5vZGVzIHRoZW4uCgogICAgY29uc3QgYklzV2VhayA9IGJJbkdyYXZleWFyZCAmJiAhYUluR3JhdmV5YXJkOyAvLyBGb3JjZSBtb3ZlIGlmIGBiYCBpcyB3ZWFrIG9yIG5laXRoZXIgb3BlcmF0aW9uIGlzIHdlYWsgYnV0IGBhYCBpcyBzdHJvbmdlciB0aHJvdWdoIGBjb250ZXh0LmFJc1N0cm9uZ2AuCgogICAgY29uc3QgZm9yY2VNb3ZlID0gYklzV2VhayB8fCAhYUlzV2VhayAmJiBjb250ZXh0LmFJc1N0cm9uZzsKCiAgICBpZiAoZm9yY2VNb3ZlKSB7CiAgICAgIGNvbnN0IHJlc3VsdCA9IFtdOyAvLyBGaXJzdCB3ZSBuZWVkIHRvIG1vdmUgYW55IG5vZGVzIHNwbGl0IGJ5IGBiYCBiYWNrIHRvIHdoZXJlIHRoZXkgd2VyZS4KICAgICAgLy8gRG8gaXQgb25seSBpZiBgYmAgYWN0dWFsbHkgbW92ZWQgc29tZXRoaW5nLgoKICAgICAgaWYgKGIuaG93TWFueSkgewogICAgICAgIHJlc3VsdC5wdXNoKG5ldyBNb3ZlT3BlcmF0aW9uKGIubW92ZVRhcmdldFBvc2l0aW9uLCBiLmhvd01hbnksIGIuc3BsaXRQb3NpdGlvbiwgMCkpOwogICAgICB9IC8vIFRoZW4gd2UgbmVlZCB0byBtb3ZlIG5vZGVzIGZyb20gYGFgIHNwbGl0IHBvc2l0aW9uIHRvIHRoZWlyIG5ldyBlbGVtZW50LgogICAgICAvLyBEbyBpdCBvbmx5IGlmIGBhYCBhY3R1YWxseSBzaG91bGQgbW92ZSBzb21ldGhpbmcuCgoKICAgICAgaWYgKGEuaG93TWFueSkgewogICAgICAgIHJlc3VsdC5wdXNoKG5ldyBNb3ZlT3BlcmF0aW9uKGEuc3BsaXRQb3NpdGlvbiwgYS5ob3dNYW55LCBhLm1vdmVUYXJnZXRQb3NpdGlvbiwgMCkpOwogICAgICB9CgogICAgICByZXR1cm4gcmVzdWx0OwogICAgfSBlbHNlIHsKICAgICAgcmV0dXJuIFtuZXcgTm9PcGVyYXRpb24oMCldOwogICAgfQogIH0KCiAgaWYgKGEuZ3JhdmV5YXJkUG9zaXRpb24pIHsKICAgIGEuZ3JhdmV5YXJkUG9zaXRpb24gPSBhLmdyYXZleWFyZFBvc2l0aW9uLl9nZXRUcmFuc2Zvcm1lZEJ5U3BsaXRPcGVyYXRpb24oYik7CiAgfSAvLyBDYXNlIDM6CiAgLy8KICAvLyBQb3NpdGlvbiB3aGVyZSBvcGVyYXRpb24gYGJgIGluc2VydGVkIGEgbmV3IG5vZGUgYWZ0ZXIgc3BsaXQgaXMgdGhlIHNhbWUgYXMgdGhlIG9wZXJhdGlvbiBgYWAgc3BsaXQgcG9zaXRpb24uCiAgLy8gQXMgaW4gc2ltaWxhciBjYXNlcywgdGhlcmUgaXMgYW1iaWd1aXR5IGlmIHRoZSBzcGxpdCBzaG91bGQgYmUgYmVmb3JlIHRoZSBuZXcgbm9kZSAoY3JlYXRlZCBieSBgYmApIG9yIGFmdGVyLgogIC8vCgoKICBpZiAoYS5zcGxpdFBvc2l0aW9uLmlzRXF1YWwoYi5pbnNlcnRpb25Qb3NpdGlvbikgJiYgY29udGV4dC5hYlJlbGF0aW9uID09ICdzcGxpdEJlZm9yZScpIHsKICAgIGEuaG93TWFueSsrOwogICAgcmV0dXJuIFthXTsKICB9IC8vIENhc2UgNDoKICAvLwogIC8vIFRoaXMgaXMgYSBtaXJyb3IgdG8gdGhlIGNhc2UgMi4gYWJvdmUuCiAgLy8KCgogIGlmIChiLnNwbGl0UG9zaXRpb24uaXNFcXVhbChhLmluc2VydGlvblBvc2l0aW9uKSAmJiBjb250ZXh0LmJhUmVsYXRpb24gPT0gJ3NwbGl0QmVmb3JlJykgewogICAgY29uc3QgbmV3UG9zaXRpb25QYXRoID0gYi5pbnNlcnRpb25Qb3NpdGlvbi5wYXRoLnNsaWNlKCk7CiAgICBuZXdQb3NpdGlvblBhdGgucHVzaCgwKTsKICAgIGNvbnN0IG5ld1Bvc2l0aW9uID0gbmV3IFBvc2l0aW9uKGIuaW5zZXJ0aW9uUG9zaXRpb24ucm9vdCwgbmV3UG9zaXRpb25QYXRoKTsKICAgIGNvbnN0IG1vdmVPcCA9IG5ldyBNb3ZlT3BlcmF0aW9uKGEuaW5zZXJ0aW9uUG9zaXRpb24sIDEsIG5ld1Bvc2l0aW9uLCAwKTsKICAgIHJldHVybiBbYSwgbW92ZU9wXTsKICB9IC8vIFRoZSBkZWZhdWx0IGNhc2UuCiAgLy8KCgogIGlmIChhLnNwbGl0UG9zaXRpb24uaGFzU2FtZVBhcmVudEFzKGIuc3BsaXRQb3NpdGlvbikgJiYgYS5zcGxpdFBvc2l0aW9uLm9mZnNldCA8IGIuc3BsaXRQb3NpdGlvbi5vZmZzZXQpIHsKICAgIGEuaG93TWFueSAtPSBiLmhvd01hbnk7CiAgfQoKICBhLnNwbGl0UG9zaXRpb24gPSBhLnNwbGl0UG9zaXRpb24uX2dldFRyYW5zZm9ybWVkQnlTcGxpdE9wZXJhdGlvbihiKTsKICBhLmluc2VydGlvblBvc2l0aW9uID0gU3BsaXRPcGVyYXRpb24uZ2V0SW5zZXJ0aW9uUG9zaXRpb24oYS5zcGxpdFBvc2l0aW9uKTsKICByZXR1cm4gW2FdOwp9KTsgLy8gQ2hlY2tzIHdoZXRoZXIgYE1vdmVPcGVyYXRpb25gIGB0YXJnZXRQb3NpdGlvbmAgaXMgaW5zaWRlIGEgbm9kZSBmcm9tIHRoZSBtb3ZlZCByYW5nZSBvZiB0aGUgb3RoZXIgYE1vdmVPcGVyYXRpb25gLgovLwovLyBAcHJpdmF0ZQovLyBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvb3BlcmF0aW9uL21vdmVvcGVyYXRpb25+TW92ZU9wZXJhdGlvbn0gYQovLyBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvb3BlcmF0aW9uL21vdmVvcGVyYXRpb25+TW92ZU9wZXJhdGlvbn0gYgovLyBAcmV0dXJucyB7Qm9vbGVhbn0KCmZ1bmN0aW9uIF9tb3ZlVGFyZ2V0SW50b01vdmVkUmFuZ2UoYSwgYikgewogIHJldHVybiBhLnRhcmdldFBvc2l0aW9uLl9nZXRUcmFuc2Zvcm1lZEJ5RGVsZXRpb24oYi5zb3VyY2VQb3NpdGlvbiwgYi5ob3dNYW55KSA9PT0gbnVsbDsKfSAvLyBIZWxwZXIgZnVuY3Rpb24gZm9yIGBNb3ZlT3BlcmF0aW9uYCB4IGBNb3ZlT3BlcmF0aW9uYCB0cmFuc2Zvcm1hdGlvbi4gQ29udmVydHMgZ2l2ZW4gcmFuZ2VzIGFuZCB0YXJnZXQgcG9zaXRpb24gdG8KLy8gbW92ZSBvcGVyYXRpb25zIGFuZCByZXR1cm5zIHRoZW0uCi8vCi8vIFJhbmdlcyBhbmQgdGFyZ2V0IHBvc2l0aW9uIHdpbGwgYmUgdHJhbnNmb3JtZWQgb24tdGhlLWZseSB3aGVuIGdlbmVyYXRpbmcgb3BlcmF0aW9ucy4KLy8KLy8gR2l2ZW4gYHJhbmdlc2Agc2hvdWxkIGJlIGluIHRoZSBvcmRlciBvZiBob3cgdGhleSB3ZXJlIGluIHRoZSBvcmlnaW5hbCB0cmFuc2Zvcm1lZCBvcGVyYXRpb24uCi8vCi8vIEdpdmVuIGB0YXJnZXRQb3NpdGlvbmAgaXMgdGhlIHRhcmdldCBwb3NpdGlvbiBvZiB0aGUgZmlyc3QgcmFuZ2UgZnJvbSBgcmFuZ2VzYC4KLy8KLy8gQHByaXZhdGUKLy8gQHBhcmFtIHtBcnJheS48bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZT59IHJhbmdlcwovLyBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvcG9zaXRpb25+UG9zaXRpb259IHRhcmdldFBvc2l0aW9uCi8vIEByZXR1cm5zIHtBcnJheS48bW9kdWxlOmVuZ2luZS9tb2RlbC9vcGVyYXRpb24vbW92ZW9wZXJhdGlvbn5Nb3ZlT3BlcmF0aW9uPn0KCgpmdW5jdGlvbiBfbWFrZU1vdmVPcGVyYXRpb25zRnJvbVJhbmdlcyhyYW5nZXMsIHRhcmdldFBvc2l0aW9uKSB7CiAgLy8gQXQgdGhpcyBtb21lbnQgd2UgaGF2ZSBzb21lIHJhbmdlcyBhbmQgYSB0YXJnZXQgcG9zaXRpb24sIHRvIHdoaWNoIHRob3NlIHJhbmdlcyBzaG91bGQgYmUgbW92ZWQuCiAgLy8gT3JkZXIgaW4gYHJhbmdlc2AgYXJyYXkgaXMgdGhlIGdvLXRvIG9yZGVyIG9mIGFmdGVyIHRyYW5zZm9ybWF0aW9uLgogIC8vCiAgLy8gV2UgYXJlIGFsbW9zdCBkb25lLiBXZSBoYXZlIGByYW5nZXNgIGFuZCBgdGFyZ2V0UG9zaXRpb25gIHRvIG1ha2Ugb3BlcmF0aW9ucyBmcm9tLgogIC8vIFVuZm9ydHVuYXRlbHksIHRob3NlIG9wZXJhdGlvbnMgbWF5IGFmZmVjdCBlYWNoIG90aGVyLiBQcmVjaXNlbHksIGZpcnN0IG9wZXJhdGlvbiBhZnRlciBtb3ZlCiAgLy8gbWF5IGFmZmVjdCBzb3VyY2UgcmFuZ2UgYW5kIHRhcmdldCBwb3NpdGlvbiBvZiBzZWNvbmQgYW5kIHRoaXJkIG9wZXJhdGlvbi4gU2FtZSB3aXRoIHNlY29uZAogIC8vIG9wZXJhdGlvbiBhZmZlY3RpbmcgdGhpcmQuCiAgLy8KICAvLyBXZSBuZWVkIHRvIGZpeCB0aG9zZSBzb3VyY2UgcmFuZ2VzIGFuZCB0YXJnZXQgcG9zaXRpb25zIG9uY2UgYWdhaW4sIGJlZm9yZSBjb252ZXJ0aW5nIGByYW5nZXNgIHRvIG9wZXJhdGlvbnMuCiAgY29uc3Qgb3BlcmF0aW9ucyA9IFtdOyAvLyBLZWVwIGluIG1pbmQgdGhhdCBub3RoaW5nIHdpbGwgYmUgdHJhbnNmb3JtZWQgaWYgdGhlcmUgaXMganVzdCBvbmUgcmFuZ2UgaW4gYHJhbmdlc2AuCgogIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7CiAgICAvLyBDcmVhdGUgbmV3IG9wZXJhdGlvbiBvdXQgb2YgYSByYW5nZSBhbmQgdGFyZ2V0IHBvc2l0aW9uLgogICAgY29uc3QgcmFuZ2UgPSByYW5nZXNbaV07CiAgICBjb25zdCBvcCA9IG5ldyBNb3ZlT3BlcmF0aW9uKHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQub2Zmc2V0IC0gcmFuZ2Uuc3RhcnQub2Zmc2V0LCB0YXJnZXRQb3NpdGlvbiwgMCk7CiAgICBvcGVyYXRpb25zLnB1c2gob3ApOyAvLyBUcmFuc2Zvcm0gb3RoZXIgcmFuZ2VzIGJ5IHRoZSBnZW5lcmF0ZWQgb3BlcmF0aW9uLgoKICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IHJhbmdlcy5sZW5ndGg7IGorKykgewogICAgICAvLyBBbGwgcmFuZ2VzIGluIGByYW5nZXNgIGFycmF5IHNob3VsZCBiZToKICAgICAgLy8KICAgICAgLy8gKiBub24taW50ZXJzZWN0aW5nICh0aGVzZSBhcmUgcGFydCBvZiBvcmlnaW5hbCBvcGVyYXRpb24gc291cmNlIHJhbmdlKSwgYW5kCiAgICAgIC8vICogYHRhcmdldFBvc2l0aW9uYCBkb2VzIG5vdCB0YXJnZXQgaW50byB0aGVtIChvcHBvc2l0ZSB3b3VsZCBtZWFuIHRoYXQgdHJhbnNmb3JtZWQgb3BlcmF0aW9uIHRhcmdldHMgImluc2lkZSBpdHNlbGYiKS4KICAgICAgLy8KICAgICAgLy8gVGhpcyBtZWFucyB0aGF0IHRoZSB0cmFuc2Zvcm1hdGlvbiB3aWxsIGJlICJjbGVhbiIgYW5kIGFsd2F5cyByZXR1cm4gb25lIHJlc3VsdC4KICAgICAgcmFuZ2VzW2pdID0gcmFuZ2VzW2pdLl9nZXRUcmFuc2Zvcm1lZEJ5TW92ZShvcC5zb3VyY2VQb3NpdGlvbiwgb3AudGFyZ2V0UG9zaXRpb24sIG9wLmhvd01hbnkpWzBdOwogICAgfQoKICAgIHRhcmdldFBvc2l0aW9uID0gdGFyZ2V0UG9zaXRpb24uX2dldFRyYW5zZm9ybWVkQnlNb3ZlKG9wLnNvdXJjZVBvc2l0aW9uLCBvcC50YXJnZXRQb3NpdGlvbiwgb3AuaG93TWFueSk7CiAgfQoKICByZXR1cm4gb3BlcmF0aW9uczsKfQ=="},{"version":3,"sources":["/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-engine/src/model/operation/transform.js"],"names":["InsertOperation","AttributeOperation","RenameOperation","MarkerOperation","MoveOperation","RootAttributeOperation","MergeOperation","SplitOperation","NoOperation","Range","Position","compareArrays","transformations","Map","setTransformation","OperationA","OperationB","transformationFunction","aGroup","get","set","getTransformation","has","noUpdateTransformation","a","transform","b","context","constructor","clone","e","transformSets","operationsA","operationsB","options","slice","contextFactory","ContextFactory","document","useRelations","forceWeakRemove","setOriginalOperations","originalOperations","length","nextTransformIndex","WeakMap","op","data","nextBaseVersionA","baseVersion","nextBaseVersionB","originalOperationsACount","originalOperationsBCount","i","opA","indexB","opB","newOpsA","getContext","newOpsB","updateRelation","newOpA","splice","padWithNoOps","brokenOperationsACount","brokenOperationsBCount","updateBaseVersions","_history","history","_useRelations","_forceWeakRemove","_relations","operations","takeFrom","originalOperation","operation","targetPosition","isEqual","sourcePosition","movedRange","containsPosition","_setRelation","deletionPosition","isAfter","isBefore","splitPosition","markerRange","newRange","_createFromPositionAndShift","howMany","affectedLeft","start","affectedRight","end","containsRange","side","path","wasInLeftElement","wasStartBeforeMergedElement","wasEndBeforeMergedElement","wasInRightElement","aIsStrong","aWasUndone","_wasUndone","bWasUndone","abRelation","_getRelation","baRelation","originalOp","wasUndone","isUndoneOperation","origB","undoneB","getUndoneOperation","origA","relationsA","relation","push","key","range","getDifference","map","oldValue","newValue","common","getIntersection","hasSameParentAs","position","_getTransformedByInsertion","shouldReceiveAttributes","result","r","_getComplementaryAttributeOperations","unshift","insertOperation","nodes","insertValue","getNode","getAttribute","getShiftedBy","ranges","graveyardPosition","_getTransformedByMergeOperation","isCollapsed","_breakRangeByMoveOperation","moveOp","moveRange","difference","diff","_getTransformedByDeletion","getMovedRangeStart","spread","_getTransformedByMove","insertionPosition","offset","secondPart","moveTargetPosition","_getCombined","stickiness","_getTransformedBySplitOperation","_getTransformedByInsertOperation","_getTransformedByMoveOperation","oldRange","name","_createFromRanges","aNewRange","_createAt","root","aToGraveyard","rootName","bToGraveyard","aIsWeak","bIsWeak","forceMove","removedRange","type","mergeInside","mergeSplittingElement","transformed","rangeA","rangeB","insertBefore","newTargetPosition","_moveTargetIntoMovedRange","getReversed","bTargetsToA","_makeMoveOperationsFromRanges","aTargetsToB","aCompB","getParentPath","shouldSpread","newRanges","rightRange","movesGraveyardElement","results","gyMoveSource","splitNodesMoveSource","gyMoveTarget","gyMove","splitNodesMoveTargetPath","splitNodesMoveTarget","splitNodesMove","oldName","newName","renamePath","splitPath","extraRename","getInsertionPosition","additionalSplit","rangeToMove","gyElementMoved","newParentPosition","newTargetPath","howManyRemoved","splitAtTarget","aInGraveyard","bInGraveyard","newPositionPath","newPosition","j"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\nimport InsertOperation from './insertoperation';\nimport AttributeOperation from './attributeoperation';\nimport RenameOperation from './renameoperation';\nimport MarkerOperation from './markeroperation';\nimport MoveOperation from './moveoperation';\nimport RootAttributeOperation from './rootattributeoperation';\nimport MergeOperation from './mergeoperation';\nimport SplitOperation from './splitoperation';\nimport NoOperation from './nooperation';\nimport Range from '../range';\nimport Position from '../position';\n\nimport compareArrays from '@ckeditor/ckeditor5-utils/src/comparearrays';\n\nconst transformations = new Map();\n\n/**\n * @module engine/model/operation/transform\n */\n\n/**\n * Sets a transformation function to be be used to transform instances of class `OperationA` by instances of class `OperationB`.\n *\n * The `transformationFunction` is passed three parameters:\n *\n * * `a` - operation to be transformed, an instance of `OperationA`,\n * * `b` - operation to be transformed by, an instance of `OperationB`,\n * * {@link module:engine/model/operation/transform~TransformationContext `context`} - object with additional information about\n * transformation context.\n *\n * The `transformationFunction` should return transformation result, which is an array with one or multiple\n * {@link module:engine/model/operation/operation~Operation operation} instances.\n *\n * @protected\n * @param {Function} OperationA\n * @param {Function} OperationB\n * @param {Function} transformationFunction Function to use for transforming.\n */\nfunction setTransformation( OperationA, OperationB, transformationFunction ) {\n\tlet aGroup = transformations.get( OperationA );\n\n\tif ( !aGroup ) {\n\t\taGroup = new Map();\n\t\ttransformations.set( OperationA, aGroup );\n\t}\n\n\taGroup.set( OperationB, transformationFunction );\n}\n\n/**\n * Returns a previously set transformation function for transforming an instance of `OperationA` by an instance of `OperationB`.\n *\n * If no transformation was set for given pair of operations, {@link module:engine/model/operation/transform~noUpdateTransformation}\n * is returned. This means that if no transformation was set, the `OperationA` instance will not change when transformed\n * by the `OperationB` instance.\n *\n * @private\n * @param {Function} OperationA\n * @param {Function} OperationB\n * @returns {Function} Function set to transform an instance of `OperationA` by an instance of `OperationB`.\n */\nfunction getTransformation( OperationA, OperationB ) {\n\tconst aGroup = transformations.get( OperationA );\n\n\tif ( aGroup && aGroup.has( OperationB ) ) {\n\t\treturn aGroup.get( OperationB );\n\t}\n\n\treturn noUpdateTransformation;\n}\n\n/**\n * A transformation function that only clones operation to transform, without changing it.\n *\n * @private\n * @param {module:engine/model/operation/operation~Operation} a Operation to transform.\n * @returns {Array.<module:engine/model/operation/operation~Operation>}\n */\nfunction noUpdateTransformation( a ) {\n\treturn [ a ];\n}\n\n/**\n * Transforms operation `a` by operation `b`.\n *\n * @param {module:engine/model/operation/operation~Operation} a Operation to be transformed.\n * @param {module:engine/model/operation/operation~Operation} b Operation to transform by.\n * @param {module:engine/model/operation/transform~TransformationContext} context Transformation context for this transformation.\n * @returns {Array.<module:engine/model/operation/operation~Operation>} Transformation result.\n */\nexport function transform( a, b, context = {} ) {\n\tconst transformationFunction = getTransformation( a.constructor, b.constructor );\n\n\ttry {\n\t\ta = a.clone();\n\n\t\treturn transformationFunction( a, b, context );\n\t} catch ( e ) {\n\t\t// @if CK_DEBUG // console.warn( 'Error during operation transformation!', e.message );\n\t\t// @if CK_DEBUG // console.warn( 'Transformed operation', a );\n\t\t// @if CK_DEBUG // console.warn( 'Operation transformed by', b );\n\t\t// @if CK_DEBUG // console.warn( 'context.aIsStrong', context.aIsStrong );\n\t\t// @if CK_DEBUG // console.warn( 'context.aWasUndone', context.aWasUndone );\n\t\t// @if CK_DEBUG // console.warn( 'context.bWasUndone', context.bWasUndone );\n\t\t// @if CK_DEBUG // console.warn( 'context.abRelation', context.abRelation );\n\t\t// @if CK_DEBUG // console.warn( 'context.baRelation', context.baRelation );\n\n\t\tthrow e;\n\t}\n}\n\n/**\n * Performs a transformation of two sets of operations - `operationsA` and `operationsB`. The transformation is two-way -\n * both transformed `operationsA` and transformed `operationsB` are returned.\n *\n * Note, that the first operation in each set should base on the same document state (\n * {@link module:engine/model/document~Document#version document version}).\n *\n * It is assumed that `operationsA` are \"more important\" during conflict resolution between two operations.\n *\n * New copies of both passed arrays and operations inside them are returned. Passed arguments are not altered.\n *\n * Base versions of the transformed operations sets are updated accordingly. For example, assume that base versions are `4`\n * and there are `3` operations in `operationsA` and `5` operations in `operationsB`. Then:\n *\n * * transformed `operationsA` will start from base version `9` (`4` base version + `5` operations B),\n * * transformed `operationsB` will start from base version `7` (`4` base version + `3` operations A).\n *\n * If no operation was broken into two during transformation, then both sets will end up with an operation that bases on version `11`:\n *\n * * transformed `operationsA` start from `9` and there are `3` of them, so the last will have `baseVersion` equal to `11`,\n * * transformed `operationsB` start from `7` and there are `5` of them, so the last will have `baseVersion` equal to `11`.\n *\n * @param {Array.<module:engine/model/operation/operation~Operation>} operationsA\n * @param {Array.<module:engine/model/operation/operation~Operation>} operationsB\n * @param {Object} options Additional transformation options.\n * @param {module:engine/model/document~Document|null} options.document Document which the operations change.\n * @param {Boolean} [options.useRelations=false] Whether during transformation relations should be used (used during undo for\n * better conflict resolution).\n * @param {Boolean} [options.padWithNoOps=false] Whether additional {@link module:engine/model/operation/nooperation~NoOperation}s\n * should be added to the transformation results to force the same last base version for both transformed sets (in case\n * if some operations got broken into multiple operations during transformation).\n * @returns {Object} Transformation result.\n * @returns {Array.<module:engine/model/operation/operation~Operation>} return.operationsA Transformed `operationsA`.\n * @returns {Array.<module:engine/model/operation/operation~Operation>} return.operationsB Transformed `operationsB`.\n * @returns {Map} return.originalOperations A map that links transformed operations to original operations. The keys are the transformed\n * operations and the values are the original operations from the input (`operationsA` and `operationsB`).\n */\nexport function transformSets( operationsA, operationsB, options ) {\n\t// Create new arrays so the originally passed arguments are not changed.\n\t// No need to clone operations, they are cloned as they are transformed.\n\toperationsA = operationsA.slice();\n\toperationsB = operationsB.slice();\n\n\tconst contextFactory = new ContextFactory( options.document, options.useRelations, options.forceWeakRemove );\n\tcontextFactory.setOriginalOperations( operationsA );\n\tcontextFactory.setOriginalOperations( operationsB );\n\n\tconst originalOperations = contextFactory.originalOperations;\n\n\t// If one of sets is empty there is simply nothing to transform, so return sets as they are.\n\tif ( operationsA.length == 0 || operationsB.length == 0 ) {\n\t\treturn { operationsA, operationsB, originalOperations };\n\t}\n\t//\n\t// Following is a description of transformation process:\n\t//\n\t// There are `operationsA` and `operationsB` to be transformed, both by both.\n\t//\n\t// So, suppose we have sets of two operations each: `operationsA` = `[ a1, a2 ]`, `operationsB` = `[ b1, b2 ]`.\n\t//\n\t// Remember, that we can only transform operations that base on the same context. We assert that `a1` and `b1` base on\n\t// the same context and we transform them. Then, we get `a1'` and `b1'`. `a2` bases on a context with `a1` -- `a2`\n\t// is an operation that followed `a1`. Similarly, `b2` bases on a context with `b1`.\n\t//\n\t// However, since `a1'` is a result of transformation by `b1`, `a1'` now also has a context with `b1`. This means that\n\t// we can safely transform `a1'` by `b2`. As we finish transforming `a1`, we also transformed all `operationsB`.\n\t// All `operationsB` also have context including `a1`. Now, we can properly transform `a2` by those operations.\n\t//\n\t// The transformation process can be visualized on a transformation diagram (\"diamond diagram\"):\n\t//\n\t//          [the initial state]\n\t//         [common for a1 and b1]\n\t//\n\t//                   *\n\t//                  / \\\n\t//                 /   \\\n\t//               b1     a1\n\t//               /       \\\n\t//              /         \\\n\t//             *           *\n\t//            / \\         / \\\n\t//           /   \\       /   \\\n\t//         b2    a1'   b1'    a2\n\t//         /       \\   /       \\\n\t//        /         \\ /         \\\n\t//       *           *           *\n\t//        \\         / \\         /\n\t//         \\       /   \\       /\n\t//        a1''   b2'   a2'   b1''\n\t//           \\   /       \\   /\n\t//            \\ /         \\ /\n\t//             *           *\n\t//              \\         /\n\t//               \\       /\n\t//              a2''   b2''\n\t//                 \\   /\n\t//                  \\ /\n\t//                   *\n\t//\n\t//           [the final state]\n\t//\n\t// The final state can be reached from the initial state by applying `a1`, `a2`, `b1''` and `b2''`, as well as by\n\t// applying `b1`, `b2`, `a1''`, `a2''`. Note how the operations get to a proper common state before each pair is\n\t// transformed.\n\t//\n\t// Another thing to consider is that an operation during transformation can be broken into multiple operations.\n\t// Suppose that `a1` * `b1` = `[ a11', a12' ]` (instead of `a1'` that we considered previously).\n\t//\n\t// In that case, we leave `a12'` for later and we continue transforming `a11'` until it is transformed by all `operationsB`\n\t// (in our case it is just `b2`). At this point, `b1` is transformed by \"whole\" `a1`, while `b2` is only transformed\n\t// by `a11'`. Similarly, `a12'` is only transformed by `b1`. This leads to a conclusion that we need to start transforming `a12'`\n\t// from the moment just after it was broken. So, `a12'` is transformed by `b2`. Now, \"the whole\" `a1` is transformed\n\t// by `operationsB`, while all `operationsB` are transformed by \"the whole\" `a1`. This means that we can continue with\n\t// following `operationsA` (in our case it is just `a2`).\n\t//\n\t// Of course, also `operationsB` can be broken. However, since we focus on transforming operation `a` to the end,\n\t// the only thing to do is to store both pieces of operation `b`, so that the next transformed operation `a` will\n\t// be transformed by both of them.\n\t//\n\t//                       *\n\t//                      / \\\n\t//                     /   \\\n\t//                    /     \\\n\t//                  b1       a1\n\t//                  /         \\\n\t//                 /           \\\n\t//                /             \\\n\t//               *               *\n\t//              / \\             / \\\n\t//             /  a11'         /   \\\n\t//            /     \\         /     \\\n\t//          b2       *      b1'      a2\n\t//          /       / \\     /         \\\n\t//         /       /  a12' /           \\\n\t//        /       /     \\ /             \\\n\t//       *       b2'     *               *\n\t//        \\     /       / \\             /\n\t//       a11'' /     b21'' \\           /\n\t//          \\ /       /     \\         /\n\t//           *       *      a2'     b1''\n\t//            \\     / \\       \\     /\n\t//          a12'' b22''\\       \\   /\n\t//              \\ /     \\       \\ /\n\t//               *      a2''     *\n\t//                \\       \\     /\n\t//                 \\       \\  b21'''\n\t//                  \\       \\ /\n\t//                a2'''      *\n\t//                    \\     /\n\t//                     \\  b22'''\n\t//                      \\ /\n\t//                       *\n\t//\n\t// Note, how `a1` is broken and transformed into `a11'` and `a12'`, while `b2'` got broken and transformed into `b21''` and `b22''`.\n\t//\n\t// Having all that on mind, here is an outline for the transformation process algorithm:\n\t//\n\t// 1. We have `operationsA` and `operationsB` array, which we dynamically update as the transformation process goes.\n\t//\n\t// 2. We take next (or first) operation from `operationsA` and check from which operation `b` we need to start transforming it.\n\t// All original `operationsA` are set to be transformed starting from the first operation `b`.\n\t//\n\t// 3. We take operations from `operationsB`, one by one, starting from the correct one, and transform operation `a`\n\t// by operation `b` (and vice versa). We update `operationsA` and `operationsB` by replacing the original operations\n\t// with the transformation results.\n\t//\n\t// 4. If operation is broken into multiple operations, we save all the new operations in the place of the\n\t// original operation.\n\t//\n\t// 5. Additionally, if operation `a` was broken, for the \"new\" operation, we remember from which operation `b` it should\n\t// be transformed by.\n\t//\n\t// 6. We continue transforming \"current\" operation `a` until it is transformed by all `operationsB`. Then, go to 2.\n\t// unless the last operation `a` was transformed.\n\t//\n\t// The actual implementation of the above algorithm is slightly different, as only one loop (while) is used.\n\t// The difference is that we have \"current\" `a` operation to transform and we store the index of the next `b` operation\n\t// to transform by. Each loop operates on two indexes then: index pointing to currently processed `a` operation and\n\t// index pointing to next `b` operation. Each loop is just one `a * b` + `b * a` transformation. After each loop\n\t// operation `b` index is updated. If all `b` operations were visited for the current `a` operation, we change\n\t// current `a` operation index to the next one.\n\t//\n\n\t// For each operation `a`, keeps information what is the index in `operationsB` from which the transformation should start.\n\tconst nextTransformIndex = new WeakMap();\n\n\t// For all the original `operationsA`, set that they should be transformed starting from the first of `operationsB`.\n\tfor ( const op of operationsA ) {\n\t\tnextTransformIndex.set( op, 0 );\n\t}\n\n\t// Additional data that is used for some postprocessing after the main transformation process is done.\n\tconst data = {\n\t\tnextBaseVersionA: operationsA[ operationsA.length - 1 ].baseVersion + 1,\n\t\tnextBaseVersionB: operationsB[ operationsB.length - 1 ].baseVersion + 1,\n\t\toriginalOperationsACount: operationsA.length,\n\t\toriginalOperationsBCount: operationsB.length\n\t};\n\n\t// Index of currently transformed operation `a`.\n\tlet i = 0;\n\n\t// While not all `operationsA` are transformed...\n\twhile ( i < operationsA.length ) {\n\t\t// Get \"current\" operation `a`.\n\t\tconst opA = operationsA[ i ];\n\n\t\t// For the \"current\" operation `a`, get the index of the next operation `b` to transform by.\n\t\tconst indexB = nextTransformIndex.get( opA );\n\n\t\t// If operation `a` was already transformed by every operation `b`, change \"current\" operation `a` to the next one.\n\t\tif ( indexB == operationsB.length ) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst opB = operationsB[ indexB ];\n\n\t\t// Transform `a` by `b` and `b` by `a`.\n\t\tconst newOpsA = transform( opA, opB, contextFactory.getContext( opA, opB, true ) );\n\t\tconst newOpsB = transform( opB, opA, contextFactory.getContext( opB, opA, false ) );\n\t\t// As a result we get one or more `newOpsA` and one or more `newOpsB` operations.\n\n\t\t// Update contextual information about operations.\n\t\tcontextFactory.updateRelation( opA, opB );\n\n\t\tcontextFactory.setOriginalOperations( newOpsA, opA );\n\t\tcontextFactory.setOriginalOperations( newOpsB, opB );\n\n\t\t// For new `a` operations, update their index of the next operation `b` to transform them by.\n\t\t//\n\t\t// This is needed even if there was only one result (`a` was not broken) because that information is used\n\t\t// at the beginning of this loop every time.\n\t\tfor ( const newOpA of newOpsA ) {\n\t\t\t// Acknowledge, that operation `b` also might be broken into multiple operations.\n\t\t\t//\n\t\t\t// This is why we raise `indexB` not just by 1. If `newOpsB` are multiple operations, they will be\n\t\t\t// spliced in the place of `opB`. So we need to change `transformBy` accordingly, so that an operation won't\n\t\t\t// be transformed by the same operation (part of it) again.\n\t\t\tnextTransformIndex.set( newOpA, indexB + newOpsB.length );\n\t\t}\n\n\t\t// Update `operationsA` and `operationsB` with the transformed versions.\n\t\toperationsA.splice( i, 1, ...newOpsA );\n\t\toperationsB.splice( indexB, 1, ...newOpsB );\n\t}\n\n\tif ( options.padWithNoOps ) {\n\t\t// If no-operations padding is enabled, count how many extra `a` and `b` operations were generated.\n\t\tconst brokenOperationsACount = operationsA.length - data.originalOperationsACount;\n\t\tconst brokenOperationsBCount = operationsB.length - data.originalOperationsBCount;\n\n\t\t// Then, if that number is not the same, pad `operationsA` or `operationsB` with correct number of no-ops so\n\t\t// that the base versions are equalled.\n\t\t//\n\t\t// Note that only one array will be updated, as only one of those subtractions can be greater than zero.\n\t\tpadWithNoOps( operationsA, brokenOperationsBCount - brokenOperationsACount );\n\t\tpadWithNoOps( operationsB, brokenOperationsACount - brokenOperationsBCount );\n\t}\n\n\t// Finally, update base versions of transformed operations.\n\tupdateBaseVersions( operationsA, data.nextBaseVersionB );\n\tupdateBaseVersions( operationsB, data.nextBaseVersionA );\n\n\treturn { operationsA, operationsB, originalOperations };\n}\n\n// Gathers additional data about operations processed during transformation. Can be used to obtain contextual information\n// about two operations that are about to be transformed. This contextual information can be used for better conflict resolution.\nclass ContextFactory {\n\t// Creates `ContextFactory` instance.\n\t//\n\t// @param {module:engine/model/document~Document} document Document which the operations change.\n\t// @param {Boolean} useRelations Whether during transformation relations should be used (used during undo for\n\t// better conflict resolution).\n\t// @param {Boolean} [forceWeakRemove=false] If set to `false`, remove operation will be always stronger than move operation,\n\t// so the removed nodes won't end up back in the document root. When set to `true`, context data will be used.\n\tconstructor( document, useRelations, forceWeakRemove = false ) {\n\t\t// For each operation that is created during transformation process, we keep a reference to the original operation\n\t\t// which it comes from. The original operation works as a kind of \"identifier\". Every contextual information\n\t\t// gathered during transformation that we want to save for given operation, is actually saved for the original operation.\n\t\t// This way no matter if operation `a` is cloned, then transformed, even breaks, we still have access to the previously\n\t\t// gathered data through original operation reference.\n\t\tthis.originalOperations = new Map();\n\n\t\t// `model.History` instance which information about undone operations will be taken from.\n\t\tthis._history = document.history;\n\n\t\t// Whether additional context should be used.\n\t\tthis._useRelations = useRelations;\n\n\t\tthis._forceWeakRemove = !!forceWeakRemove;\n\n\t\t// Relations is a double-map structure (maps in map) where for two operations we store how those operations were related\n\t\t// to each other. Those relations are evaluated during transformation process. For every transformated pair of operations\n\t\t// we keep relations between them.\n\t\tthis._relations = new Map();\n\t}\n\n\t// Sets \"original operation\" for given operations.\n\t//\n\t// During transformation process, operations are cloned, then changed, then processed again, sometimes broken into two\n\t// or multiple operations. When gathering additional data it is important that all operations can be somehow linked\n\t// so a cloned and transformed \"version\" still kept track of the data assigned earlier to it.\n\t//\n\t// The original operation object will be used as such an universal linking id. Throughout the transformation process\n\t// all cloned operations will refer to \"the original operation\" when storing and reading additional data.\n\t//\n\t// If `takeFrom` is not set, each operation from `operations` array will be assigned itself as \"the original operation\".\n\t// This should be used as an initialization step.\n\t//\n\t// If `takeFrom` is set, each operation from `operations` will be assigned the same original operation as assigned\n\t// for `takeFrom` operation. This should be used to update original operations. It should be used in a way that\n\t// `operations` are the result of `takeFrom` transformation to ensure proper \"original operation propagation\".\n\t//\n\t// @param {Array.<module:engine/model/operation/operation~Operation>} operations\n\t// @param {module:engine/model/operation/operation~Operation|null} [takeFrom=null]\n\tsetOriginalOperations( operations, takeFrom = null ) {\n\t\tconst originalOperation = takeFrom ? this.originalOperations.get( takeFrom ) : null;\n\n\t\tfor ( const operation of operations ) {\n\t\t\tthis.originalOperations.set( operation, originalOperation || operation );\n\t\t}\n\t}\n\n\t// Saves a relation between operations `opA` and `opB`.\n\t//\n\t// Relations are then later used to help solve conflicts when operations are transformed.\n\t//\n\t// @param {module:engine/model/operation/operation~Operation} opA\n\t// @param {module:engine/model/operation/operation~Operation} opB\n\tupdateRelation( opA, opB ) {\n\t\t// The use of relations is described in a bigger detail in transformation functions.\n\t\t//\n\t\t// In brief, this function, for specified pairs of operation types, checks how positions defined in those operations relate.\n\t\t// Then those relations are saved. For example, for two move operations, it is saved if one of those operations target\n\t\t// position is before the other operation source position. This kind of information gives contextual information when\n\t\t// transformation is used during undo. Similar checks are done for other pairs of operations.\n\t\t//\n\t\tswitch ( opA.constructor ) {\n\t\t\tcase MoveOperation: {\n\t\t\t\tswitch ( opB.constructor ) {\n\t\t\t\t\tcase MergeOperation: {\n\t\t\t\t\t\tif ( opA.targetPosition.isEqual( opB.sourcePosition ) || opB.movedRange.containsPosition( opA.targetPosition ) ) {\n\t\t\t\t\t\t\tthis._setRelation( opA, opB, 'insertAtSource' );\n\t\t\t\t\t\t} else if ( opA.targetPosition.isEqual( opB.deletionPosition ) ) {\n\t\t\t\t\t\t\tthis._setRelation( opA, opB, 'insertBetween' );\n\t\t\t\t\t\t} else if ( opA.targetPosition.isAfter( opB.sourcePosition ) ) {\n\t\t\t\t\t\t\tthis._setRelation( opA, opB, 'moveTargetAfter' );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcase MoveOperation: {\n\t\t\t\t\t\tif ( opA.targetPosition.isEqual( opB.sourcePosition ) || opA.targetPosition.isBefore( opB.sourcePosition ) ) {\n\t\t\t\t\t\t\tthis._setRelation( opA, opB, 'insertBefore' );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis._setRelation( opA, opB, 'insertAfter' );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase SplitOperation: {\n\t\t\t\tswitch ( opB.constructor ) {\n\t\t\t\t\tcase MergeOperation: {\n\t\t\t\t\t\tif ( opA.splitPosition.isBefore( opB.sourcePosition ) ) {\n\t\t\t\t\t\t\tthis._setRelation( opA, opB, 'splitBefore' );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcase MoveOperation: {\n\t\t\t\t\t\tif ( opA.splitPosition.isEqual( opB.sourcePosition ) || opA.splitPosition.isBefore( opB.sourcePosition ) ) {\n\t\t\t\t\t\t\tthis._setRelation( opA, opB, 'splitBefore' );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase MergeOperation: {\n\t\t\t\tswitch ( opB.constructor ) {\n\t\t\t\t\tcase MergeOperation: {\n\t\t\t\t\t\tif ( !opA.targetPosition.isEqual( opB.sourcePosition ) ) {\n\t\t\t\t\t\t\tthis._setRelation( opA, opB, 'mergeTargetNotMoved' );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( opA.sourcePosition.isEqual( opB.targetPosition ) ) {\n\t\t\t\t\t\t\tthis._setRelation( opA, opB, 'mergeSourceNotMoved' );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( opA.sourcePosition.isEqual( opB.sourcePosition ) ) {\n\t\t\t\t\t\t\tthis._setRelation( opA, opB, 'mergeSameElement' );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcase SplitOperation: {\n\t\t\t\t\t\tif ( opA.sourcePosition.isEqual( opB.splitPosition ) ) {\n\t\t\t\t\t\t\tthis._setRelation( opA, opB, 'splitAtSource' );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase MarkerOperation: {\n\t\t\t\tconst markerRange = opA.newRange;\n\n\t\t\t\tif ( !markerRange ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tswitch ( opB.constructor ) {\n\t\t\t\t\tcase MoveOperation: {\n\t\t\t\t\t\tconst movedRange = Range._createFromPositionAndShift( opB.sourcePosition, opB.howMany );\n\n\t\t\t\t\t\tconst affectedLeft = movedRange.containsPosition( markerRange.start ) ||\n\t\t\t\t\t\t\tmovedRange.start.isEqual( markerRange.start );\n\n\t\t\t\t\t\tconst affectedRight = movedRange.containsPosition( markerRange.end ) ||\n\t\t\t\t\t\t\tmovedRange.end.isEqual( markerRange.end );\n\n\t\t\t\t\t\tif ( ( affectedLeft || affectedRight ) && !movedRange.containsRange( markerRange ) ) {\n\t\t\t\t\t\t\tthis._setRelation( opA, opB, {\n\t\t\t\t\t\t\t\tside: affectedLeft ? 'left' : 'right',\n\t\t\t\t\t\t\t\tpath: affectedLeft ? markerRange.start.path.slice() : markerRange.end.path.slice()\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcase MergeOperation: {\n\t\t\t\t\t\tconst wasInLeftElement = markerRange.start.isEqual( opB.targetPosition );\n\t\t\t\t\t\tconst wasStartBeforeMergedElement = markerRange.start.isEqual( opB.deletionPosition );\n\t\t\t\t\t\tconst wasEndBeforeMergedElement = markerRange.end.isEqual( opB.deletionPosition );\n\t\t\t\t\t\tconst wasInRightElement = markerRange.end.isEqual( opB.sourcePosition );\n\n\t\t\t\t\t\tif ( wasInLeftElement || wasStartBeforeMergedElement || wasEndBeforeMergedElement || wasInRightElement ) {\n\t\t\t\t\t\t\tthis._setRelation( opA, opB, {\n\t\t\t\t\t\t\t\twasInLeftElement,\n\t\t\t\t\t\t\t\twasStartBeforeMergedElement,\n\t\t\t\t\t\t\t\twasEndBeforeMergedElement,\n\t\t\t\t\t\t\t\twasInRightElement\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Evaluates and returns contextual information about two given operations `opA` and `opB` which are about to be transformed.\n\t//\n\t// @param {module:engine/model/operation/operation~Operation} opA\n\t// @param {module:engine/model/operation/operation~Operation} opB\n\t// @returns {module:engine/model/operation/transform~TransformationContext}\n\tgetContext( opA, opB, aIsStrong ) {\n\t\treturn {\n\t\t\taIsStrong,\n\t\t\taWasUndone: this._wasUndone( opA ),\n\t\t\tbWasUndone: this._wasUndone( opB ),\n\t\t\tabRelation: this._useRelations ? this._getRelation( opA, opB ) : null,\n\t\t\tbaRelation: this._useRelations ? this._getRelation( opB, opA ) : null,\n\t\t\tforceWeakRemove: this._forceWeakRemove\n\t\t};\n\t}\n\n\t// Returns whether given operation `op` has already been undone.\n\t//\n\t// Information whether an operation was undone gives more context when making a decision when two operations are in conflict.\n\t//\n\t// @param {module:engine/model/operation/operation~Operation} op\n\t// @returns {Boolean}\n\t_wasUndone( op ) {\n\t\t// For `op`, get its original operation. After all, if `op` is a clone (or even transformed clone) of another\n\t\t// operation, literally `op` couldn't be undone. It was just generated. If anything, it was the operation it origins\n\t\t// from which was undone. So get that original operation.\n\t\tconst originalOp = this.originalOperations.get( op );\n\n\t\t// And check with the document if the original operation was undone.\n\t\treturn originalOp.wasUndone || this._history.isUndoneOperation( originalOp );\n\t}\n\n\t// Returns a relation between `opA` and an operation which is undone by `opB`. This can be `String` value if a relation\n\t// was set earlier or `null` if there was no relation between those operations.\n\t//\n\t// This is a little tricky to understand, so let's compare it to `ContextFactory#_wasUndone`.\n\t//\n\t// When `wasUndone( opB )` is used, we check if the `opB` has already been undone. It is obvious, that the\n\t// undoing operation must happen after the undone operation. So, essentially, we have `opB`, we take document history,\n\t// we look forward in the future and ask if in that future `opB` was undone.\n\t//\n\t// Relations is a backward process to `wasUndone()`.\n\t//\n\t// Long story short - using relations is asking what happened in the past. Looking back. This time we have an undoing\n\t// operation `opB` which has undone some other operation. When there is a transformation `opA` x `opB` and there is\n\t// a conflict to solve and `opB` is an undoing operation, we can look back in the history and see what was a relation\n\t// between `opA` and the operation which `opB` undone. Basing on that relation from the past, we can now make\n\t// a better decision when resolving a conflict between two operations, because we know more about the context of\n\t// those two operations.\n\t//\n\t// This is why this function does not return a relation directly between `opA` and `opB` because we need to look\n\t// back to search for a meaningful contextual information.\n\t//\n\t// @param {module:engine/model/operation/operation~Operation} opA\n\t// @param {module:engine/model/operation/operation~Operation} opB\n\t// @returns {String|null}\n\t_getRelation( opA, opB ) {\n\t\t// Get the original operation. Similarly as in `wasUndone()` it is used as an universal identifier for stored data.\n\t\tconst origB = this.originalOperations.get( opB );\n\t\tconst undoneB = this._history.getUndoneOperation( origB );\n\n\t\t// If `opB` is not undoing any operation, there is no relation.\n\t\tif ( !undoneB ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst origA = this.originalOperations.get( opA );\n\t\tconst relationsA = this._relations.get( origA );\n\n\t\t// Get all relations for `opA`, and check if there is a relation with `opB`-undone-counterpart. If so, return it.\n\t\tif ( relationsA ) {\n\t\t\treturn relationsA.get( undoneB ) || null;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t// Helper function for `ContextFactory#updateRelations`.\n\t//\n\t// @private\n\t// @param {module:engine/model/operation/operation~Operation} opA\n\t// @param {module:engine/model/operation/operation~Operation} opB\n\t// @param {String} relation\n\t_setRelation( opA, opB, relation ) {\n\t\t// As always, setting is for original operations, not the clones/transformed operations.\n\t\tconst origA = this.originalOperations.get( opA );\n\t\tconst origB = this.originalOperations.get( opB );\n\n\t\tlet relationsA = this._relations.get( origA );\n\n\t\tif ( !relationsA ) {\n\t\t\trelationsA = new Map();\n\t\t\tthis._relations.set( origA, relationsA );\n\t\t}\n\n\t\trelationsA.set( origB, relation );\n\t}\n}\n\n/**\n * Holds additional contextual information about a transformed pair of operations (`a` and `b`). Those information\n * can be used for better conflict resolving.\n *\n * @typedef {Object} module:engine/model/operation/transform~TransformationContext\n *\n * @property {Boolean} aIsStrong Whether `a` is strong operation in this transformation, or weak.\n * @property {Boolean} aWasUndone Whether `a` operation was undone.\n * @property {Boolean} bWasUndone Whether `b` operation was undone.\n * @property {String|null} abRelation The relation between `a` operation and an operation undone by `b` operation.\n * @property {String|null} baRelation The relation between `b` operation and an operation undone by `a` operation.\n */\n\n/**\n * An utility function that updates {@link module:engine/model/operation/operation~Operation#baseVersion base versions}\n * of passed operations.\n *\n * The function simply sets `baseVersion` as a base version of the first passed operation and then increments it for\n * each following operation in `operations`.\n *\n * @private\n * @param {Array.<module:engine/model/operation/operation~Operation>} operations Operations to update.\n * @param {Number} baseVersion Base version to set for the first operation in `operations`.\n */\nfunction updateBaseVersions( operations, baseVersion ) {\n\tfor ( const operation of operations ) {\n\t\toperation.baseVersion = baseVersion++;\n\t}\n}\n\n/**\n * Adds `howMany` instances of {@link module:engine/model/operation/nooperation~NoOperation} to `operations` set.\n *\n * @private\n * @param {Array.<module:engine/model/operation/operation~Operation>} operations\n * @param {Number} howMany\n */\nfunction padWithNoOps( operations, howMany ) {\n\tfor ( let i = 0; i < howMany; i++ ) {\n\t\toperations.push( new NoOperation( 0 ) );\n\t}\n}\n\n// -----------------------\n\nsetTransformation( AttributeOperation, AttributeOperation, ( a, b, context ) => {\n\tif ( a.key === b.key ) {\n\t\t// If operations attributes are in conflict, check if their ranges intersect and manage them properly.\n\n\t\t// First, we want to apply change to the part of a range that has not been changed by the other operation.\n\t\tconst operations = a.range.getDifference( b.range ).map( range => {\n\t\t\treturn new AttributeOperation( range, a.key, a.oldValue, a.newValue, 0 );\n\t\t} );\n\n\t\t// Then we take care of the common part of ranges.\n\t\tconst common = a.range.getIntersection( b.range );\n\n\t\tif ( common ) {\n\t\t\t// If this operation is more important, we also want to apply change to the part of the\n\t\t\t// original range that has already been changed by the other operation. Since that range\n\t\t\t// got changed we also have to update `oldValue`.\n\t\t\tif ( context.aIsStrong ) {\n\t\t\t\toperations.push( new AttributeOperation( common, b.key, b.newValue, a.newValue, 0 ) );\n\t\t\t}\n\t\t}\n\n\t\tif ( operations.length == 0 ) {\n\t\t\treturn [ new NoOperation( 0 ) ];\n\t\t}\n\n\t\treturn operations;\n\t} else {\n\t\t// If operations don't conflict, simply return an array containing just a clone of this operation.\n\t\treturn [ a ];\n\t}\n} );\n\nsetTransformation( AttributeOperation, InsertOperation, ( a, b ) => {\n\t// Case 1:\n\t//\n\t// The attribute operation range includes the position where nodes were inserted.\n\t// There are two possible scenarios: the inserted nodes were text and they should receive attributes or\n\t// the inserted nodes were elements and they should not receive attributes.\n\t//\n\tif ( a.range.start.hasSameParentAs( b.position ) && a.range.containsPosition( b.position ) ) {\n\t\t// If new nodes should not receive attributes, two separated ranges will be returned.\n\t\t// Otherwise, one expanded range will be returned.\n\t\tconst range = a.range._getTransformedByInsertion( b.position, b.howMany, !b.shouldReceiveAttributes );\n\t\tconst result = range.map( r => {\n\t\t\treturn new AttributeOperation( r, a.key, a.oldValue, a.newValue, a.baseVersion );\n\t\t} );\n\n\t\tif ( b.shouldReceiveAttributes ) {\n\t\t\t// `AttributeOperation#range` includes some newly inserted text.\n\t\t\t// The operation should also change the attribute of that text. An example:\n\t\t\t//\n\t\t\t// Bold should be applied on the following range:\n\t\t\t// <p>Fo[zb]ar</p>\n\t\t\t//\n\t\t\t// In meantime, new text is typed:\n\t\t\t// <p>Fozxxbar</p>\n\t\t\t//\n\t\t\t// Bold should be applied also on the new text:\n\t\t\t// <p>Fo[zxxb]ar</p>\n\t\t\t// <p>Fo<$text bold=\"true\">zxxb</$text>ar</p>\n\t\t\t//\n\t\t\t// There is a special case to consider here to consider.\n\t\t\t//\n\t\t\t// Consider setting an attribute with multiple possible values, for example `highlight`. The inserted text might\n\t\t\t// have already an attribute value applied and the `oldValue` property of the attribute operation might be wrong:\n\t\t\t//\n\t\t\t// Attribute `highlight=\"yellow\"` should be applied on the following range:\n\t\t\t// <p>Fo[zb]ar<p>\n\t\t\t//\n\t\t\t// In meantime, character `x` with `highlight=\"red\"` is typed:\n\t\t\t// <p>Fo[z<$text highlight=\"red\">x</$text>b]ar</p>\n\t\t\t//\n\t\t\t// In this case we cannot simply apply operation changing the attribute value from `null` to `\"yellow\"` for the whole range\n\t\t\t// because that would lead to an exception (`oldValue` is incorrect for `x`).\n\t\t\t//\n\t\t\t// We also cannot break the original range as this would mess up a scenario when there are multiple following\n\t\t\t// insert operations, because then only the first inserted character is included in those ranges:\n\t\t\t// <p>Fo[z][x][b]ar</p>   -->   <p>Fo[z][x]x[b]ar</p>   -->   <p>Fo[z][x]xx[b]ar</p>\n\t\t\t//\n\t\t\t// So, the attribute range needs be expanded, no matter what attributes are set on the inserted nodes:\n\t\t\t//\n\t\t\t// <p>Fo[z<$text highlight=\"red\">x</$text>b]ar</p>      <--- Change from `null` to `yellow`, throwing an exception.\n\t\t\t//\n\t\t\t// But before that operation would be applied, we will add an additional attribute operation that will change\n\t\t\t// attributes on the inserted nodes in a way which would make the original operation correct:\n\t\t\t//\n\t\t\t// <p>Fo[z{<$text highlight=\"red\">}x</$text>b]ar</p>    <--- Change range `{}` from `red` to `null`.\n\t\t\t// <p>Fo[zxb]ar</p>                                     <--- Now change from `null` to `yellow` is completely fine.\n\t\t\t//\n\n\t\t\t// Generate complementary attribute operation. Be sure to add it before the original operation.\n\t\t\tconst op = _getComplementaryAttributeOperations( b, a.key, a.oldValue );\n\n\t\t\tif ( op ) {\n\t\t\t\tresult.unshift( op );\n\t\t\t}\n\t\t}\n\n\t\t// If nodes should not receive new attribute, we are done here.\n\t\treturn result;\n\t}\n\n\t// If insert operation is not expanding the attribute operation range, simply transform the range.\n\ta.range = a.range._getTransformedByInsertion( b.position, b.howMany, false )[ 0 ];\n\n\treturn [ a ];\n} );\n\n/**\n * Helper function for `AttributeOperation` x `InsertOperation` (and reverse) transformation.\n *\n * For given `insertOperation` it checks the inserted node if it has an attribute `key` set to a value different\n * than `newValue`. If so, it generates an `AttributeOperation` which changes the value of `key` attribute to `newValue`.\n *\n * @private\n * @param {module:engine/model/operation/insertoperation~InsertOperation} insertOperation\n * @param {String} key\n * @param {*} newValue\n * @returns {module:engine/model/operation/attributeoperation~AttributeOperation|null}\n */\nfunction _getComplementaryAttributeOperations( insertOperation, key, newValue ) {\n\tconst nodes = insertOperation.nodes;\n\n\t// At the beginning we store the attribute value from the first node.\n\tconst insertValue = nodes.getNode( 0 ).getAttribute( key );\n\n\tif ( insertValue == newValue ) {\n\t\treturn null;\n\t}\n\n\tconst range = new Range( insertOperation.position, insertOperation.position.getShiftedBy( insertOperation.howMany ) );\n\n\treturn new AttributeOperation( range, key, insertValue, newValue, 0 );\n}\n\nsetTransformation( AttributeOperation, MergeOperation, ( a, b ) => {\n\tconst ranges = [];\n\n\t// Case 1:\n\t//\n\t// Attribute change on the merged element. In this case, the merged element was moved to the graveyard.\n\t// An additional attribute operation that will change the (re)moved element needs to be generated.\n\t//\n\tif ( a.range.start.hasSameParentAs( b.deletionPosition ) ) {\n\t\tif ( a.range.containsPosition( b.deletionPosition ) || a.range.start.isEqual( b.deletionPosition ) ) {\n\t\t\tranges.push( Range._createFromPositionAndShift( b.graveyardPosition, 1 ) );\n\t\t}\n\t}\n\n\tconst range = a.range._getTransformedByMergeOperation( b );\n\n\t// Do not add empty (collapsed) ranges to the result. `range` may be collapsed if it contained only the merged element.\n\tif ( !range.isCollapsed ) {\n\t\tranges.push( range );\n\t}\n\n\t// Create `AttributeOperation`s out of the ranges.\n\treturn ranges.map( range => {\n\t\treturn new AttributeOperation( range, a.key, a.oldValue, a.newValue, a.baseVersion );\n\t} );\n} );\n\nsetTransformation( AttributeOperation, MoveOperation, ( a, b ) => {\n\tconst ranges = _breakRangeByMoveOperation( a.range, b );\n\n\t// Create `AttributeOperation`s out of the ranges.\n\treturn ranges.map( range => new AttributeOperation( range, a.key, a.oldValue, a.newValue, a.baseVersion ) );\n} );\n\n// Helper function for `AttributeOperation` x `MoveOperation` transformation.\n//\n// Takes the passed `range` and transforms it by move operation `moveOp` in a specific way. Only top-level nodes of `range`\n// are considered to be in the range. If move operation moves nodes deep from inside of the range, those nodes won't\n// be included in the result. In other words, top-level nodes of the ranges from the result are exactly the same as\n// top-level nodes of the original `range`.\n//\n// This is important for `AttributeOperation` because, for its range, it changes only the top-level nodes. So we need to\n// track only how those nodes have been affected by `MoveOperation`.\n//\n// @private\n// @param {module:engine/model/range~Range} range\n// @param {module:engine/model/operation/moveoperation~MoveOperation} moveOp\n// @returns {Array.<module:engine/model/range~Range>}\nfunction _breakRangeByMoveOperation( range, moveOp ) {\n\tconst moveRange = Range._createFromPositionAndShift( moveOp.sourcePosition, moveOp.howMany );\n\n\t// We are transforming `range` (original range) by `moveRange` (range moved by move operation). As usual when it comes to\n\t// transforming a ranges, we may have a common part of the ranges and we may have a difference part (zero to two ranges).\n\tlet common = null;\n\tlet difference = [];\n\n\t// Let's compare the ranges.\n\tif ( moveRange.containsRange( range, true ) ) {\n\t\t// If the whole original range is moved, treat it whole as a common part. There's also no difference part.\n\t\tcommon = range;\n\t} else if ( range.start.hasSameParentAs( moveRange.start ) ) {\n\t\t// If the ranges are \"on the same level\" (in the same parent) then move operation may move exactly those nodes\n\t\t// that are changed by the attribute operation. In this case we get common part and difference part in the usual way.\n\t\tdifference = range.getDifference( moveRange );\n\t\tcommon = range.getIntersection( moveRange );\n\t} else {\n\t\t// In any other situation we assume that original range is different than move range, that is that move operation\n\t\t// moves other nodes that attribute operation change. Even if the moved range is deep inside in the original range.\n\t\t//\n\t\t// Note that this is different than in `.getIntersection` (we would get a common part in that case) and different\n\t\t// than `.getDifference` (we would get two ranges).\n\t\tdifference = [ range ];\n\t}\n\n\tconst result = [];\n\n\t// The default behaviour of `_getTransformedByMove` might get wrong results for difference part, though, so\n\t// we do it by hand.\n\tfor ( let diff of difference ) {\n\t\t// First, transform the range by removing moved nodes. Since this is a difference, this is safe, `null` won't be returned\n\t\t// as the range is different than the moved range.\n\t\tdiff = diff._getTransformedByDeletion( moveOp.sourcePosition, moveOp.howMany );\n\n\t\t// Transform also `targetPosition`.\n\t\tconst targetPosition = moveOp.getMovedRangeStart();\n\n\t\t// Spread the range only if moved nodes are inserted only between the top-level nodes of the `diff` range.\n\t\tconst spread = diff.start.hasSameParentAs( targetPosition );\n\n\t\t// Transform by insertion of moved nodes.\n\t\tdiff = diff._getTransformedByInsertion( targetPosition, moveOp.howMany, spread );\n\n\t\tresult.push( ...diff );\n\t}\n\n\t// Common part can be simply transformed by the move operation. This is because move operation will not target to\n\t// that common part (the operation would have to target inside its own moved range).\n\tif ( common ) {\n\t\tresult.push(\n\t\t\tcommon._getTransformedByMove( moveOp.sourcePosition, moveOp.targetPosition, moveOp.howMany, false )[ 0 ]\n\t\t);\n\t}\n\n\treturn result;\n}\n\nsetTransformation( AttributeOperation, SplitOperation, ( a, b ) => {\n\t// Case 1:\n\t//\n\t// Split node is the last node in `AttributeOperation#range`.\n\t// `AttributeOperation#range` needs to be expanded to include the new (split) node.\n\t//\n\t// Attribute `type` to be changed to `numbered` but the `listItem` is split.\n\t// <listItem type=\"bulleted\">foobar</listItem>\n\t//\n\t// After split:\n\t// <listItem type=\"bulleted\">foo</listItem><listItem type=\"bulleted\">bar</listItem>\n\t//\n\t// After attribute change:\n\t// <listItem type=\"numbered\">foo</listItem><listItem type=\"numbered\">foo</listItem>\n\t//\n\tif ( a.range.end.isEqual( b.insertionPosition ) ) {\n\t\tif ( !b.graveyardPosition ) {\n\t\t\ta.range.end.offset++;\n\t\t}\n\n\t\treturn [ a ];\n\t}\n\n\t// Case 2:\n\t//\n\t// Split position is inside `AttributeOperation#range`, at the same level, so the nodes to change are\n\t// not going to make a flat range.\n\t//\n\t// Content with range-to-change and split position:\n\t// <p>Fo[zb^a]r</p>\n\t//\n\t// After split:\n\t// <p>Fozb</p><p>ar</p>\n\t//\n\t// Make two separate ranges containing all nodes to change:\n\t// <p>Fo[zb]</p><p>[a]r</p>\n\t//\n\tif ( a.range.start.hasSameParentAs( b.splitPosition ) && a.range.containsPosition( b.splitPosition ) ) {\n\t\tconst secondPart = a.clone();\n\n\t\tsecondPart.range = new Range(\n\t\t\tb.moveTargetPosition.clone(),\n\t\t\ta.range.end._getCombined( b.splitPosition, b.moveTargetPosition )\n\t\t);\n\n\t\ta.range.end = b.splitPosition.clone();\n\t\ta.range.end.stickiness = 'toPrevious';\n\n\t\treturn [ a, secondPart ];\n\t}\n\n\t// The default case.\n\t//\n\ta.range = a.range._getTransformedBySplitOperation( b );\n\n\treturn [ a ];\n} );\n\nsetTransformation( InsertOperation, AttributeOperation, ( a, b ) => {\n\tconst result = [ a ];\n\n\t// Case 1:\n\t//\n\t// The attribute operation range includes the position where nodes were inserted.\n\t// There are two possible scenarios: the inserted nodes were text and they should receive attributes or\n\t// the inserted nodes were elements and they should not receive attributes.\n\t//\n\t// This is a mirror scenario to the one described in `AttributeOperation` x `InsertOperation` transformation,\n\t// although this case is a little less complicated. In this case we simply need to change attributes of the\n\t// inserted nodes and that's it.\n\t//\n\tif ( a.shouldReceiveAttributes && a.position.hasSameParentAs( b.range.start ) && b.range.containsPosition( a.position ) ) {\n\t\tconst op = _getComplementaryAttributeOperations( a, b.key, b.newValue );\n\n\t\tif ( op ) {\n\t\t\tresult.push( op );\n\t\t}\n\t}\n\n\t// The default case is: do nothing.\n\t// `AttributeOperation` does not change the model tree structure so `InsertOperation` does not need to be changed.\n\t//\n\treturn result;\n} );\n\nsetTransformation( InsertOperation, InsertOperation, ( a, b, context ) => {\n\t// Case 1:\n\t//\n\t// Two insert operations insert nodes at the same position. Since they are the same, it needs to be decided\n\t// what will be the order of inserted nodes. However, there is no additional information to help in that\n\t// decision. Also, when `b` will be transformed by `a`, the same order must be maintained.\n\t//\n\t// To achieve that, we will check if the operation is strong.\n\t// If it is, it won't get transformed. If it is not, it will be moved.\n\t//\n\tif ( a.position.isEqual( b.position ) && context.aIsStrong ) {\n\t\treturn [ a ];\n\t}\n\n\t// The default case.\n\t//\n\ta.position = a.position._getTransformedByInsertOperation( b );\n\n\treturn [ a ];\n} );\n\nsetTransformation( InsertOperation, MoveOperation, ( a, b ) => {\n\t// The default case.\n\t//\n\ta.position = a.position._getTransformedByMoveOperation( b );\n\n\treturn [ a ];\n} );\n\nsetTransformation( InsertOperation, SplitOperation, ( a, b ) => {\n\t// The default case.\n\t//\n\ta.position = a.position._getTransformedBySplitOperation( b );\n\n\treturn [ a ];\n} );\n\nsetTransformation( InsertOperation, MergeOperation, ( a, b ) => {\n\ta.position = a.position._getTransformedByMergeOperation( b );\n\n\treturn [ a ];\n} );\n\n// -----------------------\n\nsetTransformation( MarkerOperation, InsertOperation, ( a, b ) => {\n\tif ( a.oldRange ) {\n\t\ta.oldRange = a.oldRange._getTransformedByInsertOperation( b )[ 0 ];\n\t}\n\n\tif ( a.newRange ) {\n\t\ta.newRange = a.newRange._getTransformedByInsertOperation( b )[ 0 ];\n\t}\n\n\treturn [ a ];\n} );\n\nsetTransformation( MarkerOperation, MarkerOperation, ( a, b, context ) => {\n\tif ( a.name == b.name ) {\n\t\tif ( context.aIsStrong ) {\n\t\t\ta.oldRange = b.newRange ? b.newRange.clone() : null;\n\t\t} else {\n\t\t\treturn [ new NoOperation( 0 ) ];\n\t\t}\n\t}\n\n\treturn [ a ];\n} );\n\nsetTransformation( MarkerOperation, MergeOperation, ( a, b ) => {\n\tif ( a.oldRange ) {\n\t\ta.oldRange = a.oldRange._getTransformedByMergeOperation( b );\n\t}\n\n\tif ( a.newRange ) {\n\t\ta.newRange = a.newRange._getTransformedByMergeOperation( b );\n\t}\n\n\treturn [ a ];\n} );\n\nsetTransformation( MarkerOperation, MoveOperation, ( a, b, context ) => {\n\tif ( a.oldRange ) {\n\t\ta.oldRange = Range._createFromRanges( a.oldRange._getTransformedByMoveOperation( b ) );\n\t}\n\n\tif ( a.newRange ) {\n\t\tif ( context.abRelation ) {\n\t\t\tconst aNewRange = Range._createFromRanges( a.newRange._getTransformedByMoveOperation( b ) );\n\n\t\t\tif ( context.abRelation.side == 'left' && b.targetPosition.isEqual( a.newRange.start ) ) {\n\t\t\t\ta.newRange.start.path = context.abRelation.path;\n\t\t\t\ta.newRange.end = aNewRange.end;\n\n\t\t\t\treturn [ a ];\n\t\t\t} else if ( context.abRelation.side == 'right' && b.targetPosition.isEqual( a.newRange.end ) ) {\n\t\t\t\ta.newRange.start = aNewRange.start;\n\t\t\t\ta.newRange.end.path = context.abRelation.path;\n\n\t\t\t\treturn [ a ];\n\t\t\t}\n\t\t}\n\n\t\ta.newRange = Range._createFromRanges( a.newRange._getTransformedByMoveOperation( b ) );\n\t}\n\n\treturn [ a ];\n} );\n\nsetTransformation( MarkerOperation, SplitOperation, ( a, b, context ) => {\n\tif ( a.oldRange ) {\n\t\ta.oldRange = a.oldRange._getTransformedBySplitOperation( b );\n\t}\n\n\tif ( a.newRange ) {\n\t\tif ( context.abRelation ) {\n\t\t\tconst aNewRange = a.newRange._getTransformedBySplitOperation( b );\n\n\t\t\tif ( a.newRange.start.isEqual( b.splitPosition ) && context.abRelation.wasStartBeforeMergedElement ) {\n\t\t\t\ta.newRange.start = Position._createAt( b.insertionPosition );\n\t\t\t} else if ( a.newRange.start.isEqual( b.splitPosition ) && !context.abRelation.wasInLeftElement ) {\n\t\t\t\ta.newRange.start = Position._createAt( b.moveTargetPosition );\n\t\t\t}\n\n\t\t\tif ( a.newRange.end.isEqual( b.splitPosition ) && context.abRelation.wasInRightElement ) {\n\t\t\t\ta.newRange.end = Position._createAt( b.moveTargetPosition );\n\t\t\t} else if ( a.newRange.end.isEqual( b.splitPosition ) && context.abRelation.wasEndBeforeMergedElement ) {\n\t\t\t\ta.newRange.end = Position._createAt( b.insertionPosition );\n\t\t\t} else {\n\t\t\t\ta.newRange.end = aNewRange.end;\n\t\t\t}\n\n\t\t\treturn [ a ];\n\t\t}\n\n\t\ta.newRange = a.newRange._getTransformedBySplitOperation( b );\n\t}\n\n\treturn [ a ];\n} );\n\n// -----------------------\n\nsetTransformation( MergeOperation, InsertOperation, ( a, b ) => {\n\tif ( a.sourcePosition.hasSameParentAs( b.position ) ) {\n\t\ta.howMany += b.howMany;\n\t}\n\n\ta.sourcePosition = a.sourcePosition._getTransformedByInsertOperation( b );\n\ta.targetPosition = a.targetPosition._getTransformedByInsertOperation( b );\n\n\treturn [ a ];\n} );\n\nsetTransformation( MergeOperation, MergeOperation, ( a, b, context ) => {\n\t// Case 1:\n\t//\n\t// Same merge operations.\n\t//\n\t// Both operations have same source and target positions. So the element already got merged and there is\n\t// theoretically nothing to do.\n\t//\n\tif ( a.sourcePosition.isEqual( b.sourcePosition ) && a.targetPosition.isEqual( b.targetPosition ) ) {\n\t\t// There are two ways that we can provide a do-nothing operation.\n\t\t//\n\t\t// First is simply a NoOperation instance. We will use it if `b` operation was not undone.\n\t\t//\n\t\t// Second is a merge operation that has the source operation in the merged element - in the graveyard -\n\t\t// same target position and `howMany` equal to `0`. So it is basically merging an empty element from graveyard\n\t\t// which is almost the same as NoOperation.\n\t\t//\n\t\t// This way the merge operation can be later transformed by split operation\n\t\t// to provide correct undo. This will be used if `b` operation was undone (only then it is correct).\n\t\t//\n\t\tif ( !context.bWasUndone ) {\n\t\t\treturn [ new NoOperation( 0 ) ];\n\t\t} else {\n\t\t\tconst path = b.graveyardPosition.path.slice();\n\t\t\tpath.push( 0 );\n\n\t\t\ta.sourcePosition = new Position( b.graveyardPosition.root, path );\n\t\t\ta.howMany = 0;\n\n\t\t\treturn [ a ];\n\t\t}\n\t}\n\n\t// Case 2:\n\t//\n\t// Same merge source position but different target position.\n\t//\n\t// This can happen during collaboration. For example, if one client merged a paragraph to the previous paragraph\n\t// and the other person removed that paragraph and merged the same paragraph to something before:\n\t//\n\t// Client A:\n\t// <p>Foo</p><p>Bar</p><p>[]Xyz</p>\n\t// <p>Foo</p><p>BarXyz</p>\n\t//\n\t// Client B:\n\t// <p>Foo</p>[<p>Bar</p>]<p>Xyz</p>\n\t// <p>Foo</p><p>[]Xyz</p>\n\t// <p>FooXyz</p>\n\t//\n\t// In this case we need to decide where finally \"Xyz\" will land:\n\t//\n\t// <p>FooXyz</p>               graveyard: <p>Bar</p>\n\t// <p>Foo</p>                  graveyard: <p>BarXyz</p>\n\t//\n\t// Let's move it in a way so that a merge operation that does not target to graveyard is more important so that\n\t// nodes does not end up in the graveyard. It makes sense. Both for Client A and for Client B \"Xyz\" finally did not\n\t// end up in the graveyard (see above).\n\t//\n\t// If neither or both operations point to graveyard, then let `aIsStrong` decide.\n\t//\n\tif (\n\t\ta.sourcePosition.isEqual( b.sourcePosition ) && !a.targetPosition.isEqual( b.targetPosition ) &&\n\t\t!context.bWasUndone && context.abRelation != 'splitAtSource'\n\t) {\n\t\tconst aToGraveyard = a.targetPosition.root.rootName == '$graveyard';\n\t\tconst bToGraveyard = b.targetPosition.root.rootName == '$graveyard';\n\n\t\t// If `aIsWeak` it means that `a` points to graveyard while `b` doesn't. Don't move nodes then.\n\t\tconst aIsWeak = aToGraveyard && !bToGraveyard;\n\n\t\t// If `bIsWeak` it means that `b` points to graveyard while `a` doesn't. Force moving nodes then.\n\t\tconst bIsWeak = bToGraveyard && !aToGraveyard;\n\n\t\t// Force move if `b` is weak or neither operation is weak but `a` is stronger through `context.aIsStrong`.\n\t\tconst forceMove = bIsWeak || ( !aIsWeak && context.aIsStrong );\n\n\t\tif ( forceMove ) {\n\t\t\tconst sourcePosition = b.targetPosition._getTransformedByMergeOperation( b );\n\t\t\tconst targetPosition = a.targetPosition._getTransformedByMergeOperation( b );\n\n\t\t\treturn [ new MoveOperation( sourcePosition, a.howMany, targetPosition, 0 ) ];\n\t\t} else {\n\t\t\treturn [ new NoOperation( 0 ) ];\n\t\t}\n\t}\n\n\t// The default case.\n\t//\n\tif ( a.sourcePosition.hasSameParentAs( b.targetPosition ) ) {\n\t\ta.howMany += b.howMany;\n\t}\n\n\ta.sourcePosition = a.sourcePosition._getTransformedByMergeOperation( b );\n\ta.targetPosition = a.targetPosition._getTransformedByMergeOperation( b );\n\n\t// Handle positions in graveyard.\n\t// If graveyard positions are same and `a` operation is strong - do not transform.\n\tif ( !a.graveyardPosition.isEqual( b.graveyardPosition ) || !context.aIsStrong ) {\n\t\ta.graveyardPosition = a.graveyardPosition._getTransformedByMergeOperation( b );\n\t}\n\n\treturn [ a ];\n} );\n\nsetTransformation( MergeOperation, MoveOperation, ( a, b, context ) => {\n\t// Case 1:\n\t//\n\t// The element to merge got removed.\n\t//\n\t// Merge operation does support merging elements which are not siblings. So it would not be a problem\n\t// from technical point of view. However, if the element was removed, the intention of the user deleting it\n\t// was to have it all deleted, together with its children. From user experience point of view, moving back the\n\t// removed nodes might be unexpected. This means that in this scenario we will block the merging.\n\t//\n\t// The exception of this rule would be if the remove operation was later undone.\n\t//\n\tconst removedRange = Range._createFromPositionAndShift( b.sourcePosition, b.howMany );\n\n\tif ( b.type == 'remove' && !context.bWasUndone && !context.forceWeakRemove ) {\n\t\tif ( a.deletionPosition.hasSameParentAs( b.sourcePosition ) && removedRange.containsPosition( a.sourcePosition ) ) {\n\t\t\treturn [ new NoOperation( 0 ) ];\n\t\t}\n\t}\n\n\t// The default case.\n\t//\n\tif ( a.sourcePosition.hasSameParentAs( b.targetPosition ) ) {\n\t\ta.howMany += b.howMany;\n\t}\n\n\tif ( a.sourcePosition.hasSameParentAs( b.sourcePosition ) ) {\n\t\ta.howMany -= b.howMany;\n\t}\n\n\ta.sourcePosition = a.sourcePosition._getTransformedByMoveOperation( b );\n\ta.targetPosition = a.targetPosition._getTransformedByMoveOperation( b );\n\n\t// `MergeOperation` graveyard position is like `MoveOperation` target position. It is a position where element(s) will\n\t// be moved. Like in other similar cases, we need to consider the scenario when those positions are same.\n\t// Here, we will treat `MergeOperation` like it is always strong (see `InsertOperation` x `InsertOperation` for comparison).\n\t// This means that we won't transform graveyard position if it is equal to move operation target position.\n\tif ( !a.graveyardPosition.isEqual( b.targetPosition ) ) {\n\t\ta.graveyardPosition = a.graveyardPosition._getTransformedByMoveOperation( b );\n\t}\n\n\treturn [ a ];\n} );\n\nsetTransformation( MergeOperation, SplitOperation, ( a, b, context ) => {\n\tif ( b.graveyardPosition ) {\n\t\t// If `b` operation defines graveyard position, a node from graveyard will be moved. This means that we need to\n\t\t// transform `a.graveyardPosition` accordingly.\n\t\ta.graveyardPosition = a.graveyardPosition._getTransformedByDeletion( b.graveyardPosition, 1 );\n\n\t\t// This is a scenario foreseen in `MergeOperation` x `MergeOperation`, with two identical merge operations.\n\t\t//\n\t\t// So, there was `MergeOperation` x `MergeOperation` transformation earlier. Now, `a` is a merge operation which\n\t\t// source position is in graveyard. Interestingly, split operation wants to use the node to be merged by `a`. This\n\t\t// means that `b` is undoing that merge operation from earlier, which caused `a` to be in graveyard.\n\t\t//\n\t\t// If that's the case, at this point, we will only \"fix\" `a.howMany`. It was earlier set to `0` in\n\t\t// `MergeOperation` x `MergeOperation` transformation. Later transformations in this function will change other\n\t\t// properties.\n\t\t//\n\t\tif ( a.deletionPosition.isEqual( b.graveyardPosition ) ) {\n\t\t\ta.howMany = b.howMany;\n\t\t}\n\t}\n\n\t// Case 1:\n\t//\n\t// Merge operation moves nodes to the place where split happens.\n\t// This is a classic situation when there are two paragraphs, and there is a split (enter) after the first\n\t// paragraph and there is a merge (delete) at the beginning of the second paragraph:\n\t//\n\t// <p>Foo{}</p><p>[]Bar</p>.\n\t//\n\t// Split is after `Foo`, while merge is from `Bar` to the end of `Foo`.\n\t//\n\t// State after split:\n\t// <p>Foo</p><p></p><p>Bar</p>\n\t//\n\t// Now, `Bar` should be merged to the new paragraph:\n\t// <p>Foo</p><p>Bar</p>\n\t//\n\t// Instead of merging it to the original paragraph:\n\t// <p>FooBar</p><p></p>\n\t//\n\t// This means that `targetPosition` needs to be transformed. This is the default case though.\n\t// For example, if the split would be after `F`, `targetPosition` should also be transformed.\n\t//\n\t// There are three exceptions, though, when we want to keep `targetPosition` as it was.\n\t//\n\t// First exception is when the merge target position is inside an element (not at the end, as usual). This\n\t// happens when the merge operation earlier was transformed by \"the same\" merge operation. If merge operation\n\t// targets inside the element we want to keep the original target position (and not transform it) because\n\t// we have additional context telling us that we want to merge to the original element. We can check if the\n\t// merge operation points inside element by checking what is `SplitOperation#howMany`. Since merge target position\n\t// is same as split position, if `howMany` is non-zero, it means that the merge target position is inside an element.\n\t//\n\t// Second exception is when the element to merge is in the graveyard and split operation uses it. In that case\n\t// if target position would be transformed, the merge operation would target at the source position:\n\t//\n\t// root: <p>Foo</p>\t\t\t\tgraveyard: <p></p>\n\t//\n\t// SplitOperation: root [ 0, 3 ] using graveyard [ 0 ] (howMany = 0)\n\t// MergeOperation: graveyard [ 0, 0 ] -> root [ 0, 3 ] (howMany = 0)\n\t//\n\t// Since split operation moves the graveyard node back to the root, the merge operation source position changes.\n\t// We would like to merge from the empty <p> to the \"Foo\" <p>:\n\t//\n\t// root: <p>Foo</p><p></p>\t\t\tgraveyard:\n\t//\n\t// MergeOperation#sourcePosition = root [ 1, 0 ]\n\t//\n\t// If `targetPosition` is transformed, it would become root [ 1, 0 ] as well. It has to be kept as it was.\n\t//\n\t// Third exception is connected with relations. If this happens during undo and we have explicit information\n\t// that target position has not been affected by the operation which is undone by this split then this split should\n\t// not move the target position either.\n\t//\n\tif ( a.targetPosition.isEqual( b.splitPosition ) ) {\n\t\tconst mergeInside = b.howMany != 0;\n\t\tconst mergeSplittingElement = b.graveyardPosition && a.deletionPosition.isEqual( b.graveyardPosition );\n\n\t\tif ( mergeInside || mergeSplittingElement || context.abRelation == 'mergeTargetNotMoved' ) {\n\t\t\ta.sourcePosition = a.sourcePosition._getTransformedBySplitOperation( b );\n\n\t\t\treturn [ a ];\n\t\t}\n\t}\n\n\t// Case 2:\n\t//\n\t// Merge source is at the same position as split position. This sometimes happen, mostly during undo.\n\t// The decision here is mostly to choose whether merge source position should stay where it is (so it will be at the end of the\n\t// split element) or should be move to the beginning of the new element.\n\t//\n\tif ( a.sourcePosition.isEqual( b.splitPosition ) ) {\n\t\t// Use context to check if `SplitOperation` is not undoing a merge operation, that didn't change the `a` operation.\n\t\t// This scenario happens the undone merge operation moved nodes at the source position of `a` operation.\n\t\t// In that case `a` operation source position should stay where it is.\n\t\tif ( context.abRelation == 'mergeSourceNotMoved' ) {\n\t\t\ta.howMany = 0;\n\t\t\ta.targetPosition = a.targetPosition._getTransformedBySplitOperation( b );\n\n\t\t\treturn [ a ];\n\t\t}\n\n\t\t// This merge operation might have been earlier transformed by a merge operation which both merged the same element.\n\t\t// See that case in `MergeOperation` x `MergeOperation` transformation. In that scenario, if the merge operation has been undone,\n\t\t// the special case is not applied.\n\t\t//\n\t\t// Now, the merge operation is transformed by the split which has undone that previous merge operation.\n\t\t// So now we are fixing situation which was skipped in `MergeOperation` x `MergeOperation` case.\n\t\t//\n\t\tif ( context.abRelation == 'mergeSameElement' || a.sourcePosition.offset > 0 ) {\n\t\t\ta.sourcePosition = b.moveTargetPosition.clone();\n\t\t\ta.targetPosition = a.targetPosition._getTransformedBySplitOperation( b );\n\n\t\t\treturn [ a ];\n\t\t}\n\t}\n\n\t// The default case.\n\t//\n\tif ( a.sourcePosition.hasSameParentAs( b.splitPosition ) ) {\n\t\ta.howMany = b.splitPosition.offset;\n\t}\n\n\ta.sourcePosition = a.sourcePosition._getTransformedBySplitOperation( b );\n\ta.targetPosition = a.targetPosition._getTransformedBySplitOperation( b );\n\n\treturn [ a ];\n} );\n\n// -----------------------\n\nsetTransformation( MoveOperation, InsertOperation, ( a, b ) => {\n\tconst moveRange = Range._createFromPositionAndShift( a.sourcePosition, a.howMany );\n\tconst transformed = moveRange._getTransformedByInsertOperation( b, false )[ 0 ];\n\n\ta.sourcePosition = transformed.start;\n\ta.howMany = transformed.end.offset - transformed.start.offset;\n\n\t// See `InsertOperation` x `MoveOperation` transformation for details on this case.\n\t//\n\t// In summary, both operations point to the same place, so the order of nodes needs to be decided.\n\t// `MoveOperation` is considered weaker, so it is always transformed, unless there was a certain relation\n\t// between operations.\n\t//\n\tif ( !a.targetPosition.isEqual( b.position ) ) {\n\t\ta.targetPosition = a.targetPosition._getTransformedByInsertOperation( b );\n\t}\n\n\treturn [ a ];\n} );\n\nsetTransformation( MoveOperation, MoveOperation, ( a, b, context ) => {\n\t//\n\t// Setting and evaluating some variables that will be used in special cases and default algorithm.\n\t//\n\t// Create ranges from `MoveOperations` properties.\n\tconst rangeA = Range._createFromPositionAndShift( a.sourcePosition, a.howMany );\n\tconst rangeB = Range._createFromPositionAndShift( b.sourcePosition, b.howMany );\n\n\t// Assign `context.aIsStrong` to a different variable, because the value may change during execution of\n\t// this algorithm and we do not want to override original `context.aIsStrong` that will be used in later transformations.\n\tlet aIsStrong = context.aIsStrong;\n\n\t// This will be used to decide the order of nodes if both operations target at the same position.\n\t// By default, use strong/weak operation mechanism.\n\tlet insertBefore = !context.aIsStrong;\n\n\t// If the relation is set, then use it to decide nodes order.\n\tif ( context.abRelation == 'insertBefore' || context.baRelation == 'insertAfter' ) {\n\t\tinsertBefore = true;\n\t} else if ( context.abRelation == 'insertAfter' || context.baRelation == 'insertBefore' ) {\n\t\tinsertBefore = false;\n\t}\n\n\t// `a.targetPosition` could be affected by the `b` operation. We will transform it.\n\tlet newTargetPosition;\n\n\tif ( a.targetPosition.isEqual( b.targetPosition ) && insertBefore ) {\n\t\tnewTargetPosition = a.targetPosition._getTransformedByDeletion(\n\t\t\tb.sourcePosition,\n\t\t\tb.howMany\n\t\t);\n\t} else {\n\t\tnewTargetPosition = a.targetPosition._getTransformedByMove(\n\t\t\tb.sourcePosition,\n\t\t\tb.targetPosition,\n\t\t\tb.howMany\n\t\t);\n\t}\n\n\t//\n\t// Special case #1 + mirror.\n\t//\n\t// Special case when both move operations' target positions are inside nodes that are\n\t// being moved by the other move operation. So in other words, we move ranges into inside of each other.\n\t// This case can't be solved reasonably (on the other hand, it should not happen often).\n\tif ( _moveTargetIntoMovedRange( a, b ) && _moveTargetIntoMovedRange( b, a ) ) {\n\t\t// Instead of transforming operation, we return a reverse of the operation that we transform by.\n\t\t// So when the results of this \"transformation\" will be applied, `b` MoveOperation will get reversed.\n\t\treturn [ b.getReversed() ];\n\t}\n\t//\n\t// End of special case #1.\n\t//\n\n\t//\n\t// Special case #2.\n\t//\n\t// Check if `b` operation targets inside `rangeA`.\n\tconst bTargetsToA = rangeA.containsPosition( b.targetPosition );\n\n\t// If `b` targets to `rangeA` and `rangeA` contains `rangeB`, `b` operation has no influence on `a` operation.\n\t// You might say that operation `b` is captured inside operation `a`.\n\tif ( bTargetsToA && rangeA.containsRange( rangeB, true ) ) {\n\t\t// There is a mini-special case here, where `rangeB` is on other level than `rangeA`. That's why\n\t\t// we need to transform `a` operation anyway.\n\t\trangeA.start = rangeA.start._getTransformedByMove( b.sourcePosition, b.targetPosition, b.howMany );\n\t\trangeA.end = rangeA.end._getTransformedByMove( b.sourcePosition, b.targetPosition, b.howMany );\n\n\t\treturn _makeMoveOperationsFromRanges( [ rangeA ], newTargetPosition );\n\t}\n\n\t//\n\t// Special case #2 mirror.\n\t//\n\tconst aTargetsToB = rangeB.containsPosition( a.targetPosition );\n\n\tif ( aTargetsToB && rangeB.containsRange( rangeA, true ) ) {\n\t\t// `a` operation is \"moved together\" with `b` operation.\n\t\t// Here, just move `rangeA` \"inside\" `rangeB`.\n\t\trangeA.start = rangeA.start._getCombined( b.sourcePosition, b.getMovedRangeStart() );\n\t\trangeA.end = rangeA.end._getCombined( b.sourcePosition, b.getMovedRangeStart() );\n\n\t\treturn _makeMoveOperationsFromRanges( [ rangeA ], newTargetPosition );\n\t}\n\t//\n\t// End of special case #2.\n\t//\n\n\t//\n\t// Special case #3 + mirror.\n\t//\n\t// `rangeA` has a node which is an ancestor of `rangeB`. In other words, `rangeB` is inside `rangeA`\n\t// but not on the same tree level. In such case ranges have common part but we have to treat it\n\t// differently, because in such case those ranges are not really conflicting and should be treated like\n\t// two separate ranges. Also we have to discard two difference parts.\n\tconst aCompB = compareArrays( a.sourcePosition.getParentPath(), b.sourcePosition.getParentPath() );\n\n\tif ( aCompB == 'prefix' || aCompB == 'extension' ) {\n\t\t// Transform `rangeA` by `b` operation and make operation out of it, and that's all.\n\t\t// Note that this is a simplified version of default case, but here we treat the common part (whole `rangeA`)\n\t\t// like a one difference part.\n\t\trangeA.start = rangeA.start._getTransformedByMove( b.sourcePosition, b.targetPosition, b.howMany );\n\t\trangeA.end = rangeA.end._getTransformedByMove( b.sourcePosition, b.targetPosition, b.howMany );\n\n\t\treturn _makeMoveOperationsFromRanges( [ rangeA ], newTargetPosition );\n\t}\n\t//\n\t// End of special case #3.\n\t//\n\n\t//\n\t// Default case - ranges are on the same level or are not connected with each other.\n\t//\n\t// Modifier for default case.\n\t// Modifies `aIsStrong` flag in certain conditions.\n\t//\n\t// If only one of operations is a remove operation, we force remove operation to be the \"stronger\" one\n\t// to provide more expected results.\n\tif ( a.type == 'remove' && b.type != 'remove' && !context.aWasUndone && !context.forceWeakRemove ) {\n\t\taIsStrong = true;\n\t} else if ( a.type != 'remove' && b.type == 'remove' && !context.bWasUndone && !context.forceWeakRemove ) {\n\t\taIsStrong = false;\n\t}\n\n\t// Handle operation's source ranges - check how `rangeA` is affected by `b` operation.\n\t// This will aggregate transformed ranges.\n\tconst ranges = [];\n\n\t// Get the \"difference part\" of `a` operation source range.\n\t// This is an array with one or two ranges. Two ranges if `rangeB` is inside `rangeA`.\n\tconst difference = rangeA.getDifference( rangeB );\n\n\tfor ( const range of difference ) {\n\t\t// Transform those ranges by `b` operation. For example if `b` moved range from before those ranges, fix those ranges.\n\t\trange.start = range.start._getTransformedByDeletion( b.sourcePosition, b.howMany );\n\t\trange.end = range.end._getTransformedByDeletion( b.sourcePosition, b.howMany );\n\n\t\t// If `b` operation targets into `rangeA` on the same level, spread `rangeA` into two ranges.\n\t\tconst shouldSpread = compareArrays( range.start.getParentPath(), b.getMovedRangeStart().getParentPath() ) == 'same';\n\t\tconst newRanges = range._getTransformedByInsertion( b.getMovedRangeStart(), b.howMany, shouldSpread );\n\n\t\tranges.push( ...newRanges );\n\t}\n\n\t// Then, we have to manage the \"common part\" of both move ranges.\n\tconst common = rangeA.getIntersection( rangeB );\n\n\tif ( common !== null && aIsStrong ) {\n\t\t// Calculate the new position of that part of original range.\n\t\tcommon.start = common.start._getCombined( b.sourcePosition, b.getMovedRangeStart() );\n\t\tcommon.end = common.end._getCombined( b.sourcePosition, b.getMovedRangeStart() );\n\n\t\t// Take care of proper range order.\n\t\t//\n\t\t// Put `common` at appropriate place. Keep in mind that we are interested in original order.\n\t\t// Basically there are only three cases: there is zero, one or two difference ranges.\n\t\t//\n\t\t// If there is zero difference ranges, just push `common` in the array.\n\t\tif ( ranges.length === 0 ) {\n\t\t\tranges.push( common );\n\t\t}\n\t\t// If there is one difference range, we need to check whether common part was before it or after it.\n\t\telse if ( ranges.length == 1 ) {\n\t\t\tif ( rangeB.start.isBefore( rangeA.start ) || rangeB.start.isEqual( rangeA.start ) ) {\n\t\t\t\tranges.unshift( common );\n\t\t\t} else {\n\t\t\t\tranges.push( common );\n\t\t\t}\n\t\t}\n\t\t// If there are more ranges (which means two), put common part between them. This is the only scenario\n\t\t// where there could be two difference ranges so we don't have to make any comparisons.\n\t\telse {\n\t\t\tranges.splice( 1, 0, common );\n\t\t}\n\t}\n\n\tif ( ranges.length === 0 ) {\n\t\t// If there are no \"source ranges\", nothing should be changed.\n\t\t// Note that this can happen only if `aIsStrong == false` and `rangeA.isEqual( rangeB )`.\n\t\treturn [ new NoOperation( a.baseVersion ) ];\n\t}\n\n\treturn _makeMoveOperationsFromRanges( ranges, newTargetPosition );\n} );\n\nsetTransformation( MoveOperation, SplitOperation, ( a, b, context ) => {\n\tlet newTargetPosition = a.targetPosition.clone();\n\n\t// Do not transform if target position is same as split insertion position and this split comes from undo.\n\t// This should be done on relations but it is too much work for now as it would require relations working in collaboration.\n\t// We need to make a decision how we will resolve such conflict and this is less harmful way.\n\tif ( !a.targetPosition.isEqual( b.insertionPosition ) || !b.graveyardPosition || context.abRelation == 'moveTargetAfter' ) {\n\t\tnewTargetPosition = a.targetPosition._getTransformedBySplitOperation( b );\n\t}\n\n\t// Case 1:\n\t//\n\t// Last element in the moved range got split.\n\t//\n\t// In this case the default range transformation will not work correctly as the element created by\n\t// split operation would be outside the range. The range to move needs to be fixed manually.\n\t//\n\tconst moveRange = Range._createFromPositionAndShift( a.sourcePosition, a.howMany );\n\n\tif ( moveRange.end.isEqual( b.insertionPosition ) ) {\n\t\t// Do it only if this is a \"natural\" split, not a one that comes from undo.\n\t\t// If this is undo split, only `targetPosition` needs to be changed (if the move is a remove).\n\t\tif ( !b.graveyardPosition ) {\n\t\t\ta.howMany++;\n\t\t}\n\n\t\ta.targetPosition = newTargetPosition;\n\n\t\treturn [ a ];\n\t}\n\n\t// Case 2:\n\t//\n\t// Split happened between the moved nodes. In this case two ranges to move need to be generated.\n\t//\n\t// Characters `ozba` are moved to the end of paragraph `Xyz` but split happened.\n\t// <p>F[oz|ba]r</p><p>Xyz</p>\n\t//\n\t// After split:\n\t// <p>F[oz</p><p>ba]r</p><p>Xyz</p>\n\t//\n\t// Correct ranges:\n\t// <p>F[oz]</p><p>[ba]r</p><p>Xyz</p>\n\t//\n\t// After move:\n\t// <p>F</p><p>r</p><p>Xyzozba</p>\n\t//\n\tif ( moveRange.start.hasSameParentAs( b.splitPosition ) && moveRange.containsPosition( b.splitPosition ) ) {\n\t\tlet rightRange = new Range( b.splitPosition, moveRange.end );\n\t\trightRange = rightRange._getTransformedBySplitOperation( b );\n\n\t\tconst ranges = [\n\t\t\tnew Range( moveRange.start, b.splitPosition ),\n\t\t\trightRange\n\t\t];\n\n\t\treturn _makeMoveOperationsFromRanges( ranges, newTargetPosition );\n\t}\n\n\t// Case 3:\n\t//\n\t// Move operation targets at the split position. We need to decide if the nodes should be inserted\n\t// at the end of the split element or at the beginning of the new element.\n\t//\n\tif ( a.targetPosition.isEqual( b.splitPosition ) && context.abRelation == 'insertAtSource' ) {\n\t\tnewTargetPosition = b.moveTargetPosition;\n\t}\n\n\t// Case 4:\n\t//\n\t// Move operation targets just after the split element. We need to decide if the nodes should be inserted\n\t// between two parts of split element, or after the new element.\n\t//\n\t// Split at `|`, while move operation moves `<p>Xyz</p>` and targets at `^`:\n\t// <p>Foo|bar</p>^<p>baz</p>\n\t// <p>Foo</p>^<p>bar</p><p>baz</p> or <p>Foo</p><p>bar</p>^<p>baz</p>?\n\t//\n\t// If there is no contextual information between operations (for example, they come from collaborative\n\t// editing), we don't want to put some unrelated content (move) between parts of related content (split parts).\n\t// However, if the split is from undo, in the past, the moved content might be targeting between the\n\t// split parts, meaning that was exactly user's intention:\n\t//\n\t// <p>Foo</p>^<p>bar</p>\t\t<--- original situation, in \"past\".\n\t// <p>Foobar</p>^\t\t\t\t<--- after merge target position is transformed.\n\t// <p>Foo|bar</p>^\t\t\t\t<--- then the merge is undone, and split happens, which leads us to current situation.\n\t//\n\t// In this case it is pretty clear that the intention was to put new paragraph between those nodes,\n\t// so we need to transform accordingly. We can detect this scenario thanks to relations.\n\t//\n\tif ( a.targetPosition.isEqual( b.insertionPosition ) && context.abRelation == 'insertBetween' ) {\n\t\tnewTargetPosition = a.targetPosition;\n\t}\n\n\t// The default case.\n\t//\n\tconst transformed = moveRange._getTransformedBySplitOperation( b );\n\tconst ranges = [ transformed ];\n\n\t// Case 5:\n\t//\n\t// Moved range contains graveyard element used by split operation. Add extra move operation to the result.\n\t//\n\tif ( b.graveyardPosition ) {\n\t\tconst movesGraveyardElement = moveRange.start.isEqual( b.graveyardPosition ) || moveRange.containsPosition( b.graveyardPosition );\n\n\t\tif ( a.howMany > 1 && movesGraveyardElement && !context.aWasUndone ) {\n\t\t\tranges.push( Range._createFromPositionAndShift( b.insertionPosition, 1 ) );\n\t\t}\n\t}\n\n\treturn _makeMoveOperationsFromRanges( ranges, newTargetPosition );\n} );\n\nsetTransformation( MoveOperation, MergeOperation, ( a, b, context ) => {\n\tconst movedRange = Range._createFromPositionAndShift( a.sourcePosition, a.howMany );\n\n\tif ( b.deletionPosition.hasSameParentAs( a.sourcePosition ) && movedRange.containsPosition( b.sourcePosition ) ) {\n\t\tif ( a.type == 'remove' && !context.forceWeakRemove ) {\n\t\t\t// Case 1:\n\t\t\t//\n\t\t\t// The element to remove got merged.\n\t\t\t//\n\t\t\t// Merge operation does support merging elements which are not siblings. So it would not be a problem\n\t\t\t// from technical point of view. However, if the element was removed, the intention of the user\n\t\t\t// deleting it was to have it all deleted. From user experience point of view, moving back the\n\t\t\t// removed nodes might be unexpected. This means that in this scenario we will reverse merging and remove the element.\n\t\t\t//\n\t\t\tif ( !context.aWasUndone ) {\n\t\t\t\tconst results = [];\n\n\t\t\t\tlet gyMoveSource = b.graveyardPosition.clone();\n\t\t\t\tlet splitNodesMoveSource = b.targetPosition._getTransformedByMergeOperation( b );\n\n\t\t\t\tif ( a.howMany > 1 ) {\n\t\t\t\t\tresults.push( new MoveOperation( a.sourcePosition, a.howMany - 1, a.targetPosition, 0 ) );\n\n\t\t\t\t\tgyMoveSource = gyMoveSource._getTransformedByMove( a.sourcePosition, a.targetPosition, a.howMany - 1 );\n\t\t\t\t\tsplitNodesMoveSource = splitNodesMoveSource._getTransformedByMove( a.sourcePosition, a.targetPosition, a.howMany - 1 );\n\t\t\t\t}\n\n\t\t\t\tconst gyMoveTarget = b.deletionPosition._getCombined( a.sourcePosition, a.targetPosition );\n\t\t\t\tconst gyMove = new MoveOperation( gyMoveSource, 1, gyMoveTarget, 0 );\n\n\t\t\t\tconst splitNodesMoveTargetPath = gyMove.getMovedRangeStart().path.slice();\n\t\t\t\tsplitNodesMoveTargetPath.push( 0 );\n\n\t\t\t\tconst splitNodesMoveTarget = new Position( gyMove.targetPosition.root, splitNodesMoveTargetPath );\n\t\t\t\tsplitNodesMoveSource = splitNodesMoveSource._getTransformedByMove( gyMoveSource, gyMoveTarget, 1 );\n\t\t\t\tconst splitNodesMove = new MoveOperation( splitNodesMoveSource, b.howMany, splitNodesMoveTarget, 0 );\n\n\t\t\t\tresults.push( gyMove );\n\t\t\t\tresults.push( splitNodesMove );\n\n\t\t\t\treturn results;\n\t\t\t}\n\t\t} else {\n\t\t\t// Case 2:\n\t\t\t//\n\t\t\t// The element to move got merged and it was the only element to move.\n\t\t\t// In this case just don't do anything, leave the node in the graveyard. Without special case\n\t\t\t// it would be a move operation that moves 0 nodes, so maybe it is better just to return no-op.\n\t\t\t//\n\t\t\tif ( a.howMany == 1 ) {\n\t\t\t\tif ( !context.bWasUndone ) {\n\t\t\t\t\treturn [ new NoOperation( 0 ) ];\n\t\t\t\t} else {\n\t\t\t\t\ta.sourcePosition = b.graveyardPosition.clone();\n\t\t\t\t\ta.targetPosition = a.targetPosition._getTransformedByMergeOperation( b );\n\n\t\t\t\t\treturn [ a ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// The default case.\n\t//\n\tconst moveRange = Range._createFromPositionAndShift( a.sourcePosition, a.howMany );\n\tconst transformed = moveRange._getTransformedByMergeOperation( b );\n\n\ta.sourcePosition = transformed.start;\n\ta.howMany = transformed.end.offset - transformed.start.offset;\n\ta.targetPosition = a.targetPosition._getTransformedByMergeOperation( b );\n\n\treturn [ a ];\n} );\n\n// -----------------------\n\nsetTransformation( RenameOperation, InsertOperation, ( a, b ) => {\n\ta.position = a.position._getTransformedByInsertOperation( b );\n\n\treturn [ a ];\n} );\n\nsetTransformation( RenameOperation, MergeOperation, ( a, b ) => {\n\t// Case 1:\n\t//\n\t// Element to rename got merged, so it was moved to `b.graveyardPosition`.\n\t//\n\tif ( a.position.isEqual( b.deletionPosition ) ) {\n\t\ta.position = b.graveyardPosition.clone();\n\t\ta.position.stickiness = 'toNext';\n\n\t\treturn [ a ];\n\t}\n\n\ta.position = a.position._getTransformedByMergeOperation( b );\n\n\treturn [ a ];\n} );\n\nsetTransformation( RenameOperation, MoveOperation, ( a, b ) => {\n\ta.position = a.position._getTransformedByMoveOperation( b );\n\n\treturn [ a ];\n} );\n\nsetTransformation( RenameOperation, RenameOperation, ( a, b, context ) => {\n\tif ( a.position.isEqual( b.position ) ) {\n\t\tif ( context.aIsStrong ) {\n\t\t\ta.oldName = b.newName;\n\t\t} else {\n\t\t\treturn [ new NoOperation( 0 ) ];\n\t\t}\n\t}\n\n\treturn [ a ];\n} );\n\nsetTransformation( RenameOperation, SplitOperation, ( a, b ) => {\n\t// Case 1:\n\t//\n\t// The element to rename has been split. In this case, the new element should be also renamed.\n\t//\n\t// User decides to change the paragraph to a list item:\n\t// <paragraph>Foobar</paragraph>\n\t//\n\t// However, in meantime, split happens:\n\t// <paragraph>Foo</paragraph><paragraph>bar</paragraph>\n\t//\n\t// As a result, rename both elements:\n\t// <listItem>Foo</listItem><listItem>bar</listItem>\n\t//\n\tconst renamePath = a.position.path;\n\tconst splitPath = b.splitPosition.getParentPath();\n\n\tif ( compareArrays( renamePath, splitPath ) == 'same' && !b.graveyardPosition ) {\n\t\tconst extraRename = new RenameOperation( a.position.getShiftedBy( 1 ), a.oldName, a.newName, 0 );\n\n\t\treturn [ a, extraRename ];\n\t}\n\n\t// The default case.\n\t//\n\ta.position = a.position._getTransformedBySplitOperation( b );\n\n\treturn [ a ];\n} );\n\n// -----------------------\n\nsetTransformation( RootAttributeOperation, RootAttributeOperation, ( a, b, context ) => {\n\tif ( a.root === b.root && a.key === b.key ) {\n\t\tif ( !context.aIsStrong || a.newValue === b.newValue ) {\n\t\t\treturn [ new NoOperation( 0 ) ];\n\t\t} else {\n\t\t\ta.oldValue = b.newValue;\n\t\t}\n\t}\n\n\treturn [ a ];\n} );\n\n// -----------------------\n\nsetTransformation( SplitOperation, InsertOperation, ( a, b ) => {\n\t// The default case.\n\t//\n\tif ( a.splitPosition.hasSameParentAs( b.position ) && a.splitPosition.offset < b.position.offset ) {\n\t\ta.howMany += b.howMany;\n\t}\n\n\ta.splitPosition = a.splitPosition._getTransformedByInsertOperation( b );\n\ta.insertionPosition = SplitOperation.getInsertionPosition( a.splitPosition );\n\n\treturn [ a ];\n} );\n\nsetTransformation( SplitOperation, MergeOperation, ( a, b, context ) => {\n\t// Case 1:\n\t//\n\t// Split element got merged. If two different elements were merged, clients will have different content.\n\t//\n\t// Example. Merge at `{}`, split at `[]`:\n\t// <heading>Foo</heading>{}<paragraph>B[]ar</paragraph>\n\t//\n\t// On merge side it will look like this:\n\t// <heading>FooB[]ar</heading>\n\t// <heading>FooB</heading><heading>ar</heading>\n\t//\n\t// On split side it will look like this:\n\t// <heading>Foo</heading>{}<paragraph>B</paragraph><paragraph>ar</paragraph>\n\t// <heading>FooB</heading><paragraph>ar</paragraph>\n\t//\n\t// Clearly, the second element is different for both clients.\n\t//\n\t// We could use the removed merge element from graveyard as a split element but then clients would have a different\n\t// model state (in graveyard), because the split side client would still have an element in graveyard (removed by merge).\n\t//\n\t// To overcome this, in `SplitOperation` x `MergeOperation` transformation we will add additional `SplitOperation`\n\t// in the graveyard, which will actually clone the merged-and-deleted element. Then, that cloned element will be\n\t// used for splitting. Example below.\n\t//\n\t// Original state:\n\t// <heading>Foo</heading>{}<paragraph>B[]ar</paragraph>\n\t//\n\t// Merge side client:\n\t//\n\t// After merge:\n\t// <heading>FooB[]ar</heading>                                 graveyard: <paragraph></paragraph>\n\t//\n\t// Extra split:\n\t// <heading>FooB[]ar</heading>                                 graveyard: <paragraph></paragraph><paragraph></paragraph>\n\t//\n\t// Use the \"cloned\" element from graveyard:\n\t// <heading>FooB</heading><paragraph>ar</paragraph>            graveyard: <paragraph></paragraph>\n\t//\n\t// Split side client:\n\t//\n\t// After split:\n\t// <heading>Foo</heading>{}<paragraph>B</paragraph><paragraph>ar</paragraph>\n\t//\n\t// After merge:\n\t// <heading>FooB</heading><paragraph>ar</paragraph>            graveyard: <paragraph></paragraph>\n\t//\n\t// This special case scenario only applies if the original split operation clones the split element.\n\t// If the original split operation has `graveyardPosition` set, it all doesn't have sense because split operation\n\t// knows exactly which element it should use. So there would be no original problem with different contents.\n\t//\n\t// Additionally, the special case applies only if the merge wasn't already undone.\n\t//\n\tif ( !a.graveyardPosition && !context.bWasUndone && a.splitPosition.hasSameParentAs( b.sourcePosition ) ) {\n\t\tconst splitPath = b.graveyardPosition.path.slice();\n\t\tsplitPath.push( 0 );\n\n\t\tconst splitPosition = new Position( b.graveyardPosition.root, splitPath );\n\t\tconst insertionPosition = SplitOperation.getInsertionPosition( new Position( b.graveyardPosition.root, splitPath ) );\n\n\t\tconst additionalSplit = new SplitOperation( splitPosition, 0, null, 0 );\n\t\tadditionalSplit.insertionPosition = insertionPosition;\n\n\t\ta.splitPosition = a.splitPosition._getTransformedByMergeOperation( b );\n\t\ta.insertionPosition = SplitOperation.getInsertionPosition( a.splitPosition );\n\t\ta.graveyardPosition = additionalSplit.insertionPosition.clone();\n\t\ta.graveyardPosition.stickiness = 'toNext';\n\n\t\treturn [ additionalSplit, a ];\n\t}\n\n\t// The default case.\n\t//\n\tif ( a.splitPosition.hasSameParentAs( b.deletionPosition ) && !a.splitPosition.isAfter( b.deletionPosition ) ) {\n\t\ta.howMany--;\n\t}\n\n\tif ( a.splitPosition.hasSameParentAs( b.targetPosition ) ) {\n\t\ta.howMany += b.howMany;\n\t}\n\n\ta.splitPosition = a.splitPosition._getTransformedByMergeOperation( b );\n\ta.insertionPosition = SplitOperation.getInsertionPosition( a.splitPosition );\n\n\tif ( a.graveyardPosition ) {\n\t\ta.graveyardPosition = a.graveyardPosition._getTransformedByMergeOperation( b );\n\t}\n\n\treturn [ a ];\n} );\n\nsetTransformation( SplitOperation, MoveOperation, ( a, b, context ) => {\n\tconst rangeToMove = Range._createFromPositionAndShift( b.sourcePosition, b.howMany );\n\n\tif ( a.graveyardPosition ) {\n\t\t// Case 1:\n\t\t//\n\t\t// Split operation graveyard node was moved. In this case move operation is stronger. Since graveyard element\n\t\t// is already moved to the correct position, we need to only move the nodes after the split position.\n\t\t// This will be done by `MoveOperation` instead of `SplitOperation`.\n\t\t//\n\t\tconst gyElementMoved = rangeToMove.start.isEqual( a.graveyardPosition ) || rangeToMove.containsPosition( a.graveyardPosition );\n\n\t\tif ( !context.bWasUndone && gyElementMoved ) {\n\t\t\tconst sourcePosition = a.splitPosition._getTransformedByMoveOperation( b );\n\n\t\t\tconst newParentPosition = a.graveyardPosition._getTransformedByMoveOperation( b );\n\t\t\tconst newTargetPath = newParentPosition.path.slice();\n\t\t\tnewTargetPath.push( 0 );\n\n\t\t\tconst newTargetPosition = new Position( newParentPosition.root, newTargetPath );\n\t\t\tconst moveOp = new MoveOperation( sourcePosition, a.howMany, newTargetPosition, 0 );\n\n\t\t\treturn [ moveOp ];\n\t\t}\n\n\t\ta.graveyardPosition = a.graveyardPosition._getTransformedByMoveOperation( b );\n\t}\n\n\t// Case 2:\n\t//\n\t// If the split position is inside the moved range, we need to shift the split position to a proper place.\n\t// The position cannot be moved together with moved range because that would result in splitting of an incorrect element.\n\t//\n\t// Characters `bc` should be moved to the second paragraph while split position is between them:\n\t// <paragraph>A[b|c]d</paragraph><paragraph>Xyz</paragraph>\n\t//\n\t// After move, new split position is incorrect:\n\t// <paragraph>Ad</paragraph><paragraph>Xb|cyz</paragraph>\n\t//\n\t// Correct split position:\n\t// <paragraph>A|d</paragraph><paragraph>Xbcyz</paragraph>\n\t//\n\t// After split:\n\t// <paragraph>A</paragraph><paragraph>d</paragraph><paragraph>Xbcyz</paragraph>\n\t//\n\tif ( a.splitPosition.hasSameParentAs( b.sourcePosition ) && rangeToMove.containsPosition( a.splitPosition ) ) {\n\t\tconst howManyRemoved = b.howMany - ( a.splitPosition.offset - b.sourcePosition.offset );\n\t\ta.howMany -= howManyRemoved;\n\n\t\tif ( a.splitPosition.hasSameParentAs( b.targetPosition ) && a.splitPosition.offset < b.targetPosition.offset ) {\n\t\t\ta.howMany += b.howMany;\n\t\t}\n\n\t\ta.splitPosition = b.sourcePosition.clone();\n\t\ta.insertionPosition = SplitOperation.getInsertionPosition( a.splitPosition );\n\n\t\treturn [ a ];\n\t}\n\n\t// Case 3:\n\t//\n\t// Split is at a position where nodes were moved.\n\t//\n\t// This is a scenario described in `MoveOperation` x `SplitOperation` transformation but from the\n\t// \"split operation point of view\".\n\t//\n\tconst splitAtTarget = a.splitPosition.isEqual( b.targetPosition );\n\n\tif ( splitAtTarget && ( context.baRelation == 'insertAtSource' || context.abRelation == 'splitBefore' ) ) {\n\t\ta.howMany += b.howMany;\n\t\ta.splitPosition = a.splitPosition._getTransformedByDeletion( b.sourcePosition, b.howMany );\n\t\ta.insertionPosition = SplitOperation.getInsertionPosition( a.splitPosition );\n\n\t\treturn [ a ];\n\t}\n\n\t// The default case.\n\t// Don't change `howMany` if move operation does not really move anything.\n\t//\n\tif ( !b.sourcePosition.isEqual( b.targetPosition ) ) {\n\t\tif ( a.splitPosition.hasSameParentAs( b.sourcePosition ) && a.splitPosition.offset <= b.sourcePosition.offset ) {\n\t\t\ta.howMany -= b.howMany;\n\t\t}\n\n\t\tif ( a.splitPosition.hasSameParentAs( b.targetPosition ) && a.splitPosition.offset < b.targetPosition.offset ) {\n\t\t\ta.howMany += b.howMany;\n\t\t}\n\t}\n\n\t// Change position stickiness to force a correct transformation.\n\ta.splitPosition.stickiness = 'toNone';\n\ta.splitPosition = a.splitPosition._getTransformedByMoveOperation( b );\n\ta.splitPosition.stickiness = 'toNext';\n\n\tif ( a.graveyardPosition ) {\n\t\ta.insertionPosition = a.insertionPosition._getTransformedByMoveOperation( b );\n\t} else {\n\t\ta.insertionPosition = SplitOperation.getInsertionPosition( a.splitPosition );\n\t}\n\n\treturn [ a ];\n} );\n\nsetTransformation( SplitOperation, SplitOperation, ( a, b, context ) => {\n\t// Case 1:\n\t//\n\t// Split at the same position.\n\t//\n\t// If there already was a split at the same position as in `a` operation, it means that the intention\n\t// conveyed by `a` operation has already been fulfilled and `a` should not do anything (to avoid double split).\n\t//\n\t// However, there is a difference if these are new splits or splits created by undo. These have different\n\t// intentions. Also splits moving back different elements from graveyard have different intentions. They\n\t// are just different operations.\n\t//\n\t// So we cancel split operation only if it was really identical.\n\t//\n\t// Also, there is additional case, where split operations aren't identical and should not be cancelled, however the\n\t// default transformation is incorrect too.\n\t//\n\tif ( a.splitPosition.isEqual( b.splitPosition ) ) {\n\t\tif ( !a.graveyardPosition && !b.graveyardPosition ) {\n\t\t\treturn [ new NoOperation( 0 ) ];\n\t\t}\n\n\t\tif ( a.graveyardPosition && b.graveyardPosition && a.graveyardPosition.isEqual( b.graveyardPosition ) ) {\n\t\t\treturn [ new NoOperation( 0 ) ];\n\t\t}\n\n\t\t// Use context to know that the `a.splitPosition` should stay where it is.\n\t\t// This happens during undo when first a merge operation moved nodes to `a.splitPosition` and now `b` operation undoes that merge.\n\t\tif ( context.abRelation == 'splitBefore' ) {\n\t\t\t// Since split is at the same position, there are no nodes left to split.\n\t\t\ta.howMany = 0;\n\n\t\t\t// Note: there was `if ( a.graveyardPosition )` here but it was uncovered in tests and I couldn't find any scenarios for now.\n\t\t\t// That would have to be a `SplitOperation` that didn't come from undo but is transformed by operations that were undone.\n\t\t\t// It could happen if `context` is enabled in collaboration.\n\t\t\ta.graveyardPosition = a.graveyardPosition._getTransformedBySplitOperation( b );\n\n\t\t\treturn [ a ];\n\t\t}\n\t}\n\n\t// Case 2:\n\t//\n\t// Same node is using to split different elements. This happens in undo when previously same element was merged to\n\t// two different elements. This is described in `MergeOperation` x `MergeOperation` transformation.\n\t//\n\t// In this case we will follow the same logic. We will assume that `insertionPosition` is same for both\n\t// split operations. This might not always be true but in the real cases that were experienced it was. After all,\n\t// if these splits are reverses of merge operations that were merging the same element, then the `insertionPosition`\n\t// should be same for both of those splits.\n\t//\n\t// Again, we will decide which operation is stronger by checking if split happens in graveyard or in non-graveyard root.\n\t//\n\tif ( a.graveyardPosition && b.graveyardPosition && a.graveyardPosition.isEqual( b.graveyardPosition ) ) {\n\t\tconst aInGraveyard = a.splitPosition.root.rootName == '$graveyard';\n\t\tconst bInGraveyard = b.splitPosition.root.rootName == '$graveyard';\n\n\t\t// If `aIsWeak` it means that `a` points to graveyard while `b` doesn't. Don't move nodes then.\n\t\tconst aIsWeak = aInGraveyard && !bInGraveyard;\n\n\t\t// If `bIsWeak` it means that `b` points to graveyard while `a` doesn't. Force moving nodes then.\n\t\tconst bIsWeak = bInGraveyard && !aInGraveyard;\n\n\t\t// Force move if `b` is weak or neither operation is weak but `a` is stronger through `context.aIsStrong`.\n\t\tconst forceMove = bIsWeak || ( !aIsWeak && context.aIsStrong );\n\n\t\tif ( forceMove ) {\n\t\t\tconst result = [];\n\n\t\t\t// First we need to move any nodes split by `b` back to where they were.\n\t\t\t// Do it only if `b` actually moved something.\n\t\t\tif ( b.howMany ) {\n\t\t\t\tresult.push( new MoveOperation( b.moveTargetPosition, b.howMany, b.splitPosition, 0 ) );\n\t\t\t}\n\n\t\t\t// Then we need to move nodes from `a` split position to their new element.\n\t\t\t// Do it only if `a` actually should move something.\n\t\t\tif ( a.howMany ) {\n\t\t\t\tresult.push( new MoveOperation( a.splitPosition, a.howMany, a.moveTargetPosition, 0 ) );\n\t\t\t}\n\n\t\t\treturn result;\n\t\t} else {\n\t\t\treturn [ new NoOperation( 0 ) ];\n\t\t}\n\t}\n\n\tif ( a.graveyardPosition ) {\n\t\ta.graveyardPosition = a.graveyardPosition._getTransformedBySplitOperation( b );\n\t}\n\n\t// Case 3:\n\t//\n\t// Position where operation `b` inserted a new node after split is the same as the operation `a` split position.\n\t// As in similar cases, there is ambiguity if the split should be before the new node (created by `b`) or after.\n\t//\n\tif ( a.splitPosition.isEqual( b.insertionPosition ) && context.abRelation == 'splitBefore' ) {\n\t\ta.howMany++;\n\n\t\treturn [ a ];\n\t}\n\n\t// Case 4:\n\t//\n\t// This is a mirror to the case 2. above.\n\t//\n\tif ( b.splitPosition.isEqual( a.insertionPosition ) && context.baRelation == 'splitBefore' ) {\n\t\tconst newPositionPath = b.insertionPosition.path.slice();\n\t\tnewPositionPath.push( 0 );\n\n\t\tconst newPosition = new Position( b.insertionPosition.root, newPositionPath );\n\t\tconst moveOp = new MoveOperation( a.insertionPosition, 1, newPosition, 0 );\n\n\t\treturn [ a, moveOp ];\n\t}\n\n\t// The default case.\n\t//\n\tif ( a.splitPosition.hasSameParentAs( b.splitPosition ) && a.splitPosition.offset < b.splitPosition.offset ) {\n\t\ta.howMany -= b.howMany;\n\t}\n\n\ta.splitPosition = a.splitPosition._getTransformedBySplitOperation( b );\n\ta.insertionPosition = SplitOperation.getInsertionPosition( a.splitPosition );\n\n\treturn [ a ];\n} );\n\n// Checks whether `MoveOperation` `targetPosition` is inside a node from the moved range of the other `MoveOperation`.\n//\n// @private\n// @param {module:engine/model/operation/moveoperation~MoveOperation} a\n// @param {module:engine/model/operation/moveoperation~MoveOperation} b\n// @returns {Boolean}\nfunction _moveTargetIntoMovedRange( a, b ) {\n\treturn a.targetPosition._getTransformedByDeletion( b.sourcePosition, b.howMany ) === null;\n}\n\n// Helper function for `MoveOperation` x `MoveOperation` transformation. Converts given ranges and target position to\n// move operations and returns them.\n//\n// Ranges and target position will be transformed on-the-fly when generating operations.\n//\n// Given `ranges` should be in the order of how they were in the original transformed operation.\n//\n// Given `targetPosition` is the target position of the first range from `ranges`.\n//\n// @private\n// @param {Array.<module:engine/model/range~Range>} ranges\n// @param {module:engine/model/position~Position} targetPosition\n// @returns {Array.<module:engine/model/operation/moveoperation~MoveOperation>}\nfunction _makeMoveOperationsFromRanges( ranges, targetPosition ) {\n\t// At this moment we have some ranges and a target position, to which those ranges should be moved.\n\t// Order in `ranges` array is the go-to order of after transformation.\n\t//\n\t// We are almost done. We have `ranges` and `targetPosition` to make operations from.\n\t// Unfortunately, those operations may affect each other. Precisely, first operation after move\n\t// may affect source range and target position of second and third operation. Same with second\n\t// operation affecting third.\n\t//\n\t// We need to fix those source ranges and target positions once again, before converting `ranges` to operations.\n\tconst operations = [];\n\n\t// Keep in mind that nothing will be transformed if there is just one range in `ranges`.\n\tfor ( let i = 0; i < ranges.length; i++ ) {\n\t\t// Create new operation out of a range and target position.\n\t\tconst range = ranges[ i ];\n\t\tconst op = new MoveOperation(\n\t\t\trange.start,\n\t\t\trange.end.offset - range.start.offset,\n\t\t\ttargetPosition,\n\t\t\t0\n\t\t);\n\n\t\toperations.push( op );\n\n\t\t// Transform other ranges by the generated operation.\n\t\tfor ( let j = i + 1; j < ranges.length; j++ ) {\n\t\t\t// All ranges in `ranges` array should be:\n\t\t\t//\n\t\t\t// * non-intersecting (these are part of original operation source range), and\n\t\t\t// * `targetPosition` does not target into them (opposite would mean that transformed operation targets \"inside itself\").\n\t\t\t//\n\t\t\t// This means that the transformation will be \"clean\" and always return one result.\n\t\t\tranges[ j ] = ranges[ j ]._getTransformedByMove( op.sourcePosition, op.targetPosition, op.howMany )[ 0 ];\n\t\t}\n\n\t\ttargetPosition = targetPosition._getTransformedByMove( op.sourcePosition, op.targetPosition, op.howMany );\n\t}\n\n\treturn operations;\n}\n"]}]}