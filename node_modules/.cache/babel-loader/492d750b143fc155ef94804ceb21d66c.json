{"remainingRequest":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/babel-loader/lib/index.js!/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-utils/src/dom/scroll.js","dependencies":[{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-utils/src/dom/scroll.js","mtime":499162500000},{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js","mtime":499162500000},{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/babel-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:LyoqCiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDE5LCBDS1NvdXJjZSAtIEZyZWRlcmljbyBLbmFiYmVuLiBBbGwgcmlnaHRzIHJlc2VydmVkLgogKiBGb3IgbGljZW5zaW5nLCBzZWUgTElDRU5TRS5tZCBvciBodHRwczovL2NrZWRpdG9yLmNvbS9sZWdhbC9ja2VkaXRvci1vc3MtbGljZW5zZQogKi8KCi8qKgogKiBAbW9kdWxlIHV0aWxzL2RvbS9zY3JvbGwKICovCmltcG9ydCBpc1JhbmdlIGZyb20gJy4vaXNyYW5nZSc7CmltcG9ydCBSZWN0IGZyb20gJy4vcmVjdCc7CmltcG9ydCBpc1RleHQgZnJvbSAnLi9pc3RleHQnOwpjb25zdCB1dGlscyA9IHt9OwovKioKICogTWFrZXMgYW55IHBhZ2UgYEhUTUxFbGVtZW50YCBvciBgUmFuZ2VgIChgdGFyZ2V0YCkgdmlzaWJsZSBpbnNpZGUgdGhlIGJyb3dzZXIgdmlld3BvcnQuCiAqIFRoaXMgaGVscGVyIHdpbGwgc2Nyb2xsIGFsbCBgdGFyZ2V0YCBhbmNlc3RvcnMgYW5kIHRoZSB3ZWIgYnJvd3NlciB2aWV3cG9ydCB0byByZXZlYWwgdGhlIHRhcmdldCB0bwogKiB0aGUgdXNlci4gSWYgdGhlIGB0YXJnZXRgIGlzIGFscmVhZHkgdmlzaWJsZSwgbm90aGluZyB3aWxsIGhhcHBlbi4KICoKICogQHBhcmFtIHtIVE1MRWxlbWVudHxSYW5nZX0gb3B0aW9ucy50YXJnZXQgQSB0YXJnZXQsIHdoaWNoIHN1cHBvc2VkIHRvIGJlY29tZSB2aXNpYmxlIHRvIHRoZSB1c2VyLgogKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudmlld3BvcnRPZmZzZXRdIEFuIG9mZnNldCBmcm9tIHRoZSBlZGdlIG9mIHRoZSB2aWV3cG9ydCAoaW4gcGl4ZWxzKQogKiB0aGUgYHRhcmdldGAgd2lsbCBiZSBtb3ZlZCBieSB3aGVuIHRoZSB2aWV3cG9ydCBpcyBzY3JvbGxlZC4gSXQgZW5oYW5jZXMgdGhlIHVzZXIgZXhwZXJpZW5jZQogKiBieSBrZWVwaW5nIHRoZSBgdGFyZ2V0YCBzb21lIGRpc3RhbmNlIGZyb20gdGhlIGVkZ2Ugb2YgdGhlIHZpZXdwb3J0IGFuZCB0aHVzIG1ha2luZyBpdCBlYXNpZXIgdG8KICogcmVhZCBvciBlZGl0IGJ5IHRoZSB1c2VyLgogKi8KCmV4cG9ydCBmdW5jdGlvbiBzY3JvbGxWaWV3cG9ydFRvU2hvd1RhcmdldCh7CiAgdGFyZ2V0LAogIHZpZXdwb3J0T2Zmc2V0ID0gMAp9KSB7CiAgY29uc3QgdGFyZ2V0V2luZG93ID0gZ2V0V2luZG93KHRhcmdldCk7CiAgbGV0IGN1cnJlbnRXaW5kb3cgPSB0YXJnZXRXaW5kb3c7CiAgbGV0IGN1cnJlbnRGcmFtZSA9IG51bGw7IC8vIEl0ZXJhdGUgb3ZlciBhbGwgd2luZG93cywgc3RhcnRpbmcgZnJvbSB0YXJnZXQncyBwYXJlbnQgd2luZG93IHVwIHRvIHdpbmRvdyN0b3AuCgogIHdoaWxlIChjdXJyZW50V2luZG93KSB7CiAgICBsZXQgZmlyc3RBbmNlc3RvclRvU2Nyb2xsOyAvLyBMZXQncyBzY3JvbGwgdGFyZ2V0J3MgYW5jZXN0b3JzIGZpcnN0IHRvIHJldmVhbCBpdC4gVGhlbiwgb25jZSB0aGUgYW5jZXN0b3Igc2Nyb2xscwogICAgLy8gc2V0dGxlZCBkb3duLCB0aGUgYWxnb3JpdGhtIGNhbiBldmVudHVhbGx5IHNjcm9sbCB0aGUgdmlld3BvcnQgb2YgdGhlIGN1cnJlbnQgd2luZG93LgogICAgLy8KICAgIC8vIE5vdGU6IElmIHRoZSBjdXJyZW50IHdpbmRvdyBpcyB0YXJnZXQncyAqKm9yaWdpbmFsKiogd2luZG93IChlLmcuIHRoZSBmaXJzdCBvbmUpLAogICAgLy8gc3RhcnQgc2Nyb2xsaW5nIHRoZSBjbG9zZXN0IHBhcmVudCBvZiB0aGUgdGFyZ2V0LiBJZiBub3QsIHNjcm9sbCB0aGUgY2xvc2VzdCBwYXJlbnQKICAgIC8vIG9mIGFuIGlmcmFtZSB0aGF0IHJlc2lkZXMgaW4gdGhlIGN1cnJlbnQgd2luZG93LgoKICAgIGlmIChjdXJyZW50V2luZG93ID09IHRhcmdldFdpbmRvdykgewogICAgICBmaXJzdEFuY2VzdG9yVG9TY3JvbGwgPSBnZXRQYXJlbnRFbGVtZW50KHRhcmdldCk7CiAgICB9IGVsc2UgewogICAgICBmaXJzdEFuY2VzdG9yVG9TY3JvbGwgPSBnZXRQYXJlbnRFbGVtZW50KGN1cnJlbnRGcmFtZSk7CiAgICB9IC8vIFNjcm9sbCB0aGUgdGFyZ2V0J3MgYW5jZXN0b3JzIGZpcnN0LiBPbmNlIGRvbmUsIHNjcm9sbGluZyB0aGUgdmlld3BvcnQgaXMgZWFzeS4KCgogICAgc2Nyb2xsQW5jZXN0b3JzVG9TaG93UmVjdChmaXJzdEFuY2VzdG9yVG9TY3JvbGwsICgpID0+IHsKICAgICAgLy8gTm90ZTogSWYgdGhlIHRhcmdldCBkb2VzIG5vdCBiZWxvbmcgdG8gdGhlIGN1cnJlbnQgd2luZG93ICoqZGlyZWN0bHkqKiwKICAgICAgLy8gaS5lLiBpdCByZXNpZGVzIGluIGFuIGlmcmFtZSBiZWxvbmdpbmcgdG8gdGhlIHdpbmRvdywgb2J0YWluIHRoZSB0YXJnZXQncyByZWN0CiAgICAgIC8vIGluIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgY3VycmVudCB3aW5kb3cuIEJ5IGRlZmF1bHQsIGEgUmVjdCByZXR1cm5zIGdlb21ldHJ5CiAgICAgIC8vIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IHdpbmRvdydzIHZpZXdwb3J0LiBUbyBtYWtlIGl0IHdvcmsgaW4gYSBwYXJlbnQgd2luZG93LAogICAgICAvLyBpdCBtdXN0IGJlIHNoaWZ0ZWQuCiAgICAgIHJldHVybiBnZXRSZWN0UmVsYXRpdmVUb1dpbmRvdyh0YXJnZXQsIGN1cnJlbnRXaW5kb3cpOwogICAgfSk7IC8vIE9idGFpbiB0aGUgcmVjdCBvZiB0aGUgdGFyZ2V0IGFmdGVyIGl0IGhhcyBiZWVuIHNjcm9sbGVkIHdpdGhpbiBpdHMgYW5jZXN0b3JzLgogICAgLy8gSXQncyB0aW1lIHRvIHNjcm9sbCB0aGUgdmlld3BvcnQuCgogICAgY29uc3QgdGFyZ2V0UmVjdCA9IGdldFJlY3RSZWxhdGl2ZVRvV2luZG93KHRhcmdldCwgY3VycmVudFdpbmRvdyk7CiAgICBzY3JvbGxXaW5kb3dUb1Nob3dSZWN0KGN1cnJlbnRXaW5kb3csIHRhcmdldFJlY3QsIHZpZXdwb3J0T2Zmc2V0KTsKCiAgICBpZiAoY3VycmVudFdpbmRvdy5wYXJlbnQgIT0gY3VycmVudFdpbmRvdykgewogICAgICAvLyBLZWVwIHRoZSByZWZlcmVuY2UgdG8gdGhlIDxpZnJhbWU+IGVsZW1lbnQgdGhlICJwcmV2aW91cyBjdXJyZW50IHdpbmRvdyIgd2FzCiAgICAgIC8vIHJlbmRlcmVkIHdpdGhpbi4gSXQgd2lsbCBiZSB1c2VmdWwgdG8gcmXigJNjYWxjdWxhdGUgdGhlIHJlY3Qgb2YgdGhlIHRhcmdldAogICAgICAvLyBpbiB0aGUgcGFyZW50IHdpbmRvdydzIHJlbGF0aXZlIGdlb21ldHJ5LiBUaGUgdGFyZ2V0J3MgcmVjdCBtdXN0IGJlIHNoaWZ0ZWQKICAgICAgLy8gYnkgaXQncyBpZnJhbWUncyBwb3NpdGlvbi4KICAgICAgY3VycmVudEZyYW1lID0gY3VycmVudFdpbmRvdy5mcmFtZUVsZW1lbnQ7CiAgICAgIGN1cnJlbnRXaW5kb3cgPSBjdXJyZW50V2luZG93LnBhcmVudDsgLy8gSWYgdGhlIGN1cnJlbnQgd2luZG93IGhhcyBzb21lIHBhcmVudCBidXQgZnJhbWVFbGVtZW50IGlzIGluYWNjZXNzaWJsZSwgdGhlbiB0aGV5IGhhdmUKICAgICAgLy8gZGlmZmVyZW50IGRvbWFpbnMvcG9ydHMgYW5kLCBkdWUgdG8gc2VjdXJpdHkgcmVhc29ucywgYWNjZXNzaW5nIGFuZCBzY3JvbGxpbmcKICAgICAgLy8gdGhlIHBhcmVudCB3aW5kb3cgd29uJ3QgYmUgcG9zc2libGUuCiAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vY2tlZGl0b3IvY2tlZGl0b3I1L2lzc3Vlcy85MzAuCgogICAgICBpZiAoIWN1cnJlbnRGcmFtZSkgewogICAgICAgIHJldHVybjsKICAgICAgfQogICAgfSBlbHNlIHsKICAgICAgY3VycmVudFdpbmRvdyA9IG51bGw7CiAgICB9CiAgfQp9Ci8qKgogKiBNYWtlcyBhbnkgcGFnZSBgSFRNTEVsZW1lbnRgIG9yIGBSYW5nZWAgKHRhcmdldCkgdmlzaWJsZSB3aXRoaW4gaXRzIHNjcm9sbGFibGUgYW5jZXN0b3JzLAogKiBlLmcuIGlmIHRoZXkgaGF2ZSBgb3ZlcmZsb3c6IHNjcm9sbGAgQ1NTIHN0eWxlLgogKgogKiBAcGFyYW0ge0hUTUxFbGVtZW50fFJhbmdlfSB0YXJnZXQgQSB0YXJnZXQsIHdoaWNoIHN1cHBvc2VkIHRvIGJlY29tZSB2aXNpYmxlIHRvIHRoZSB1c2VyLgogKi8KCmV4cG9ydCBmdW5jdGlvbiBzY3JvbGxBbmNlc3RvcnNUb1Nob3dUYXJnZXQodGFyZ2V0KSB7CiAgY29uc3QgdGFyZ2V0UGFyZW50ID0gZ2V0UGFyZW50RWxlbWVudCh0YXJnZXQpOwogIHNjcm9sbEFuY2VzdG9yc1RvU2hvd1JlY3QodGFyZ2V0UGFyZW50LCAoKSA9PiB7CiAgICByZXR1cm4gbmV3IFJlY3QodGFyZ2V0KTsKICB9KTsKfSAvLyBUT0RPOiBVc2luZyBhIHByb3BlcnR5IHZhbHVlIHNob3J0aGFuZCBpbiB0aGUgdG9wIG9mIHRoZSBmaWxlCi8vIGNhdXNlcyBKU0RvYyB0byB0aHJvdyBlcnJvcnMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vY2tzb3VyY2UvZG9jcy1idWlsZGVyL2lzc3Vlcy83NS4KCk9iamVjdC5hc3NpZ24odXRpbHMsIHsKICBzY3JvbGxWaWV3cG9ydFRvU2hvd1RhcmdldCwKICBzY3JvbGxBbmNlc3RvcnNUb1Nob3dUYXJnZXQKfSk7IC8vIE1ha2VzIGEgZ2l2ZW4gcmVjdCB2aXNpYmxlIHdpdGhpbiBpdHMgcGFyZW50IHdpbmRvdy4KLy8KLy8gTm90ZTogQXZvaWQgdGhlIHNpdHVhdGlvbiB3aGVyZSB0aGUgY2FyZXQgaXMgc3RpbGwgaW4gdGhlIHZpZXdwb3J0LCBidXQgdG90YWxseQovLyBhdCB0aGUgZWRnZSBvZiBpdC4gSW4gc3VjaCBzaXR1YXRpb24sIGlmIGl0IG1vdmVkIGJleW9uZCB0aGUgdmlld3BvcnQgaW4gdGhlIG5leHQKLy8gYWN0aW9uIGUuZy4gYWZ0ZXIgcGFzdGUsIHRoZSBzY3JvbGxpbmcgd291bGQgbW92ZSBpdCB0byB0aGUgdmlld3BvcnRPZmZzZXQgbGV2ZWwKLy8gYW5kIGl0IGFsbCB3b3VsZCBsb29rIGxpa2UgdGhlIGNhcmV0IHZpc3VhbGx5IG1vdmVkIHVwL2Rvd246Ci8vCi8vIDEuCi8vCQl8IGZvb1tdCi8vCQl8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC0tLSBOIHB4IG9mIHNwYWNlIGJlbG93IHRoZSBjYXJldAovLwkJKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS4uLgovLwovLyAyLiAqcGFzdGUqCi8vIDMuCi8vCQl8Ci8vCQl8Ci8vCQkrLWZvby0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLi4uCi8vCQkgIGJhcltdICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC0tLSBjYXJldCBiZWxvdyB2aWV3cG9ydCwgc2Nyb2xsaW5nLi4uCi8vCi8vIDQuICpzY3JvbGxpbmcqCi8vIDUuCi8vCQl8Ci8vCQl8IGZvbwovLwkJfCBiYXJbXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwtLS0gY2FyZXQgcHJlY2lzZWx5IGF0IHRoZSBlZGdlCi8vCQkrLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLi4uCi8vCi8vIFRvIHByZXZlbnQgdGhpcywgdGhpcyBtZXRob2QgY2hlY2tzIHRoZSByZWN0cyBtb3ZlZCBieSB0aGUgdmlld3BvcnRPZmZzZXQgdG8gY292ZXIKLy8gdGhlIHVwcGVyL2xvd2VyIGVkZ2Ugb2YgdGhlIHZpZXdwb3J0LiBJdCBtYWtlcyBzdXJlIGlmIHRoZSBhY3Rpb24gcmVwZWF0cywgdGhlcmUncwovLyBubyB0d2l0Y2hpbmcg4oCTIGl0J3MgYSBwdXJlbHkgdmlzdWFsIGltcHJvdmVtZW50OgovLwovLyA1LiAoYWZ0ZXIgZml4KQovLwkJfAovLwkJfCBmb28KLy8JCXwgYmFyW10KLy8JCXwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8LS0tIE4gcHggb2Ygc3BhY2UgYmVsb3cgdGhlIGNhcmV0Ci8vCQkrLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLi4uCi8vCi8vIEBwcml2YXRlCi8vIEBwYXJhbSB7V2luZG93fSB3aW5kb3cgQSB3aW5kb3cgd2hpY2ggaXMgc2Nyb2xsZWQgdG8gcmV2ZWFsIHRoZSByZWN0LgovLyBAcGFyYW0ge21vZHVsZTp1dGlscy9kb20vcmVjdH5SZWN0fSByZWN0IEEgcmVjdCB3aGljaCBpcyB0byBiZSByZXZlYWxlZC4KLy8gQHBhcmFtIHtOdW1iZXJ9IHZpZXdwb3J0T2Zmc2V0IFNlZSBzY3JvbGxWaWV3cG9ydFRvU2hvd1RhcmdldC4KCmZ1bmN0aW9uIHNjcm9sbFdpbmRvd1RvU2hvd1JlY3Qod2luZG93LCByZWN0LCB2aWV3cG9ydE9mZnNldCkgewogIGNvbnN0IHRhcmdldFNoaWZ0ZWREb3duUmVjdCA9IHJlY3QuY2xvbmUoKS5tb3ZlQnkoMCwgdmlld3BvcnRPZmZzZXQpOwogIGNvbnN0IHRhcmdldFNoaWZ0ZWRVcFJlY3QgPSByZWN0LmNsb25lKCkubW92ZUJ5KDAsIC12aWV3cG9ydE9mZnNldCk7CiAgY29uc3Qgdmlld3BvcnRSZWN0ID0gbmV3IFJlY3Qod2luZG93KS5leGNsdWRlU2Nyb2xsYmFyc0FuZEJvcmRlcnMoKTsKICBjb25zdCByZWN0cyA9IFt0YXJnZXRTaGlmdGVkVXBSZWN0LCB0YXJnZXRTaGlmdGVkRG93blJlY3RdOwoKICBpZiAoIXJlY3RzLmV2ZXJ5KHJlY3QgPT4gdmlld3BvcnRSZWN0LmNvbnRhaW5zKHJlY3QpKSkgewogICAgbGV0IHsKICAgICAgc2Nyb2xsWCwKICAgICAgc2Nyb2xsWQogICAgfSA9IHdpbmRvdzsKCiAgICBpZiAoaXNBYm92ZSh0YXJnZXRTaGlmdGVkVXBSZWN0LCB2aWV3cG9ydFJlY3QpKSB7CiAgICAgIHNjcm9sbFkgLT0gdmlld3BvcnRSZWN0LnRvcCAtIHJlY3QudG9wICsgdmlld3BvcnRPZmZzZXQ7CiAgICB9IGVsc2UgaWYgKGlzQmVsb3codGFyZ2V0U2hpZnRlZERvd25SZWN0LCB2aWV3cG9ydFJlY3QpKSB7CiAgICAgIHNjcm9sbFkgKz0gcmVjdC5ib3R0b20gLSB2aWV3cG9ydFJlY3QuYm90dG9tICsgdmlld3BvcnRPZmZzZXQ7CiAgICB9IC8vIFRPRE86IFdlYiBicm93c2VycyBzY3JvbGwgbmF0aXZlbHkgdG8gcGxhY2UgdGhlIHRhcmdldCBpbiB0aGUgbWlkZGxlCiAgICAvLyBvZiB0aGUgdmlld3BvcnQuIEl0J3Mgbm90IGEgdmVyeSBwb3B1bGFyIGNhc2UsIHRob3VnaC4KCgogICAgaWYgKGlzTGVmdE9mKHJlY3QsIHZpZXdwb3J0UmVjdCkpIHsKICAgICAgc2Nyb2xsWCAtPSB2aWV3cG9ydFJlY3QubGVmdCAtIHJlY3QubGVmdCArIHZpZXdwb3J0T2Zmc2V0OwogICAgfSBlbHNlIGlmIChpc1JpZ2h0T2YocmVjdCwgdmlld3BvcnRSZWN0KSkgewogICAgICBzY3JvbGxYICs9IHJlY3QucmlnaHQgLSB2aWV3cG9ydFJlY3QucmlnaHQgKyB2aWV3cG9ydE9mZnNldDsKICAgIH0KCiAgICB3aW5kb3cuc2Nyb2xsVG8oc2Nyb2xsWCwgc2Nyb2xsWSk7CiAgfQp9IC8vIFJlY3Vyc2l2ZWx5IHNjcm9sbHMgZWxlbWVudCBhbmNlc3RvcnMgdG8gdmlzdWFsbHkgcmV2ZWFsIGEgcmVjdC4KLy8KLy8gQHByaXZhdGUKLy8gQHBhcmFtIHtIVE1MRWxlbWVudH0gQSBwYXJlbnQgVGhlIGZpcnN0IGFuY2VzdG9ycyB0byBzdGFydCBzY3JvbGxpbmcuCi8vIEBwYXJhbSB7RnVuY3Rpb259IGdldFJlY3QgQSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIHRoZSBSZWN0LCB3aGljaCBpcyB0byBiZSByZXZlYWxlZC4KCgpmdW5jdGlvbiBzY3JvbGxBbmNlc3RvcnNUb1Nob3dSZWN0KHBhcmVudCwgZ2V0UmVjdCkgewogIGNvbnN0IHBhcmVudFdpbmRvdyA9IGdldFdpbmRvdyhwYXJlbnQpOwogIGxldCBwYXJlbnRSZWN0LCB0YXJnZXRSZWN0OwoKICB3aGlsZSAocGFyZW50ICE9IHBhcmVudFdpbmRvdy5kb2N1bWVudC5ib2R5KSB7CiAgICB0YXJnZXRSZWN0ID0gZ2V0UmVjdCgpOwogICAgcGFyZW50UmVjdCA9IG5ldyBSZWN0KHBhcmVudCkuZXhjbHVkZVNjcm9sbGJhcnNBbmRCb3JkZXJzKCk7CgogICAgaWYgKCFwYXJlbnRSZWN0LmNvbnRhaW5zKHRhcmdldFJlY3QpKSB7CiAgICAgIGlmIChpc0Fib3ZlKHRhcmdldFJlY3QsIHBhcmVudFJlY3QpKSB7CiAgICAgICAgcGFyZW50LnNjcm9sbFRvcCAtPSBwYXJlbnRSZWN0LnRvcCAtIHRhcmdldFJlY3QudG9wOwogICAgICB9IGVsc2UgaWYgKGlzQmVsb3codGFyZ2V0UmVjdCwgcGFyZW50UmVjdCkpIHsKICAgICAgICBwYXJlbnQuc2Nyb2xsVG9wICs9IHRhcmdldFJlY3QuYm90dG9tIC0gcGFyZW50UmVjdC5ib3R0b207CiAgICAgIH0KCiAgICAgIGlmIChpc0xlZnRPZih0YXJnZXRSZWN0LCBwYXJlbnRSZWN0KSkgewogICAgICAgIHBhcmVudC5zY3JvbGxMZWZ0IC09IHBhcmVudFJlY3QubGVmdCAtIHRhcmdldFJlY3QubGVmdDsKICAgICAgfSBlbHNlIGlmIChpc1JpZ2h0T2YodGFyZ2V0UmVjdCwgcGFyZW50UmVjdCkpIHsKICAgICAgICBwYXJlbnQuc2Nyb2xsTGVmdCArPSB0YXJnZXRSZWN0LnJpZ2h0IC0gcGFyZW50UmVjdC5yaWdodDsKICAgICAgfQogICAgfQoKICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlOwogIH0KfSAvLyBEZXRlcm1pbmVzIGlmIGEgZ2l2ZW4gYFJlY3RgIGV4dGVuZHMgYmV5b25kIHRoZSBib3R0b20gZWRnZSBvZiB0aGUgc2Vjb25kIGBSZWN0YC4KLy8KLy8gQHByaXZhdGUKLy8gQHBhcmFtIHttb2R1bGU6dXRpbHMvZG9tL3JlY3R+UmVjdH0gZmlyc3RSZWN0Ci8vIEBwYXJhbSB7bW9kdWxlOnV0aWxzL2RvbS9yZWN0flJlY3R9IHNlY29uZFJlY3QKCgpmdW5jdGlvbiBpc0JlbG93KGZpcnN0UmVjdCwgc2Vjb25kUmVjdCkgewogIHJldHVybiBmaXJzdFJlY3QuYm90dG9tID4gc2Vjb25kUmVjdC5ib3R0b207Cn0gLy8gRGV0ZXJtaW5lcyBpZiBhIGdpdmVuIGBSZWN0YCBleHRlbmRzIGJleW9uZCB0aGUgdG9wIGVkZ2Ugb2YgdGhlIHNlY29uZCBgUmVjdGAuCi8vCi8vIEBwcml2YXRlCi8vIEBwYXJhbSB7bW9kdWxlOnV0aWxzL2RvbS9yZWN0flJlY3R9IGZpcnN0UmVjdAovLyBAcGFyYW0ge21vZHVsZTp1dGlscy9kb20vcmVjdH5SZWN0fSBzZWNvbmRSZWN0CgoKZnVuY3Rpb24gaXNBYm92ZShmaXJzdFJlY3QsIHNlY29uZFJlY3QpIHsKICByZXR1cm4gZmlyc3RSZWN0LnRvcCA8IHNlY29uZFJlY3QudG9wOwp9IC8vIERldGVybWluZXMgaWYgYSBnaXZlbiBgUmVjdGAgZXh0ZW5kcyBiZXlvbmQgdGhlIGxlZnQgZWRnZSBvZiB0aGUgc2Vjb25kIGBSZWN0YC4KLy8KLy8gQHByaXZhdGUKLy8gQHBhcmFtIHttb2R1bGU6dXRpbHMvZG9tL3JlY3R+UmVjdH0gZmlyc3RSZWN0Ci8vIEBwYXJhbSB7bW9kdWxlOnV0aWxzL2RvbS9yZWN0flJlY3R9IHNlY29uZFJlY3QKCgpmdW5jdGlvbiBpc0xlZnRPZihmaXJzdFJlY3QsIHNlY29uZFJlY3QpIHsKICByZXR1cm4gZmlyc3RSZWN0LmxlZnQgPCBzZWNvbmRSZWN0LmxlZnQ7Cn0gLy8gRGV0ZXJtaW5lcyBpZiBhIGdpdmVuIGBSZWN0YCBleHRlbmRzIGJleW9uZCB0aGUgcmlnaHQgZWRnZSBvZiB0aGUgc2Vjb25kIGBSZWN0YC4KLy8KLy8gQHByaXZhdGUKLy8gQHBhcmFtIHttb2R1bGU6dXRpbHMvZG9tL3JlY3R+UmVjdH0gZmlyc3RSZWN0Ci8vIEBwYXJhbSB7bW9kdWxlOnV0aWxzL2RvbS9yZWN0flJlY3R9IHNlY29uZFJlY3QKCgpmdW5jdGlvbiBpc1JpZ2h0T2YoZmlyc3RSZWN0LCBzZWNvbmRSZWN0KSB7CiAgcmV0dXJuIGZpcnN0UmVjdC5yaWdodCA+IHNlY29uZFJlY3QucmlnaHQ7Cn0gLy8gUmV0dXJucyB0aGUgY2xvc2VzdCB3aW5kb3cgb2YgYW4gZWxlbWVudCBvciByYW5nZS4KLy8KLy8gQHByaXZhdGUKLy8gQHBhcmFtIHtIVE1MRWxlbWVudHxSYW5nZX0gZmlyc3RSZWN0Ci8vIEByZXR1cm5zIHtXaW5kb3d9CgoKZnVuY3Rpb24gZ2V0V2luZG93KGVsZW1lbnRPclJhbmdlKSB7CiAgaWYgKGlzUmFuZ2UoZWxlbWVudE9yUmFuZ2UpKSB7CiAgICByZXR1cm4gZWxlbWVudE9yUmFuZ2Uuc3RhcnRDb250YWluZXIub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldzsKICB9IGVsc2UgewogICAgcmV0dXJuIGVsZW1lbnRPclJhbmdlLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7CiAgfQp9IC8vIFJldHVybnMgdGhlIGNsb3Nlc3QgcGFyZW50IG9mIGFuIGVsZW1lbnQgb3IgRE9NIHJhbmdlLgovLwovLyBAcHJpdmF0ZQovLyBAcGFyYW0ge0hUTUxFbGVtZW50fFJhbmdlfSBmaXJzdFJlY3QKLy8gQHJldHVybnMge0hUTUxlbGVtZW50fQoKCmZ1bmN0aW9uIGdldFBhcmVudEVsZW1lbnQoZWxlbWVudE9yUmFuZ2UpIHsKICBpZiAoaXNSYW5nZShlbGVtZW50T3JSYW5nZSkpIHsKICAgIGxldCBwYXJlbnQgPSBlbGVtZW50T3JSYW5nZS5jb21tb25BbmNlc3RvckNvbnRhaW5lcjsgLy8gSWYgYSBSYW5nZSBpcyBhdHRhY2hlZCB0byB0aGUgVGV4dCwgdXNlIHRoZSBjbG9zZXN0IGVsZW1lbnQgYW5jZXN0b3IuCgogICAgaWYgKGlzVGV4dChwYXJlbnQpKSB7CiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlOwogICAgfQoKICAgIHJldHVybiBwYXJlbnQ7CiAgfSBlbHNlIHsKICAgIHJldHVybiBlbGVtZW50T3JSYW5nZS5wYXJlbnROb2RlOwogIH0KfSAvLyBSZXR1cm5zIHRoZSByZWN0IG9mIGFuIGVsZW1lbnQgb3IgcmFuZ2UgcmVzaWRpbmcgaW4gYW4gaWZyYW1lLgovLyBUaGUgcmVzdWx0IHJlY3QgaXMgcmVsYXRpdmUgdG8gdGhlIGdlb21ldHJ5IG9mIHRoZSBwYXNzZWQgd2luZG93IGluc3RhbmNlLgovLwovLyBAcHJpdmF0ZQovLyBAcGFyYW0ge0hUTUxFbGVtZW50fFJhbmdlfSB0YXJnZXQgRWxlbWVudCBvciByYW5nZSB3aGljaCByZWN0IHNob3VsZCBiZSByZXR1cm5lZC4KLy8gQHBhcmFtIHtXaW5kb3d9IHJlbGF0aXZlV2luZG93IEEgd2luZG93IHRoZSByZWN0IHNob3VsZCBiZSByZWxhdGl2ZSB0by4KLy8gQHJldHVybnMge21vZHVsZTp1dGlscy9kb20vcmVjdH5SZWN0fQoKCmZ1bmN0aW9uIGdldFJlY3RSZWxhdGl2ZVRvV2luZG93KHRhcmdldCwgcmVsYXRpdmVXaW5kb3cpIHsKICBjb25zdCB0YXJnZXRXaW5kb3cgPSBnZXRXaW5kb3codGFyZ2V0KTsKICBjb25zdCByZWN0ID0gbmV3IFJlY3QodGFyZ2V0KTsKCiAgaWYgKHRhcmdldFdpbmRvdyA9PT0gcmVsYXRpdmVXaW5kb3cpIHsKICAgIHJldHVybiByZWN0OwogIH0gZWxzZSB7CiAgICBsZXQgY3VycmVudFdpbmRvdyA9IHRhcmdldFdpbmRvdzsKCiAgICB3aGlsZSAoY3VycmVudFdpbmRvdyAhPSByZWxhdGl2ZVdpbmRvdykgewogICAgICBjb25zdCBmcmFtZSA9IGN1cnJlbnRXaW5kb3cuZnJhbWVFbGVtZW50OwogICAgICBjb25zdCBmcmFtZVJlY3QgPSBuZXcgUmVjdChmcmFtZSkuZXhjbHVkZVNjcm9sbGJhcnNBbmRCb3JkZXJzKCk7CiAgICAgIHJlY3QubW92ZUJ5KGZyYW1lUmVjdC5sZWZ0LCBmcmFtZVJlY3QudG9wKTsKICAgICAgY3VycmVudFdpbmRvdyA9IGN1cnJlbnRXaW5kb3cucGFyZW50OwogICAgfQogIH0KCiAgcmV0dXJuIHJlY3Q7Cn0="},{"version":3,"sources":["/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-utils/src/dom/scroll.js"],"names":["isRange","Rect","isText","utils","scrollViewportToShowTarget","target","viewportOffset","targetWindow","getWindow","currentWindow","currentFrame","firstAncestorToScroll","getParentElement","scrollAncestorsToShowRect","getRectRelativeToWindow","targetRect","scrollWindowToShowRect","parent","frameElement","scrollAncestorsToShowTarget","targetParent","Object","assign","window","rect","targetShiftedDownRect","clone","moveBy","targetShiftedUpRect","viewportRect","excludeScrollbarsAndBorders","rects","every","contains","scrollX","scrollY","isAbove","top","isBelow","bottom","isLeftOf","left","isRightOf","right","scrollTo","getRect","parentWindow","parentRect","document","body","scrollTop","scrollLeft","parentNode","firstRect","secondRect","elementOrRange","startContainer","ownerDocument","defaultView","commonAncestorContainer","relativeWindow","frame","frameRect"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module utils/dom/scroll\n */\n\nimport isRange from './isrange';\nimport Rect from './rect';\nimport isText from './istext';\n\nconst utils = {};\n\n/**\n * Makes any page `HTMLElement` or `Range` (`target`) visible inside the browser viewport.\n * This helper will scroll all `target` ancestors and the web browser viewport to reveal the target to\n * the user. If the `target` is already visible, nothing will happen.\n *\n * @param {HTMLElement|Range} options.target A target, which supposed to become visible to the user.\n * @param {Number} [options.viewportOffset] An offset from the edge of the viewport (in pixels)\n * the `target` will be moved by when the viewport is scrolled. It enhances the user experience\n * by keeping the `target` some distance from the edge of the viewport and thus making it easier to\n * read or edit by the user.\n */\nexport function scrollViewportToShowTarget( { target, viewportOffset = 0 } ) {\n\tconst targetWindow = getWindow( target );\n\tlet currentWindow = targetWindow;\n\tlet currentFrame = null;\n\n\t// Iterate over all windows, starting from target's parent window up to window#top.\n\twhile ( currentWindow ) {\n\t\tlet firstAncestorToScroll;\n\n\t\t// Let's scroll target's ancestors first to reveal it. Then, once the ancestor scrolls\n\t\t// settled down, the algorithm can eventually scroll the viewport of the current window.\n\t\t//\n\t\t// Note: If the current window is target's **original** window (e.g. the first one),\n\t\t// start scrolling the closest parent of the target. If not, scroll the closest parent\n\t\t// of an iframe that resides in the current window.\n\t\tif ( currentWindow == targetWindow ) {\n\t\t\tfirstAncestorToScroll = getParentElement( target );\n\t\t} else {\n\t\t\tfirstAncestorToScroll = getParentElement( currentFrame );\n\t\t}\n\n\t\t// Scroll the target's ancestors first. Once done, scrolling the viewport is easy.\n\t\tscrollAncestorsToShowRect( firstAncestorToScroll, () => {\n\t\t\t// Note: If the target does not belong to the current window **directly**,\n\t\t\t// i.e. it resides in an iframe belonging to the window, obtain the target's rect\n\t\t\t// in the coordinates of the current window. By default, a Rect returns geometry\n\t\t\t// relative to the current window's viewport. To make it work in a parent window,\n\t\t\t// it must be shifted.\n\t\t\treturn getRectRelativeToWindow( target, currentWindow );\n\t\t} );\n\n\t\t// Obtain the rect of the target after it has been scrolled within its ancestors.\n\t\t// It's time to scroll the viewport.\n\t\tconst targetRect = getRectRelativeToWindow( target, currentWindow );\n\n\t\tscrollWindowToShowRect( currentWindow, targetRect, viewportOffset );\n\n\t\tif ( currentWindow.parent != currentWindow ) {\n\t\t\t// Keep the reference to the <iframe> element the \"previous current window\" was\n\t\t\t// rendered within. It will be useful to re–calculate the rect of the target\n\t\t\t// in the parent window's relative geometry. The target's rect must be shifted\n\t\t\t// by it's iframe's position.\n\t\t\tcurrentFrame = currentWindow.frameElement;\n\t\t\tcurrentWindow = currentWindow.parent;\n\n\t\t\t// If the current window has some parent but frameElement is inaccessible, then they have\n\t\t\t// different domains/ports and, due to security reasons, accessing and scrolling\n\t\t\t// the parent window won't be possible.\n\t\t\t// See https://github.com/ckeditor/ckeditor5/issues/930.\n\t\t\tif ( !currentFrame ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tcurrentWindow = null;\n\t\t}\n\t}\n}\n\n/**\n * Makes any page `HTMLElement` or `Range` (target) visible within its scrollable ancestors,\n * e.g. if they have `overflow: scroll` CSS style.\n *\n * @param {HTMLElement|Range} target A target, which supposed to become visible to the user.\n */\nexport function scrollAncestorsToShowTarget( target ) {\n\tconst targetParent = getParentElement( target );\n\n\tscrollAncestorsToShowRect( targetParent, () => {\n\t\treturn new Rect( target );\n\t} );\n}\n\n// TODO: Using a property value shorthand in the top of the file\n// causes JSDoc to throw errors. See https://github.com/cksource/docs-builder/issues/75.\nObject.assign( utils, {\n\tscrollViewportToShowTarget,\n\tscrollAncestorsToShowTarget\n} );\n\n// Makes a given rect visible within its parent window.\n//\n// Note: Avoid the situation where the caret is still in the viewport, but totally\n// at the edge of it. In such situation, if it moved beyond the viewport in the next\n// action e.g. after paste, the scrolling would move it to the viewportOffset level\n// and it all would look like the caret visually moved up/down:\n//\n// 1.\n//\t\t| foo[]\n//\t\t|                                    <--- N px of space below the caret\n//\t\t+---------------------------------...\n//\n// 2. *paste*\n// 3.\n//\t\t|\n//\t\t|\n//\t\t+-foo-----------------------------...\n//\t\t  bar[]                              <--- caret below viewport, scrolling...\n//\n// 4. *scrolling*\n// 5.\n//\t\t|\n//\t\t| foo\n//\t\t| bar[]                              <--- caret precisely at the edge\n//\t\t+---------------------------------...\n//\n// To prevent this, this method checks the rects moved by the viewportOffset to cover\n// the upper/lower edge of the viewport. It makes sure if the action repeats, there's\n// no twitching – it's a purely visual improvement:\n//\n// 5. (after fix)\n//\t\t|\n//\t\t| foo\n//\t\t| bar[]\n//\t\t|                                    <--- N px of space below the caret\n//\t\t+---------------------------------...\n//\n// @private\n// @param {Window} window A window which is scrolled to reveal the rect.\n// @param {module:utils/dom/rect~Rect} rect A rect which is to be revealed.\n// @param {Number} viewportOffset See scrollViewportToShowTarget.\nfunction scrollWindowToShowRect( window, rect, viewportOffset ) {\n\tconst targetShiftedDownRect = rect.clone().moveBy( 0, viewportOffset );\n\tconst targetShiftedUpRect = rect.clone().moveBy( 0, -viewportOffset );\n\tconst viewportRect = new Rect( window ).excludeScrollbarsAndBorders();\n\n\tconst rects = [ targetShiftedUpRect, targetShiftedDownRect ];\n\n\tif ( !rects.every( rect => viewportRect.contains( rect ) ) ) {\n\t\tlet { scrollX, scrollY } = window;\n\n\t\tif ( isAbove( targetShiftedUpRect, viewportRect ) ) {\n\t\t\tscrollY -= viewportRect.top - rect.top + viewportOffset;\n\t\t} else if ( isBelow( targetShiftedDownRect, viewportRect ) ) {\n\t\t\tscrollY += rect.bottom - viewportRect.bottom + viewportOffset;\n\t\t}\n\n\t\t// TODO: Web browsers scroll natively to place the target in the middle\n\t\t// of the viewport. It's not a very popular case, though.\n\t\tif ( isLeftOf( rect, viewportRect ) ) {\n\t\t\tscrollX -= viewportRect.left - rect.left + viewportOffset;\n\t\t} else if ( isRightOf( rect, viewportRect ) ) {\n\t\t\tscrollX += rect.right - viewportRect.right + viewportOffset;\n\t\t}\n\n\t\twindow.scrollTo( scrollX, scrollY );\n\t}\n}\n\n// Recursively scrolls element ancestors to visually reveal a rect.\n//\n// @private\n// @param {HTMLElement} A parent The first ancestors to start scrolling.\n// @param {Function} getRect A function which returns the Rect, which is to be revealed.\nfunction scrollAncestorsToShowRect( parent, getRect ) {\n\tconst parentWindow = getWindow( parent );\n\tlet parentRect, targetRect;\n\n\twhile ( parent != parentWindow.document.body ) {\n\t\ttargetRect = getRect();\n\t\tparentRect = new Rect( parent ).excludeScrollbarsAndBorders();\n\n\t\tif ( !parentRect.contains( targetRect ) ) {\n\t\t\tif ( isAbove( targetRect, parentRect ) ) {\n\t\t\t\tparent.scrollTop -= parentRect.top - targetRect.top;\n\t\t\t} else if ( isBelow( targetRect, parentRect ) ) {\n\t\t\t\tparent.scrollTop += targetRect.bottom - parentRect.bottom;\n\t\t\t}\n\n\t\t\tif ( isLeftOf( targetRect, parentRect ) ) {\n\t\t\t\tparent.scrollLeft -= parentRect.left - targetRect.left;\n\t\t\t} else if ( isRightOf( targetRect, parentRect ) ) {\n\t\t\t\tparent.scrollLeft += targetRect.right - parentRect.right;\n\t\t\t}\n\t\t}\n\n\t\tparent = parent.parentNode;\n\t}\n}\n\n// Determines if a given `Rect` extends beyond the bottom edge of the second `Rect`.\n//\n// @private\n// @param {module:utils/dom/rect~Rect} firstRect\n// @param {module:utils/dom/rect~Rect} secondRect\nfunction isBelow( firstRect, secondRect ) {\n\treturn firstRect.bottom > secondRect.bottom;\n}\n\n// Determines if a given `Rect` extends beyond the top edge of the second `Rect`.\n//\n// @private\n// @param {module:utils/dom/rect~Rect} firstRect\n// @param {module:utils/dom/rect~Rect} secondRect\nfunction isAbove( firstRect, secondRect ) {\n\treturn firstRect.top < secondRect.top;\n}\n\n// Determines if a given `Rect` extends beyond the left edge of the second `Rect`.\n//\n// @private\n// @param {module:utils/dom/rect~Rect} firstRect\n// @param {module:utils/dom/rect~Rect} secondRect\nfunction isLeftOf( firstRect, secondRect ) {\n\treturn firstRect.left < secondRect.left;\n}\n\n// Determines if a given `Rect` extends beyond the right edge of the second `Rect`.\n//\n// @private\n// @param {module:utils/dom/rect~Rect} firstRect\n// @param {module:utils/dom/rect~Rect} secondRect\nfunction isRightOf( firstRect, secondRect ) {\n\treturn firstRect.right > secondRect.right;\n}\n\n// Returns the closest window of an element or range.\n//\n// @private\n// @param {HTMLElement|Range} firstRect\n// @returns {Window}\nfunction getWindow( elementOrRange ) {\n\tif ( isRange( elementOrRange ) ) {\n\t\treturn elementOrRange.startContainer.ownerDocument.defaultView;\n\t} else {\n\t\treturn elementOrRange.ownerDocument.defaultView;\n\t}\n}\n\n// Returns the closest parent of an element or DOM range.\n//\n// @private\n// @param {HTMLElement|Range} firstRect\n// @returns {HTMLelement}\nfunction getParentElement( elementOrRange ) {\n\tif ( isRange( elementOrRange ) ) {\n\t\tlet parent = elementOrRange.commonAncestorContainer;\n\n\t\t// If a Range is attached to the Text, use the closest element ancestor.\n\t\tif ( isText( parent ) ) {\n\t\t\tparent = parent.parentNode;\n\t\t}\n\n\t\treturn parent;\n\t} else {\n\t\treturn elementOrRange.parentNode;\n\t}\n}\n\n// Returns the rect of an element or range residing in an iframe.\n// The result rect is relative to the geometry of the passed window instance.\n//\n// @private\n// @param {HTMLElement|Range} target Element or range which rect should be returned.\n// @param {Window} relativeWindow A window the rect should be relative to.\n// @returns {module:utils/dom/rect~Rect}\nfunction getRectRelativeToWindow( target, relativeWindow ) {\n\tconst targetWindow = getWindow( target );\n\tconst rect = new Rect( target );\n\n\tif ( targetWindow === relativeWindow ) {\n\t\treturn rect;\n\t} else {\n\t\tlet currentWindow = targetWindow;\n\n\t\twhile ( currentWindow != relativeWindow ) {\n\t\t\tconst frame = currentWindow.frameElement;\n\t\t\tconst frameRect = new Rect( frame ).excludeScrollbarsAndBorders();\n\n\t\t\trect.moveBy( frameRect.left, frameRect.top );\n\n\t\t\tcurrentWindow = currentWindow.parent;\n\t\t}\n\t}\n\n\treturn rect;\n}\n"]}]}