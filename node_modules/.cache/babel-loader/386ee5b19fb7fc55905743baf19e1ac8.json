{"remainingRequest":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/babel-loader/lib/index.js!/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-engine/src/view/downcastwriter.js","dependencies":[{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-engine/src/view/downcastwriter.js","mtime":499162500000},{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js","mtime":499162500000},{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/babel-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:LyoqCiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDE5LCBDS1NvdXJjZSAtIEZyZWRlcmljbyBLbmFiYmVuLiBBbGwgcmlnaHRzIHJlc2VydmVkLgogKiBGb3IgbGljZW5zaW5nLCBzZWUgTElDRU5TRS5tZCBvciBodHRwczovL2NrZWRpdG9yLmNvbS9sZWdhbC9ja2VkaXRvci1vc3MtbGljZW5zZQogKi8KCi8qKgogKiBAbW9kdWxlIG1vZHVsZTplbmdpbmUvdmlldy9kb3duY2FzdHdyaXRlcgogKi8KaW1wb3J0IFBvc2l0aW9uIGZyb20gJy4vcG9zaXRpb24nOwppbXBvcnQgUmFuZ2UgZnJvbSAnLi9yYW5nZSc7CmltcG9ydCBTZWxlY3Rpb24gZnJvbSAnLi9zZWxlY3Rpb24nOwppbXBvcnQgQ29udGFpbmVyRWxlbWVudCBmcm9tICcuL2NvbnRhaW5lcmVsZW1lbnQnOwppbXBvcnQgQXR0cmlidXRlRWxlbWVudCBmcm9tICcuL2F0dHJpYnV0ZWVsZW1lbnQnOwppbXBvcnQgRW1wdHlFbGVtZW50IGZyb20gJy4vZW1wdHllbGVtZW50JzsKaW1wb3J0IFVJRWxlbWVudCBmcm9tICcuL3VpZWxlbWVudCc7CmltcG9ydCBDS0VkaXRvckVycm9yIGZyb20gJ0Bja2VkaXRvci9ja2VkaXRvcjUtdXRpbHMvc3JjL2NrZWRpdG9yZXJyb3InOwppbXBvcnQgRG9jdW1lbnRGcmFnbWVudCBmcm9tICcuL2RvY3VtZW50ZnJhZ21lbnQnOwppbXBvcnQgaXNJdGVyYWJsZSBmcm9tICdAY2tlZGl0b3IvY2tlZGl0b3I1LXV0aWxzL3NyYy9pc2l0ZXJhYmxlJzsKaW1wb3J0IFRleHQgZnJvbSAnLi90ZXh0JzsKaW1wb3J0IEVkaXRhYmxlRWxlbWVudCBmcm9tICcuL2VkaXRhYmxlZWxlbWVudCc7CmltcG9ydCB7IGlzUGxhaW5PYmplY3QgfSBmcm9tICdsb2Rhc2gtZXMnOwovKioKICogVmlldyBkb3duY2FzdCB3cml0ZXIuCiAqCiAqIEl0IHByb3ZpZGVzIGEgc2V0IG9mIG1ldGhvZHMgdXNlZCB0byBtYW5pcHVsYXRlIHZpZXcgbm9kZXMuCiAqCiAqIERvIG5vdCBjcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyB3cml0ZXIgbWFudWFsbHkuIFRvIG1vZGlmeSBhIHZpZXcgc3RydWN0dXJlLCB1c2UKICogdGhlIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdmlld35WaWV3I2NoYW5nZSBgVmlldyNjaGFuZ2UoKWB9IGJsb2NrLgogKgogKiBUaGUgYERvd25jYXN0V3JpdGVyYCBpcyBkZXNpZ25lZCB0byB3b3JrIHdpdGggc2VtYW50aWMgdmlld3Mgd2hpY2ggYXJlIHRoZSB2aWV3cyB0aGF0IHdlcmUvYXJlIGJlaW5nIGRvd25jYXN0ZWQgZnJvbSB0aGUgbW9kZWwuCiAqIFRvIHdvcmsgd2l0aCBvcmRpbmFyeSB2aWV3cyAoZS5nLiBwYXJzZWQgZnJvbSBhIHBhc3RlZCBjb250ZW50KSB1c2UgdGhlCiAqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdXBjYXN0d3JpdGVyflVwY2FzdFdyaXRlciB1cGNhc3Qgd3JpdGVyfS4KICoKICogUmVhZCBtb3JlIGFib3V0IGNoYW5naW5nIHRoZSB2aWV3IGluIHRoZSB7QGdsaW5rIGZyYW1ld29yay9ndWlkZXMvYXJjaGl0ZWN0dXJlL2VkaXRpbmctZW5naW5lI2NoYW5naW5nLXRoZS12aWV3IENoYW5naW5nIHRoZSB2aWV3fQogKiBzZWN0aW9uIG9mIHRoZSB7QGdsaW5rIGZyYW1ld29yay9ndWlkZXMvYXJjaGl0ZWN0dXJlL2VkaXRpbmctZW5naW5lIEVkaXRpbmcgZW5naW5lIGFyY2hpdGVjdHVyZX0gZ3VpZGUuCiAqLwoKZXhwb3J0IGRlZmF1bHQgY2xhc3MgRG93bmNhc3RXcml0ZXIgewogIGNvbnN0cnVjdG9yKGRvY3VtZW50KSB7CiAgICAvKioKICAgICAqIEByZWFkb25seQogICAgICogQHR5cGUge21vZHVsZTplbmdpbmUvdmlldy9kb2N1bWVudH5Eb2N1bWVudH0KICAgICAqLwogICAgdGhpcy5kb2N1bWVudCA9IGRvY3VtZW50OwogICAgLyoqCiAgICAgKiBIb2xkcyByZWZlcmVuY2VzIHRvIHRoZSBhdHRyaWJ1dGUgZ3JvdXBzIHRoYXQgc2hhcmUgdGhlIHNhbWUge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9hdHRyaWJ1dGVlbGVtZW50fkF0dHJpYnV0ZUVsZW1lbnQjaWQgaWR9LgogICAgICogVGhlIGtleXMgYXJlIGBpZGBzLCB0aGUgdmFsdWVzIGFyZSBgU2V0YHMgaG9sZGluZyB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2F0dHJpYnV0ZWVsZW1lbnR+QXR0cmlidXRlRWxlbWVudH1zLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAdHlwZSB7TWFwLjxTdHJpbmcsU2V0Pn0KICAgICAqLwoKICAgIHRoaXMuX2Nsb25lR3JvdXBzID0gbmV3IE1hcCgpOwogIH0KICAvKioKICAgKiBTZXRzIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZG9jdW1lbnRzZWxlY3Rpb25+RG9jdW1lbnRTZWxlY3Rpb24gc2VsZWN0aW9uJ3N9IHJhbmdlcyBhbmQgZGlyZWN0aW9uIHRvIHRoZQogICAqIHNwZWNpZmllZCBsb2NhdGlvbiBiYXNlZCBvbiB0aGUgZ2l2ZW4ge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9zZWxlY3Rpb25+U2VsZWN0YWJsZSBzZWxlY3RhYmxlfS4KICAgKgogICAqIFVzYWdlOgogICAqCiAgICoJCS8vIFNldHMgc2VsZWN0aW9uIHRvIHRoZSBnaXZlbiByYW5nZS4KICAgKgkJY29uc3QgcmFuZ2UgPSB3cml0ZXIuY3JlYXRlUmFuZ2UoIHN0YXJ0LCBlbmQgKTsKICAgKgkJd3JpdGVyLnNldFNlbGVjdGlvbiggcmFuZ2UgKTsKICAgKgogICAqCQkvLyBTZXRzIGJhY2t3YXJkIHNlbGVjdGlvbiB0byB0aGUgZ2l2ZW4gcmFuZ2UuCiAgICoJCWNvbnN0IHJhbmdlID0gd3JpdGVyLmNyZWF0ZVJhbmdlKCBzdGFydCwgZW5kICk7CiAgICoJCXdyaXRlci5zZXRTZWxlY3Rpb24oIHJhbmdlICk7CiAgICoKICAgKgkJLy8gU2V0cyBzZWxlY3Rpb24gdG8gZ2l2ZW4gcmFuZ2VzLgogICAqIAkJY29uc3QgcmFuZ2VzID0gWyB3cml0ZXIuY3JlYXRlUmFuZ2UoIHN0YXJ0MSwgZW5kMiApLCB3cml0ZXIuY3JlYXRlUmFuZ2UoIHN0YXJ0MiwgZW5kMiApIF07CiAgICoJCXdyaXRlci5zZXRTZWxlY3Rpb24oIHJhbmdlICk7CiAgICoKICAgKgkJLy8gU2V0cyBzZWxlY3Rpb24gdG8gdGhlIG90aGVyIHNlbGVjdGlvbi4KICAgKgkJY29uc3Qgb3RoZXJTZWxlY3Rpb24gPSB3cml0ZXIuY3JlYXRlU2VsZWN0aW9uKCk7CiAgICoJCXdyaXRlci5zZXRTZWxlY3Rpb24oIG90aGVyU2VsZWN0aW9uICk7CiAgICoKICAgKiAJCS8vIFNldHMgY29sbGFwc2VkIHNlbGVjdGlvbiBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uCiAgICoJCWNvbnN0IHBvc2l0aW9uID0gd3JpdGVyLmNyZWF0ZVBvc2l0aW9uRnJvbVBhdGgoIHJvb3QsIHBhdGggKTsKICAgKgkJd3JpdGVyLnNldFNlbGVjdGlvbiggcG9zaXRpb24gKTsKICAgKgogICAqIAkJLy8gU2V0cyBjb2xsYXBzZWQgc2VsZWN0aW9uIGF0IHRoZSBwb3NpdGlvbiBvZiBnaXZlbiBpdGVtIGFuZCBvZmZzZXQuCiAgICoJCWNvbnN0IHBhcmFncmFwaCA9IHdyaXRlci5jcmVhdGVDb250YWluZXJFbGVtZW50KCAncCcgKTsKICAgKgkJd3JpdGVyLnNldFNlbGVjdGlvbiggcGFyYWdyYXBoLCBvZmZzZXQgKTsKICAgKgogICAqIENyZWF0ZXMgYSByYW5nZSBpbnNpZGUgYW4ge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnQgZWxlbWVudH0gd2hpY2ggc3RhcnRzIGJlZm9yZSB0aGUgZmlyc3QgY2hpbGQgb2YKICAJICogdGhhdCBlbGVtZW50IGFuZCBlbmRzIGFmdGVyIHRoZSBsYXN0IGNoaWxkIG9mIHRoYXQgZWxlbWVudC4KICAgKgogICAqIAkJd3JpdGVyLnNldFNlbGVjdGlvbiggcGFyYWdyYXBoLCAnaW4nICk7CiAgICoKICAgKiBDcmVhdGVzIGEgcmFuZ2Ugb24gdGhlIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvaXRlbX5JdGVtIGl0ZW19IHdoaWNoIHN0YXJ0cyBiZWZvcmUgdGhlIGl0ZW0gYW5kIGVuZHMganVzdCBhZnRlciB0aGUgaXRlbS4KICAgKgogICAqCQl3cml0ZXIuc2V0U2VsZWN0aW9uKCBwYXJhZ3JhcGgsICdvbicgKTsKICAgKgogICAqIAkJLy8gUmVtb3ZlcyBhbGwgcmFuZ2VzLgogICAqCQl3cml0ZXIuc2V0U2VsZWN0aW9uKCBudWxsICk7CiAgICoKICAgKiBgRG93bmNhc3RXcml0ZXIjc2V0U2VsZWN0aW9uKClgIGFsbG93IHBhc3NpbmcgYWRkaXRpb25hbCBvcHRpb25zIChgYmFja3dhcmRgLCBgZmFrZWAgYW5kIGBsYWJlbGApIGFzIHRoZSBsYXN0IGFyZ3VtZW50LgogICAqCiAgICoJCS8vIFNldHMgc2VsZWN0aW9uIGFzIGJhY2t3YXJkLgogICAqCQl3cml0ZXIuc2V0U2VsZWN0aW9uKCByYW5nZSwgeyBiYWNrd2FyZDogdHJ1ZSB9ICk7CiAgICoKICAgKgkJLy8gU2V0cyBzZWxlY3Rpb24gYXMgZmFrZS4KICAgKgkJLy8gRmFrZSBzZWxlY3Rpb24gZG9lcyBub3QgcmVuZGVyIGFzIGJyb3dzZXIgbmF0aXZlIHNlbGVjdGlvbiBvdmVyIHNlbGVjdGVkIGVsZW1lbnRzIGFuZCBpcyBoaWRkZW4gdG8gdGhlIHVzZXIuCiAgICogCQkvLyBUaGlzIHdheSwgbm8gbmF0aXZlIHNlbGVjdGlvbiBVSSBhcnRpZmFjdHMgYXJlIGRpc3BsYXllZCB0byB0aGUgdXNlciBhbmQgc2VsZWN0aW9uIG92ZXIgZWxlbWVudHMgY2FuIGJlCiAgICogCQkvLyByZXByZXNlbnRlZCBpbiBvdGhlciB3YXksIGZvciBleGFtcGxlIGJ5IGFwcGx5aW5nIHByb3BlciBDU1MgY2xhc3MuCiAgICoJCXdyaXRlci5zZXRTZWxlY3Rpb24oIHJhbmdlLCB7IGZha2U6IHRydWUgfSApOwogICAqCiAgICogCQkvLyBBZGRpdGlvbmFsbHkgZmFrZSdzIHNlbGVjdGlvbiBsYWJlbCBjYW4gYmUgcHJvdmlkZWQuIEl0IHdpbGwgYmUgdXNlZCB0byBkZXNjcmliZSBmYWtlIHNlbGVjdGlvbiBpbiBET00KICAgKiAJCS8vIChhbmQgYmUgIHByb3Blcmx5IGhhbmRsZWQgYnkgc2NyZWVuIHJlYWRlcnMpLgogICAqCQl3cml0ZXIuc2V0U2VsZWN0aW9uKCByYW5nZSwgeyBmYWtlOiB0cnVlLCBsYWJlbDogJ2ZvbycgfSApOwogICAqCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvc2VsZWN0aW9uflNlbGVjdGFibGV9IHNlbGVjdGFibGUKICAgKiBAcGFyYW0ge051bWJlcnwnYmVmb3JlJ3wnZW5kJ3wnYWZ0ZXInfCdvbid8J2luJ30gW3BsYWNlT3JPZmZzZXRdIFNldHMgcGxhY2Ugb3Igb2Zmc2V0IG9mIHRoZSBzZWxlY3Rpb24uCiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXQogICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYmFja3dhcmRdIFNldHMgdGhpcyBzZWxlY3Rpb24gaW5zdGFuY2UgdG8gYmUgYmFja3dhcmQuCiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5mYWtlXSBTZXRzIHRoaXMgc2VsZWN0aW9uIGluc3RhbmNlIHRvIGJlIG1hcmtlZCBhcyBgZmFrZWAuCiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmxhYmVsXSBMYWJlbCBmb3IgdGhlIGZha2Ugc2VsZWN0aW9uLgogICAqLwoKCiAgc2V0U2VsZWN0aW9uKHNlbGVjdGFibGUsIHBsYWNlT3JPZmZzZXQsIG9wdGlvbnMpIHsKICAgIHRoaXMuZG9jdW1lbnQuc2VsZWN0aW9uLl9zZXRUbyhzZWxlY3RhYmxlLCBwbGFjZU9yT2Zmc2V0LCBvcHRpb25zKTsKICB9CiAgLyoqCiAgICogTW92ZXMge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9kb2N1bWVudHNlbGVjdGlvbn5Eb2N1bWVudFNlbGVjdGlvbiNmb2N1cyBzZWxlY3Rpb24ncyBmb2N1c30gdG8gdGhlIHNwZWNpZmllZCBsb2NhdGlvbi4KICAgKgogICAqIFRoZSBsb2NhdGlvbiBjYW4gYmUgc3BlY2lmaWVkIGluIHRoZSBzYW1lIGZvcm0gYXMge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy92aWV3flZpZXcjY3JlYXRlUG9zaXRpb25BdCB2aWV3LmNyZWF0ZVBvc2l0aW9uQXQoKX0KICAgKiBwYXJhbWV0ZXJzLgogICAqCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvaXRlbX5JdGVtfG1vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbn0gaXRlbU9yUG9zaXRpb24KICAgKiBAcGFyYW0ge051bWJlcnwnZW5kJ3wnYmVmb3JlJ3wnYWZ0ZXInfSBbb2Zmc2V0XSBPZmZzZXQgb3Igb25lIG9mIHRoZSBmbGFncy4gVXNlZCBvbmx5IHdoZW4KICAgKiBmaXJzdCBwYXJhbWV0ZXIgaXMgYSB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2l0ZW1+SXRlbSB2aWV3IGl0ZW19LgogICAqLwoKCiAgc2V0U2VsZWN0aW9uRm9jdXMoaXRlbU9yUG9zaXRpb24sIG9mZnNldCkgewogICAgdGhpcy5kb2N1bWVudC5zZWxlY3Rpb24uX3NldEZvY3VzKGl0ZW1PclBvc2l0aW9uLCBvZmZzZXQpOwogIH0KICAvKioKICAgKiBDcmVhdGVzIGEgbmV3IHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdGV4dH5UZXh0IHRleHQgbm9kZX0uCiAgICoKICAgKgkJd3JpdGVyLmNyZWF0ZVRleHQoICdmb28nICk7CiAgICoKICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YSBUaGUgdGV4dCdzIGRhdGEuCiAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy90ZXh0flRleHR9IFRoZSBjcmVhdGVkIHRleHQgbm9kZS4KICAgKi8KCgogIGNyZWF0ZVRleHQoZGF0YSkgewogICAgcmV0dXJuIG5ldyBUZXh0KGRhdGEpOwogIH0KICAvKioKICAgKiBDcmVhdGVzIG5ldyB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2F0dHJpYnV0ZWVsZW1lbnR+QXR0cmlidXRlRWxlbWVudH0uCiAgICoKICAgKgkJd3JpdGVyLmNyZWF0ZUF0dHJpYnV0ZUVsZW1lbnQoICdzdHJvbmcnICk7CiAgICoJCXdyaXRlci5jcmVhdGVBdHRyaWJ1dGVFbGVtZW50KCAnYScsIHsgaHJlZjogJ2Zvby5iYXInIH0gKTsKICAgKgogICAqCQkvLyBNYWtlIGA8YT5gIGVsZW1lbnQgY29udGFpbiBvdGhlciBhdHRyaWJ1dGVzIGVsZW1lbnQgc28gdGhlIGA8YT5gIGVsZW1lbnQgaXMgbm90IGJyb2tlbi4KICAgKgkJd3JpdGVyLmNyZWF0ZUF0dHJpYnV0ZUVsZW1lbnQoICdhJywgeyBocmVmOiAnZm9vLmJhcicgfSwgeyBwcmlvcml0eTogNSB9ICk7CiAgICoKICAgKgkJLy8gU2V0IGBpZGAgb2YgYSBtYXJrZXIgZWxlbWVudCBzbyBpdCBpcyBub3Qgam9pbmVkIG9yIG1lcmdlZCB3aXRoICJub3JtYWwiIGVsZW1lbnRzLgogICAqCQl3cml0ZXIuY3JlYXRlQXR0cmlidXRlRWxlbWVudCggJ3NwYW4nLCB7IGNsYXNzOiAnbXktbWFya2VyJyB9LCB7IGlkOiAnbWFya2VyOm15JyB9ICk7CiAgICoKICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBOYW1lIG9mIHRoZSBlbGVtZW50LgogICAqIEBwYXJhbSB7T2JqZWN0fSBbYXR0cmlidXRlc10gRWxlbWVudCdzIGF0dHJpYnV0ZXMuCiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBFbGVtZW50J3Mgb3B0aW9ucy4KICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucHJpb3JpdHldIEVsZW1lbnQncyB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2F0dHJpYnV0ZWVsZW1lbnR+QXR0cmlidXRlRWxlbWVudCNwcmlvcml0eSBwcmlvcml0eX0uCiAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBbb3B0aW9ucy5pZF0gRWxlbWVudCdzIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvYXR0cmlidXRlZWxlbWVudH5BdHRyaWJ1dGVFbGVtZW50I2lkIGlkfS4KICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS92aWV3L2F0dHJpYnV0ZWVsZW1lbnR+QXR0cmlidXRlRWxlbWVudH0gQ3JlYXRlZCBlbGVtZW50LgogICAqLwoKCiAgY3JlYXRlQXR0cmlidXRlRWxlbWVudChuYW1lLCBhdHRyaWJ1dGVzLCBvcHRpb25zID0ge30pIHsKICAgIGNvbnN0IGF0dHJpYnV0ZUVsZW1lbnQgPSBuZXcgQXR0cmlidXRlRWxlbWVudChuYW1lLCBhdHRyaWJ1dGVzKTsKCiAgICBpZiAob3B0aW9ucy5wcmlvcml0eSkgewogICAgICBhdHRyaWJ1dGVFbGVtZW50Ll9wcmlvcml0eSA9IG9wdGlvbnMucHJpb3JpdHk7CiAgICB9CgogICAgaWYgKG9wdGlvbnMuaWQpIHsKICAgICAgYXR0cmlidXRlRWxlbWVudC5faWQgPSBvcHRpb25zLmlkOwogICAgfQoKICAgIHJldHVybiBhdHRyaWJ1dGVFbGVtZW50OwogIH0KICAvKioKICAgKiBDcmVhdGVzIG5ldyB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2NvbnRhaW5lcmVsZW1lbnR+Q29udGFpbmVyRWxlbWVudH0uCiAgICoKICAgKgkJd3JpdGVyLmNyZWF0ZUNvbnRhaW5lckVsZW1lbnQoICdwJyApOwogICAqCiAgICoJCS8vIENyZWF0ZSBlbGVtZW50IHdpdGggY3VzdG9tIGF0dHJpYnV0ZXMuCiAgICoJCXdyaXRlci5jcmVhdGVDb250YWluZXJFbGVtZW50KCAnZGl2JywgeyBpZDogJ2Zvby1iYXInLCAnZGF0YS1iYXonOiAnMTIzJyB9ICk7CiAgICoKICAgKgkJLy8gQ3JlYXRlIGVsZW1lbnQgd2l0aCBjdXN0b20gc3R5bGVzLgogICAqCQl3cml0ZXIuY3JlYXRlQ29udGFpbmVyRWxlbWVudCggJ3AnLCB7IHN0eWxlOiAnZm9udC13ZWlnaHQ6IGJvbGQ7IHBhZGRpbmctYm90dG9tOiAxMHB4JyB9ICk7CiAgICoKICAgKgkJLy8gQ3JlYXRlIGVsZW1lbnQgd2l0aCBjdXN0b20gY2xhc3Nlcy4KICAgKgkJd3JpdGVyLmNyZWF0ZUNvbnRhaW5lckVsZW1lbnQoICdwJywgeyBjbGFzczogJ2ZvbyBiYXIgYmF6JyB9ICk7CiAgICoKICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBOYW1lIG9mIHRoZSBlbGVtZW50LgogICAqIEBwYXJhbSB7T2JqZWN0fSBbYXR0cmlidXRlc10gRWxlbWVudHMgYXR0cmlidXRlcy4KICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS92aWV3L2NvbnRhaW5lcmVsZW1lbnR+Q29udGFpbmVyRWxlbWVudH0gQ3JlYXRlZCBlbGVtZW50LgogICAqLwoKCiAgY3JlYXRlQ29udGFpbmVyRWxlbWVudChuYW1lLCBhdHRyaWJ1dGVzKSB7CiAgICByZXR1cm4gbmV3IENvbnRhaW5lckVsZW1lbnQobmFtZSwgYXR0cmlidXRlcyk7CiAgfQogIC8qKgogICAqIENyZWF0ZXMgbmV3IHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZWRpdGFibGVlbGVtZW50fkVkaXRhYmxlRWxlbWVudH0uCiAgICoKICAgKgkJd3JpdGVyLmNyZWF0ZUVkaXRhYmxlRWxlbWVudCggJ2RpdicgKTsKICAgKgkJd3JpdGVyLmNyZWF0ZUVkaXRhYmxlRWxlbWVudCggJ2RpdicsIHsgaWQ6ICdmb28tMTIzNCcgfSApOwogICAqCiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgTmFtZSBvZiB0aGUgZWxlbWVudC4KICAgKiBAcGFyYW0ge09iamVjdH0gW2F0dHJpYnV0ZXNdIEVsZW1lbnRzIGF0dHJpYnV0ZXMuCiAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy9lZGl0YWJsZWVsZW1lbnR+RWRpdGFibGVFbGVtZW50fSBDcmVhdGVkIGVsZW1lbnQuCiAgICovCgoKICBjcmVhdGVFZGl0YWJsZUVsZW1lbnQobmFtZSwgYXR0cmlidXRlcykgewogICAgY29uc3QgZWRpdGFibGVFbGVtZW50ID0gbmV3IEVkaXRhYmxlRWxlbWVudChuYW1lLCBhdHRyaWJ1dGVzKTsKICAgIGVkaXRhYmxlRWxlbWVudC5fZG9jdW1lbnQgPSB0aGlzLmRvY3VtZW50OwogICAgcmV0dXJuIGVkaXRhYmxlRWxlbWVudDsKICB9CiAgLyoqCiAgICogQ3JlYXRlcyBuZXcge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9lbXB0eWVsZW1lbnR+RW1wdHlFbGVtZW50fS4KICAgKgogICAqCQl3cml0ZXIuY3JlYXRlRW1wdHlFbGVtZW50KCAnaW1nJyApOwogICAqCQl3cml0ZXIuY3JlYXRlRW1wdHlFbGVtZW50KCAnaW1nJywgeyBpZDogJ2Zvby0xMjM0JyB9ICk7CiAgICoKICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBOYW1lIG9mIHRoZSBlbGVtZW50LgogICAqIEBwYXJhbSB7T2JqZWN0fSBbYXR0cmlidXRlc10gRWxlbWVudHMgYXR0cmlidXRlcy4KICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS92aWV3L2VtcHR5ZWxlbWVudH5FbXB0eUVsZW1lbnR9IENyZWF0ZWQgZWxlbWVudC4KICAgKi8KCgogIGNyZWF0ZUVtcHR5RWxlbWVudChuYW1lLCBhdHRyaWJ1dGVzKSB7CiAgICByZXR1cm4gbmV3IEVtcHR5RWxlbWVudChuYW1lLCBhdHRyaWJ1dGVzKTsKICB9CiAgLyoqCiAgICogQ3JlYXRlcyBuZXcge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy91aWVsZW1lbnR+VUlFbGVtZW50fS4KICAgKgogICAqCQl3cml0ZXIuY3JlYXRlVUlFbGVtZW50KCAnc3BhbicgKTsKICAgKgkJd3JpdGVyLmNyZWF0ZVVJRWxlbWVudCggJ3NwYW4nLCB7IGlkOiAnZm9vLTEyMzQnIH0gKTsKICAgKgogICAqIEN1c3RvbSByZW5kZXIgZnVuY3Rpb24gY2FuIGJlIHByb3ZpZGVkIGFzIHRoaXJkIHBhcmFtZXRlcjoKICAgKgogICAqCQl3cml0ZXIuY3JlYXRlVUlFbGVtZW50KCAnc3BhbicsIG51bGwsIGZ1bmN0aW9uKCBkb21Eb2N1bWVudCApIHsKICAgKgkJCWNvbnN0IGRvbUVsZW1lbnQgPSB0aGlzLnRvRG9tRWxlbWVudCggZG9tRG9jdW1lbnQgKTsKICAgKgkJCWRvbUVsZW1lbnQuaW5uZXJIVE1MID0gJzxiPnRoaXMgaXMgdWkgZWxlbWVudDwvYj4nOwogICAqCiAgICoJCQlyZXR1cm4gZG9tRWxlbWVudDsKICAgKgkJfSApOwogICAqCiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgTmFtZSBvZiB0aGUgZWxlbWVudC4KICAgKiBAcGFyYW0ge09iamVjdH0gW2F0dHJpYnV0ZXNdIEVsZW1lbnRzIGF0dHJpYnV0ZXMuCiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3JlbmRlckZ1bmN0aW9uXSBDdXN0b20gcmVuZGVyIGZ1bmN0aW9uLgogICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL3ZpZXcvdWllbGVtZW50flVJRWxlbWVudH0gQ3JlYXRlZCBlbGVtZW50LgogICAqLwoKCiAgY3JlYXRlVUlFbGVtZW50KG5hbWUsIGF0dHJpYnV0ZXMsIHJlbmRlckZ1bmN0aW9uKSB7CiAgICBjb25zdCB1aUVsZW1lbnQgPSBuZXcgVUlFbGVtZW50KG5hbWUsIGF0dHJpYnV0ZXMpOwoKICAgIGlmIChyZW5kZXJGdW5jdGlvbikgewogICAgICB1aUVsZW1lbnQucmVuZGVyID0gcmVuZGVyRnVuY3Rpb247CiAgICB9CgogICAgcmV0dXJuIHVpRWxlbWVudDsKICB9CiAgLyoqCiAgICogQWRkcyBvciBvdmVyd3JpdGUgZWxlbWVudCdzIGF0dHJpYnV0ZSB3aXRoIGEgc3BlY2lmaWVkIGtleSBhbmQgdmFsdWUuCiAgICoKICAgKgkJd3JpdGVyLnNldEF0dHJpYnV0ZSggJ2hyZWYnLCAnaHR0cDovL2NrZWRpdG9yLmNvbScsIGxpbmtFbGVtZW50ICk7CiAgICoKICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IEF0dHJpYnV0ZSBrZXkuCiAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIEF0dHJpYnV0ZSB2YWx1ZS4KICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnR9IGVsZW1lbnQKICAgKi8KCgogIHNldEF0dHJpYnV0ZShrZXksIHZhbHVlLCBlbGVtZW50KSB7CiAgICBlbGVtZW50Ll9zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7CiAgfQogIC8qKgogICAqIFJlbW92ZXMgYXR0cmlidXRlIGZyb20gdGhlIGVsZW1lbnQuCiAgICoKICAgKgkJd3JpdGVyLnJlbW92ZUF0dHJpYnV0ZSggJ2hyZWYnLCBsaW5rRWxlbWVudCApOwogICAqCiAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBBdHRyaWJ1dGUga2V5LgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudH0gZWxlbWVudAogICAqLwoKCiAgcmVtb3ZlQXR0cmlidXRlKGtleSwgZWxlbWVudCkgewogICAgZWxlbWVudC5fcmVtb3ZlQXR0cmlidXRlKGtleSk7CiAgfQogIC8qKgogICAqIEFkZHMgc3BlY2lmaWVkIGNsYXNzIHRvIHRoZSBlbGVtZW50LgogICAqCiAgICoJCXdyaXRlci5hZGRDbGFzcyggJ2ZvbycsIGxpbmtFbGVtZW50ICk7CiAgICoJCXdyaXRlci5hZGRDbGFzcyggWyAnZm9vJywgJ2JhcicgXSwgbGlua0VsZW1lbnQgKTsKICAgKgogICAqIEBwYXJhbSB7QXJyYXkuPFN0cmluZz58U3RyaW5nfSBjbGFzc05hbWUKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnR9IGVsZW1lbnQKICAgKi8KCgogIGFkZENsYXNzKGNsYXNzTmFtZSwgZWxlbWVudCkgewogICAgZWxlbWVudC5fYWRkQ2xhc3MoY2xhc3NOYW1lKTsKICB9CiAgLyoqCiAgICogUmVtb3ZlcyBzcGVjaWZpZWQgY2xhc3MgZnJvbSB0aGUgZWxlbWVudC4KICAgKgogICAqCQl3cml0ZXIucmVtb3ZlQ2xhc3MoICdmb28nLCBsaW5rRWxlbWVudCApOwogICAqCQl3cml0ZXIucmVtb3ZlQ2xhc3MoIFsgJ2ZvbycsICdiYXInIF0sIGxpbmtFbGVtZW50ICk7CiAgICoKICAgKiBAcGFyYW0ge0FycmF5LjxTdHJpbmc+fFN0cmluZ30gY2xhc3NOYW1lCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50fSBlbGVtZW50CiAgICovCgoKICByZW1vdmVDbGFzcyhjbGFzc05hbWUsIGVsZW1lbnQpIHsKICAgIGVsZW1lbnQuX3JlbW92ZUNsYXNzKGNsYXNzTmFtZSk7CiAgfQogIC8qKgogICAqIEFkZHMgc3R5bGUgdG8gdGhlIGVsZW1lbnQuCiAgICoKICAgKgkJd3JpdGVyLnNldFN0eWxlKCAnY29sb3InLCAncmVkJywgZWxlbWVudCApOwogICAqCQl3cml0ZXIuc2V0U3R5bGUoIHsKICAgKgkJCWNvbG9yOiAncmVkJywKICAgKgkJCXBvc2l0aW9uOiAnZml4ZWQnCiAgICoJCX0sIGVsZW1lbnQgKTsKICAgKgogICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gcHJvcGVydHkgUHJvcGVydHkgbmFtZSBvciBvYmplY3Qgd2l0aCBrZXkgLSB2YWx1ZSBwYWlycy4KICAgKiBAcGFyYW0ge1N0cmluZ30gW3ZhbHVlXSBWYWx1ZSB0byBzZXQuIFRoaXMgcGFyYW1ldGVyIGlzIGlnbm9yZWQgaWYgb2JqZWN0IGlzIHByb3ZpZGVkIGFzIHRoZSBmaXJzdCBwYXJhbWV0ZXIuCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gc2V0IHN0eWxlcyBvbi4KICAgKi8KCgogIHNldFN0eWxlKHByb3BlcnR5LCB2YWx1ZSwgZWxlbWVudCkgewogICAgaWYgKGlzUGxhaW5PYmplY3QocHJvcGVydHkpICYmIGVsZW1lbnQgPT09IHVuZGVmaW5lZCkgewogICAgICBlbGVtZW50ID0gdmFsdWU7CiAgICB9CgogICAgZWxlbWVudC5fc2V0U3R5bGUocHJvcGVydHksIHZhbHVlKTsKICB9CiAgLyoqCiAgICogUmVtb3ZlcyBzcGVjaWZpZWQgc3R5bGUgZnJvbSB0aGUgZWxlbWVudC4KICAgKgogICAqCQl3cml0ZXIucmVtb3ZlU3R5bGUoICdjb2xvcicsIGVsZW1lbnQgKTsgIC8vIFJlbW92ZXMgJ2NvbG9yJyBzdHlsZS4KICAgKgkJd3JpdGVyLnJlbW92ZVN0eWxlKCBbICdjb2xvcicsICdib3JkZXItdG9wJyBdLCBlbGVtZW50ICk7IC8vIFJlbW92ZXMgYm90aCAnY29sb3InIGFuZCAnYm9yZGVyLXRvcCcgc3R5bGVzLgogICAqCiAgICogQHBhcmFtIHtBcnJheS48U3RyaW5nPnxTdHJpbmd9IHByb3BlcnR5CiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50fSBlbGVtZW50CiAgICovCgoKICByZW1vdmVTdHlsZShwcm9wZXJ0eSwgZWxlbWVudCkgewogICAgZWxlbWVudC5fcmVtb3ZlU3R5bGUocHJvcGVydHkpOwogIH0KICAvKioKICAgKiBTZXRzIGEgY3VzdG9tIHByb3BlcnR5IG9uIGVsZW1lbnQuIFVubGlrZSBhdHRyaWJ1dGVzLCBjdXN0b20gcHJvcGVydGllcyBhcmUgbm90IHJlbmRlcmVkIHRvIHRoZSBET00sCiAgICogc28gdGhleSBjYW4gYmUgdXNlZCB0byBhZGQgc3BlY2lhbCBkYXRhIHRvIGVsZW1lbnRzLgogICAqCiAgICogQHBhcmFtIHtTdHJpbmd8U3ltYm9sfSBrZXkKICAgKiBAcGFyYW0geyp9IHZhbHVlCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50fSBlbGVtZW50CiAgICovCgoKICBzZXRDdXN0b21Qcm9wZXJ0eShrZXksIHZhbHVlLCBlbGVtZW50KSB7CiAgICBlbGVtZW50Ll9zZXRDdXN0b21Qcm9wZXJ0eShrZXksIHZhbHVlKTsKICB9CiAgLyoqCiAgICogUmVtb3ZlcyBhIGN1c3RvbSBwcm9wZXJ0eSBzdG9yZWQgdW5kZXIgdGhlIGdpdmVuIGtleS4KICAgKgogICAqIEBwYXJhbSB7U3RyaW5nfFN5bWJvbH0ga2V5CiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50fSBlbGVtZW50CiAgICogQHJldHVybnMge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiBwcm9wZXJ0eSB3YXMgcmVtb3ZlZC4KICAgKi8KCgogIHJlbW92ZUN1c3RvbVByb3BlcnR5KGtleSwgZWxlbWVudCkgewogICAgcmV0dXJuIGVsZW1lbnQuX3JlbW92ZUN1c3RvbVByb3BlcnR5KGtleSk7CiAgfQogIC8qKgogICAqIEJyZWFrcyBhdHRyaWJ1dGUgbm9kZXMgYXQgcHJvdmlkZWQgcG9zaXRpb24gb3IgYXQgYm91bmRhcmllcyBvZiBwcm92aWRlZCByYW5nZS4gSXQgYnJlYWtzIGF0dHJpYnV0ZSBlbGVtZW50cyBpbnNpZGUKICAgKiB1cCB0byBhIGNvbnRhaW5lciBlbGVtZW50LgogICAqCiAgICogSW4gZm9sbG93aW5nIGV4YW1wbGVzIGA8cD5gIGlzIGEgY29udGFpbmVyLCBgPGI+YCBhbmQgYDx1PmAgYXJlIGF0dHJpYnV0ZSBub2RlczoKICAgKgogICAqCQk8cD5mb288Yj48dT5iYXJ7fTwvdT48L2I+PC9wPiAtPiA8cD5mb288Yj48dT5iYXI8L3U+PC9iPltdPC9wPgogICAqCQk8cD5mb288Yj48dT57fWJhcjwvdT48L2I+PC9wPiAtPiA8cD5mb297fTxiPjx1PmJhcjwvdT48L2I+PC9wPgogICAqCQk8cD5mb288Yj48dT5ie31hcjwvdT48L2I+PC9wPiAtPiA8cD5mb288Yj48dT5iPC91PjwvYj5bXTxiPjx1PmFyPC91PjwvYj48L3A+CiAgICoJCTxwPjxiPmZve288L2I+PHU+YmF9cjwvdT48L3A+IC0+IDxwPjxiPmZvPC9iPjxiPm88L2I+PHU+YmE8L3U+PHU+cjwvdT48L2I+PC9wPgogICAqCiAgICogKipOb3RlOioqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50IERvY3VtZW50RnJhZ21lbnR9IGlzIHRyZWF0ZWQgbGlrZSBhIGNvbnRhaW5lci4KICAgKgogICAqICoqTm90ZToqKiBEaWZmZXJlbmNlIGJldHdlZW4ge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9kb3duY2FzdHdyaXRlcn5Eb3duY2FzdFdyaXRlciNicmVha0F0dHJpYnV0ZXMgYnJlYWtBdHRyaWJ1dGVzfSBhbmQKICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2Rvd25jYXN0d3JpdGVyfkRvd25jYXN0V3JpdGVyI2JyZWFrQ29udGFpbmVyIGJyZWFrQ29udGFpbmVyfSBpcyB0aGF0IGBicmVha0F0dHJpYnV0ZXNgIGJyZWFrcyBhbGwKICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2F0dHJpYnV0ZWVsZW1lbnR+QXR0cmlidXRlRWxlbWVudCBhdHRyaWJ1dGUgZWxlbWVudHN9IHRoYXQgYXJlIGFuY2VzdG9ycyBvZiBnaXZlbiBgcG9zaXRpb25gLAogICAqIHVwIHRvIHRoZSBmaXJzdCBlbmNvdW50ZXJlZCB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2NvbnRhaW5lcmVsZW1lbnR+Q29udGFpbmVyRWxlbWVudCBjb250YWluZXIgZWxlbWVudH0uCiAgICogYGJyZWFrQ29udGFpbmVyYCBhc3N1bWVzIHRoYXQgZ2l2ZW4gYHBvc2l0aW9uYCBpcyBkaXJlY3RseSBpbiBjb250YWluZXIgZWxlbWVudCBhbmQgYnJlYWtzIHRoYXQgY29udGFpbmVyIGVsZW1lbnQuCiAgICoKICAgKiBUaHJvd3Mge0BsaW5rIG1vZHVsZTp1dGlscy9ja2VkaXRvcmVycm9yfkNLRWRpdG9yRXJyb3IgQ0tFZGl0b3JFcnJvcn0gYHZpZXctd3JpdGVyLWludmFsaWQtcmFuZ2UtY29udGFpbmVyYAogICAqIHdoZW4ge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9yYW5nZX5SYW5nZSNzdGFydCBzdGFydH0KICAgKiBhbmQge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9yYW5nZX5SYW5nZSNlbmQgZW5kfSBwb3NpdGlvbnMgb2YgYSBwYXNzZWQgcmFuZ2UgYXJlIG5vdCBwbGFjZWQgaW5zaWRlIHNhbWUgcGFyZW50IGNvbnRhaW5lci4KICAgKgogICAqIFRocm93cyB7QGxpbmsgbW9kdWxlOnV0aWxzL2NrZWRpdG9yZXJyb3J+Q0tFZGl0b3JFcnJvciBDS0VkaXRvckVycm9yfSBgdmlldy13cml0ZXItY2Fubm90LWJyZWFrLWVtcHR5LWVsZW1lbnRgCiAgICogd2hlbiB0cnlpbmcgdG8gYnJlYWsgYXR0cmlidXRlcwogICAqIGluc2lkZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2VtcHR5ZWxlbWVudH5FbXB0eUVsZW1lbnQgRW1wdHlFbGVtZW50fS4KICAgKgogICAqIFRocm93cyB7QGxpbmsgbW9kdWxlOnV0aWxzL2NrZWRpdG9yZXJyb3J+Q0tFZGl0b3JFcnJvciBDS0VkaXRvckVycm9yfSBgdmlldy13cml0ZXItY2Fubm90LWJyZWFrLXVpLWVsZW1lbnRgCiAgICogd2hlbiB0cnlpbmcgdG8gYnJlYWsgYXR0cmlidXRlcwogICAqIGluc2lkZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3VpZWxlbWVudH5VSUVsZW1lbnQgVUlFbGVtZW50fS4KICAgKgogICAqIEBzZWUgbW9kdWxlOmVuZ2luZS92aWV3L2F0dHJpYnV0ZWVsZW1lbnR+QXR0cmlidXRlRWxlbWVudAogICAqIEBzZWUgbW9kdWxlOmVuZ2luZS92aWV3L2NvbnRhaW5lcmVsZW1lbnR+Q29udGFpbmVyRWxlbWVudAogICAqIEBzZWUgbW9kdWxlOmVuZ2luZS92aWV3L2Rvd25jYXN0d3JpdGVyfkRvd25jYXN0V3JpdGVyI2JyZWFrQ29udGFpbmVyCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvcG9zaXRpb25+UG9zaXRpb258bW9kdWxlOmVuZ2luZS92aWV3L3JhbmdlflJhbmdlfSBwb3NpdGlvbk9yUmFuZ2UgUG9zaXRpb24gd2hlcmUKICAgKiB0byBicmVhayBhdHRyaWJ1dGUgZWxlbWVudHMuCiAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbnxtb2R1bGU6ZW5naW5lL3ZpZXcvcmFuZ2V+UmFuZ2V9IE5ldyBwb3NpdGlvbiBvciByYW5nZSwgYWZ0ZXIgYnJlYWtpbmcgdGhlIGF0dHJpYnV0ZQogICAqIGVsZW1lbnRzLgogICAqLwoKCiAgYnJlYWtBdHRyaWJ1dGVzKHBvc2l0aW9uT3JSYW5nZSkgewogICAgaWYgKHBvc2l0aW9uT3JSYW5nZSBpbnN0YW5jZW9mIFBvc2l0aW9uKSB7CiAgICAgIHJldHVybiB0aGlzLl9icmVha0F0dHJpYnV0ZXMocG9zaXRpb25PclJhbmdlKTsKICAgIH0gZWxzZSB7CiAgICAgIHJldHVybiB0aGlzLl9icmVha0F0dHJpYnV0ZXNSYW5nZShwb3NpdGlvbk9yUmFuZ2UpOwogICAgfQogIH0KICAvKioKICAgKiBCcmVha3Mge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9jb250YWluZXJlbGVtZW50fkNvbnRhaW5lckVsZW1lbnQgY29udGFpbmVyIHZpZXcgZWxlbWVudH0gaW50byB0d28sIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi4gUG9zaXRpb24KICAgKiBoYXMgdG8gYmUgZGlyZWN0bHkgaW5zaWRlIGNvbnRhaW5lciBlbGVtZW50IGFuZCBjYW5ub3QgYmUgaW4gcm9vdC4gRG9lcyBub3QgYnJlYWsgaWYgcG9zaXRpb24gaXMgYXQgdGhlIGJlZ2lubmluZwogICAqIG9yIGF0IHRoZSBlbmQgb2YgaXQncyBwYXJlbnQgZWxlbWVudC4KICAgKgogICAqCQk8cD5mb29eYmFyPC9wPiAtPiA8cD5mb288L3A+PHA+YmFyPC9wPgogICAqCQk8ZGl2PjxwPmZvbzwvcD5ePHA+YmFyPC9wPjwvZGl2PiAtPiA8ZGl2PjxwPmZvbzwvcD48L2Rpdj48ZGl2PjxwPmJhcjwvcD48L2Rpdj4KICAgKgkJPHA+XmZvb2JhcjwvcD4gLT4gXjxwPmZvb2JhcjwvcD4KICAgKgkJPHA+Zm9vYmFyXjwvcD4gLT4gPHA+Zm9vYmFyPC9wPl4KICAgKgogICAqICoqTm90ZToqKiBEaWZmZXJlbmNlIGJldHdlZW4ge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9kb3duY2FzdHdyaXRlcn5Eb3duY2FzdFdyaXRlciNicmVha0F0dHJpYnV0ZXMgYnJlYWtBdHRyaWJ1dGVzfSBhbmQKICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2Rvd25jYXN0d3JpdGVyfkRvd25jYXN0V3JpdGVyI2JyZWFrQ29udGFpbmVyIGJyZWFrQ29udGFpbmVyfSBpcyB0aGF0IGBicmVha0F0dHJpYnV0ZXNgIGJyZWFrcyBhbGwKICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2F0dHJpYnV0ZWVsZW1lbnR+QXR0cmlidXRlRWxlbWVudCBhdHRyaWJ1dGUgZWxlbWVudHN9IHRoYXQgYXJlIGFuY2VzdG9ycyBvZiBnaXZlbiBgcG9zaXRpb25gLAogICAqIHVwIHRvIHRoZSBmaXJzdCBlbmNvdW50ZXJlZCB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2NvbnRhaW5lcmVsZW1lbnR+Q29udGFpbmVyRWxlbWVudCBjb250YWluZXIgZWxlbWVudH0uCiAgICogYGJyZWFrQ29udGFpbmVyYCBhc3N1bWVzIHRoYXQgZ2l2ZW4gYHBvc2l0aW9uYCBpcyBkaXJlY3RseSBpbiBjb250YWluZXIgZWxlbWVudCBhbmQgYnJlYWtzIHRoYXQgY29udGFpbmVyIGVsZW1lbnQuCiAgICoKICAgKiBAc2VlIG1vZHVsZTplbmdpbmUvdmlldy9hdHRyaWJ1dGVlbGVtZW50fkF0dHJpYnV0ZUVsZW1lbnQKICAgKiBAc2VlIG1vZHVsZTplbmdpbmUvdmlldy9jb250YWluZXJlbGVtZW50fkNvbnRhaW5lckVsZW1lbnQKICAgKiBAc2VlIG1vZHVsZTplbmdpbmUvdmlldy9kb3duY2FzdHdyaXRlcn5Eb3duY2FzdFdyaXRlciNicmVha0F0dHJpYnV0ZXMKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbn0gcG9zaXRpb24gUG9zaXRpb24gd2hlcmUgdG8gYnJlYWsgZWxlbWVudC4KICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS92aWV3L3Bvc2l0aW9uflBvc2l0aW9ufSBQb3NpdGlvbiBiZXR3ZWVuIGJyb2tlbiBlbGVtZW50cy4gSWYgZWxlbWVudCBoYXMgbm90IGJlZW4gYnJva2VuLAogICAqIHRoZSByZXR1cm5lZCBwb3NpdGlvbiBpcyBwbGFjZWQgZWl0aGVyIGJlZm9yZSBpdCBvciBhZnRlciBpdC4KICAgKi8KCgogIGJyZWFrQ29udGFpbmVyKHBvc2l0aW9uKSB7CiAgICBjb25zdCBlbGVtZW50ID0gcG9zaXRpb24ucGFyZW50OwoKICAgIGlmICghZWxlbWVudC5pcygnY29udGFpbmVyRWxlbWVudCcpKSB7CiAgICAgIC8qKgogICAgICAgKiBUcnlpbmcgdG8gYnJlYWsgYW4gZWxlbWVudCB3aGljaCBpcyBub3QgYSBjb250YWluZXIgZWxlbWVudC4KICAgICAgICoKICAgICAgICogQGVycm9yIHZpZXctd3JpdGVyLWJyZWFrLW5vbi1jb250YWluZXItZWxlbWVudAogICAgICAgKi8KICAgICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ3ZpZXctd3JpdGVyLWJyZWFrLW5vbi1jb250YWluZXItZWxlbWVudDogVHJ5aW5nIHRvIGJyZWFrIGFuIGVsZW1lbnQgd2hpY2ggaXMgbm90IGEgY29udGFpbmVyIGVsZW1lbnQuJywgdGhpcy5kb2N1bWVudCk7CiAgICB9CgogICAgaWYgKCFlbGVtZW50LnBhcmVudCkgewogICAgICAvKioKICAgICAgICogVHJ5aW5nIHRvIGJyZWFrIHJvb3QgZWxlbWVudC4KICAgICAgICoKICAgICAgICogQGVycm9yIHZpZXctd3JpdGVyLWJyZWFrLXJvb3QKICAgICAgICovCiAgICAgIHRocm93IG5ldyBDS0VkaXRvckVycm9yKCd2aWV3LXdyaXRlci1icmVhay1yb290OiBUcnlpbmcgdG8gYnJlYWsgcm9vdCBlbGVtZW50LicsIHRoaXMuZG9jdW1lbnQpOwogICAgfQoKICAgIGlmIChwb3NpdGlvbi5pc0F0U3RhcnQpIHsKICAgICAgcmV0dXJuIFBvc2l0aW9uLl9jcmVhdGVCZWZvcmUoZWxlbWVudCk7CiAgICB9IGVsc2UgaWYgKCFwb3NpdGlvbi5pc0F0RW5kKSB7CiAgICAgIGNvbnN0IG5ld0VsZW1lbnQgPSBlbGVtZW50Ll9jbG9uZShmYWxzZSk7CgogICAgICB0aGlzLmluc2VydChQb3NpdGlvbi5fY3JlYXRlQWZ0ZXIoZWxlbWVudCksIG5ld0VsZW1lbnQpOwogICAgICBjb25zdCBzb3VyY2VSYW5nZSA9IG5ldyBSYW5nZShwb3NpdGlvbiwgUG9zaXRpb24uX2NyZWF0ZUF0KGVsZW1lbnQsICdlbmQnKSk7CiAgICAgIGNvbnN0IHRhcmdldFBvc2l0aW9uID0gbmV3IFBvc2l0aW9uKG5ld0VsZW1lbnQsIDApOwogICAgICB0aGlzLm1vdmUoc291cmNlUmFuZ2UsIHRhcmdldFBvc2l0aW9uKTsKICAgIH0KCiAgICByZXR1cm4gUG9zaXRpb24uX2NyZWF0ZUFmdGVyKGVsZW1lbnQpOwogIH0KICAvKioKICAgKiBNZXJnZXMge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9hdHRyaWJ1dGVlbGVtZW50fkF0dHJpYnV0ZUVsZW1lbnQgYXR0cmlidXRlIGVsZW1lbnRzfS4gSXQgYWxzbyBtZXJnZXMgdGV4dCBub2RlcyBpZiBuZWVkZWQuCiAgICogT25seSB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2F0dHJpYnV0ZWVsZW1lbnR+QXR0cmlidXRlRWxlbWVudCNpc1NpbWlsYXIgc2ltaWxhcn0gYXR0cmlidXRlIGVsZW1lbnRzIGNhbiBiZSBtZXJnZWQuCiAgICoKICAgKiBJbiBmb2xsb3dpbmcgZXhhbXBsZXMgYDxwPmAgaXMgYSBjb250YWluZXIgYW5kIGA8Yj5gIGlzIGFuIGF0dHJpYnV0ZSBlbGVtZW50OgogICAqCiAgICoJCTxwPmZvb1tdYmFyPC9wPiAtPiA8cD5mb297fWJhcjwvcD4KICAgKgkJPHA+PGI+Zm9vPC9iPltdPGI+YmFyPC9iPjwvcD4gLT4gPHA+PGI+Zm9ve31iYXI8L2I+PC9wPgogICAqCQk8cD48YiBmb289ImJhciI+YTwvYj5bXTxiIGZvbz0iYmF6Ij5iPC9iPjwvcD4gLT4gPHA+PGIgZm9vPSJiYXIiPmE8L2I+W108YiBmb289ImJheiI+YjwvYj48L3A+CiAgICoKICAgKiBJdCB3aWxsIGFsc28gdGFrZSBjYXJlIGFib3V0IGVtcHR5IGF0dHJpYnV0ZXMgd2hlbiBtZXJnaW5nOgogICAqCiAgICoJCTxwPjxiPltdPC9iPjwvcD4gLT4gPHA+W108L3A+CiAgICoJCTxwPjxiPmZvbzwvYj48aT5bXTwvaT48Yj5iYXI8L2I+PC9wPiAtPiA8cD48Yj5mb297fWJhcjwvYj48L3A+CiAgICoKICAgKiAqKk5vdGU6KiogRGlmZmVyZW5jZSBiZXR3ZWVuIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZG93bmNhc3R3cml0ZXJ+RG93bmNhc3RXcml0ZXIjbWVyZ2VBdHRyaWJ1dGVzIG1lcmdlQXR0cmlidXRlc30gYW5kCiAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9kb3duY2FzdHdyaXRlcn5Eb3duY2FzdFdyaXRlciNtZXJnZUNvbnRhaW5lcnMgbWVyZ2VDb250YWluZXJzfSBpcyB0aGF0IGBtZXJnZUF0dHJpYnV0ZXNgIG1lcmdlcyB0d28KICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2F0dHJpYnV0ZWVsZW1lbnR+QXR0cmlidXRlRWxlbWVudCBhdHRyaWJ1dGUgZWxlbWVudHN9IG9yIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdGV4dH5UZXh0IHRleHQgbm9kZXN9CiAgICogd2hpbGUgYG1lcmdlQ29udGFpbmVyYCBtZXJnZXMgdHdvIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvY29udGFpbmVyZWxlbWVudH5Db250YWluZXJFbGVtZW50IGNvbnRhaW5lciBlbGVtZW50c30uCiAgICoKICAgKiBAc2VlIG1vZHVsZTplbmdpbmUvdmlldy9hdHRyaWJ1dGVlbGVtZW50fkF0dHJpYnV0ZUVsZW1lbnQKICAgKiBAc2VlIG1vZHVsZTplbmdpbmUvdmlldy9jb250YWluZXJlbGVtZW50fkNvbnRhaW5lckVsZW1lbnQKICAgKiBAc2VlIG1vZHVsZTplbmdpbmUvdmlldy9kb3duY2FzdHdyaXRlcn5Eb3duY2FzdFdyaXRlciNtZXJnZUNvbnRhaW5lcnMKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbn0gcG9zaXRpb24gTWVyZ2UgcG9zaXRpb24uCiAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbn0gUG9zaXRpb24gYWZ0ZXIgbWVyZ2UuCiAgICovCgoKICBtZXJnZUF0dHJpYnV0ZXMocG9zaXRpb24pIHsKICAgIGNvbnN0IHBvc2l0aW9uT2Zmc2V0ID0gcG9zaXRpb24ub2Zmc2V0OwogICAgY29uc3QgcG9zaXRpb25QYXJlbnQgPSBwb3NpdGlvbi5wYXJlbnQ7IC8vIFdoZW4gaW5zaWRlIHRleHQgbm9kZSAtIG5vdGhpbmcgdG8gbWVyZ2UuCgogICAgaWYgKHBvc2l0aW9uUGFyZW50LmlzKCd0ZXh0JykpIHsKICAgICAgcmV0dXJuIHBvc2l0aW9uOwogICAgfSAvLyBXaGVuIGluc2lkZSBlbXB0eSBhdHRyaWJ1dGUgLSByZW1vdmUgaXQuCgoKICAgIGlmIChwb3NpdGlvblBhcmVudC5pcygnYXR0cmlidXRlRWxlbWVudCcpICYmIHBvc2l0aW9uUGFyZW50LmNoaWxkQ291bnQgPT09IDApIHsKICAgICAgY29uc3QgcGFyZW50ID0gcG9zaXRpb25QYXJlbnQucGFyZW50OwogICAgICBjb25zdCBvZmZzZXQgPSBwb3NpdGlvblBhcmVudC5pbmRleDsKCiAgICAgIHBvc2l0aW9uUGFyZW50Ll9yZW1vdmUoKTsKCiAgICAgIHRoaXMuX3JlbW92ZUZyb21DbG9uZWRFbGVtZW50c0dyb3VwKHBvc2l0aW9uUGFyZW50KTsKCiAgICAgIHJldHVybiB0aGlzLm1lcmdlQXR0cmlidXRlcyhuZXcgUG9zaXRpb24ocGFyZW50LCBvZmZzZXQpKTsKICAgIH0KCiAgICBjb25zdCBub2RlQmVmb3JlID0gcG9zaXRpb25QYXJlbnQuZ2V0Q2hpbGQocG9zaXRpb25PZmZzZXQgLSAxKTsKICAgIGNvbnN0IG5vZGVBZnRlciA9IHBvc2l0aW9uUGFyZW50LmdldENoaWxkKHBvc2l0aW9uT2Zmc2V0KTsgLy8gUG9zaXRpb24gc2hvdWxkIGJlIHBsYWNlZCBiZXR3ZWVuIHR3byBub2Rlcy4KCiAgICBpZiAoIW5vZGVCZWZvcmUgfHwgIW5vZGVBZnRlcikgewogICAgICByZXR1cm4gcG9zaXRpb247CiAgICB9IC8vIFdoZW4gcG9zaXRpb24gaXMgYmV0d2VlbiB0d28gdGV4dCBub2Rlcy4KCgogICAgaWYgKG5vZGVCZWZvcmUuaXMoJ3RleHQnKSAmJiBub2RlQWZ0ZXIuaXMoJ3RleHQnKSkgewogICAgICByZXR1cm4gbWVyZ2VUZXh0Tm9kZXMobm9kZUJlZm9yZSwgbm9kZUFmdGVyKTsKICAgIH0gLy8gV2hlbiBwb3NpdGlvbiBpcyBiZXR3ZWVuIHR3byBzYW1lIGF0dHJpYnV0ZSBlbGVtZW50cy4KICAgIGVsc2UgaWYgKG5vZGVCZWZvcmUuaXMoJ2F0dHJpYnV0ZUVsZW1lbnQnKSAmJiBub2RlQWZ0ZXIuaXMoJ2F0dHJpYnV0ZUVsZW1lbnQnKSAmJiBub2RlQmVmb3JlLmlzU2ltaWxhcihub2RlQWZ0ZXIpKSB7CiAgICAgICAgLy8gTW92ZSBhbGwgY2hpbGRyZW4gbm9kZXMgZnJvbSBub2RlIHBsYWNlZCBhZnRlciBzZWxlY3Rpb24gYW5kIHJlbW92ZSB0aGF0IG5vZGUuCiAgICAgICAgY29uc3QgY291bnQgPSBub2RlQmVmb3JlLmNoaWxkQ291bnQ7CgogICAgICAgIG5vZGVCZWZvcmUuX2FwcGVuZENoaWxkKG5vZGVBZnRlci5nZXRDaGlsZHJlbigpKTsKCiAgICAgICAgbm9kZUFmdGVyLl9yZW1vdmUoKTsKCiAgICAgICAgdGhpcy5fcmVtb3ZlRnJvbUNsb25lZEVsZW1lbnRzR3JvdXAobm9kZUFmdGVyKTsgLy8gTmV3IHBvc2l0aW9uIGlzIGxvY2F0ZWQgaW5zaWRlIHRoZSBmaXJzdCBub2RlLCBiZWZvcmUgbmV3IG5vZGVzLgogICAgICAgIC8vIENhbGwgdGhpcyBtZXRob2QgcmVjdXJzaXZlbHkgdG8gbWVyZ2UgYWdhaW4gaWYgbmVlZGVkLgoKCiAgICAgICAgcmV0dXJuIHRoaXMubWVyZ2VBdHRyaWJ1dGVzKG5ldyBQb3NpdGlvbihub2RlQmVmb3JlLCBjb3VudCkpOwogICAgICB9CgogICAgcmV0dXJuIHBvc2l0aW9uOwogIH0KICAvKioKICAgKiBNZXJnZXMgdHdvIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvY29udGFpbmVyZWxlbWVudH5Db250YWluZXJFbGVtZW50IGNvbnRhaW5lciBlbGVtZW50c30gdGhhdCBhcmUgYmVmb3JlIGFuZCBhZnRlciBnaXZlbiBwb3NpdGlvbi4KICAgKiBQcmVjaXNlbHksIHRoZSBlbGVtZW50IGFmdGVyIHRoZSBwb3NpdGlvbiBpcyByZW1vdmVkIGFuZCBpdCdzIGNvbnRlbnRzIGFyZSBtb3ZlZCB0byBlbGVtZW50IGJlZm9yZSB0aGUgcG9zaXRpb24uCiAgICoKICAgKgkJPHA+Zm9vPC9wPl48cD5iYXI8L3A+IC0+IDxwPmZvb15iYXI8L3A+CiAgICoJCTxkaXY+Zm9vPC9kaXY+XjxwPmJhcjwvcD4gLT4gPGRpdj5mb29eYmFyPC9kaXY+CiAgICoKICAgKiAqKk5vdGU6KiogRGlmZmVyZW5jZSBiZXR3ZWVuIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZG93bmNhc3R3cml0ZXJ+RG93bmNhc3RXcml0ZXIjbWVyZ2VBdHRyaWJ1dGVzIG1lcmdlQXR0cmlidXRlc30gYW5kCiAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9kb3duY2FzdHdyaXRlcn5Eb3duY2FzdFdyaXRlciNtZXJnZUNvbnRhaW5lcnMgbWVyZ2VDb250YWluZXJzfSBpcyB0aGF0IGBtZXJnZUF0dHJpYnV0ZXNgIG1lcmdlcyB0d28KICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2F0dHJpYnV0ZWVsZW1lbnR+QXR0cmlidXRlRWxlbWVudCBhdHRyaWJ1dGUgZWxlbWVudHN9IG9yIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdGV4dH5UZXh0IHRleHQgbm9kZXN9CiAgICogd2hpbGUgYG1lcmdlQ29udGFpbmVyYCBtZXJnZXMgdHdvIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvY29udGFpbmVyZWxlbWVudH5Db250YWluZXJFbGVtZW50IGNvbnRhaW5lciBlbGVtZW50c30uCiAgICoKICAgKiBAc2VlIG1vZHVsZTplbmdpbmUvdmlldy9hdHRyaWJ1dGVlbGVtZW50fkF0dHJpYnV0ZUVsZW1lbnQKICAgKiBAc2VlIG1vZHVsZTplbmdpbmUvdmlldy9jb250YWluZXJlbGVtZW50fkNvbnRhaW5lckVsZW1lbnQKICAgKiBAc2VlIG1vZHVsZTplbmdpbmUvdmlldy9kb3duY2FzdHdyaXRlcn5Eb3duY2FzdFdyaXRlciNtZXJnZUF0dHJpYnV0ZXMKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbn0gcG9zaXRpb24gTWVyZ2UgcG9zaXRpb24uCiAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbn0gUG9zaXRpb24gYWZ0ZXIgbWVyZ2UuCiAgICovCgoKICBtZXJnZUNvbnRhaW5lcnMocG9zaXRpb24pIHsKICAgIGNvbnN0IHByZXYgPSBwb3NpdGlvbi5ub2RlQmVmb3JlOwogICAgY29uc3QgbmV4dCA9IHBvc2l0aW9uLm5vZGVBZnRlcjsKCiAgICBpZiAoIXByZXYgfHwgIW5leHQgfHwgIXByZXYuaXMoJ2NvbnRhaW5lckVsZW1lbnQnKSB8fCAhbmV4dC5pcygnY29udGFpbmVyRWxlbWVudCcpKSB7CiAgICAgIC8qKgogICAgICAgKiBFbGVtZW50IGJlZm9yZSBhbmQgYWZ0ZXIgZ2l2ZW4gcG9zaXRpb24gY2Fubm90IGJlIG1lcmdlZC4KICAgICAgICoKICAgICAgICogQGVycm9yIHZpZXctd3JpdGVyLW1lcmdlLWNvbnRhaW5lcnMtaW52YWxpZC1wb3NpdGlvbgogICAgICAgKi8KICAgICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ3ZpZXctd3JpdGVyLW1lcmdlLWNvbnRhaW5lcnMtaW52YWxpZC1wb3NpdGlvbjogJyArICdFbGVtZW50IGJlZm9yZSBhbmQgYWZ0ZXIgZ2l2ZW4gcG9zaXRpb24gY2Fubm90IGJlIG1lcmdlZC4nLCB0aGlzLmRvY3VtZW50KTsKICAgIH0KCiAgICBjb25zdCBsYXN0Q2hpbGQgPSBwcmV2LmdldENoaWxkKHByZXYuY2hpbGRDb3VudCAtIDEpOwogICAgY29uc3QgbmV3UG9zaXRpb24gPSBsYXN0Q2hpbGQgaW5zdGFuY2VvZiBUZXh0ID8gUG9zaXRpb24uX2NyZWF0ZUF0KGxhc3RDaGlsZCwgJ2VuZCcpIDogUG9zaXRpb24uX2NyZWF0ZUF0KHByZXYsICdlbmQnKTsKICAgIHRoaXMubW92ZShSYW5nZS5fY3JlYXRlSW4obmV4dCksIFBvc2l0aW9uLl9jcmVhdGVBdChwcmV2LCAnZW5kJykpOwogICAgdGhpcy5yZW1vdmUoUmFuZ2UuX2NyZWF0ZU9uKG5leHQpKTsKICAgIHJldHVybiBuZXdQb3NpdGlvbjsKICB9CiAgLyoqCiAgICogSW5zZXJ0IG5vZGUgb3Igbm9kZXMgYXQgc3BlY2lmaWVkIHBvc2l0aW9uLiBUYWtlcyBjYXJlIGFib3V0IGJyZWFraW5nIGF0dHJpYnV0ZXMgYmVmb3JlIGluc2VydGlvbgogICAqIGFuZCBtZXJnaW5nIHRoZW0gYWZ0ZXJ3YXJkcy4KICAgKgogICAqIFRocm93cyB7QGxpbmsgbW9kdWxlOnV0aWxzL2NrZWRpdG9yZXJyb3J+Q0tFZGl0b3JFcnJvciBDS0VkaXRvckVycm9yfSBgdmlldy13cml0ZXItaW5zZXJ0LWludmFsaWQtbm9kZWAgd2hlbiBub2RlcyB0byBpbnNlcnQKICAgKiBjb250YWlucyBpbnN0YW5jZXMgdGhhdCBhcmUgbm90IHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdGV4dH5UZXh0IFRleHRzfSwKICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2F0dHJpYnV0ZWVsZW1lbnR+QXR0cmlidXRlRWxlbWVudCBBdHRyaWJ1dGVFbGVtZW50c30sCiAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9jb250YWluZXJlbGVtZW50fkNvbnRhaW5lckVsZW1lbnQgQ29udGFpbmVyRWxlbWVudHN9LAogICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZW1wdHllbGVtZW50fkVtcHR5RWxlbWVudCBFbXB0eUVsZW1lbnRzfSBvcgogICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdWllbGVtZW50flVJRWxlbWVudCBVSUVsZW1lbnRzfS4KICAgKgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L3Bvc2l0aW9uflBvc2l0aW9ufSBwb3NpdGlvbiBJbnNlcnRpb24gcG9zaXRpb24uCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvdGV4dH5UZXh0fG1vZHVsZTplbmdpbmUvdmlldy9hdHRyaWJ1dGVlbGVtZW50fkF0dHJpYnV0ZUVsZW1lbnR8CiAgICogbW9kdWxlOmVuZ2luZS92aWV3L2NvbnRhaW5lcmVsZW1lbnR+Q29udGFpbmVyRWxlbWVudHxtb2R1bGU6ZW5naW5lL3ZpZXcvZW1wdHllbGVtZW50fkVtcHR5RWxlbWVudHwKICAgKiBtb2R1bGU6ZW5naW5lL3ZpZXcvdWllbGVtZW50flVJRWxlbWVudHxJdGVyYWJsZS48bW9kdWxlOmVuZ2luZS92aWV3L3RleHR+VGV4dHwKICAgKiBtb2R1bGU6ZW5naW5lL3ZpZXcvYXR0cmlidXRlZWxlbWVudH5BdHRyaWJ1dGVFbGVtZW50fG1vZHVsZTplbmdpbmUvdmlldy9jb250YWluZXJlbGVtZW50fkNvbnRhaW5lckVsZW1lbnR8CiAgICogbW9kdWxlOmVuZ2luZS92aWV3L2VtcHR5ZWxlbWVudH5FbXB0eUVsZW1lbnR8bW9kdWxlOmVuZ2luZS92aWV3L3VpZWxlbWVudH5VSUVsZW1lbnQ+fSBub2RlcyBOb2RlIG9yIG5vZGVzIHRvIGluc2VydC4KICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS92aWV3L3JhbmdlflJhbmdlfSBSYW5nZSBhcm91bmQgaW5zZXJ0ZWQgbm9kZXMuCiAgICovCgoKICBpbnNlcnQocG9zaXRpb24sIG5vZGVzKSB7CiAgICBub2RlcyA9IGlzSXRlcmFibGUobm9kZXMpID8gWy4uLm5vZGVzXSA6IFtub2Rlc107IC8vIENoZWNrIGlmIG5vZGVzIHRvIGluc2VydCBhcmUgaW5zdGFuY2VzIG9mIEF0dHJpYnV0ZUVsZW1lbnRzLCBDb250YWluZXJFbGVtZW50cywgRW1wdHlFbGVtZW50cywgVUlFbGVtZW50cyBvciBUZXh0LgoKICAgIHZhbGlkYXRlTm9kZXNUb0luc2VydChub2RlcywgdGhpcy5kb2N1bWVudCk7CiAgICBjb25zdCBjb250YWluZXIgPSBnZXRQYXJlbnRDb250YWluZXIocG9zaXRpb24pOwoKICAgIGlmICghY29udGFpbmVyKSB7CiAgICAgIC8qKgogICAgICAgKiBQb3NpdGlvbidzIHBhcmVudCBjb250YWluZXIgY2Fubm90IGJlIGZvdW5kLgogICAgICAgKgogICAgICAgKiBAZXJyb3Igdmlldy13cml0ZXItaW52YWxpZC1wb3NpdGlvbi1jb250YWluZXIKICAgICAgICovCiAgICAgIHRocm93IG5ldyBDS0VkaXRvckVycm9yKCd2aWV3LXdyaXRlci1pbnZhbGlkLXBvc2l0aW9uLWNvbnRhaW5lcicsIHRoaXMuZG9jdW1lbnQpOwogICAgfQoKICAgIGNvbnN0IGluc2VydGlvblBvc2l0aW9uID0gdGhpcy5fYnJlYWtBdHRyaWJ1dGVzKHBvc2l0aW9uLCB0cnVlKTsKCiAgICBjb25zdCBsZW5ndGggPSBjb250YWluZXIuX2luc2VydENoaWxkKGluc2VydGlvblBvc2l0aW9uLm9mZnNldCwgbm9kZXMpOwoKICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2RlcykgewogICAgICB0aGlzLl9hZGRUb0Nsb25lZEVsZW1lbnRzR3JvdXAobm9kZSk7CiAgICB9CgogICAgY29uc3QgZW5kUG9zaXRpb24gPSBpbnNlcnRpb25Qb3NpdGlvbi5nZXRTaGlmdGVkQnkobGVuZ3RoKTsKICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5tZXJnZUF0dHJpYnV0ZXMoaW5zZXJ0aW9uUG9zaXRpb24pOyAvLyBXaGVuIG5vIG5vZGVzIHdlcmUgaW5zZXJ0ZWQgLSByZXR1cm4gY29sbGFwc2VkIHJhbmdlLgoKICAgIGlmIChsZW5ndGggPT09IDApIHsKICAgICAgcmV0dXJuIG5ldyBSYW5nZShzdGFydCwgc3RhcnQpOwogICAgfSBlbHNlIHsKICAgICAgLy8gSWYgc3RhcnQgcG9zaXRpb24gd2FzIG1lcmdlZCAtIG1vdmUgZW5kIHBvc2l0aW9uLgogICAgICBpZiAoIXN0YXJ0LmlzRXF1YWwoaW5zZXJ0aW9uUG9zaXRpb24pKSB7CiAgICAgICAgZW5kUG9zaXRpb24ub2Zmc2V0LS07CiAgICAgIH0KCiAgICAgIGNvbnN0IGVuZCA9IHRoaXMubWVyZ2VBdHRyaWJ1dGVzKGVuZFBvc2l0aW9uKTsKICAgICAgcmV0dXJuIG5ldyBSYW5nZShzdGFydCwgZW5kKTsKICAgIH0KICB9CiAgLyoqCiAgICogUmVtb3ZlcyBwcm92aWRlZCByYW5nZSBmcm9tIHRoZSBjb250YWluZXIuCiAgICoKICAgKiBUaHJvd3Mge0BsaW5rIG1vZHVsZTp1dGlscy9ja2VkaXRvcmVycm9yfkNLRWRpdG9yRXJyb3IgQ0tFZGl0b3JFcnJvcn0gYHZpZXctd3JpdGVyLWludmFsaWQtcmFuZ2UtY29udGFpbmVyYCB3aGVuCiAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9yYW5nZX5SYW5nZSNzdGFydCBzdGFydH0gYW5kIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvcmFuZ2V+UmFuZ2UjZW5kIGVuZH0gcG9zaXRpb25zIGFyZSBub3QgcGxhY2VkIGluc2lkZQogICAqIHNhbWUgcGFyZW50IGNvbnRhaW5lci4KICAgKgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L3JhbmdlflJhbmdlfG1vZHVsZTplbmdpbmUvdmlldy9pdGVtfkl0ZW19IHJhbmdlT3JJdGVtIFJhbmdlIHRvIHJlbW92ZSBmcm9tIGNvbnRhaW5lcgogICAqIG9yIGFuIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvaXRlbX5JdGVtIGl0ZW19IHRvIHJlbW92ZS4gSWYgcmFuZ2UgaXMgcHJvdmlkZWQsIGFmdGVyIHJlbW92aW5nLCBpdCB3aWxsIGJlIHVwZGF0ZWQKICAgKiB0byBhIGNvbGxhcHNlZCByYW5nZSBzaG93aW5nIHRoZSBuZXcgcG9zaXRpb24uCiAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnR9IERvY3VtZW50IGZyYWdtZW50IGNvbnRhaW5pbmcgcmVtb3ZlZCBub2Rlcy4KICAgKi8KCgogIHJlbW92ZShyYW5nZU9ySXRlbSkgewogICAgY29uc3QgcmFuZ2UgPSByYW5nZU9ySXRlbSBpbnN0YW5jZW9mIFJhbmdlID8gcmFuZ2VPckl0ZW0gOiBSYW5nZS5fY3JlYXRlT24ocmFuZ2VPckl0ZW0pOwogICAgdmFsaWRhdGVSYW5nZUNvbnRhaW5lcihyYW5nZSwgdGhpcy5kb2N1bWVudCk7IC8vIElmIHJhbmdlIGlzIGNvbGxhcHNlZCAtIG5vdGhpbmcgdG8gcmVtb3ZlLgoKICAgIGlmIChyYW5nZS5pc0NvbGxhcHNlZCkgewogICAgICByZXR1cm4gbmV3IERvY3VtZW50RnJhZ21lbnQoKTsKICAgIH0gLy8gQnJlYWsgYXR0cmlidXRlcyBhdCByYW5nZSBzdGFydCBhbmQgZW5kLgoKCiAgICBjb25zdCB7CiAgICAgIHN0YXJ0OiBicmVha1N0YXJ0LAogICAgICBlbmQ6IGJyZWFrRW5kCiAgICB9ID0gdGhpcy5fYnJlYWtBdHRyaWJ1dGVzUmFuZ2UocmFuZ2UsIHRydWUpOwoKICAgIGNvbnN0IHBhcmVudENvbnRhaW5lciA9IGJyZWFrU3RhcnQucGFyZW50OwogICAgY29uc3QgY291bnQgPSBicmVha0VuZC5vZmZzZXQgLSBicmVha1N0YXJ0Lm9mZnNldDsgLy8gUmVtb3ZlIG5vZGVzIGluIHJhbmdlLgoKICAgIGNvbnN0IHJlbW92ZWQgPSBwYXJlbnRDb250YWluZXIuX3JlbW92ZUNoaWxkcmVuKGJyZWFrU3RhcnQub2Zmc2V0LCBjb3VudCk7CgogICAgZm9yIChjb25zdCBub2RlIG9mIHJlbW92ZWQpIHsKICAgICAgdGhpcy5fcmVtb3ZlRnJvbUNsb25lZEVsZW1lbnRzR3JvdXAobm9kZSk7CiAgICB9IC8vIE1lcmdlIGFmdGVyIHJlbW92aW5nLgoKCiAgICBjb25zdCBtZXJnZVBvc2l0aW9uID0gdGhpcy5tZXJnZUF0dHJpYnV0ZXMoYnJlYWtTdGFydCk7CiAgICByYW5nZS5zdGFydCA9IG1lcmdlUG9zaXRpb247CiAgICByYW5nZS5lbmQgPSBtZXJnZVBvc2l0aW9uLmNsb25lKCk7IC8vIFJldHVybiByZW1vdmVkIG5vZGVzLgoKICAgIHJldHVybiBuZXcgRG9jdW1lbnRGcmFnbWVudChyZW1vdmVkKTsKICB9CiAgLyoqCiAgICogUmVtb3ZlcyBtYXRjaGluZyBlbGVtZW50cyBmcm9tIGdpdmVuIHJhbmdlLgogICAqCiAgICogVGhyb3dzIHtAbGluayBtb2R1bGU6dXRpbHMvY2tlZGl0b3JlcnJvcn5DS0VkaXRvckVycm9yIENLRWRpdG9yRXJyb3J9IGB2aWV3LXdyaXRlci1pbnZhbGlkLXJhbmdlLWNvbnRhaW5lcmAgd2hlbgogICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvcmFuZ2V+UmFuZ2Ujc3RhcnQgc3RhcnR9IGFuZCB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3JhbmdlflJhbmdlI2VuZCBlbmR9IHBvc2l0aW9ucyBhcmUgbm90IHBsYWNlZCBpbnNpZGUKICAgKiBzYW1lIHBhcmVudCBjb250YWluZXIuCiAgICoKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9yYW5nZX5SYW5nZX0gcmFuZ2UgUmFuZ2UgdG8gY2xlYXIuCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdG8gcmVtb3ZlLgogICAqLwoKCiAgY2xlYXIocmFuZ2UsIGVsZW1lbnQpIHsKICAgIHZhbGlkYXRlUmFuZ2VDb250YWluZXIocmFuZ2UsIHRoaXMuZG9jdW1lbnQpOyAvLyBDcmVhdGUgd2Fsa2VyIG9uIGdpdmVuIHJhbmdlLgogICAgLy8gV2Ugd2FsayBiYWNrd2FyZCBiZWNhdXNlIHdoZW4gd2UgcmVtb3ZlIGVsZW1lbnQgZHVyaW5nIHdhbGsgaXQgbW9kaWZpZXMgcmFuZ2UgZW5kIHBvc2l0aW9uLgoKICAgIGNvbnN0IHdhbGtlciA9IHJhbmdlLmdldFdhbGtlcih7CiAgICAgIGRpcmVjdGlvbjogJ2JhY2t3YXJkJywKICAgICAgaWdub3JlRWxlbWVudEVuZDogdHJ1ZQogICAgfSk7IC8vIExldCdzIHdhbGsuCgogICAgZm9yIChjb25zdCBjdXJyZW50IG9mIHdhbGtlcikgewogICAgICBjb25zdCBpdGVtID0gY3VycmVudC5pdGVtOwogICAgICBsZXQgcmFuZ2VUb1JlbW92ZTsgLy8gV2hlbiBjdXJyZW50IGl0ZW0gbWF0Y2hlcyB0byB0aGUgZ2l2ZW4gZWxlbWVudC4KCiAgICAgIGlmIChpdGVtLmlzKCdlbGVtZW50JykgJiYgZWxlbWVudC5pc1NpbWlsYXIoaXRlbSkpIHsKICAgICAgICAvLyBDcmVhdGUgcmFuZ2Ugb24gdGhpcyBlbGVtZW50LgogICAgICAgIHJhbmdlVG9SZW1vdmUgPSBSYW5nZS5fY3JlYXRlT24oaXRlbSk7IC8vIFdoZW4gcmFuZ2Ugc3RhcnRzIGluc2lkZSBUZXh0IG9yIFRleHRQcm94eSBlbGVtZW50LgogICAgICB9IGVsc2UgaWYgKCFjdXJyZW50Lm5leHRQb3NpdGlvbi5pc0FmdGVyKHJhbmdlLnN0YXJ0KSAmJiBpdGVtLmlzKCd0ZXh0UHJveHknKSkgewogICAgICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgaWYgcGFyZW50IG9mIHRoaXMgdGV4dCBtYXRjaGVzIHRvIGdpdmVuIGVsZW1lbnQuCiAgICAgICAgY29uc3QgcGFyZW50RWxlbWVudCA9IGl0ZW0uZ2V0QW5jZXN0b3JzKCkuZmluZChhbmNlc3RvciA9PiB7CiAgICAgICAgICByZXR1cm4gYW5jZXN0b3IuaXMoJ2VsZW1lbnQnKSAmJiBlbGVtZW50LmlzU2ltaWxhcihhbmNlc3Rvcik7CiAgICAgICAgfSk7IC8vIElmIGl0IGlzIHRoZW4gY3JlYXRlIHJhbmdlIGluc2lkZSB0aGlzIGVsZW1lbnQuCgogICAgICAgIGlmIChwYXJlbnRFbGVtZW50KSB7CiAgICAgICAgICByYW5nZVRvUmVtb3ZlID0gUmFuZ2UuX2NyZWF0ZUluKHBhcmVudEVsZW1lbnQpOwogICAgICAgIH0KICAgICAgfSAvLyBJZiB3ZSBoYXZlIGZvdW5kIGVsZW1lbnQgdG8gcmVtb3ZlLgoKCiAgICAgIGlmIChyYW5nZVRvUmVtb3ZlKSB7CiAgICAgICAgLy8gV2UgbmVlZCB0byBjaGVjayBpZiBlbGVtZW50IHJhbmdlIHN0aWNrIG91dCBvZiB0aGUgZ2l2ZW4gcmFuZ2UgYW5kIHRydW5jYXRlIGlmIGl0IGlzLgogICAgICAgIGlmIChyYW5nZVRvUmVtb3ZlLmVuZC5pc0FmdGVyKHJhbmdlLmVuZCkpIHsKICAgICAgICAgIHJhbmdlVG9SZW1vdmUuZW5kID0gcmFuZ2UuZW5kOwogICAgICAgIH0KCiAgICAgICAgaWYgKHJhbmdlVG9SZW1vdmUuc3RhcnQuaXNCZWZvcmUocmFuZ2Uuc3RhcnQpKSB7CiAgICAgICAgICByYW5nZVRvUmVtb3ZlLnN0YXJ0ID0gcmFuZ2Uuc3RhcnQ7CiAgICAgICAgfSAvLyBBdCB0aGUgZW5kIHdlIHJlbW92ZSByYW5nZSB3aXRoIGZvdW5kIGVsZW1lbnQuCgoKICAgICAgICB0aGlzLnJlbW92ZShyYW5nZVRvUmVtb3ZlKTsKICAgICAgfQogICAgfQogIH0KICAvKioKICAgKiBNb3ZlcyBub2RlcyBmcm9tIHByb3ZpZGVkIHJhbmdlIHRvIHRhcmdldCBwb3NpdGlvbi4KICAgKgogICAqIFRocm93cyB7QGxpbmsgbW9kdWxlOnV0aWxzL2NrZWRpdG9yZXJyb3J+Q0tFZGl0b3JFcnJvciBDS0VkaXRvckVycm9yfSBgdmlldy13cml0ZXItaW52YWxpZC1yYW5nZS1jb250YWluZXJgIHdoZW4KICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3JhbmdlflJhbmdlI3N0YXJ0IHN0YXJ0fSBhbmQge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9yYW5nZX5SYW5nZSNlbmQgZW5kfSBwb3NpdGlvbnMgYXJlIG5vdCBwbGFjZWQgaW5zaWRlCiAgICogc2FtZSBwYXJlbnQgY29udGFpbmVyLgogICAqCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvcmFuZ2V+UmFuZ2V9IHNvdXJjZVJhbmdlIFJhbmdlIGNvbnRhaW5pbmcgbm9kZXMgdG8gbW92ZS4KICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbn0gdGFyZ2V0UG9zaXRpb24gUG9zaXRpb24gdG8gaW5zZXJ0LgogICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL3ZpZXcvcmFuZ2V+UmFuZ2V9IFJhbmdlIGluIHRhcmdldCBjb250YWluZXIuIEluc2VydGVkIG5vZGVzIGFyZSBwbGFjZWQgYmV0d2VlbgogICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvcmFuZ2V+UmFuZ2Ujc3RhcnQgc3RhcnR9IGFuZCB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3JhbmdlflJhbmdlI2VuZCBlbmR9IHBvc2l0aW9ucy4KICAgKi8KCgogIG1vdmUoc291cmNlUmFuZ2UsIHRhcmdldFBvc2l0aW9uKSB7CiAgICBsZXQgbm9kZXM7CgogICAgaWYgKHRhcmdldFBvc2l0aW9uLmlzQWZ0ZXIoc291cmNlUmFuZ2UuZW5kKSkgewogICAgICB0YXJnZXRQb3NpdGlvbiA9IHRoaXMuX2JyZWFrQXR0cmlidXRlcyh0YXJnZXRQb3NpdGlvbiwgdHJ1ZSk7CiAgICAgIGNvbnN0IHBhcmVudCA9IHRhcmdldFBvc2l0aW9uLnBhcmVudDsKICAgICAgY29uc3QgY291bnRCZWZvcmUgPSBwYXJlbnQuY2hpbGRDb3VudDsKICAgICAgc291cmNlUmFuZ2UgPSB0aGlzLl9icmVha0F0dHJpYnV0ZXNSYW5nZShzb3VyY2VSYW5nZSwgdHJ1ZSk7CiAgICAgIG5vZGVzID0gdGhpcy5yZW1vdmUoc291cmNlUmFuZ2UpOwogICAgICB0YXJnZXRQb3NpdGlvbi5vZmZzZXQgKz0gcGFyZW50LmNoaWxkQ291bnQgLSBjb3VudEJlZm9yZTsKICAgIH0gZWxzZSB7CiAgICAgIG5vZGVzID0gdGhpcy5yZW1vdmUoc291cmNlUmFuZ2UpOwogICAgfQoKICAgIHJldHVybiB0aGlzLmluc2VydCh0YXJnZXRQb3NpdGlvbiwgbm9kZXMpOwogIH0KICAvKioKICAgKiBXcmFwcyBlbGVtZW50cyB3aXRoaW4gcmFuZ2Ugd2l0aCBwcm92aWRlZCB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2F0dHJpYnV0ZWVsZW1lbnR+QXR0cmlidXRlRWxlbWVudCBBdHRyaWJ1dGVFbGVtZW50fS4KICAgKiBJZiBhIGNvbGxhcHNlZCByYW5nZSBpcyBwcm92aWRlZCwgaXQgd2lsbCBiZSB3cmFwcGVkIG9ubHkgaWYgaXQgaXMgZXF1YWwgdG8gdmlldyBzZWxlY3Rpb24uCiAgICoKICAgKiBJZiBhIGNvbGxhcHNlZCByYW5nZSB3YXMgcGFzc2VkIGFuZCBpcyBzYW1lIGFzIHNlbGVjdGlvbiwgdGhlIHNlbGVjdGlvbgogICAqIHdpbGwgYmUgbW92ZWQgdG8gdGhlIGluc2lkZSBvZiB0aGUgd3JhcHBlZCBhdHRyaWJ1dGUgZWxlbWVudC4KICAgKgogICAqIFRocm93cyB7QGxpbmsgbW9kdWxlOnV0aWxzL2NrZWRpdG9yZXJyb3J+Q0tFZGl0b3JFcnJvcn0gYHZpZXctd3JpdGVyLWludmFsaWQtcmFuZ2UtY29udGFpbmVyYAogICAqIHdoZW4ge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9yYW5nZX5SYW5nZSNzdGFydH0KICAgKiBhbmQge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9yYW5nZX5SYW5nZSNlbmR9IHBvc2l0aW9ucyBhcmUgbm90IHBsYWNlZCBpbnNpZGUgc2FtZSBwYXJlbnQgY29udGFpbmVyLgogICAqCiAgICogVGhyb3dzIHtAbGluayBtb2R1bGU6dXRpbHMvY2tlZGl0b3JlcnJvcn5DS0VkaXRvckVycm9yfSBgdmlldy13cml0ZXItd3JhcC1pbnZhbGlkLWF0dHJpYnV0ZWAgd2hlbiBwYXNzZWQgYXR0cmlidXRlIGVsZW1lbnQgaXMgbm90CiAgICogYW4gaW5zdGFuY2Ugb2Yge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9hdHRyaWJ1dGVlbGVtZW50fkF0dHJpYnV0ZUVsZW1lbnQgQXR0cmlidXRlRWxlbWVudH0uCiAgICoKICAgKiBUaHJvd3Mge0BsaW5rIG1vZHVsZTp1dGlscy9ja2VkaXRvcmVycm9yfkNLRWRpdG9yRXJyb3J9IGB2aWV3LXdyaXRlci13cmFwLW5vbnNlbGVjdGlvbi1jb2xsYXBzZWQtcmFuZ2VgIHdoZW4gcGFzc2VkIHJhbmdlCiAgICogaXMgY29sbGFwc2VkIGFuZCBkaWZmZXJlbnQgdGhhbiB2aWV3IHNlbGVjdGlvbi4KICAgKgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L3JhbmdlflJhbmdlfSByYW5nZSBSYW5nZSB0byB3cmFwLgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L2F0dHJpYnV0ZWVsZW1lbnR+QXR0cmlidXRlRWxlbWVudH0gYXR0cmlidXRlIEF0dHJpYnV0ZSBlbGVtZW50IHRvIHVzZSBhcyB3cmFwcGVyLgogICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL3ZpZXcvcmFuZ2V+UmFuZ2V9IHJhbmdlIFJhbmdlIGFmdGVyIHdyYXBwaW5nLCBzcGFubmluZyBvdmVyIHdyYXBwaW5nIGF0dHJpYnV0ZSBlbGVtZW50LgogICovCgoKICB3cmFwKHJhbmdlLCBhdHRyaWJ1dGUpIHsKICAgIGlmICghKGF0dHJpYnV0ZSBpbnN0YW5jZW9mIEF0dHJpYnV0ZUVsZW1lbnQpKSB7CiAgICAgIHRocm93IG5ldyBDS0VkaXRvckVycm9yKCd2aWV3LXdyaXRlci13cmFwLWludmFsaWQtYXR0cmlidXRlJywgdGhpcy5kb2N1bWVudCk7CiAgICB9CgogICAgdmFsaWRhdGVSYW5nZUNvbnRhaW5lcihyYW5nZSwgdGhpcy5kb2N1bWVudCk7CgogICAgaWYgKCFyYW5nZS5pc0NvbGxhcHNlZCkgewogICAgICAvLyBOb24tY29sbGFwc2VkIHJhbmdlLiBXcmFwIGl0IHdpdGggdGhlIGF0dHJpYnV0ZSBlbGVtZW50LgogICAgICByZXR1cm4gdGhpcy5fd3JhcFJhbmdlKHJhbmdlLCBhdHRyaWJ1dGUpOwogICAgfSBlbHNlIHsKICAgICAgLy8gQ29sbGFwc2VkIHJhbmdlLiBXcmFwIHBvc2l0aW9uLgogICAgICBsZXQgcG9zaXRpb24gPSByYW5nZS5zdGFydDsKCiAgICAgIGlmIChwb3NpdGlvbi5wYXJlbnQuaXMoJ2VsZW1lbnQnKSAmJiAhX2hhc05vblVpQ2hpbGRyZW4ocG9zaXRpb24ucGFyZW50KSkgewogICAgICAgIHBvc2l0aW9uID0gcG9zaXRpb24uZ2V0TGFzdE1hdGNoaW5nUG9zaXRpb24odmFsdWUgPT4gdmFsdWUuaXRlbS5pcygndWlFbGVtZW50JykpOwogICAgICB9CgogICAgICBwb3NpdGlvbiA9IHRoaXMuX3dyYXBQb3NpdGlvbihwb3NpdGlvbiwgYXR0cmlidXRlKTsKICAgICAgY29uc3Qgdmlld1NlbGVjdGlvbiA9IHRoaXMuZG9jdW1lbnQuc2VsZWN0aW9uOyAvLyBJZiB3cmFwcGluZyBwb3NpdGlvbiBpcyBlcXVhbCB0byB2aWV3IHNlbGVjdGlvbiwgbW92ZSB2aWV3IHNlbGVjdGlvbiBpbnNpZGUgd3JhcHBpbmcgYXR0cmlidXRlIGVsZW1lbnQuCgogICAgICBpZiAodmlld1NlbGVjdGlvbi5pc0NvbGxhcHNlZCAmJiB2aWV3U2VsZWN0aW9uLmdldEZpcnN0UG9zaXRpb24oKS5pc0VxdWFsKHJhbmdlLnN0YXJ0KSkgewogICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uKHBvc2l0aW9uKTsKICAgICAgfQoKICAgICAgcmV0dXJuIG5ldyBSYW5nZShwb3NpdGlvbik7CiAgICB9CiAgfQogIC8qKgogICAqIFVud3JhcHMgbm9kZXMgd2l0aGluIHByb3ZpZGVkIHJhbmdlIGZyb20gYXR0cmlidXRlIGVsZW1lbnQuCiAgICoKICAgKiBUaHJvd3Mge0BsaW5rIG1vZHVsZTp1dGlscy9ja2VkaXRvcmVycm9yfkNLRWRpdG9yRXJyb3IgQ0tFZGl0b3JFcnJvcn0gYHZpZXctd3JpdGVyLWludmFsaWQtcmFuZ2UtY29udGFpbmVyYCB3aGVuCiAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9yYW5nZX5SYW5nZSNzdGFydCBzdGFydH0gYW5kIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvcmFuZ2V+UmFuZ2UjZW5kIGVuZH0gcG9zaXRpb25zIGFyZSBub3QgcGxhY2VkIGluc2lkZQogICAqIHNhbWUgcGFyZW50IGNvbnRhaW5lci4KICAgKgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L3JhbmdlflJhbmdlfSByYW5nZQogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L2F0dHJpYnV0ZWVsZW1lbnR+QXR0cmlidXRlRWxlbWVudH0gYXR0cmlidXRlCiAgICovCgoKICB1bndyYXAocmFuZ2UsIGF0dHJpYnV0ZSkgewogICAgaWYgKCEoYXR0cmlidXRlIGluc3RhbmNlb2YgQXR0cmlidXRlRWxlbWVudCkpIHsKICAgICAgLyoqCiAgICAgICAqIEF0dHJpYnV0ZSBlbGVtZW50IG5lZWQgdG8gYmUgaW5zdGFuY2Ugb2YgYXR0cmlidXRlIGVsZW1lbnQuCiAgICAgICAqCiAgICAgICAqIEBlcnJvciB2aWV3LXdyaXRlci11bndyYXAtaW52YWxpZC1hdHRyaWJ1dGUKICAgICAgICovCiAgICAgIHRocm93IG5ldyBDS0VkaXRvckVycm9yKCd2aWV3LXdyaXRlci11bndyYXAtaW52YWxpZC1hdHRyaWJ1dGUnLCB0aGlzLmRvY3VtZW50KTsKICAgIH0KCiAgICB2YWxpZGF0ZVJhbmdlQ29udGFpbmVyKHJhbmdlLCB0aGlzLmRvY3VtZW50KTsgLy8gSWYgcmFuZ2UgaXMgY29sbGFwc2VkIC0gbm90aGluZyB0byB1bndyYXAuCgogICAgaWYgKHJhbmdlLmlzQ29sbGFwc2VkKSB7CiAgICAgIHJldHVybiByYW5nZTsKICAgIH0gLy8gQnJlYWsgYXR0cmlidXRlcyBhdCByYW5nZSBzdGFydCBhbmQgZW5kLgoKCiAgICBjb25zdCB7CiAgICAgIHN0YXJ0OiBicmVha1N0YXJ0LAogICAgICBlbmQ6IGJyZWFrRW5kCiAgICB9ID0gdGhpcy5fYnJlYWtBdHRyaWJ1dGVzUmFuZ2UocmFuZ2UsIHRydWUpOwoKICAgIGNvbnN0IHBhcmVudENvbnRhaW5lciA9IGJyZWFrU3RhcnQucGFyZW50OyAvLyBVbndyYXAgY2hpbGRyZW4gbG9jYXRlZCBiZXR3ZWVuIGJyZWFrIHBvaW50cy4KCiAgICBjb25zdCBuZXdSYW5nZSA9IHRoaXMuX3Vud3JhcENoaWxkcmVuKHBhcmVudENvbnRhaW5lciwgYnJlYWtTdGFydC5vZmZzZXQsIGJyZWFrRW5kLm9mZnNldCwgYXR0cmlidXRlKTsgLy8gTWVyZ2UgYXR0cmlidXRlcyBhdCB0aGUgYm90aCBlbmRzIGFuZCByZXR1cm4gYSBuZXcgcmFuZ2UuCgoKICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5tZXJnZUF0dHJpYnV0ZXMobmV3UmFuZ2Uuc3RhcnQpOyAvLyBJZiBzdGFydCBwb3NpdGlvbiB3YXMgbWVyZ2VkIC0gbW92ZSBlbmQgcG9zaXRpb24gYmFjay4KCiAgICBpZiAoIXN0YXJ0LmlzRXF1YWwobmV3UmFuZ2Uuc3RhcnQpKSB7CiAgICAgIG5ld1JhbmdlLmVuZC5vZmZzZXQtLTsKICAgIH0KCiAgICBjb25zdCBlbmQgPSB0aGlzLm1lcmdlQXR0cmlidXRlcyhuZXdSYW5nZS5lbmQpOwogICAgcmV0dXJuIG5ldyBSYW5nZShzdGFydCwgZW5kKTsKICB9CiAgLyoqCiAgICogUmVuYW1lcyBlbGVtZW50IGJ5IGNyZWF0aW5nIGEgY29weSBvZiByZW5hbWVkIGVsZW1lbnQgYnV0IHdpdGggY2hhbmdlZCBuYW1lIGFuZCB0aGVuIG1vdmluZyBjb250ZW50cyBvZiB0aGUKICAgKiBvbGQgZWxlbWVudCB0byB0aGUgbmV3IG9uZS4gS2VlcCBpbiBtaW5kIHRoYXQgdGhpcyB3aWxsIGludmFsaWRhdGUgYWxsIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvcG9zaXRpb25+UG9zaXRpb24gcG9zaXRpb25zfSB3aGljaAogICAqIGhhcyByZW5hbWVkIGVsZW1lbnQgYXMge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbiNwYXJlbnQgYSBwYXJlbnR9LgogICAqCiAgICogTmV3IGVsZW1lbnQgaGFzIHRvIGJlIGNyZWF0ZWQgYmVjYXVzZSBgRWxlbWVudCN0YWdOYW1lYCBwcm9wZXJ0eSBpbiBET00gaXMgcmVhZG9ubHkuCiAgICoKICAgKiBTaW5jZSB0aGlzIGZ1bmN0aW9uIGNyZWF0ZXMgYSBuZXcgZWxlbWVudCBhbmQgcmVtb3ZlcyB0aGUgZ2l2ZW4gb25lLCB0aGUgbmV3IGVsZW1lbnQgaXMgcmV0dXJuZWQgdG8ga2VlcCByZWZlcmVuY2UuCiAgICoKICAgKiBAcGFyYW0ge1N0cmluZ30gbmV3TmFtZSBOZXcgbmFtZSBmb3IgZWxlbWVudC4KICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9jb250YWluZXJlbGVtZW50fkNvbnRhaW5lckVsZW1lbnR9IHZpZXdFbGVtZW50IEVsZW1lbnQgdG8gYmUgcmVuYW1lZC4KICAgKi8KCgogIHJlbmFtZShuZXdOYW1lLCB2aWV3RWxlbWVudCkgewogICAgY29uc3QgbmV3RWxlbWVudCA9IG5ldyBDb250YWluZXJFbGVtZW50KG5ld05hbWUsIHZpZXdFbGVtZW50LmdldEF0dHJpYnV0ZXMoKSk7CiAgICB0aGlzLmluc2VydChQb3NpdGlvbi5fY3JlYXRlQWZ0ZXIodmlld0VsZW1lbnQpLCBuZXdFbGVtZW50KTsKICAgIHRoaXMubW92ZShSYW5nZS5fY3JlYXRlSW4odmlld0VsZW1lbnQpLCBQb3NpdGlvbi5fY3JlYXRlQXQobmV3RWxlbWVudCwgMCkpOwogICAgdGhpcy5yZW1vdmUoUmFuZ2UuX2NyZWF0ZU9uKHZpZXdFbGVtZW50KSk7CiAgICByZXR1cm4gbmV3RWxlbWVudDsKICB9CiAgLyoqCiAgICogQ2xlYW5zIHVwIG1lbW9yeSBieSByZW1vdmluZyBvYnNvbGV0ZSBjbG9uZWQgZWxlbWVudHMgZ3JvdXAgZnJvbSB0aGUgd3JpdGVyLgogICAqCiAgICogU2hvdWxkIGJlIHVzZWQgd2hlbmV2ZXIgYWxsIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvYXR0cmlidXRlZWxlbWVudH5BdHRyaWJ1dGVFbGVtZW50IGF0dHJpYnV0ZSBlbGVtZW50c30KICAgKiB3aXRoIHRoZSBzYW1lIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvYXR0cmlidXRlZWxlbWVudH5BdHRyaWJ1dGVFbGVtZW50I2lkIGlkfSBhcmUgZ29pbmcgdG8gYmUgcmVtb3ZlZCBmcm9tIHRoZSB2aWV3IGFuZAogICAqIHRoZSBncm91cCB3aWxsIG5vIGxvbmdlciBiZSBuZWVkZWQuCiAgICoKICAgKiBDbG9uZWQgZWxlbWVudHMgZ3JvdXAgYXJlIG5vdCByZW1vdmVkIGF1dG9tYXRpY2FsbHkgaW4gY2FzZSBpZiB0aGUgZ3JvdXAgaXMgc3RpbGwgbmVlZGVkIGFmdGVyIGFsbCBpdHMgZWxlbWVudHMKICAgKiB3ZXJlIHJlbW92ZWQgZnJvbSB0aGUgdmlldy4KICAgKgogICAqIEtlZXAgaW4gbWluZCB0aGF0IGdyb3VwIG5hbWVzIGFyZSBlcXVhbCB0byB0aGUgYGlkYCBwcm9wZXJ0eSBvZiB0aGUgYXR0cmlidXRlIGVsZW1lbnQuCiAgICoKICAgKiBAcGFyYW0ge1N0cmluZ30gZ3JvdXBOYW1lIE5hbWUgb2YgdGhlIGdyb3VwIHRvIGNsZWFyLgogICAqLwoKCiAgY2xlYXJDbG9uZWRFbGVtZW50c0dyb3VwKGdyb3VwTmFtZSkgewogICAgdGhpcy5fY2xvbmVHcm91cHMuZGVsZXRlKGdyb3VwTmFtZSk7CiAgfQogIC8qKgogICAqIENyZWF0ZXMgcG9zaXRpb24gYXQgdGhlIGdpdmVuIGxvY2F0aW9uLiBUaGUgbG9jYXRpb24gY2FuIGJlIHNwZWNpZmllZCBhczoKICAgKgogICAqICogYSB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3Bvc2l0aW9uflBvc2l0aW9uIHBvc2l0aW9ufSwKICAgKiAqIHBhcmVudCBlbGVtZW50IGFuZCBvZmZzZXQgKG9mZnNldCBkZWZhdWx0cyB0byBgMGApLAogICAqICogcGFyZW50IGVsZW1lbnQgYW5kIGAnZW5kJ2AgKHNldHMgcG9zaXRpb24gYXQgdGhlIGVuZCBvZiB0aGF0IGVsZW1lbnQpLAogICAqICoge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9pdGVtfkl0ZW0gdmlldyBpdGVtfSBhbmQgYCdiZWZvcmUnYCBvciBgJ2FmdGVyJ2AgKHNldHMgcG9zaXRpb24gYmVmb3JlIG9yIGFmdGVyIGdpdmVuIHZpZXcgaXRlbSkuCiAgICoKICAgKiBUaGlzIG1ldGhvZCBpcyBhIHNob3J0Y3V0IHRvIG90aGVyIGNvbnN0cnVjdG9ycyBzdWNoIGFzOgogICAqCiAgICogKiB7QGxpbmsgI2NyZWF0ZVBvc2l0aW9uQmVmb3JlfSwKICAgKiAqIHtAbGluayAjY3JlYXRlUG9zaXRpb25BZnRlcn0sCiAgICoKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9pdGVtfkl0ZW18bW9kdWxlOmVuZ2luZS9tb2RlbC9wb3NpdGlvbn5Qb3NpdGlvbn0gaXRlbU9yUG9zaXRpb24KICAgKiBAcGFyYW0ge051bWJlcnwnZW5kJ3wnYmVmb3JlJ3wnYWZ0ZXInfSBbb2Zmc2V0XSBPZmZzZXQgb3Igb25lIG9mIHRoZSBmbGFncy4gVXNlZCBvbmx5IHdoZW4KICAgKiBmaXJzdCBwYXJhbWV0ZXIgaXMgYSB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2l0ZW1+SXRlbSB2aWV3IGl0ZW19LgogICAqLwoKCiAgY3JlYXRlUG9zaXRpb25BdChpdGVtT3JQb3NpdGlvbiwgb2Zmc2V0KSB7CiAgICByZXR1cm4gUG9zaXRpb24uX2NyZWF0ZUF0KGl0ZW1PclBvc2l0aW9uLCBvZmZzZXQpOwogIH0KICAvKioKICAgKiBDcmVhdGVzIGEgbmV3IHBvc2l0aW9uIGFmdGVyIGdpdmVuIHZpZXcgaXRlbS4KICAgKgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L2l0ZW1+SXRlbX0gaXRlbSBWaWV3IGl0ZW0gYWZ0ZXIgd2hpY2ggdGhlIHBvc2l0aW9uIHNob3VsZCBiZSBsb2NhdGVkLgogICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL3ZpZXcvcG9zaXRpb25+UG9zaXRpb259CiAgICovCgoKICBjcmVhdGVQb3NpdGlvbkFmdGVyKGl0ZW0pIHsKICAgIHJldHVybiBQb3NpdGlvbi5fY3JlYXRlQWZ0ZXIoaXRlbSk7CiAgfQogIC8qKgogICAqIENyZWF0ZXMgYSBuZXcgcG9zaXRpb24gYmVmb3JlIGdpdmVuIHZpZXcgaXRlbS4KICAgKgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L2l0ZW1+SXRlbX0gaXRlbSBWaWV3IGl0ZW0gYmVmb3JlIHdoaWNoIHRoZSBwb3NpdGlvbiBzaG91bGQgYmUgbG9jYXRlZC4KICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS92aWV3L3Bvc2l0aW9uflBvc2l0aW9ufQogICAqLwoKCiAgY3JlYXRlUG9zaXRpb25CZWZvcmUoaXRlbSkgewogICAgcmV0dXJuIFBvc2l0aW9uLl9jcmVhdGVCZWZvcmUoaXRlbSk7CiAgfQogIC8qKgogICAqIENyZWF0ZXMgYSByYW5nZSBzcGFubmluZyBmcm9tIGBzdGFydGAgcG9zaXRpb24gdG8gYGVuZGAgcG9zaXRpb24uCiAgICoKICAgKiAqKk5vdGU6KiogVGhpcyBmYWN0b3J5IG1ldGhvZCBjcmVhdGVzIGl0J3Mgb3duIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvcG9zaXRpb25+UG9zaXRpb259IGluc3RhbmNlcyBiYXNpbmcgb24gcGFzc2VkIHZhbHVlcy4KICAgKgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L3Bvc2l0aW9uflBvc2l0aW9ufSBzdGFydCBTdGFydCBwb3NpdGlvbi4KICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbn0gW2VuZF0gRW5kIHBvc2l0aW9uLiBJZiBub3Qgc2V0LCByYW5nZSB3aWxsIGJlIGNvbGxhcHNlZCBhdCBgc3RhcnRgIHBvc2l0aW9uLgogICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL3ZpZXcvcmFuZ2V+UmFuZ2V9CiAgICovCgoKICBjcmVhdGVSYW5nZShzdGFydCwgZW5kKSB7CiAgICByZXR1cm4gbmV3IFJhbmdlKHN0YXJ0LCBlbmQpOwogIH0KICAvKioKICAgKiBDcmVhdGVzIGEgcmFuZ2UgdGhhdCBzdGFydHMgYmVmb3JlIGdpdmVuIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvaXRlbX5JdGVtIHZpZXcgaXRlbX0gYW5kIGVuZHMgYWZ0ZXIgaXQuCiAgICoKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9pdGVtfkl0ZW19IGl0ZW0KICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS92aWV3L3JhbmdlflJhbmdlfQogICAqLwoKCiAgY3JlYXRlUmFuZ2VPbihpdGVtKSB7CiAgICByZXR1cm4gUmFuZ2UuX2NyZWF0ZU9uKGl0ZW0pOwogIH0KICAvKioKICAgKiBDcmVhdGVzIGEgcmFuZ2UgaW5zaWRlIGFuIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50IGVsZW1lbnR9IHdoaWNoIHN0YXJ0cyBiZWZvcmUgdGhlIGZpcnN0IGNoaWxkIG9mCiAgICogdGhhdCBlbGVtZW50IGFuZCBlbmRzIGFmdGVyIHRoZSBsYXN0IGNoaWxkIG9mIHRoYXQgZWxlbWVudC4KICAgKgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHdoaWNoIGlzIGEgcGFyZW50IGZvciB0aGUgcmFuZ2UuCiAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy9yYW5nZX5SYW5nZX0KICAgKi8KCgogIGNyZWF0ZVJhbmdlSW4oZWxlbWVudCkgewogICAgcmV0dXJuIFJhbmdlLl9jcmVhdGVJbihlbGVtZW50KTsKICB9CiAgLyoqCiAgIENyZWF0ZXMgbmV3IHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvc2VsZWN0aW9uflNlbGVjdGlvbn0gaW5zdGFuY2UuCiAgICoKICAgKiAJCS8vIENyZWF0ZXMgZW1wdHkgc2VsZWN0aW9uIHdpdGhvdXQgcmFuZ2VzLgogICAqCQljb25zdCBzZWxlY3Rpb24gPSB3cml0ZXIuY3JlYXRlU2VsZWN0aW9uKCk7CiAgICoKICAgKgkJLy8gQ3JlYXRlcyBzZWxlY3Rpb24gYXQgdGhlIGdpdmVuIHJhbmdlLgogICAqCQljb25zdCByYW5nZSA9IHdyaXRlci5jcmVhdGVSYW5nZSggc3RhcnQsIGVuZCApOwogICAqCQljb25zdCBzZWxlY3Rpb24gPSB3cml0ZXIuY3JlYXRlU2VsZWN0aW9uKCByYW5nZSApOwogICAqCiAgICoJCS8vIENyZWF0ZXMgc2VsZWN0aW9uIGF0IHRoZSBnaXZlbiByYW5nZXMKICAgKiAJCWNvbnN0IHJhbmdlcyA9IFsgd3JpdGVyLmNyZWF0ZVJhbmdlKCBzdGFydDEsIGVuZDIgKSwgd3JpdGVyLmNyZWF0ZVJhbmdlKCBzdGFyMiwgZW5kMiApIF07CiAgICoJCWNvbnN0IHNlbGVjdGlvbiA9IHdyaXRlci5jcmVhdGVTZWxlY3Rpb24oIHJhbmdlcyApOwogICAqCiAgICoJCS8vIENyZWF0ZXMgc2VsZWN0aW9uIGZyb20gdGhlIG90aGVyIHNlbGVjdGlvbi4KICAgKgkJY29uc3Qgb3RoZXJTZWxlY3Rpb24gPSB3cml0ZXIuY3JlYXRlU2VsZWN0aW9uKCk7CiAgICoJCWNvbnN0IHNlbGVjdGlvbiA9IHdyaXRlci5jcmVhdGVTZWxlY3Rpb24oIG90aGVyU2VsZWN0aW9uICk7CiAgICoKICAgKgkJLy8gQ3JlYXRlcyBzZWxlY3Rpb24gZnJvbSB0aGUgZG9jdW1lbnQgc2VsZWN0aW9uLgogICAqCQljb25zdCBzZWxlY3Rpb24gPSB3cml0ZXIuY3JlYXRlU2VsZWN0aW9uKCBlZGl0b3IuZWRpdGluZy52aWV3LmRvY3VtZW50LnNlbGVjdGlvbiApOwogICAqCiAgICogCQkvLyBDcmVhdGVzIHNlbGVjdGlvbiBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uCiAgICoJCWNvbnN0IHBvc2l0aW9uID0gd3JpdGVyLmNyZWF0ZVBvc2l0aW9uRnJvbVBhdGgoIHJvb3QsIHBhdGggKTsKICAgKgkJY29uc3Qgc2VsZWN0aW9uID0gd3JpdGVyLmNyZWF0ZVNlbGVjdGlvbiggcG9zaXRpb24gKTsKICAgKgogICAqCQkvLyBDcmVhdGVzIGNvbGxhcHNlZCBzZWxlY3Rpb24gYXQgdGhlIHBvc2l0aW9uIG9mIGdpdmVuIGl0ZW0gYW5kIG9mZnNldC4KICAgKgkJY29uc3QgcGFyYWdyYXBoID0gd3JpdGVyLmNyZWF0ZUNvbnRhaW5lckVsZW1lbnQoICdwJyApOwogICAqCQljb25zdCBzZWxlY3Rpb24gPSB3cml0ZXIuY3JlYXRlU2VsZWN0aW9uKCBwYXJhZ3JhcGgsIG9mZnNldCApOwogICAqCiAgICoJCS8vIENyZWF0ZXMgYSByYW5nZSBpbnNpZGUgYW4ge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnQgZWxlbWVudH0gd2hpY2ggc3RhcnRzIGJlZm9yZSB0aGUKICAgKgkJLy8gZmlyc3QgY2hpbGQgb2YgdGhhdCBlbGVtZW50IGFuZCBlbmRzIGFmdGVyIHRoZSBsYXN0IGNoaWxkIG9mIHRoYXQgZWxlbWVudC4KICAgKgkJY29uc3Qgc2VsZWN0aW9uID0gd3JpdGVyLmNyZWF0ZVNlbGVjdGlvbiggcGFyYWdyYXBoLCAnaW4nICk7CiAgICoKICAgKgkJLy8gQ3JlYXRlcyBhIHJhbmdlIG9uIGFuIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvaXRlbX5JdGVtIGl0ZW19IHdoaWNoIHN0YXJ0cyBiZWZvcmUgdGhlIGl0ZW0gYW5kIGVuZHMKICAgKgkJLy8ganVzdCBhZnRlciB0aGUgaXRlbS4KICAgKgkJY29uc3Qgc2VsZWN0aW9uID0gd3JpdGVyLmNyZWF0ZVNlbGVjdGlvbiggcGFyYWdyYXBoLCAnb24nICk7CiAgICoKICAgKiBgU2VsZWN0aW9uYCdzIGNvbnN0cnVjdG9yIGFsbG93IHBhc3NpbmcgYWRkaXRpb25hbCBvcHRpb25zIChgYmFja3dhcmRgLCBgZmFrZWAgYW5kIGBsYWJlbGApIGFzIHRoZSBsYXN0IGFyZ3VtZW50LgogICAqCiAgICoJCS8vIENyZWF0ZXMgYmFja3dhcmQgc2VsZWN0aW9uLgogICAqCQljb25zdCBzZWxlY3Rpb24gPSB3cml0ZXIuY3JlYXRlU2VsZWN0aW9uKCByYW5nZSwgeyBiYWNrd2FyZDogdHJ1ZSB9ICk7CiAgICoKICAgKiBGYWtlIHNlbGVjdGlvbiBkb2VzIG5vdCByZW5kZXIgYXMgYnJvd3NlciBuYXRpdmUgc2VsZWN0aW9uIG92ZXIgc2VsZWN0ZWQgZWxlbWVudHMgYW5kIGlzIGhpZGRlbiB0byB0aGUgdXNlci4KICAgKiBUaGlzIHdheSwgbm8gbmF0aXZlIHNlbGVjdGlvbiBVSSBhcnRpZmFjdHMgYXJlIGRpc3BsYXllZCB0byB0aGUgdXNlciBhbmQgc2VsZWN0aW9uIG92ZXIgZWxlbWVudHMgY2FuIGJlCiAgICogcmVwcmVzZW50ZWQgaW4gb3RoZXIgd2F5LCBmb3IgZXhhbXBsZSBieSBhcHBseWluZyBwcm9wZXIgQ1NTIGNsYXNzLgogICAqCiAgICogQWRkaXRpb25hbGx5IGZha2UncyBzZWxlY3Rpb24gbGFiZWwgY2FuIGJlIHByb3ZpZGVkLiBJdCB3aWxsIGJlIHVzZWQgdG8gZGVzY3JpYmUgZmFrZSBzZWxlY3Rpb24gaW4gRE9NCiAgICogKGFuZCBiZSAgcHJvcGVybHkgaGFuZGxlZCBieSBzY3JlZW4gcmVhZGVycykuCiAgICoKICAgKgkJLy8gQ3JlYXRlcyBmYWtlIHNlbGVjdGlvbiB3aXRoIGxhYmVsLgogICAqCQljb25zdCBzZWxlY3Rpb24gPSB3cml0ZXIuY3JlYXRlU2VsZWN0aW9uKCByYW5nZSwgeyBmYWtlOiB0cnVlLCBsYWJlbDogJ2ZvbycgfSApOwogICAqCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvc2VsZWN0aW9uflNlbGVjdGFibGV9IFtzZWxlY3RhYmxlPW51bGxdCiAgICogQHBhcmFtIHtOdW1iZXJ8J2JlZm9yZSd8J2VuZCd8J2FmdGVyJ3wnb24nfCdpbid9IFtwbGFjZU9yT2Zmc2V0XSBPZmZzZXQgb3IgcGxhY2Ugd2hlbiBzZWxlY3RhYmxlIGlzIGFuIGBJdGVtYC4KICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdCiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5iYWNrd2FyZF0gU2V0cyB0aGlzIHNlbGVjdGlvbiBpbnN0YW5jZSB0byBiZSBiYWNrd2FyZC4KICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZha2VdIFNldHMgdGhpcyBzZWxlY3Rpb24gaW5zdGFuY2UgdG8gYmUgbWFya2VkIGFzIGBmYWtlYC4KICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubGFiZWxdIExhYmVsIGZvciB0aGUgZmFrZSBzZWxlY3Rpb24uCiAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy9zZWxlY3Rpb25+U2VsZWN0aW9ufQogICAqLwoKCiAgY3JlYXRlU2VsZWN0aW9uKHNlbGVjdGFibGUsIHBsYWNlT3JPZmZzZXQsIG9wdGlvbnMpIHsKICAgIHJldHVybiBuZXcgU2VsZWN0aW9uKHNlbGVjdGFibGUsIHBsYWNlT3JPZmZzZXQsIG9wdGlvbnMpOwogIH0KICAvKioKICAgKiBXcmFwcyBjaGlsZHJlbiB3aXRoIHByb3ZpZGVkIGB3cmFwRWxlbWVudGAuIE9ubHkgY2hpbGRyZW4gY29udGFpbmVkIGluIGBwYXJlbnRgIGVsZW1lbnQgYmV0d2VlbgogICAqIGBzdGFydE9mZnNldGAgYW5kIGBlbmRPZmZzZXRgIHdpbGwgYmUgd3JhcHBlZC4KICAgKgogICAqIEBwcml2YXRlCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50fSBwYXJlbnQKICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRPZmZzZXQKICAgKiBAcGFyYW0ge051bWJlcn0gZW5kT2Zmc2V0CiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50fSB3cmFwRWxlbWVudAogICAqLwoKCiAgX3dyYXBDaGlsZHJlbihwYXJlbnQsIHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQsIHdyYXBFbGVtZW50KSB7CiAgICBsZXQgaSA9IHN0YXJ0T2Zmc2V0OwogICAgY29uc3Qgd3JhcFBvc2l0aW9ucyA9IFtdOwoKICAgIHdoaWxlIChpIDwgZW5kT2Zmc2V0KSB7CiAgICAgIGNvbnN0IGNoaWxkID0gcGFyZW50LmdldENoaWxkKGkpOwogICAgICBjb25zdCBpc1RleHQgPSBjaGlsZC5pcygndGV4dCcpOwogICAgICBjb25zdCBpc0F0dHJpYnV0ZSA9IGNoaWxkLmlzKCdhdHRyaWJ1dGVFbGVtZW50Jyk7CiAgICAgIGNvbnN0IGlzRW1wdHkgPSBjaGlsZC5pcygnZW1wdHlFbGVtZW50Jyk7CiAgICAgIGNvbnN0IGlzVUkgPSBjaGlsZC5pcygndWlFbGVtZW50Jyk7IC8vCiAgICAgIC8vIChJbiBhbGwgZXhhbXBsZXMsIGFzc3VtZSB0aGF0IGB3cmFwRWxlbWVudGAgaXMgYDxzcGFuIGNsYXNzPSJmb28iPmAgZWxlbWVudC4pCiAgICAgIC8vCiAgICAgIC8vIENoZWNrIGlmIGB3cmFwRWxlbWVudGAgY2FuIGJlIGpvaW5lZCB3aXRoIHRoZSB3cmFwcGVkIGVsZW1lbnQuIE9uZSBvZiByZXF1aXJlbWVudHMgaXMgaGF2aW5nIHNhbWUgbmFtZS4KICAgICAgLy8gSWYgcG9zc2libGUsIGpvaW4gZWxlbWVudHMuCiAgICAgIC8vCiAgICAgIC8vIDxwPjxzcGFuIGNsYXNzPSJiYXIiPmFiYzwvc3Bhbj48L3A+ICAtLT4gIDxwPjxzcGFuIGNsYXNzPSJmb28gYmFyIj5hYmM8L3NwYW4+PC9wPgogICAgICAvLwoKICAgICAgaWYgKGlzQXR0cmlidXRlICYmIHRoaXMuX3dyYXBBdHRyaWJ1dGVFbGVtZW50KHdyYXBFbGVtZW50LCBjaGlsZCkpIHsKICAgICAgICB3cmFwUG9zaXRpb25zLnB1c2gobmV3IFBvc2l0aW9uKHBhcmVudCwgaSkpOwogICAgICB9IC8vCiAgICAgIC8vIFdyYXAgdGhlIGNoaWxkIGlmIGl0IGlzIG5vdCBhbiBhdHRyaWJ1dGUgZWxlbWVudCBvciBpZiBpdCBpcyBhbiBhdHRyaWJ1dGUgZWxlbWVudCB0aGF0IHNob3VsZCBiZSBpbnNpZGUKICAgICAgLy8gYHdyYXBFbGVtZW50YCAoZHVlIHRvIHByaW9yaXR5KS4KICAgICAgLy8KICAgICAgLy8gPHA+YWJjPC9wPiAgICAgICAgICAgICAgICAgICAtLT4gIDxwPjxzcGFuIGNsYXNzPSJmb28iPmFiYzwvc3Bhbj48L3A+CiAgICAgIC8vIDxwPjxzdHJvbmc+YWJjPC9zdHJvbmc+PC9wPiAgLS0+ICA8cD48c3BhbiBjbGFzcz0iZm9vIj48c3Ryb25nPmFiYzwvc3Ryb25nPjwvc3Bhbj48L3A+CiAgICAgIC8vCiAgICAgIGVsc2UgaWYgKGlzVGV4dCB8fCBpc0VtcHR5IHx8IGlzVUkgfHwgaXNBdHRyaWJ1dGUgJiYgc2hvdWxkQUJlT3V0c2lkZUIod3JhcEVsZW1lbnQsIGNoaWxkKSkgewogICAgICAgICAgLy8gQ2xvbmUgYXR0cmlidXRlLgogICAgICAgICAgY29uc3QgbmV3QXR0cmlidXRlID0gd3JhcEVsZW1lbnQuX2Nsb25lKCk7IC8vIFdyYXAgY3VycmVudCBub2RlIHdpdGggbmV3IGF0dHJpYnV0ZS4KCgogICAgICAgICAgY2hpbGQuX3JlbW92ZSgpOwoKICAgICAgICAgIG5ld0F0dHJpYnV0ZS5fYXBwZW5kQ2hpbGQoY2hpbGQpOwoKICAgICAgICAgIHBhcmVudC5faW5zZXJ0Q2hpbGQoaSwgbmV3QXR0cmlidXRlKTsKCiAgICAgICAgICB0aGlzLl9hZGRUb0Nsb25lZEVsZW1lbnRzR3JvdXAobmV3QXR0cmlidXRlKTsKCiAgICAgICAgICB3cmFwUG9zaXRpb25zLnB1c2gobmV3IFBvc2l0aW9uKHBhcmVudCwgaSkpOwogICAgICAgIH0gLy8KICAgICAgICAvLyBJZiBvdGhlciBuZXN0ZWQgYXR0cmlidXRlIGlzIGZvdW5kIGFuZCBpdCB3YXNuJ3Qgd3JhcHBlZCAoc2VlIGFib3ZlKSwgY29udGludWUgd3JhcHBpbmcgaW5zaWRlIGl0LgogICAgICAgIC8vCiAgICAgICAgLy8gPHA+PGEgaHJlZj0iZm9vLmh0bWwiPmFiYzwvYT48L3A+ICAtLT4gIDxwPjxhIGhyZWY9ImZvby5odG1sIj48c3BhbiBjbGFzcz0iZm9vIj5hYmM8L3NwYW4+PC9hPjwvcD4KICAgICAgICAvLwogICAgICAgIGVsc2UgaWYgKGlzQXR0cmlidXRlKSB7CiAgICAgICAgICAgIHRoaXMuX3dyYXBDaGlsZHJlbihjaGlsZCwgMCwgY2hpbGQuY2hpbGRDb3VudCwgd3JhcEVsZW1lbnQpOwogICAgICAgICAgfQoKICAgICAgaSsrOwogICAgfSAvLyBNZXJnZSBhdCBlYWNoIHdyYXAuCgoKICAgIGxldCBvZmZzZXRDaGFuZ2UgPSAwOwoKICAgIGZvciAoY29uc3QgcG9zaXRpb24gb2Ygd3JhcFBvc2l0aW9ucykgewogICAgICBwb3NpdGlvbi5vZmZzZXQgLT0gb2Zmc2V0Q2hhbmdlOyAvLyBEbyBub3QgbWVyZ2Ugd2l0aCBlbGVtZW50cyBvdXRzaWRlIHNlbGVjdGVkIGNoaWxkcmVuLgoKICAgICAgaWYgKHBvc2l0aW9uLm9mZnNldCA9PSBzdGFydE9mZnNldCkgewogICAgICAgIGNvbnRpbnVlOwogICAgICB9CgogICAgICBjb25zdCBuZXdQb3NpdGlvbiA9IHRoaXMubWVyZ2VBdHRyaWJ1dGVzKHBvc2l0aW9uKTsgLy8gSWYgbm9kZXMgd2VyZSBtZXJnZWQgLSBvdGhlciBtZXJnZSBvZmZzZXRzIHdpbGwgY2hhbmdlLgoKICAgICAgaWYgKCFuZXdQb3NpdGlvbi5pc0VxdWFsKHBvc2l0aW9uKSkgewogICAgICAgIG9mZnNldENoYW5nZSsrOwogICAgICAgIGVuZE9mZnNldC0tOwogICAgICB9CiAgICB9CgogICAgcmV0dXJuIFJhbmdlLl9jcmVhdGVGcm9tUGFyZW50c0FuZE9mZnNldHMocGFyZW50LCBzdGFydE9mZnNldCwgcGFyZW50LCBlbmRPZmZzZXQpOwogIH0KICAvKioKICAgKiBVbndyYXBzIGNoaWxkcmVuIGZyb20gcHJvdmlkZWQgYHVud3JhcEVsZW1lbnRgLiBPbmx5IGNoaWxkcmVuIGNvbnRhaW5lZCBpbiBgcGFyZW50YCBlbGVtZW50IGJldHdlZW4KICAgKiBgc3RhcnRPZmZzZXRgIGFuZCBgZW5kT2Zmc2V0YCB3aWxsIGJlIHVud3JhcHBlZC4KICAgKgogICAqIEBwcml2YXRlCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50fSBwYXJlbnQKICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRPZmZzZXQKICAgKiBAcGFyYW0ge051bWJlcn0gZW5kT2Zmc2V0CiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50fSB1bndyYXBFbGVtZW50CiAgICovCgoKICBfdW53cmFwQ2hpbGRyZW4ocGFyZW50LCBzdGFydE9mZnNldCwgZW5kT2Zmc2V0LCB1bndyYXBFbGVtZW50KSB7CiAgICBsZXQgaSA9IHN0YXJ0T2Zmc2V0OwogICAgY29uc3QgdW53cmFwUG9zaXRpb25zID0gW107IC8vIEl0ZXJhdGUgb3ZlciBlYWNoIGVsZW1lbnQgYmV0d2VlbiBwcm92aWRlZCBvZmZzZXRzIGluc2lkZSBwYXJlbnQuCiAgICAvLyBXZSBkb24ndCB1c2UgdHJlZSB3YWxrZXIgb3IgcmFuZ2UgaXRlcmF0b3IgYmVjYXVzZSB3ZSB3aWxsIGJlIHJlbW92aW5nIGFuZCBtZXJnaW5nIHBvdGVudGlhbGx5IG11bHRpcGxlIG5vZGVzLAogICAgLy8gc28gaXQgY291bGQgZ2V0IG1lc3N5LiBJdCBpcyBzYWZlciB0byBpdCBtYW51YWxseSBpbiB0aGlzIGNhc2UuCgogICAgd2hpbGUgKGkgPCBlbmRPZmZzZXQpIHsKICAgICAgY29uc3QgY2hpbGQgPSBwYXJlbnQuZ2V0Q2hpbGQoaSk7IC8vIFNraXAgYWxsIHRleHQgbm9kZXMuIFRoZXJlIHNob3VsZCBiZSBubyBjb250YWluZXIgZWxlbWVudCdzIGhlcmUgZWl0aGVyLgoKICAgICAgaWYgKCFjaGlsZC5pcygnYXR0cmlidXRlRWxlbWVudCcpKSB7CiAgICAgICAgaSsrOwogICAgICAgIGNvbnRpbnVlOwogICAgICB9IC8vCiAgICAgIC8vIChJbiBhbGwgZXhhbXBsZXMsIGFzc3VtZSB0aGF0IGB1bndyYXBFbGVtZW50YCBpcyBgPHNwYW4gY2xhc3M9ImZvbyI+YCBlbGVtZW50LikKICAgICAgLy8KICAgICAgLy8gSWYgdGhlIGNoaWxkIGlzIHNpbWlsYXIgdG8gdGhlIGdpdmVuIGF0dHJpYnV0ZSBlbGVtZW50LCB1bndyYXAgaXQgLSBpdCB3aWxsIGJlIGNvbXBsZXRlbHkgcmVtb3ZlZC4KICAgICAgLy8KICAgICAgLy8gPHA+PHNwYW4gY2xhc3M9ImZvbyI+YWJjPC9zcGFuPnh5ejwvcD4gIC0tPiAgPHA+YWJjeHl6PC9wPgogICAgICAvLwoKCiAgICAgIGlmIChjaGlsZC5pc1NpbWlsYXIodW53cmFwRWxlbWVudCkpIHsKICAgICAgICBjb25zdCB1bndyYXBwZWQgPSBjaGlsZC5nZXRDaGlsZHJlbigpOwogICAgICAgIGNvbnN0IGNvdW50ID0gY2hpbGQuY2hpbGRDb3VudDsgLy8gUmVwbGFjZSB3cmFwcGVyIGVsZW1lbnQgd2l0aCBpdHMgY2hpbGRyZW4KCiAgICAgICAgY2hpbGQuX3JlbW92ZSgpOwoKICAgICAgICBwYXJlbnQuX2luc2VydENoaWxkKGksIHVud3JhcHBlZCk7CgogICAgICAgIHRoaXMuX3JlbW92ZUZyb21DbG9uZWRFbGVtZW50c0dyb3VwKGNoaWxkKTsgLy8gU2F2ZSBzdGFydCBhbmQgZW5kIHBvc2l0aW9uIG9mIG1vdmVkIGl0ZW1zLgoKCiAgICAgICAgdW53cmFwUG9zaXRpb25zLnB1c2gobmV3IFBvc2l0aW9uKHBhcmVudCwgaSksIG5ldyBQb3NpdGlvbihwYXJlbnQsIGkgKyBjb3VudCkpOyAvLyBTa2lwIGVsZW1lbnRzIHRoYXQgd2VyZSB1bndyYXBwZWQuIEFzc3VtaW5nIHRoZXJlIHdvbid0IGJlIGFub3RoZXIgZWxlbWVudCB0byB1bndyYXAgaW4gY2hpbGQgZWxlbWVudHMuCgogICAgICAgIGkgKz0gY291bnQ7CiAgICAgICAgZW5kT2Zmc2V0ICs9IGNvdW50IC0gMTsKICAgICAgICBjb250aW51ZTsKICAgICAgfSAvLwogICAgICAvLyBJZiB0aGUgY2hpbGQgaXMgbm90IHNpbWlsYXIgYnV0IGlzIGFuIGF0dHJpYnV0ZSBlbGVtZW50LCB0cnkgcGFydGlhbCB1bndyYXBwaW5nIC0gcmVtb3ZlIHRoZSBzYW1lIGF0dHJpYnV0ZXMvc3R5bGVzL2NsYXNzZXMuCiAgICAgIC8vIFBhcnRpYWwgdW53cmFwcGluZyB3aWxsIGhhcHBlbiBvbmx5IGlmIHRoZSBlbGVtZW50cyBoYXZlIHRoZSBzYW1lIG5hbWUuCiAgICAgIC8vCiAgICAgIC8vIDxwPjxzcGFuIGNsYXNzPSJmb28gYmFyIj5hYmM8L3NwYW4+eHl6PC9wPiAgLS0+ICA8cD48c3BhbiBjbGFzcz0iYmFyIj5hYmM8L3NwYW4+eHl6PC9wPgogICAgICAvLyA8cD48aSBjbGFzcz0iZm9vIj5hYmM8L2k+eHl6PC9wPiAgICAgICAgICAgIC0tPiAgPHA+PGkgY2xhc3M9ImZvbyI+YWJjPC9pPnh5ejwvcD4KICAgICAgLy8KCgogICAgICBpZiAodGhpcy5fdW53cmFwQXR0cmlidXRlRWxlbWVudCh1bndyYXBFbGVtZW50LCBjaGlsZCkpIHsKICAgICAgICB1bndyYXBQb3NpdGlvbnMucHVzaChuZXcgUG9zaXRpb24ocGFyZW50LCBpKSwgbmV3IFBvc2l0aW9uKHBhcmVudCwgaSArIDEpKTsKICAgICAgICBpKys7CiAgICAgICAgY29udGludWU7CiAgICAgIH0gLy8KICAgICAgLy8gSWYgb3RoZXIgbmVzdGVkIGF0dHJpYnV0ZSBpcyBmb3VuZCwgbG9vayB0aHJvdWdoIGl0J3MgY2hpbGRyZW4gZm9yIGVsZW1lbnRzIHRvIHVud3JhcC4KICAgICAgLy8KICAgICAgLy8gPHA+PGk+PHNwYW4gY2xhc3M9ImZvbyI+YWJjPC9zcGFuPjwvaT48cD4gIC0tPiAgPHA+PGk+YWJjPC9pPjxwPgogICAgICAvLwoKCiAgICAgIHRoaXMuX3Vud3JhcENoaWxkcmVuKGNoaWxkLCAwLCBjaGlsZC5jaGlsZENvdW50LCB1bndyYXBFbGVtZW50KTsKCiAgICAgIGkrKzsKICAgIH0gLy8gTWVyZ2UgYXQgZWFjaCB1bndyYXAuCgoKICAgIGxldCBvZmZzZXRDaGFuZ2UgPSAwOwoKICAgIGZvciAoY29uc3QgcG9zaXRpb24gb2YgdW53cmFwUG9zaXRpb25zKSB7CiAgICAgIHBvc2l0aW9uLm9mZnNldCAtPSBvZmZzZXRDaGFuZ2U7IC8vIERvIG5vdCBtZXJnZSB3aXRoIGVsZW1lbnRzIG91dHNpZGUgc2VsZWN0ZWQgY2hpbGRyZW4uCgogICAgICBpZiAocG9zaXRpb24ub2Zmc2V0ID09IHN0YXJ0T2Zmc2V0IHx8IHBvc2l0aW9uLm9mZnNldCA9PSBlbmRPZmZzZXQpIHsKICAgICAgICBjb250aW51ZTsKICAgICAgfQoKICAgICAgY29uc3QgbmV3UG9zaXRpb24gPSB0aGlzLm1lcmdlQXR0cmlidXRlcyhwb3NpdGlvbik7IC8vIElmIG5vZGVzIHdlcmUgbWVyZ2VkIC0gb3RoZXIgbWVyZ2Ugb2Zmc2V0cyB3aWxsIGNoYW5nZS4KCiAgICAgIGlmICghbmV3UG9zaXRpb24uaXNFcXVhbChwb3NpdGlvbikpIHsKICAgICAgICBvZmZzZXRDaGFuZ2UrKzsKICAgICAgICBlbmRPZmZzZXQtLTsKICAgICAgfQogICAgfQoKICAgIHJldHVybiBSYW5nZS5fY3JlYXRlRnJvbVBhcmVudHNBbmRPZmZzZXRzKHBhcmVudCwgc3RhcnRPZmZzZXQsIHBhcmVudCwgZW5kT2Zmc2V0KTsKICB9CiAgLyoqCiAgICogSGVscGVyIGZ1bmN0aW9uIGZvciBgdmlldy53cml0ZXIud3JhcGAuIFdyYXBzIHJhbmdlIHdpdGggcHJvdmlkZWQgYXR0cmlidXRlIGVsZW1lbnQuCiAgICogVGhpcyBtZXRob2Qgd2lsbCBhbHNvIG1lcmdlIG5ld2x5IGFkZGVkIGF0dHJpYnV0ZSBlbGVtZW50IHdpdGggaXRzIHNpYmxpbmdzIHdoZW5ldmVyIHBvc3NpYmxlLgogICAqCiAgICogVGhyb3dzIHtAbGluayBtb2R1bGU6dXRpbHMvY2tlZGl0b3JlcnJvcn5DS0VkaXRvckVycm9yfSBgdmlldy13cml0ZXItd3JhcC1pbnZhbGlkLWF0dHJpYnV0ZWAgd2hlbiBwYXNzZWQgYXR0cmlidXRlIGVsZW1lbnQgaXMgbm90CiAgICogYW4gaW5zdGFuY2Ugb2Yge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9hdHRyaWJ1dGVlbGVtZW50fkF0dHJpYnV0ZUVsZW1lbnQgQXR0cmlidXRlRWxlbWVudH0uCiAgICoKICAgKiBAcHJpdmF0ZQogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L3JhbmdlflJhbmdlfSByYW5nZQogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L2F0dHJpYnV0ZWVsZW1lbnR+QXR0cmlidXRlRWxlbWVudH0gYXR0cmlidXRlCiAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy9yYW5nZX5SYW5nZX0gTmV3IHJhbmdlIGFmdGVyIHdyYXBwaW5nLCBzcGFubmluZyBvdmVyIHdyYXBwaW5nIGF0dHJpYnV0ZSBlbGVtZW50LgogICAqLwoKCiAgX3dyYXBSYW5nZShyYW5nZSwgYXR0cmlidXRlKSB7CiAgICAvLyBCcmVhayBhdHRyaWJ1dGVzIGF0IHJhbmdlIHN0YXJ0IGFuZCBlbmQuCiAgICBjb25zdCB7CiAgICAgIHN0YXJ0OiBicmVha1N0YXJ0LAogICAgICBlbmQ6IGJyZWFrRW5kCiAgICB9ID0gdGhpcy5fYnJlYWtBdHRyaWJ1dGVzUmFuZ2UocmFuZ2UsIHRydWUpOwoKICAgIGNvbnN0IHBhcmVudENvbnRhaW5lciA9IGJyZWFrU3RhcnQucGFyZW50OyAvLyBXcmFwIGFsbCBjaGlsZHJlbiB3aXRoIGF0dHJpYnV0ZS4KCiAgICBjb25zdCBuZXdSYW5nZSA9IHRoaXMuX3dyYXBDaGlsZHJlbihwYXJlbnRDb250YWluZXIsIGJyZWFrU3RhcnQub2Zmc2V0LCBicmVha0VuZC5vZmZzZXQsIGF0dHJpYnV0ZSk7IC8vIE1lcmdlIGF0dHJpYnV0ZXMgYXQgdGhlIGJvdGggZW5kcyBhbmQgcmV0dXJuIGEgbmV3IHJhbmdlLgoKCiAgICBjb25zdCBzdGFydCA9IHRoaXMubWVyZ2VBdHRyaWJ1dGVzKG5ld1JhbmdlLnN0YXJ0KTsgLy8gSWYgc3RhcnQgcG9zaXRpb24gd2FzIG1lcmdlZCAtIG1vdmUgZW5kIHBvc2l0aW9uIGJhY2suCgogICAgaWYgKCFzdGFydC5pc0VxdWFsKG5ld1JhbmdlLnN0YXJ0KSkgewogICAgICBuZXdSYW5nZS5lbmQub2Zmc2V0LS07CiAgICB9CgogICAgY29uc3QgZW5kID0gdGhpcy5tZXJnZUF0dHJpYnV0ZXMobmV3UmFuZ2UuZW5kKTsKICAgIHJldHVybiBuZXcgUmFuZ2Uoc3RhcnQsIGVuZCk7CiAgfQogIC8qKgogICAqIEhlbHBlciBmdW5jdGlvbiBmb3Ige0BsaW5rICN3cmFwfS4gV3JhcHMgcG9zaXRpb24gd2l0aCBwcm92aWRlZCBhdHRyaWJ1dGUgZWxlbWVudC4KICAgKiBUaGlzIG1ldGhvZCB3aWxsIGFsc28gbWVyZ2UgbmV3bHkgYWRkZWQgYXR0cmlidXRlIGVsZW1lbnQgd2l0aCBpdHMgc2libGluZ3Mgd2hlbmV2ZXIgcG9zc2libGUuCiAgICoKICAgKiBUaHJvd3Mge0BsaW5rIG1vZHVsZTp1dGlscy9ja2VkaXRvcmVycm9yfkNLRWRpdG9yRXJyb3J9IGB2aWV3LXdyaXRlci13cmFwLWludmFsaWQtYXR0cmlidXRlYCB3aGVuIHBhc3NlZCBhdHRyaWJ1dGUgZWxlbWVudCBpcyBub3QKICAgKiBhbiBpbnN0YW5jZSBvZiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2F0dHJpYnV0ZWVsZW1lbnR+QXR0cmlidXRlRWxlbWVudCBBdHRyaWJ1dGVFbGVtZW50fS4KICAgKgogICAqIEBwcml2YXRlCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvcG9zaXRpb25+UG9zaXRpb259IHBvc2l0aW9uCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvYXR0cmlidXRlZWxlbWVudH5BdHRyaWJ1dGVFbGVtZW50fSBhdHRyaWJ1dGUKICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS92aWV3L3Bvc2l0aW9uflBvc2l0aW9ufSBOZXcgcG9zaXRpb24gYWZ0ZXIgd3JhcHBpbmcuCiAgICovCgoKICBfd3JhcFBvc2l0aW9uKHBvc2l0aW9uLCBhdHRyaWJ1dGUpIHsKICAgIC8vIFJldHVybiBzYW1lIHBvc2l0aW9uIHdoZW4gdHJ5aW5nIHRvIHdyYXAgd2l0aCBhdHRyaWJ1dGUgc2ltaWxhciB0byBwb3NpdGlvbiBwYXJlbnQuCiAgICBpZiAoYXR0cmlidXRlLmlzU2ltaWxhcihwb3NpdGlvbi5wYXJlbnQpKSB7CiAgICAgIHJldHVybiBtb3ZlUG9zaXRpb25Ub1RleHROb2RlKHBvc2l0aW9uLmNsb25lKCkpOwogICAgfSAvLyBXaGVuIHBvc2l0aW9uIGlzIGluc2lkZSB0ZXh0IG5vZGUgLSBicmVhayBpdCBhbmQgcGxhY2UgbmV3IHBvc2l0aW9uIGJldHdlZW4gdHdvIHRleHQgbm9kZXMuCgoKICAgIGlmIChwb3NpdGlvbi5wYXJlbnQuaXMoJ3RleHQnKSkgewogICAgICBwb3NpdGlvbiA9IGJyZWFrVGV4dE5vZGUocG9zaXRpb24pOwogICAgfSAvLyBDcmVhdGUgZmFrZSBlbGVtZW50IHRoYXQgd2lsbCByZXByZXNlbnQgcG9zaXRpb24sIGFuZCB3aWxsIG5vdCBiZSBtZXJnZWQgd2l0aCBvdGhlciBhdHRyaWJ1dGVzLgoKCiAgICBjb25zdCBmYWtlUG9zaXRpb24gPSB0aGlzLmNyZWF0ZUF0dHJpYnV0ZUVsZW1lbnQoKTsKICAgIGZha2VQb3NpdGlvbi5fcHJpb3JpdHkgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7CgogICAgZmFrZVBvc2l0aW9uLmlzU2ltaWxhciA9ICgpID0+IGZhbHNlOyAvLyBJbnNlcnQgZmFrZSBlbGVtZW50IGluIHBvc2l0aW9uIGxvY2F0aW9uLgoKCiAgICBwb3NpdGlvbi5wYXJlbnQuX2luc2VydENoaWxkKHBvc2l0aW9uLm9mZnNldCwgZmFrZVBvc2l0aW9uKTsgLy8gUmFuZ2UgYXJvdW5kIGluc2VydGVkIGZha2UgYXR0cmlidXRlIGVsZW1lbnQuCgoKICAgIGNvbnN0IHdyYXBSYW5nZSA9IG5ldyBSYW5nZShwb3NpdGlvbiwgcG9zaXRpb24uZ2V0U2hpZnRlZEJ5KDEpKTsgLy8gV3JhcCBmYWtlIGVsZW1lbnQgd2l0aCBhdHRyaWJ1dGUgKGl0IHdpbGwgYWxzbyBtZXJnZSBpZiBwb3NzaWJsZSkuCgogICAgdGhpcy53cmFwKHdyYXBSYW5nZSwgYXR0cmlidXRlKTsgLy8gUmVtb3ZlIGZha2UgZWxlbWVudCBhbmQgcGxhY2UgbmV3IHBvc2l0aW9uIHRoZXJlLgoKICAgIGNvbnN0IG5ld1Bvc2l0aW9uID0gbmV3IFBvc2l0aW9uKGZha2VQb3NpdGlvbi5wYXJlbnQsIGZha2VQb3NpdGlvbi5pbmRleCk7CgogICAgZmFrZVBvc2l0aW9uLl9yZW1vdmUoKTsgLy8gSWYgcG9zaXRpb24gaXMgcGxhY2VkIGJldHdlZW4gdGV4dCBub2RlcyAtIG1lcmdlIHRoZW0gYW5kIHJldHVybiBwb3NpdGlvbiBpbnNpZGUuCgoKICAgIGNvbnN0IG5vZGVCZWZvcmUgPSBuZXdQb3NpdGlvbi5ub2RlQmVmb3JlOwogICAgY29uc3Qgbm9kZUFmdGVyID0gbmV3UG9zaXRpb24ubm9kZUFmdGVyOwoKICAgIGlmIChub2RlQmVmb3JlIGluc3RhbmNlb2YgVGV4dCAmJiBub2RlQWZ0ZXIgaW5zdGFuY2VvZiBUZXh0KSB7CiAgICAgIHJldHVybiBtZXJnZVRleHROb2Rlcyhub2RlQmVmb3JlLCBub2RlQWZ0ZXIpOwogICAgfSAvLyBJZiBwb3NpdGlvbiBpcyBuZXh0IHRvIHRleHQgbm9kZSAtIG1vdmUgcG9zaXRpb24gaW5zaWRlLgoKCiAgICByZXR1cm4gbW92ZVBvc2l0aW9uVG9UZXh0Tm9kZShuZXdQb3NpdGlvbik7CiAgfQogIC8qKgogICAqIAlXcmFwcyBvbmUge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9hdHRyaWJ1dGVlbGVtZW50fkF0dHJpYnV0ZUVsZW1lbnQgQXR0cmlidXRlRWxlbWVudH0gaW50byBhbm90aGVyIGJ5CiAgICogCW1lcmdpbmcgdGhlbSBpZiBwb3NzaWJsZS4gV2hlbiBtZXJnaW5nIGlzIHBvc3NpYmxlIC0gYWxsIGF0dHJpYnV0ZXMsIHN0eWxlcyBhbmQgY2xhc3NlcyBhcmUgbW92ZWQgZnJvbSB3cmFwcGVyCiAgICogCWVsZW1lbnQgdG8gZWxlbWVudCBiZWluZyB3cmFwcGVkLgogICAqCiAgICogCUBwcml2YXRlCiAgICogCUBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L2F0dHJpYnV0ZWVsZW1lbnR+QXR0cmlidXRlRWxlbWVudH0gd3JhcHBlciBXcmFwcGVyIEF0dHJpYnV0ZUVsZW1lbnQuCiAgICogCUBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L2F0dHJpYnV0ZWVsZW1lbnR+QXR0cmlidXRlRWxlbWVudH0gdG9XcmFwIEF0dHJpYnV0ZUVsZW1lbnQgdG8gd3JhcCB1c2luZyB3cmFwcGVyIGVsZW1lbnQuCiAgICogCUByZXR1cm5zIHtCb29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBlbGVtZW50cyBhcmUgbWVyZ2VkLgogICAqLwoKCiAgX3dyYXBBdHRyaWJ1dGVFbGVtZW50KHdyYXBwZXIsIHRvV3JhcCkgewogICAgaWYgKCFjYW5CZUpvaW5lZCh3cmFwcGVyLCB0b1dyYXApKSB7CiAgICAgIHJldHVybiBmYWxzZTsKICAgIH0gLy8gQ2FuJ3QgbWVyZ2UgaWYgbmFtZSBvciBwcmlvcml0eSBkaWZmZXJzLgoKCiAgICBpZiAod3JhcHBlci5uYW1lICE9PSB0b1dyYXAubmFtZSB8fCB3cmFwcGVyLnByaW9yaXR5ICE9PSB0b1dyYXAucHJpb3JpdHkpIHsKICAgICAgcmV0dXJuIGZhbHNlOwogICAgfSAvLyBDaGVjayBpZiBhdHRyaWJ1dGVzIGNhbiBiZSBtZXJnZWQuCgoKICAgIGZvciAoY29uc3Qga2V5IG9mIHdyYXBwZXIuZ2V0QXR0cmlidXRlS2V5cygpKSB7CiAgICAgIC8vIENsYXNzZXMgYW5kIHN0eWxlcyBzaG91bGQgYmUgY2hlY2tlZCBzZXBhcmF0ZWx5LgogICAgICBpZiAoa2V5ID09PSAnY2xhc3MnIHx8IGtleSA9PT0gJ3N0eWxlJykgewogICAgICAgIGNvbnRpbnVlOwogICAgICB9IC8vIElmIHNvbWUgYXR0cmlidXRlcyBhcmUgZGlmZmVyZW50IHdlIGNhbm5vdCB3cmFwLgoKCiAgICAgIGlmICh0b1dyYXAuaGFzQXR0cmlidXRlKGtleSkgJiYgdG9XcmFwLmdldEF0dHJpYnV0ZShrZXkpICE9PSB3cmFwcGVyLmdldEF0dHJpYnV0ZShrZXkpKSB7CiAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICB9CiAgICB9IC8vIENoZWNrIGlmIHN0eWxlcyBjYW4gYmUgbWVyZ2VkLgoKCiAgICBmb3IgKGNvbnN0IGtleSBvZiB3cmFwcGVyLmdldFN0eWxlTmFtZXMoKSkgewogICAgICBpZiAodG9XcmFwLmhhc1N0eWxlKGtleSkgJiYgdG9XcmFwLmdldFN0eWxlKGtleSkgIT09IHdyYXBwZXIuZ2V0U3R5bGUoa2V5KSkgewogICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgfQogICAgfSAvLyBNb3ZlIGFsbCBhdHRyaWJ1dGVzL2NsYXNzZXMvc3R5bGVzIGZyb20gd3JhcHBlciB0byB3cmFwcGVkIEF0dHJpYnV0ZUVsZW1lbnQuCgoKICAgIGZvciAoY29uc3Qga2V5IG9mIHdyYXBwZXIuZ2V0QXR0cmlidXRlS2V5cygpKSB7CiAgICAgIC8vIENsYXNzZXMgYW5kIHN0eWxlcyBzaG91bGQgYmUgY2hlY2tlZCBzZXBhcmF0ZWx5LgogICAgICBpZiAoa2V5ID09PSAnY2xhc3MnIHx8IGtleSA9PT0gJ3N0eWxlJykgewogICAgICAgIGNvbnRpbnVlOwogICAgICB9IC8vIE1vdmUgb25seSB0aGVzZSBhdHRyaWJ1dGVzIHRoYXQgYXJlIG5vdCBwcmVzZW50IC0gb3RoZXIgYXJlIHNpbWlsYXIuCgoKICAgICAgaWYgKCF0b1dyYXAuaGFzQXR0cmlidXRlKGtleSkpIHsKICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShrZXksIHdyYXBwZXIuZ2V0QXR0cmlidXRlKGtleSksIHRvV3JhcCk7CiAgICAgIH0KICAgIH0KCiAgICBmb3IgKGNvbnN0IGtleSBvZiB3cmFwcGVyLmdldFN0eWxlTmFtZXMoKSkgewogICAgICBpZiAoIXRvV3JhcC5oYXNTdHlsZShrZXkpKSB7CiAgICAgICAgdGhpcy5zZXRTdHlsZShrZXksIHdyYXBwZXIuZ2V0U3R5bGUoa2V5KSwgdG9XcmFwKTsKICAgICAgfQogICAgfQoKICAgIGZvciAoY29uc3Qga2V5IG9mIHdyYXBwZXIuZ2V0Q2xhc3NOYW1lcygpKSB7CiAgICAgIGlmICghdG9XcmFwLmhhc0NsYXNzKGtleSkpIHsKICAgICAgICB0aGlzLmFkZENsYXNzKGtleSwgdG9XcmFwKTsKICAgICAgfQogICAgfQoKICAgIHJldHVybiB0cnVlOwogIH0KICAvKioKICAgKiBVbndyYXBzIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvYXR0cmlidXRlZWxlbWVudH5BdHRyaWJ1dGVFbGVtZW50IEF0dHJpYnV0ZUVsZW1lbnR9IGZyb20gYW5vdGhlciBieSByZW1vdmluZwogICAqIGNvcnJlc3BvbmRpbmcgYXR0cmlidXRlcywgY2xhc3NlcyBhbmQgc3R5bGVzLiBBbGwgYXR0cmlidXRlcywgY2xhc3NlcyBhbmQgc3R5bGVzIGZyb20gd3JhcHBlciBzaG91bGQgYmUgcHJlc2VudAogICAqIGluc2lkZSBlbGVtZW50IGJlaW5nIHVud3JhcHBlZC4KICAgKgogICAqIEBwcml2YXRlCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvYXR0cmlidXRlZWxlbWVudH5BdHRyaWJ1dGVFbGVtZW50fSB3cmFwcGVyIFdyYXBwZXIgQXR0cmlidXRlRWxlbWVudC4KICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9hdHRyaWJ1dGVlbGVtZW50fkF0dHJpYnV0ZUVsZW1lbnR9IHRvVW53cmFwIEF0dHJpYnV0ZUVsZW1lbnQgdG8gdW53cmFwIHVzaW5nIHdyYXBwZXIgZWxlbWVudC4KICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgZWxlbWVudHMgYXJlIHVud3JhcHBlZC4KICAgKiovCgoKICBfdW53cmFwQXR0cmlidXRlRWxlbWVudCh3cmFwcGVyLCB0b1Vud3JhcCkgewogICAgaWYgKCFjYW5CZUpvaW5lZCh3cmFwcGVyLCB0b1Vud3JhcCkpIHsKICAgICAgcmV0dXJuIGZhbHNlOwogICAgfSAvLyBDYW4ndCB1bndyYXAgaWYgbmFtZSBvciBwcmlvcml0eSBkaWZmZXJzLgoKCiAgICBpZiAod3JhcHBlci5uYW1lICE9PSB0b1Vud3JhcC5uYW1lIHx8IHdyYXBwZXIucHJpb3JpdHkgIT09IHRvVW53cmFwLnByaW9yaXR5KSB7CiAgICAgIHJldHVybiBmYWxzZTsKICAgIH0gLy8gQ2hlY2sgaWYgQXR0cmlidXRlRWxlbWVudCBoYXMgYWxsIHdyYXBwZXIgYXR0cmlidXRlcy4KCgogICAgZm9yIChjb25zdCBrZXkgb2Ygd3JhcHBlci5nZXRBdHRyaWJ1dGVLZXlzKCkpIHsKICAgICAgLy8gQ2xhc3NlcyBhbmQgc3R5bGVzIHNob3VsZCBiZSBjaGVja2VkIHNlcGFyYXRlbHkuCiAgICAgIGlmIChrZXkgPT09ICdjbGFzcycgfHwga2V5ID09PSAnc3R5bGUnKSB7CiAgICAgICAgY29udGludWU7CiAgICAgIH0gLy8gSWYgc29tZSBhdHRyaWJ1dGVzIGFyZSBtaXNzaW5nIG9yIGRpZmZlcmVudCB3ZSBjYW5ub3QgdW53cmFwLgoKCiAgICAgIGlmICghdG9VbndyYXAuaGFzQXR0cmlidXRlKGtleSkgfHwgdG9VbndyYXAuZ2V0QXR0cmlidXRlKGtleSkgIT09IHdyYXBwZXIuZ2V0QXR0cmlidXRlKGtleSkpIHsKICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH0KICAgIH0gLy8gQ2hlY2sgaWYgQXR0cmlidXRlRWxlbWVudCBoYXMgYWxsIHdyYXBwZXIgY2xhc3Nlcy4KCgogICAgaWYgKCF0b1Vud3JhcC5oYXNDbGFzcyguLi53cmFwcGVyLmdldENsYXNzTmFtZXMoKSkpIHsKICAgICAgcmV0dXJuIGZhbHNlOwogICAgfSAvLyBDaGVjayBpZiBBdHRyaWJ1dGVFbGVtZW50IGhhcyBhbGwgd3JhcHBlciBzdHlsZXMuCgoKICAgIGZvciAoY29uc3Qga2V5IG9mIHdyYXBwZXIuZ2V0U3R5bGVOYW1lcygpKSB7CiAgICAgIC8vIElmIHNvbWUgc3R5bGVzIGFyZSBtaXNzaW5nIG9yIGRpZmZlcmVudCB3ZSBjYW5ub3QgdW53cmFwLgogICAgICBpZiAoIXRvVW53cmFwLmhhc1N0eWxlKGtleSkgfHwgdG9VbndyYXAuZ2V0U3R5bGUoa2V5KSAhPT0gd3JhcHBlci5nZXRTdHlsZShrZXkpKSB7CiAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICB9CiAgICB9IC8vIFJlbW92ZSBhbGwgd3JhcHBlcidzIGF0dHJpYnV0ZXMgZnJvbSB1bndyYXBwZWQgZWxlbWVudC4KCgogICAgZm9yIChjb25zdCBrZXkgb2Ygd3JhcHBlci5nZXRBdHRyaWJ1dGVLZXlzKCkpIHsKICAgICAgLy8gQ2xhc3NlcyBhbmQgc3R5bGVzIHNob3VsZCBiZSBjaGVja2VkIHNlcGFyYXRlbHkuCiAgICAgIGlmIChrZXkgPT09ICdjbGFzcycgfHwga2V5ID09PSAnc3R5bGUnKSB7CiAgICAgICAgY29udGludWU7CiAgICAgIH0KCiAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKGtleSwgdG9VbndyYXApOwogICAgfSAvLyBSZW1vdmUgYWxsIHdyYXBwZXIncyBjbGFzc2VzIGZyb20gdW53cmFwcGVkIGVsZW1lbnQuCgoKICAgIHRoaXMucmVtb3ZlQ2xhc3MoQXJyYXkuZnJvbSh3cmFwcGVyLmdldENsYXNzTmFtZXMoKSksIHRvVW53cmFwKTsgLy8gUmVtb3ZlIGFsbCB3cmFwcGVyJ3Mgc3R5bGVzIGZyb20gdW53cmFwcGVkIGVsZW1lbnQuCgogICAgdGhpcy5yZW1vdmVTdHlsZShBcnJheS5mcm9tKHdyYXBwZXIuZ2V0U3R5bGVOYW1lcygpKSwgdG9VbndyYXApOwogICAgcmV0dXJuIHRydWU7CiAgfQogIC8qKgogICAqIEhlbHBlciBmdW5jdGlvbiB1c2VkIGJ5IG90aGVyIGBEb3duY2FzdFdyaXRlcmAgbWV0aG9kcy4gQnJlYWtzIGF0dHJpYnV0ZSBlbGVtZW50cyBhdCB0aGUgYm91bmRhcmllcyBvZiBnaXZlbiByYW5nZS4KICAgKgogICAqIEBwcml2YXRlCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvcmFuZ2V+UmFuZ2V9IHJhbmdlIFJhbmdlIHdoaWNoIGBzdGFydGAgYW5kIGBlbmRgIHBvc2l0aW9ucyB3aWxsIGJlIHVzZWQgdG8gYnJlYWsgYXR0cmlidXRlcy4KICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtmb3JjZVNwbGl0VGV4dD1mYWxzZV0gSWYgc2V0IHRvIGB0cnVlYCwgd2lsbCBicmVhayB0ZXh0IG5vZGVzIGV2ZW4gaWYgdGhleSBhcmUgZGlyZWN0bHkgaW4gY29udGFpbmVyIGVsZW1lbnQuCiAgICogVGhpcyBiZWhhdmlvciB3aWxsIHJlc3VsdCBpbiBpbmNvcnJlY3QgdmlldyBzdGF0ZSwgYnV0IGlzIG5lZWRlZCBieSBvdGhlciB2aWV3IHdyaXRpbmcgbWV0aG9kcyB3aGljaCB0aGVuIGZpeGVzIHZpZXcgc3RhdGUuCiAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy9yYW5nZX5SYW5nZX0gTmV3IHJhbmdlIHdpdGggbG9jYXRlZCBhdCBicmVhayBwb3NpdGlvbnMuCiAgICovCgoKICBfYnJlYWtBdHRyaWJ1dGVzUmFuZ2UocmFuZ2UsIGZvcmNlU3BsaXRUZXh0ID0gZmFsc2UpIHsKICAgIGNvbnN0IHJhbmdlU3RhcnQgPSByYW5nZS5zdGFydDsKICAgIGNvbnN0IHJhbmdlRW5kID0gcmFuZ2UuZW5kOwogICAgdmFsaWRhdGVSYW5nZUNvbnRhaW5lcihyYW5nZSwgdGhpcy5kb2N1bWVudCk7IC8vIEJyZWFrIGF0IHRoZSBjb2xsYXBzZWQgcG9zaXRpb24uIFJldHVybiBuZXcgY29sbGFwc2VkIHJhbmdlLgoKICAgIGlmIChyYW5nZS5pc0NvbGxhcHNlZCkgewogICAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMuX2JyZWFrQXR0cmlidXRlcyhyYW5nZS5zdGFydCwgZm9yY2VTcGxpdFRleHQpOwoKICAgICAgcmV0dXJuIG5ldyBSYW5nZShwb3NpdGlvbiwgcG9zaXRpb24pOwogICAgfQoKICAgIGNvbnN0IGJyZWFrRW5kID0gdGhpcy5fYnJlYWtBdHRyaWJ1dGVzKHJhbmdlRW5kLCBmb3JjZVNwbGl0VGV4dCk7CgogICAgY29uc3QgY291bnQgPSBicmVha0VuZC5wYXJlbnQuY2hpbGRDb3VudDsKCiAgICBjb25zdCBicmVha1N0YXJ0ID0gdGhpcy5fYnJlYWtBdHRyaWJ1dGVzKHJhbmdlU3RhcnQsIGZvcmNlU3BsaXRUZXh0KTsgLy8gQ2FsY3VsYXRlIG5ldyBicmVhayBlbmQgb2Zmc2V0LgoKCiAgICBicmVha0VuZC5vZmZzZXQgKz0gYnJlYWtFbmQucGFyZW50LmNoaWxkQ291bnQgLSBjb3VudDsKICAgIHJldHVybiBuZXcgUmFuZ2UoYnJlYWtTdGFydCwgYnJlYWtFbmQpOwogIH0KICAvKioKICAgKiBIZWxwZXIgZnVuY3Rpb24gdXNlZCBieSBvdGhlciBgRG93bmNhc3RXcml0ZXJgIG1ldGhvZHMuIEJyZWFrcyBhdHRyaWJ1dGUgZWxlbWVudHMgYXQgZ2l2ZW4gcG9zaXRpb24uCiAgICoKICAgKiBUaHJvd3Mge0BsaW5rIG1vZHVsZTp1dGlscy9ja2VkaXRvcmVycm9yfkNLRWRpdG9yRXJyb3IgQ0tFZGl0b3JFcnJvcn0gYHZpZXctd3JpdGVyLWNhbm5vdC1icmVhay1lbXB0eS1lbGVtZW50YCB3aGVuIGJyZWFrIHBvc2l0aW9uCiAgICogaXMgcGxhY2VkIGluc2lkZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2VtcHR5ZWxlbWVudH5FbXB0eUVsZW1lbnQgRW1wdHlFbGVtZW50fS4KICAgKgogICAqIFRocm93cyB7QGxpbmsgbW9kdWxlOnV0aWxzL2NrZWRpdG9yZXJyb3J+Q0tFZGl0b3JFcnJvciBDS0VkaXRvckVycm9yfSBgdmlldy13cml0ZXItY2Fubm90LWJyZWFrLXVpLWVsZW1lbnRgIHdoZW4gYnJlYWsgcG9zaXRpb24KICAgKiBpcyBwbGFjZWQgaW5zaWRlIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdWllbGVtZW50flVJRWxlbWVudCBVSUVsZW1lbnR9LgogICAqCiAgICogQHByaXZhdGUKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbn0gcG9zaXRpb24gUG9zaXRpb24gd2hlcmUgdG8gYnJlYWsgYXR0cmlidXRlcy4KICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtmb3JjZVNwbGl0VGV4dD1mYWxzZV0gSWYgc2V0IHRvIGB0cnVlYCwgd2lsbCBicmVhayB0ZXh0IG5vZGVzIGV2ZW4gaWYgdGhleSBhcmUgZGlyZWN0bHkgaW4gY29udGFpbmVyIGVsZW1lbnQuCiAgICogVGhpcyBiZWhhdmlvciB3aWxsIHJlc3VsdCBpbiBpbmNvcnJlY3QgdmlldyBzdGF0ZSwgYnV0IGlzIG5lZWRlZCBieSBvdGhlciB2aWV3IHdyaXRpbmcgbWV0aG9kcyB3aGljaCB0aGVuIGZpeGVzIHZpZXcgc3RhdGUuCiAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbn0gTmV3IHBvc2l0aW9uIGFmdGVyIGJyZWFraW5nIHRoZSBhdHRyaWJ1dGVzLgogICAqLwoKCiAgX2JyZWFrQXR0cmlidXRlcyhwb3NpdGlvbiwgZm9yY2VTcGxpdFRleHQgPSBmYWxzZSkgewogICAgY29uc3QgcG9zaXRpb25PZmZzZXQgPSBwb3NpdGlvbi5vZmZzZXQ7CiAgICBjb25zdCBwb3NpdGlvblBhcmVudCA9IHBvc2l0aW9uLnBhcmVudDsgLy8gSWYgcG9zaXRpb24gaXMgcGxhY2VkIGluc2lkZSBFbXB0eUVsZW1lbnQgLSB0aHJvdyBhbiBleGNlcHRpb24gYXMgd2UgY2Fubm90IGJyZWFrIGluc2lkZS4KCiAgICBpZiAocG9zaXRpb24ucGFyZW50LmlzKCdlbXB0eUVsZW1lbnQnKSkgewogICAgICAvKioKICAgICAgICogQ2Fubm90IGJyZWFrIGluc2lkZSBFbXB0eUVsZW1lbnQgaW5zdGFuY2UuCiAgICAgICAqCiAgICAgICAqIEBlcnJvciB2aWV3LXdyaXRlci1jYW5ub3QtYnJlYWstZW1wdHktZWxlbWVudAogICAgICAgKi8KICAgICAgdGhyb3cgbmV3IENLRWRpdG9yRXJyb3IoJ3ZpZXctd3JpdGVyLWNhbm5vdC1icmVhay1lbXB0eS1lbGVtZW50JywgdGhpcy5kb2N1bWVudCk7CiAgICB9IC8vIElmIHBvc2l0aW9uIGlzIHBsYWNlZCBpbnNpZGUgVUlFbGVtZW50IC0gdGhyb3cgYW4gZXhjZXB0aW9uIGFzIHdlIGNhbm5vdCBicmVhayBpbnNpZGUuCgoKICAgIGlmIChwb3NpdGlvbi5wYXJlbnQuaXMoJ3VpRWxlbWVudCcpKSB7CiAgICAgIC8qKgogICAgICAgKiBDYW5ub3QgYnJlYWsgaW5zaWRlIFVJRWxlbWVudCBpbnN0YW5jZS4KICAgICAgICoKICAgICAgICogQGVycm9yIHZpZXctd3JpdGVyLWNhbm5vdC1icmVhay11aS1lbGVtZW50CiAgICAgICAqLwogICAgICB0aHJvdyBuZXcgQ0tFZGl0b3JFcnJvcigndmlldy13cml0ZXItY2Fubm90LWJyZWFrLXVpLWVsZW1lbnQnLCB0aGlzLmRvY3VtZW50KTsKICAgIH0gLy8gVGhlcmUgYXJlIG5vIGF0dHJpYnV0ZXMgdG8gYnJlYWsgYW5kIHRleHQgbm9kZXMgYnJlYWtpbmcgaXMgbm90IGZvcmNlZC4KCgogICAgaWYgKCFmb3JjZVNwbGl0VGV4dCAmJiBwb3NpdGlvblBhcmVudC5pcygndGV4dCcpICYmIGlzQ29udGFpbmVyT3JGcmFnbWVudChwb3NpdGlvblBhcmVudC5wYXJlbnQpKSB7CiAgICAgIHJldHVybiBwb3NpdGlvbi5jbG9uZSgpOwogICAgfSAvLyBQb3NpdGlvbidzIHBhcmVudCBpcyBjb250YWluZXIsIHNvIG5vIGF0dHJpYnV0ZXMgdG8gYnJlYWsuCgoKICAgIGlmIChpc0NvbnRhaW5lck9yRnJhZ21lbnQocG9zaXRpb25QYXJlbnQpKSB7CiAgICAgIHJldHVybiBwb3NpdGlvbi5jbG9uZSgpOwogICAgfSAvLyBCcmVhayB0ZXh0IGFuZCBzdGFydCBhZ2FpbiBpbiBuZXcgcG9zaXRpb24uCgoKICAgIGlmIChwb3NpdGlvblBhcmVudC5pcygndGV4dCcpKSB7CiAgICAgIHJldHVybiB0aGlzLl9icmVha0F0dHJpYnV0ZXMoYnJlYWtUZXh0Tm9kZShwb3NpdGlvbiksIGZvcmNlU3BsaXRUZXh0KTsKICAgIH0KCiAgICBjb25zdCBsZW5ndGggPSBwb3NpdGlvblBhcmVudC5jaGlsZENvdW50OyAvLyA8cD5mb288Yj48dT5iYXJ7fTwvdT48L2I+PC9wPgogICAgLy8gPHA+Zm9vPGI+PHU+YmFyPC91PltdPC9iPjwvcD4KICAgIC8vIDxwPmZvbzxiPjx1PmJhcjwvdT48L2I+W108L3A+CgogICAgaWYgKHBvc2l0aW9uT2Zmc2V0ID09IGxlbmd0aCkgewogICAgICBjb25zdCBuZXdQb3NpdGlvbiA9IG5ldyBQb3NpdGlvbihwb3NpdGlvblBhcmVudC5wYXJlbnQsIHBvc2l0aW9uUGFyZW50LmluZGV4ICsgMSk7CiAgICAgIHJldHVybiB0aGlzLl9icmVha0F0dHJpYnV0ZXMobmV3UG9zaXRpb24sIGZvcmNlU3BsaXRUZXh0KTsKICAgIH0gZWxzZSB7CiAgICAgIC8vIDxwPmZvbzxiPjx1Pnt9YmFyPC91PjwvYj48L3A+CiAgICAgIC8vIDxwPmZvbzxiPltdPHU+YmFyPC91PjwvYj48L3A+CiAgICAgIC8vIDxwPmZvb3t9PGI+PHU+YmFyPC91PjwvYj48L3A+CiAgICAgIGlmIChwb3NpdGlvbk9mZnNldCA9PT0gMCkgewogICAgICAgIGNvbnN0IG5ld1Bvc2l0aW9uID0gbmV3IFBvc2l0aW9uKHBvc2l0aW9uUGFyZW50LnBhcmVudCwgcG9zaXRpb25QYXJlbnQuaW5kZXgpOwogICAgICAgIHJldHVybiB0aGlzLl9icmVha0F0dHJpYnV0ZXMobmV3UG9zaXRpb24sIGZvcmNlU3BsaXRUZXh0KTsKICAgICAgfSAvLyA8cD5mb288Yj48dT5ie31hcjwvdT48L2I+PC9wPgogICAgICAvLyA8cD5mb288Yj48dT5iW11hcjwvdT48L2I+PC9wPgogICAgICAvLyA8cD5mb288Yj48dT5iPC91PltdPHU+YXI8L3U+PC9iPjwvcD4KICAgICAgLy8gPHA+Zm9vPGI+PHU+YjwvdT48L2I+W108Yj48dT5hcjwvdT48L2I+PC9wPgogICAgICBlbHNlIHsKICAgICAgICAgIGNvbnN0IG9mZnNldEFmdGVyID0gcG9zaXRpb25QYXJlbnQuaW5kZXggKyAxOyAvLyBCcmVhayBlbGVtZW50LgoKICAgICAgICAgIGNvbnN0IGNsb25lZE5vZGUgPSBwb3NpdGlvblBhcmVudC5fY2xvbmUoKTsgLy8gSW5zZXJ0IGNsb25lZCBub2RlIHRvIHBvc2l0aW9uJ3MgcGFyZW50IG5vZGUuCgoKICAgICAgICAgIHBvc2l0aW9uUGFyZW50LnBhcmVudC5faW5zZXJ0Q2hpbGQob2Zmc2V0QWZ0ZXIsIGNsb25lZE5vZGUpOwoKICAgICAgICAgIHRoaXMuX2FkZFRvQ2xvbmVkRWxlbWVudHNHcm91cChjbG9uZWROb2RlKTsgLy8gR2V0IG5vZGVzIHRvIG1vdmUuCgoKICAgICAgICAgIGNvbnN0IGNvdW50ID0gcG9zaXRpb25QYXJlbnQuY2hpbGRDb3VudCAtIHBvc2l0aW9uT2Zmc2V0OwoKICAgICAgICAgIGNvbnN0IG5vZGVzVG9Nb3ZlID0gcG9zaXRpb25QYXJlbnQuX3JlbW92ZUNoaWxkcmVuKHBvc2l0aW9uT2Zmc2V0LCBjb3VudCk7IC8vIE1vdmUgbm9kZXMgdG8gY2xvbmVkIG5vZGUuCgoKICAgICAgICAgIGNsb25lZE5vZGUuX2FwcGVuZENoaWxkKG5vZGVzVG9Nb3ZlKTsgLy8gQ3JlYXRlIG5ldyBwb3NpdGlvbiB0byB3b3JrIG9uLgoKCiAgICAgICAgICBjb25zdCBuZXdQb3NpdGlvbiA9IG5ldyBQb3NpdGlvbihwb3NpdGlvblBhcmVudC5wYXJlbnQsIG9mZnNldEFmdGVyKTsKICAgICAgICAgIHJldHVybiB0aGlzLl9icmVha0F0dHJpYnV0ZXMobmV3UG9zaXRpb24sIGZvcmNlU3BsaXRUZXh0KTsKICAgICAgICB9CiAgICB9CiAgfQogIC8qKgogICAqIFN0b3JlcyB0aGUgaW5mb3JtYXRpb24gdGhhdCBhbiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2F0dHJpYnV0ZWVsZW1lbnR+QXR0cmlidXRlRWxlbWVudCBhdHRyaWJ1dGUgZWxlbWVudH0gd2FzCiAgICogYWRkZWQgdG8gdGhlIHRyZWUuIFNhdmVzIHRoZSByZWZlcmVuY2UgdG8gdGhlIGdyb3VwIGluIHRoZSBnaXZlbiBlbGVtZW50IGFuZCB1cGRhdGVzIHRoZSBncm91cCwgc28gb3RoZXIgZWxlbWVudHMKICAgKiBmcm9tIHRoZSBncm91cCBub3cga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgZ2l2ZW4gYXR0cmlidXRlIGVsZW1lbnQuCiAgICoKICAgKiBUaGUgY2xvbmVzIGdyb3VwIGNhbiBiZSBvYnRhaW5lZCB1c2luZyB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2F0dHJpYnV0ZWVsZW1lbnR+QXR0cmlidXRlRWxlbWVudCNnZXRFbGVtZW50c1dpdGhTYW1lSWR9LgogICAqCiAgICogRG9lcyBub3RoaW5nIGlmIGFkZGVkIGVsZW1lbnQgaGFzIG5vIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvYXR0cmlidXRlZWxlbWVudH5BdHRyaWJ1dGVFbGVtZW50I2lkIGlkfS4KICAgKgogICAqIEBwcml2YXRlCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvYXR0cmlidXRlZWxlbWVudH5BdHRyaWJ1dGVFbGVtZW50fSBlbGVtZW50IEF0dHJpYnV0ZSBlbGVtZW50IHRvIHNhdmUuCiAgICovCgoKICBfYWRkVG9DbG9uZWRFbGVtZW50c0dyb3VwKGVsZW1lbnQpIHsKICAgIC8vIEFkZCBvbmx5IGlmIHRoZSBlbGVtZW50IGlzIGluIGRvY3VtZW50IHRyZWUuCiAgICBpZiAoIWVsZW1lbnQucm9vdC5pcygncm9vdEVsZW1lbnQnKSkgewogICAgICByZXR1cm47CiAgICB9IC8vIFRyYXZlcnNlIHRoZSBlbGVtZW50J3MgY2hpbGRyZW4gcmVjdXJzaXZlbHkgdG8gZmluZCBvdGhlciBhdHRyaWJ1dGUgZWxlbWVudHMgdGhhdCBhbHNvIG1pZ2h0IGdvdCBpbnNlcnRlZC4KICAgIC8vIFRoZSBsb29wIGlzIGF0IHRoZSBiZWdpbm5pbmcgc28gd2UgY2FuIG1ha2UgZmFzdCByZXR1cm5zIGxhdGVyIGluIHRoZSBjb2RlLgoKCiAgICBpZiAoZWxlbWVudC5pcygnZWxlbWVudCcpKSB7CiAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgZWxlbWVudC5nZXRDaGlsZHJlbigpKSB7CiAgICAgICAgdGhpcy5fYWRkVG9DbG9uZWRFbGVtZW50c0dyb3VwKGNoaWxkKTsKICAgICAgfQogICAgfQoKICAgIGNvbnN0IGlkID0gZWxlbWVudC5pZDsKCiAgICBpZiAoIWlkKSB7CiAgICAgIHJldHVybjsKICAgIH0KCiAgICBsZXQgZ3JvdXAgPSB0aGlzLl9jbG9uZUdyb3Vwcy5nZXQoaWQpOwoKICAgIGlmICghZ3JvdXApIHsKICAgICAgZ3JvdXAgPSBuZXcgU2V0KCk7CgogICAgICB0aGlzLl9jbG9uZUdyb3Vwcy5zZXQoaWQsIGdyb3VwKTsKICAgIH0KCiAgICBncm91cC5hZGQoZWxlbWVudCk7CiAgICBlbGVtZW50Ll9jbG9uZXNHcm91cCA9IGdyb3VwOwogIH0KICAvKioKICAgKiBSZW1vdmVzIGFsbCB0aGUgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGdpdmVuIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvYXR0cmlidXRlZWxlbWVudH5BdHRyaWJ1dGVFbGVtZW50IGF0dHJpYnV0ZSBlbGVtZW50fQogICAqIGZyb20gaXRzIGNsb25lcyBncm91cC4KICAgKgogICAqIEtlZXAgaW4gbWluZCwgdGhhdCB0aGUgZWxlbWVudCB3aWxsIHN0aWxsIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIGdyb3VwIChidXQgdGhlIGdyb3VwIHdpbGwgbm90IGtlZXAgYSByZWZlcmVuY2UgdG8gaXQpLgogICAqIFRoaXMgYWxsb3dzIHRvIHJlZmVyZW5jZSB0aGUgd2hvbGUgZ3JvdXAgZXZlbiBpZiB0aGUgZWxlbWVudCB3YXMgYWxyZWFkeSByZW1vdmVkIGZyb20gdGhlIHRyZWUuCiAgICoKICAgKiBEb2VzIG5vdGhpbmcgaWYgdGhlIGVsZW1lbnQgaGFzIG5vIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvYXR0cmlidXRlZWxlbWVudH5BdHRyaWJ1dGVFbGVtZW50I2lkIGlkfS4KICAgKgogICAqIEBwcml2YXRlCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvYXR0cmlidXRlZWxlbWVudH5BdHRyaWJ1dGVFbGVtZW50fSBlbGVtZW50IEF0dHJpYnV0ZSBlbGVtZW50IHRvIHJlbW92ZS4KICAgKi8KCgogIF9yZW1vdmVGcm9tQ2xvbmVkRWxlbWVudHNHcm91cChlbGVtZW50KSB7CiAgICAvLyBUcmF2ZXJzZSB0aGUgZWxlbWVudCdzIGNoaWxkcmVuIHJlY3Vyc2l2ZWx5IHRvIGZpbmQgb3RoZXIgYXR0cmlidXRlIGVsZW1lbnRzIHRoYXQgYWxzbyBnb3QgcmVtb3ZlZC4KICAgIC8vIFRoZSBsb29wIGlzIGF0IHRoZSBiZWdpbm5pbmcgc28gd2UgY2FuIG1ha2UgZmFzdCByZXR1cm5zIGxhdGVyIGluIHRoZSBjb2RlLgogICAgaWYgKGVsZW1lbnQuaXMoJ2VsZW1lbnQnKSkgewogICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGVsZW1lbnQuZ2V0Q2hpbGRyZW4oKSkgewogICAgICAgIHRoaXMuX3JlbW92ZUZyb21DbG9uZWRFbGVtZW50c0dyb3VwKGNoaWxkKTsKICAgICAgfQogICAgfQoKICAgIGNvbnN0IGlkID0gZWxlbWVudC5pZDsKCiAgICBpZiAoIWlkKSB7CiAgICAgIHJldHVybjsKICAgIH0KCiAgICBjb25zdCBncm91cCA9IHRoaXMuX2Nsb25lR3JvdXBzLmdldChpZCk7CgogICAgaWYgKCFncm91cCkgewogICAgICByZXR1cm47CiAgICB9CgogICAgZ3JvdXAuZGVsZXRlKGVsZW1lbnQpOyAvLyBOb3QgcmVtb3ZpbmcgZ3JvdXAgZnJvbSBlbGVtZW50IG9uIHB1cnBvc2UhCiAgICAvLyBJZiBvdGhlciBwYXJ0cyBvZiBjb2RlIGhhdmUgcmVmZXJlbmNlIHRvIHRoaXMgZWxlbWVudCwgdGhleSB3aWxsIGJlIGFibGUgdG8gZ2V0IHJlZmVyZW5jZXMgdG8gb3RoZXIgZWxlbWVudHMgZnJvbSB0aGUgZ3JvdXAuCiAgfQoKfSAvLyBIZWxwZXIgZnVuY3Rpb24gZm9yIGB2aWV3LndyaXRlci53cmFwYC4gQ2hlY2tzIGlmIGdpdmVuIGVsZW1lbnQgaGFzIGFueSBjaGlsZHJlbiB0aGF0IGFyZSBub3QgdWkgZWxlbWVudHMuCgpmdW5jdGlvbiBfaGFzTm9uVWlDaGlsZHJlbihwYXJlbnQpIHsKICByZXR1cm4gQXJyYXkuZnJvbShwYXJlbnQuZ2V0Q2hpbGRyZW4oKSkuc29tZShjaGlsZCA9PiAhY2hpbGQuaXMoJ3VpRWxlbWVudCcpKTsKfQovKioKICogQXR0cmlidXRlIGVsZW1lbnQgbmVlZCB0byBiZSBpbnN0YW5jZSBvZiBhdHRyaWJ1dGUgZWxlbWVudC4KICoKICogQGVycm9yIHZpZXctd3JpdGVyLXdyYXAtaW52YWxpZC1hdHRyaWJ1dGUKICovCi8vIFJldHVybnMgZmlyc3QgcGFyZW50IGNvbnRhaW5lciBvZiBzcGVjaWZpZWQge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbiBQb3NpdGlvbn0uCi8vIFBvc2l0aW9uJ3MgcGFyZW50IG5vZGUgaXMgY2hlY2tlZCBhcyBmaXJzdCwgdGhlbiBuZXh0IHBhcmVudHMgYXJlIGNoZWNrZWQuCi8vIE5vdGUgdGhhdCB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudCBEb2N1bWVudEZyYWdtZW50fSBpcyB0cmVhdGVkIGxpa2UgYSBjb250YWluZXIuCi8vCi8vIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L3Bvc2l0aW9uflBvc2l0aW9ufSBwb3NpdGlvbiBQb3NpdGlvbiB1c2VkIGFzIGEgc3RhcnQgcG9pbnQgdG8gbG9jYXRlIHBhcmVudCBjb250YWluZXIuCi8vIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL3ZpZXcvY29udGFpbmVyZWxlbWVudH5Db250YWluZXJFbGVtZW50fG1vZHVsZTplbmdpbmUvdmlldy9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnR8dW5kZWZpbmVkfQovLyBQYXJlbnQgY29udGFpbmVyIGVsZW1lbnQgb3IgYHVuZGVmaW5lZGAgaWYgY29udGFpbmVyIGlzIG5vdCBmb3VuZC4KCgpmdW5jdGlvbiBnZXRQYXJlbnRDb250YWluZXIocG9zaXRpb24pIHsKICBsZXQgcGFyZW50ID0gcG9zaXRpb24ucGFyZW50OwoKICB3aGlsZSAoIWlzQ29udGFpbmVyT3JGcmFnbWVudChwYXJlbnQpKSB7CiAgICBpZiAoIXBhcmVudCkgewogICAgICByZXR1cm4gdW5kZWZpbmVkOwogICAgfQoKICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7CiAgfQoKICByZXR1cm4gcGFyZW50Owp9IC8vIENoZWNrcyBpZiBmaXJzdCB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2F0dHJpYnV0ZWVsZW1lbnR+QXR0cmlidXRlRWxlbWVudCBBdHRyaWJ1dGVFbGVtZW50fSBwcm92aWRlZCB0byB0aGUgZnVuY3Rpb24KLy8gY2FuIGJlIHdyYXBwZWQgb3R1c2lkZSBzZWNvbmQgZWxlbWVudC4gSXQgaXMgZG9uZSBieSBjb21wYXJpbmcgZWxlbWVudHMnCi8vIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvYXR0cmlidXRlZWxlbWVudH5BdHRyaWJ1dGVFbGVtZW50I3ByaW9yaXR5IHByaW9yaXRpZXN9LCBpZiBib3RoIGhhdmUgc2FtZSBwcmlvcml0eQovLyB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudCNnZXRJZGVudGl0eSBpZGVudGl0aWVzfSBhcmUgY29tcGFyZWQuCi8vCi8vIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L2F0dHJpYnV0ZWVsZW1lbnR+QXR0cmlidXRlRWxlbWVudH0gYQovLyBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9hdHRyaWJ1dGVlbGVtZW50fkF0dHJpYnV0ZUVsZW1lbnR9IGIKLy8gQHJldHVybnMge0Jvb2xlYW59CgoKZnVuY3Rpb24gc2hvdWxkQUJlT3V0c2lkZUIoYSwgYikgewogIGlmIChhLnByaW9yaXR5IDwgYi5wcmlvcml0eSkgewogICAgcmV0dXJuIHRydWU7CiAgfSBlbHNlIGlmIChhLnByaW9yaXR5ID4gYi5wcmlvcml0eSkgewogICAgcmV0dXJuIGZhbHNlOwogIH0gLy8gV2hlbiBwcmlvcml0aWVzIGFyZSBlcXVhbCBhbmQgbmFtZXMgYXJlIGRpZmZlcmVudCAtIHVzZSBpZGVudGl0aWVzLgoKCiAgcmV0dXJuIGEuZ2V0SWRlbnRpdHkoKSA8IGIuZ2V0SWRlbnRpdHkoKTsKfSAvLyBSZXR1cm5zIG5ldyBwb3NpdGlvbiB0aGF0IGlzIG1vdmVkIHRvIG5lYXIgdGV4dCBub2RlLiBSZXR1cm5zIHNhbWUgcG9zaXRpb24gaWYgdGhlcmUgaXMgbm8gdGV4dCBub2RlIGJlZm9yZSBvZiBhZnRlcgovLyBzcGVjaWZpZWQgcG9zaXRpb24uCi8vCi8vCQk8cD5mb29bXTwvcD4gIC0+ICA8cD5mb297fTwvcD4KLy8JCTxwPltdZm9vPC9wPiAgLT4gIDxwPnt9Zm9vPC9wPgovLwovLyBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbn0gcG9zaXRpb24KLy8gQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbn0gUG9zaXRpb24gbG9jYXRlZCBpbnNpZGUgdGV4dCBub2RlIG9yIHNhbWUgcG9zaXRpb24gaWYgdGhlcmUgaXMgbm8gdGV4dCBub2RlcwovLyBiZWZvcmUgb3IgYWZ0ZXIgcG9zaXRpb24gbG9jYXRpb24uCgoKZnVuY3Rpb24gbW92ZVBvc2l0aW9uVG9UZXh0Tm9kZShwb3NpdGlvbikgewogIGNvbnN0IG5vZGVCZWZvcmUgPSBwb3NpdGlvbi5ub2RlQmVmb3JlOwoKICBpZiAobm9kZUJlZm9yZSAmJiBub2RlQmVmb3JlLmlzKCd0ZXh0JykpIHsKICAgIHJldHVybiBuZXcgUG9zaXRpb24obm9kZUJlZm9yZSwgbm9kZUJlZm9yZS5kYXRhLmxlbmd0aCk7CiAgfQoKICBjb25zdCBub2RlQWZ0ZXIgPSBwb3NpdGlvbi5ub2RlQWZ0ZXI7CgogIGlmIChub2RlQWZ0ZXIgJiYgbm9kZUFmdGVyLmlzKCd0ZXh0JykpIHsKICAgIHJldHVybiBuZXcgUG9zaXRpb24obm9kZUFmdGVyLCAwKTsKICB9CgogIHJldHVybiBwb3NpdGlvbjsKfSAvLyBCcmVha3MgdGV4dCBub2RlIGludG8gdHdvIHRleHQgbm9kZXMgd2hlbiBwb3NzaWJsZS4KLy8KLy8JCTxwPmZvb3t9YmFyPC9wPiAtPiA8cD5mb29bXWJhcjwvcD4KLy8JCTxwPnt9Zm9vYmFyPC9wPiAtPiA8cD5bXWZvb2JhcjwvcD4KLy8JCTxwPmZvb2Jhcnt9PC9wPiAtPiA8cD5mb29iYXJbXTwvcD4KLy8KLy8gQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvcG9zaXRpb25+UG9zaXRpb259IHBvc2l0aW9uIFBvc2l0aW9uIHRoYXQgbmVlZCB0byBiZSBwbGFjZWQgaW5zaWRlIHRleHQgbm9kZS4KLy8gQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbn0gTmV3IHBvc2l0aW9uIGFmdGVyIGJyZWFraW5nIHRleHQgbm9kZS4KCgpmdW5jdGlvbiBicmVha1RleHROb2RlKHBvc2l0aW9uKSB7CiAgaWYgKHBvc2l0aW9uLm9mZnNldCA9PSBwb3NpdGlvbi5wYXJlbnQuZGF0YS5sZW5ndGgpIHsKICAgIHJldHVybiBuZXcgUG9zaXRpb24ocG9zaXRpb24ucGFyZW50LnBhcmVudCwgcG9zaXRpb24ucGFyZW50LmluZGV4ICsgMSk7CiAgfQoKICBpZiAocG9zaXRpb24ub2Zmc2V0ID09PSAwKSB7CiAgICByZXR1cm4gbmV3IFBvc2l0aW9uKHBvc2l0aW9uLnBhcmVudC5wYXJlbnQsIHBvc2l0aW9uLnBhcmVudC5pbmRleCk7CiAgfSAvLyBHZXQgcGFydCBvZiB0aGUgdGV4dCB0aGF0IG5lZWQgdG8gYmUgbW92ZWQuCgoKICBjb25zdCB0ZXh0VG9Nb3ZlID0gcG9zaXRpb24ucGFyZW50LmRhdGEuc2xpY2UocG9zaXRpb24ub2Zmc2V0KTsgLy8gTGVhdmUgcmVzdCBvZiB0aGUgdGV4dCBpbiBwb3NpdGlvbidzIHBhcmVudC4KCiAgcG9zaXRpb24ucGFyZW50Ll9kYXRhID0gcG9zaXRpb24ucGFyZW50LmRhdGEuc2xpY2UoMCwgcG9zaXRpb24ub2Zmc2V0KTsgLy8gSW5zZXJ0IG5ldyB0ZXh0IG5vZGUgYWZ0ZXIgcG9zaXRpb24ncyBwYXJlbnQgdGV4dCBub2RlLgoKICBwb3NpdGlvbi5wYXJlbnQucGFyZW50Ll9pbnNlcnRDaGlsZChwb3NpdGlvbi5wYXJlbnQuaW5kZXggKyAxLCBuZXcgVGV4dCh0ZXh0VG9Nb3ZlKSk7IC8vIFJldHVybiBuZXcgcG9zaXRpb24gYmV0d2VlbiB0d28gbmV3bHkgY3JlYXRlZCB0ZXh0IG5vZGVzLgoKCiAgcmV0dXJuIG5ldyBQb3NpdGlvbihwb3NpdGlvbi5wYXJlbnQucGFyZW50LCBwb3NpdGlvbi5wYXJlbnQuaW5kZXggKyAxKTsKfSAvLyBNZXJnZXMgdHdvIHRleHQgbm9kZXMgaW50byBmaXJzdCBub2RlLiBSZW1vdmVzIHNlY29uZCBub2RlIGFuZCByZXR1cm5zIG1lcmdlIHBvc2l0aW9uLgovLwovLyBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy90ZXh0flRleHR9IHQxIEZpcnN0IHRleHQgbm9kZSB0byBtZXJnZS4gRGF0YSBmcm9tIHNlY29uZCB0ZXh0IG5vZGUgd2lsbCBiZSBtb3ZlZCBhdCB0aGUgZW5kIG9mCi8vIHRoaXMgdGV4dCBub2RlLgovLyBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy90ZXh0flRleHR9IHQyIFNlY29uZCB0ZXh0IG5vZGUgdG8gbWVyZ2UuIFRoaXMgbm9kZSB3aWxsIGJlIHJlbW92ZWQgYWZ0ZXIgbWVyZ2luZy4KLy8gQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy9wb3NpdGlvbn5Qb3NpdGlvbn0gUG9zaXRpb24gYWZ0ZXIgbWVyZ2luZyB0ZXh0IG5vZGVzLgoKCmZ1bmN0aW9uIG1lcmdlVGV4dE5vZGVzKHQxLCB0MikgewogIC8vIE1lcmdlIHRleHQgZGF0YSBpbnRvIGZpcnN0IHRleHQgbm9kZSBhbmQgcmVtb3ZlIHNlY29uZCBvbmUuCiAgY29uc3Qgbm9kZUJlZm9yZUxlbmd0aCA9IHQxLmRhdGEubGVuZ3RoOwogIHQxLl9kYXRhICs9IHQyLmRhdGE7CgogIHQyLl9yZW1vdmUoKTsKCiAgcmV0dXJuIG5ldyBQb3NpdGlvbih0MSwgbm9kZUJlZm9yZUxlbmd0aCk7Cn0gLy8gQ2hlY2tzIGlmIHByb3ZpZGVkIG5vZGVzIGFyZSB2YWxpZCB0byBpbnNlcnQuIENoZWNrcyBpZiBlYWNoIG5vZGUgaXMgYW4gaW5zdGFuY2Ugb2YKLy8ge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy90ZXh0flRleHQgVGV4dH0gb3Ige0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9hdHRyaWJ1dGVlbGVtZW50fkF0dHJpYnV0ZUVsZW1lbnQgQXR0cmlidXRlRWxlbWVudH0sCi8vIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvY29udGFpbmVyZWxlbWVudH5Db250YWluZXJFbGVtZW50IENvbnRhaW5lckVsZW1lbnR9LAovLyB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2VtcHR5ZWxlbWVudH5FbXB0eUVsZW1lbnQgRW1wdHlFbGVtZW50fSBvcgovLyB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3VpZWxlbWVudH5VSUVsZW1lbnQgVUlFbGVtZW50fS4KLy8KLy8gVGhyb3dzIHtAbGluayBtb2R1bGU6dXRpbHMvY2tlZGl0b3JlcnJvcn5DS0VkaXRvckVycm9yIENLRWRpdG9yRXJyb3J9IGB2aWV3LXdyaXRlci1pbnNlcnQtaW52YWxpZC1ub2RlYCB3aGVuIG5vZGVzIHRvIGluc2VydAovLyBjb250YWlucyBpbnN0YW5jZXMgdGhhdCBhcmUgbm90IHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdGV4dH5UZXh0IFRleHRzfSwKLy8ge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9lbXB0eWVsZW1lbnR+RW1wdHlFbGVtZW50IEVtcHR5RWxlbWVudHN9LAovLyB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3VpZWxlbWVudH5VSUVsZW1lbnQgVUlFbGVtZW50c30sCi8vIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvYXR0cmlidXRlZWxlbWVudH5BdHRyaWJ1dGVFbGVtZW50IEF0dHJpYnV0ZUVsZW1lbnRzfSBvcgovLyB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2NvbnRhaW5lcmVsZW1lbnR+Q29udGFpbmVyRWxlbWVudCBDb250YWluZXJFbGVtZW50c30uCi8vCi8vIEBwYXJhbSBJdGVyYWJsZS48bW9kdWxlOmVuZ2luZS92aWV3L3RleHR+VGV4dHxtb2R1bGU6ZW5naW5lL3ZpZXcvYXR0cmlidXRlZWxlbWVudH5BdHRyaWJ1dGVFbGVtZW50Ci8vIHxtb2R1bGU6ZW5naW5lL3ZpZXcvY29udGFpbmVyZWxlbWVudH5Db250YWluZXJFbGVtZW50PiBub2RlcwovLyBAcGFyYW0ge09iamVjdH0gZXJyb3JDb250ZXh0CgoKZnVuY3Rpb24gdmFsaWRhdGVOb2Rlc1RvSW5zZXJ0KG5vZGVzLCBlcnJvckNvbnRleHQpIHsKICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMpIHsKICAgIGlmICghdmFsaWROb2Rlc1RvSW5zZXJ0LnNvbWUodmFsaWROb2RlID0+IG5vZGUgaW5zdGFuY2VvZiB2YWxpZE5vZGUpKSB7CiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdXNlLWJlZm9yZS1kZWZpbmUKCiAgICAgIC8qKgogICAgICAgKiBJbnNlcnRlZCBub2RlcyBzaG91bGQgYmUgdmFsaWQgdG8gaW5zZXJ0LiBvZiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2F0dHJpYnV0ZWVsZW1lbnR+QXR0cmlidXRlRWxlbWVudCBBdHRyaWJ1dGVFbGVtZW50fSwKICAgICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9jb250YWluZXJlbGVtZW50fkNvbnRhaW5lckVsZW1lbnQgQ29udGFpbmVyRWxlbWVudH0sCiAgICAgICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZW1wdHllbGVtZW50fkVtcHR5RWxlbWVudCBFbXB0eUVsZW1lbnR9LAogICAgICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3VpZWxlbWVudH5VSUVsZW1lbnQgVUlFbGVtZW50fSwge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy90ZXh0flRleHQgVGV4dH0uCiAgICAgICAqCiAgICAgICAqIEBlcnJvciB2aWV3LXdyaXRlci1pbnNlcnQtaW52YWxpZC1ub2RlCiAgICAgICAqLwogICAgICB0aHJvdyBuZXcgQ0tFZGl0b3JFcnJvcigndmlldy13cml0ZXItaW5zZXJ0LWludmFsaWQtbm9kZScsIGVycm9yQ29udGV4dCk7CiAgICB9CgogICAgaWYgKCFub2RlLmlzKCd0ZXh0JykpIHsKICAgICAgdmFsaWRhdGVOb2Rlc1RvSW5zZXJ0KG5vZGUuZ2V0Q2hpbGRyZW4oKSwgZXJyb3JDb250ZXh0KTsKICAgIH0KICB9Cn0KCmNvbnN0IHZhbGlkTm9kZXNUb0luc2VydCA9IFtUZXh0LCBBdHRyaWJ1dGVFbGVtZW50LCBDb250YWluZXJFbGVtZW50LCBFbXB0eUVsZW1lbnQsIFVJRWxlbWVudF07IC8vIENoZWNrcyBpZiBub2RlIGlzIENvbnRhaW5lckVsZW1lbnQgb3IgRG9jdW1lbnRGcmFnbWVudCwgYmVjYXVzZSBpbiBtb3N0IGNhc2VzIHRoZXkgc2hvdWxkIGJlIHRyZWF0ZWQgdGhlIHNhbWUgd2F5LgovLwovLyBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9ub2Rlfk5vZGV9IG5vZGUKLy8gQHJldHVybnMge0Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIG5vZGUgaXMgaW5zdGFuY2Ugb2YgQ29udGFpbmVyRWxlbWVudCBvciBEb2N1bWVudEZyYWdtZW50LgoKZnVuY3Rpb24gaXNDb250YWluZXJPckZyYWdtZW50KG5vZGUpIHsKICByZXR1cm4gbm9kZSAmJiAobm9kZS5pcygnY29udGFpbmVyRWxlbWVudCcpIHx8IG5vZGUuaXMoJ2RvY3VtZW50RnJhZ21lbnQnKSk7Cn0gLy8gQ2hlY2tzIGlmIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvcmFuZ2V+UmFuZ2Ujc3RhcnQgcmFuZ2Ugc3RhcnR9IGFuZCB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3JhbmdlflJhbmdlI2VuZCByYW5nZSBlbmR9IGFyZSBwbGFjZWQKLy8gaW5zaWRlIHNhbWUge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9jb250YWluZXJlbGVtZW50fkNvbnRhaW5lckVsZW1lbnQgY29udGFpbmVyIGVsZW1lbnR9LgovLyBUaHJvd3Mge0BsaW5rIG1vZHVsZTp1dGlscy9ja2VkaXRvcmVycm9yfkNLRWRpdG9yRXJyb3IgQ0tFZGl0b3JFcnJvcn0gYHZpZXctd3JpdGVyLWludmFsaWQtcmFuZ2UtY29udGFpbmVyYCB3aGVuIHZhbGlkYXRpb24gZmFpbHMuCi8vCi8vIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L3JhbmdlflJhbmdlfSByYW5nZQovLyBAcGFyYW0ge09iamVjdH0gZXJyb3JDb250ZXh0CgoKZnVuY3Rpb24gdmFsaWRhdGVSYW5nZUNvbnRhaW5lcihyYW5nZSwgZXJyb3JDb250ZXh0KSB7CiAgY29uc3Qgc3RhcnRDb250YWluZXIgPSBnZXRQYXJlbnRDb250YWluZXIocmFuZ2Uuc3RhcnQpOwogIGNvbnN0IGVuZENvbnRhaW5lciA9IGdldFBhcmVudENvbnRhaW5lcihyYW5nZS5lbmQpOwoKICBpZiAoIXN0YXJ0Q29udGFpbmVyIHx8ICFlbmRDb250YWluZXIgfHwgc3RhcnRDb250YWluZXIgIT09IGVuZENvbnRhaW5lcikgewogICAgLyoqCiAgICAgKiBSYW5nZSBjb250YWluZXIgaXMgaW52YWxpZC4gVGhpcyBjYW4gaGFwcGVuIGlmIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvcmFuZ2V+UmFuZ2Ujc3RhcnQgcmFuZ2Ugc3RhcnR9IGFuZAogICAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9yYW5nZX5SYW5nZSNlbmQgcmFuZ2UgZW5kfSBwb3NpdGlvbnMgYXJlIG5vdCBwbGFjZWQgaW5zaWRlIHNhbWUgY29udGFpbmVyIG9yCiAgICAgKiBwYXJlbnQgY29udGFpbmVyIGZvciB0aGVzZSBwb3NpdGlvbnMgY2Fubm90IGJlIGZvdW5kLgogICAgICoKICAgICAqIEBlcnJvciB2aWV3LXdyaXRlci1pbnZhbGlkLXJhbmdlLWNvbnRhaW5lcgogICAgICovCiAgICB0aHJvdyBuZXcgQ0tFZGl0b3JFcnJvcigndmlldy13cml0ZXItaW52YWxpZC1yYW5nZS1jb250YWluZXInLCBlcnJvckNvbnRleHQpOwogIH0KfSAvLyBDaGVja3MgaWYgdHdvIGF0dHJpYnV0ZSBlbGVtZW50cyBjYW4gYmUgam9pbmVkIHRvZ2V0aGVyLiBFbGVtZW50cyBjYW4gYmUgam9pbmVkIHRvZ2V0aGVyIGlmLCBhbmQgb25seSBpZgovLyB0aGV5IGRvIG5vdCBoYXZlIGlkcyBzcGVjaWZpZWQuCi8vCi8vIEBwcml2YXRlCi8vIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudH0gYQovLyBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnR9IGIKLy8gQHJldHVybnMge0Jvb2xlYW59CgoKZnVuY3Rpb24gY2FuQmVKb2luZWQoYSwgYikgewogIHJldHVybiBhLmlkID09PSBudWxsICYmIGIuaWQgPT09IG51bGw7Cn0="},{"version":3,"sources":["/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-engine/src/view/downcastwriter.js"],"names":["Position","Range","Selection","ContainerElement","AttributeElement","EmptyElement","UIElement","CKEditorError","DocumentFragment","isIterable","Text","EditableElement","isPlainObject","DowncastWriter","constructor","document","_cloneGroups","Map","setSelection","selectable","placeOrOffset","options","selection","_setTo","setSelectionFocus","itemOrPosition","offset","_setFocus","createText","data","createAttributeElement","name","attributes","attributeElement","priority","_priority","id","_id","createContainerElement","createEditableElement","editableElement","_document","createEmptyElement","createUIElement","renderFunction","uiElement","render","setAttribute","key","value","element","_setAttribute","removeAttribute","_removeAttribute","addClass","className","_addClass","removeClass","_removeClass","setStyle","property","undefined","_setStyle","removeStyle","_removeStyle","setCustomProperty","_setCustomProperty","removeCustomProperty","_removeCustomProperty","breakAttributes","positionOrRange","_breakAttributes","_breakAttributesRange","breakContainer","position","parent","is","isAtStart","_createBefore","isAtEnd","newElement","_clone","insert","_createAfter","sourceRange","_createAt","targetPosition","move","mergeAttributes","positionOffset","positionParent","childCount","index","_remove","_removeFromClonedElementsGroup","nodeBefore","getChild","nodeAfter","mergeTextNodes","isSimilar","count","_appendChild","getChildren","mergeContainers","prev","next","lastChild","newPosition","_createIn","remove","_createOn","nodes","validateNodesToInsert","container","getParentContainer","insertionPosition","length","_insertChild","node","_addToClonedElementsGroup","endPosition","getShiftedBy","start","isEqual","end","rangeOrItem","range","validateRangeContainer","isCollapsed","breakStart","breakEnd","parentContainer","removed","_removeChildren","mergePosition","clone","clear","walker","getWalker","direction","ignoreElementEnd","current","item","rangeToRemove","nextPosition","isAfter","parentElement","getAncestors","find","ancestor","isBefore","countBefore","wrap","attribute","_wrapRange","_hasNonUiChildren","getLastMatchingPosition","_wrapPosition","viewSelection","getFirstPosition","unwrap","newRange","_unwrapChildren","rename","newName","viewElement","getAttributes","clearClonedElementsGroup","groupName","delete","createPositionAt","createPositionAfter","createPositionBefore","createRange","createRangeOn","createRangeIn","createSelection","_wrapChildren","startOffset","endOffset","wrapElement","i","wrapPositions","child","isText","isAttribute","isEmpty","isUI","_wrapAttributeElement","push","shouldABeOutsideB","newAttribute","offsetChange","_createFromParentsAndOffsets","unwrapElement","unwrapPositions","unwrapped","_unwrapAttributeElement","movePositionToTextNode","breakTextNode","fakePosition","Number","POSITIVE_INFINITY","wrapRange","wrapper","toWrap","canBeJoined","getAttributeKeys","hasAttribute","getAttribute","getStyleNames","hasStyle","getStyle","getClassNames","hasClass","toUnwrap","Array","from","forceSplitText","rangeStart","rangeEnd","isContainerOrFragment","offsetAfter","clonedNode","nodesToMove","root","group","get","Set","set","add","_clonesGroup","some","a","b","getIdentity","textToMove","slice","_data","t1","t2","nodeBeforeLength","errorContext","validNodesToInsert","validNode","startContainer","endContainer"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module module:engine/view/downcastwriter\n */\n\nimport Position from './position';\nimport Range from './range';\nimport Selection from './selection';\nimport ContainerElement from './containerelement';\nimport AttributeElement from './attributeelement';\nimport EmptyElement from './emptyelement';\nimport UIElement from './uielement';\nimport CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';\nimport DocumentFragment from './documentfragment';\nimport isIterable from '@ckeditor/ckeditor5-utils/src/isiterable';\nimport Text from './text';\nimport EditableElement from './editableelement';\nimport { isPlainObject } from 'lodash-es';\n\n/**\n * View downcast writer.\n *\n * It provides a set of methods used to manipulate view nodes.\n *\n * Do not create an instance of this writer manually. To modify a view structure, use\n * the {@link module:engine/view/view~View#change `View#change()`} block.\n *\n * The `DowncastWriter` is designed to work with semantic views which are the views that were/are being downcasted from the model.\n * To work with ordinary views (e.g. parsed from a pasted content) use the\n * {@link module:engine/view/upcastwriter~UpcastWriter upcast writer}.\n *\n * Read more about changing the view in the {@glink framework/guides/architecture/editing-engine#changing-the-view Changing the view}\n * section of the {@glink framework/guides/architecture/editing-engine Editing engine architecture} guide.\n */\nexport default class DowncastWriter {\n\tconstructor( document ) {\n\t\t/**\n\t\t * @readonly\n\t\t * @type {module:engine/view/document~Document}\n\t\t */\n\t\tthis.document = document;\n\n\t\t/**\n\t\t * Holds references to the attribute groups that share the same {@link module:engine/view/attributeelement~AttributeElement#id id}.\n\t\t * The keys are `id`s, the values are `Set`s holding {@link module:engine/view/attributeelement~AttributeElement}s.\n\t\t *\n\t\t * @private\n\t\t * @type {Map.<String,Set>}\n\t\t */\n\t\tthis._cloneGroups = new Map();\n\t}\n\n\t/**\n\t * Sets {@link module:engine/view/documentselection~DocumentSelection selection's} ranges and direction to the\n\t * specified location based on the given {@link module:engine/view/selection~Selectable selectable}.\n\t *\n\t * Usage:\n\t *\n\t *\t\t// Sets selection to the given range.\n\t *\t\tconst range = writer.createRange( start, end );\n\t *\t\twriter.setSelection( range );\n\t *\n\t *\t\t// Sets backward selection to the given range.\n\t *\t\tconst range = writer.createRange( start, end );\n\t *\t\twriter.setSelection( range );\n\t *\n\t *\t\t// Sets selection to given ranges.\n\t * \t\tconst ranges = [ writer.createRange( start1, end2 ), writer.createRange( start2, end2 ) ];\n\t *\t\twriter.setSelection( range );\n\t *\n\t *\t\t// Sets selection to the other selection.\n\t *\t\tconst otherSelection = writer.createSelection();\n\t *\t\twriter.setSelection( otherSelection );\n\t *\n\t * \t\t// Sets collapsed selection at the given position.\n\t *\t\tconst position = writer.createPositionFromPath( root, path );\n\t *\t\twriter.setSelection( position );\n\t *\n\t * \t\t// Sets collapsed selection at the position of given item and offset.\n\t *\t\tconst paragraph = writer.createContainerElement( 'p' );\n\t *\t\twriter.setSelection( paragraph, offset );\n\t *\n\t * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of\n \t * that element and ends after the last child of that element.\n\t *\n\t * \t\twriter.setSelection( paragraph, 'in' );\n\t *\n\t * Creates a range on the {@link module:engine/view/item~Item item} which starts before the item and ends just after the item.\n\t *\n\t *\t\twriter.setSelection( paragraph, 'on' );\n\t *\n\t * \t\t// Removes all ranges.\n\t *\t\twriter.setSelection( null );\n\t *\n\t * `DowncastWriter#setSelection()` allow passing additional options (`backward`, `fake` and `label`) as the last argument.\n\t *\n\t *\t\t// Sets selection as backward.\n\t *\t\twriter.setSelection( range, { backward: true } );\n\t *\n\t *\t\t// Sets selection as fake.\n\t *\t\t// Fake selection does not render as browser native selection over selected elements and is hidden to the user.\n\t * \t\t// This way, no native selection UI artifacts are displayed to the user and selection over elements can be\n\t * \t\t// represented in other way, for example by applying proper CSS class.\n\t *\t\twriter.setSelection( range, { fake: true } );\n\t *\n\t * \t\t// Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM\n\t * \t\t// (and be  properly handled by screen readers).\n\t *\t\twriter.setSelection( range, { fake: true, label: 'foo' } );\n\t *\n\t * @param {module:engine/view/selection~Selectable} selectable\n\t * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.\n\t * @param {Object} [options]\n\t * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n\t * @param {Boolean} [options.fake] Sets this selection instance to be marked as `fake`.\n\t * @param {String} [options.label] Label for the fake selection.\n\t */\n\tsetSelection( selectable, placeOrOffset, options ) {\n\t\tthis.document.selection._setTo( selectable, placeOrOffset, options );\n\t}\n\n\t/**\n\t * Moves {@link module:engine/view/documentselection~DocumentSelection#focus selection's focus} to the specified location.\n\t *\n\t * The location can be specified in the same form as {@link module:engine/view/view~View#createPositionAt view.createPositionAt()}\n\t * parameters.\n\t *\n\t * @param {module:engine/view/item~Item|module:engine/view/position~Position} itemOrPosition\n\t * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n\t * first parameter is a {@link module:engine/view/item~Item view item}.\n\t */\n\tsetSelectionFocus( itemOrPosition, offset ) {\n\t\tthis.document.selection._setFocus( itemOrPosition, offset );\n\t}\n\n\t/**\n\t * Creates a new {@link module:engine/view/text~Text text node}.\n\t *\n\t *\t\twriter.createText( 'foo' );\n\t *\n\t * @param {String} data The text's data.\n\t * @returns {module:engine/view/text~Text} The created text node.\n\t */\n\tcreateText( data ) {\n\t\treturn new Text( data );\n\t}\n\n\t/**\n\t * Creates new {@link module:engine/view/attributeelement~AttributeElement}.\n\t *\n\t *\t\twriter.createAttributeElement( 'strong' );\n\t *\t\twriter.createAttributeElement( 'a', { href: 'foo.bar' } );\n\t *\n\t *\t\t// Make `<a>` element contain other attributes element so the `<a>` element is not broken.\n\t *\t\twriter.createAttributeElement( 'a', { href: 'foo.bar' }, { priority: 5 } );\n\t *\n\t *\t\t// Set `id` of a marker element so it is not joined or merged with \"normal\" elements.\n\t *\t\twriter.createAttributeElement( 'span', { class: 'my-marker' }, { id: 'marker:my' } );\n\t *\n\t * @param {String} name Name of the element.\n\t * @param {Object} [attributes] Element's attributes.\n\t * @param {Object} [options] Element's options.\n\t * @param {Number} [options.priority] Element's {@link module:engine/view/attributeelement~AttributeElement#priority priority}.\n\t * @param {Number|String} [options.id] Element's {@link module:engine/view/attributeelement~AttributeElement#id id}.\n\t * @returns {module:engine/view/attributeelement~AttributeElement} Created element.\n\t */\n\tcreateAttributeElement( name, attributes, options = {} ) {\n\t\tconst attributeElement = new AttributeElement( name, attributes );\n\n\t\tif ( options.priority ) {\n\t\t\tattributeElement._priority = options.priority;\n\t\t}\n\n\t\tif ( options.id ) {\n\t\t\tattributeElement._id = options.id;\n\t\t}\n\n\t\treturn attributeElement;\n\t}\n\n\t/**\n\t * Creates new {@link module:engine/view/containerelement~ContainerElement}.\n\t *\n\t *\t\twriter.createContainerElement( 'p' );\n\t *\n\t *\t\t// Create element with custom attributes.\n\t *\t\twriter.createContainerElement( 'div', { id: 'foo-bar', 'data-baz': '123' } );\n\t *\n\t *\t\t// Create element with custom styles.\n\t *\t\twriter.createContainerElement( 'p', { style: 'font-weight: bold; padding-bottom: 10px' } );\n\t *\n\t *\t\t// Create element with custom classes.\n\t *\t\twriter.createContainerElement( 'p', { class: 'foo bar baz' } );\n\t *\n\t * @param {String} name Name of the element.\n\t * @param {Object} [attributes] Elements attributes.\n\t * @returns {module:engine/view/containerelement~ContainerElement} Created element.\n\t */\n\tcreateContainerElement( name, attributes ) {\n\t\treturn new ContainerElement( name, attributes );\n\t}\n\n\t/**\n\t * Creates new {@link module:engine/view/editableelement~EditableElement}.\n\t *\n\t *\t\twriter.createEditableElement( 'div' );\n\t *\t\twriter.createEditableElement( 'div', { id: 'foo-1234' } );\n\t *\n\t * @param {String} name Name of the element.\n\t * @param {Object} [attributes] Elements attributes.\n\t * @returns {module:engine/view/editableelement~EditableElement} Created element.\n\t */\n\tcreateEditableElement( name, attributes ) {\n\t\tconst editableElement = new EditableElement( name, attributes );\n\t\teditableElement._document = this.document;\n\n\t\treturn editableElement;\n\t}\n\n\t/**\n\t * Creates new {@link module:engine/view/emptyelement~EmptyElement}.\n\t *\n\t *\t\twriter.createEmptyElement( 'img' );\n\t *\t\twriter.createEmptyElement( 'img', { id: 'foo-1234' } );\n\t *\n\t * @param {String} name Name of the element.\n\t * @param {Object} [attributes] Elements attributes.\n\t * @returns {module:engine/view/emptyelement~EmptyElement} Created element.\n\t */\n\tcreateEmptyElement( name, attributes ) {\n\t\treturn new EmptyElement( name, attributes );\n\t}\n\n\t/**\n\t * Creates new {@link module:engine/view/uielement~UIElement}.\n\t *\n\t *\t\twriter.createUIElement( 'span' );\n\t *\t\twriter.createUIElement( 'span', { id: 'foo-1234' } );\n\t *\n\t * Custom render function can be provided as third parameter:\n\t *\n\t *\t\twriter.createUIElement( 'span', null, function( domDocument ) {\n\t *\t\t\tconst domElement = this.toDomElement( domDocument );\n\t *\t\t\tdomElement.innerHTML = '<b>this is ui element</b>';\n\t *\n\t *\t\t\treturn domElement;\n\t *\t\t} );\n\t *\n\t * @param {String} name Name of the element.\n\t * @param {Object} [attributes] Elements attributes.\n\t * @param {Function} [renderFunction] Custom render function.\n\t * @returns {module:engine/view/uielement~UIElement} Created element.\n\t */\n\tcreateUIElement( name, attributes, renderFunction ) {\n\t\tconst uiElement = new UIElement( name, attributes );\n\n\t\tif ( renderFunction ) {\n\t\t\tuiElement.render = renderFunction;\n\t\t}\n\n\t\treturn uiElement;\n\t}\n\n\t/**\n\t * Adds or overwrite element's attribute with a specified key and value.\n\t *\n\t *\t\twriter.setAttribute( 'href', 'http://ckeditor.com', linkElement );\n\t *\n\t * @param {String} key Attribute key.\n\t * @param {String} value Attribute value.\n\t * @param {module:engine/view/element~Element} element\n\t */\n\tsetAttribute( key, value, element ) {\n\t\telement._setAttribute( key, value );\n\t}\n\n\t/**\n\t * Removes attribute from the element.\n\t *\n\t *\t\twriter.removeAttribute( 'href', linkElement );\n\t *\n\t * @param {String} key Attribute key.\n\t * @param {module:engine/view/element~Element} element\n\t */\n\tremoveAttribute( key, element ) {\n\t\telement._removeAttribute( key );\n\t}\n\n\t/**\n\t * Adds specified class to the element.\n\t *\n\t *\t\twriter.addClass( 'foo', linkElement );\n\t *\t\twriter.addClass( [ 'foo', 'bar' ], linkElement );\n\t *\n\t * @param {Array.<String>|String} className\n\t * @param {module:engine/view/element~Element} element\n\t */\n\taddClass( className, element ) {\n\t\telement._addClass( className );\n\t}\n\n\t/**\n\t * Removes specified class from the element.\n\t *\n\t *\t\twriter.removeClass( 'foo', linkElement );\n\t *\t\twriter.removeClass( [ 'foo', 'bar' ], linkElement );\n\t *\n\t * @param {Array.<String>|String} className\n\t * @param {module:engine/view/element~Element} element\n\t */\n\tremoveClass( className, element ) {\n\t\telement._removeClass( className );\n\t}\n\n\t/**\n\t * Adds style to the element.\n\t *\n\t *\t\twriter.setStyle( 'color', 'red', element );\n\t *\t\twriter.setStyle( {\n\t *\t\t\tcolor: 'red',\n\t *\t\t\tposition: 'fixed'\n\t *\t\t}, element );\n\t *\n\t * @param {String|Object} property Property name or object with key - value pairs.\n\t * @param {String} [value] Value to set. This parameter is ignored if object is provided as the first parameter.\n\t * @param {module:engine/view/element~Element} element Element to set styles on.\n\t */\n\tsetStyle( property, value, element ) {\n\t\tif ( isPlainObject( property ) && element === undefined ) {\n\t\t\telement = value;\n\t\t}\n\n\t\telement._setStyle( property, value );\n\t}\n\n\t/**\n\t * Removes specified style from the element.\n\t *\n\t *\t\twriter.removeStyle( 'color', element );  // Removes 'color' style.\n\t *\t\twriter.removeStyle( [ 'color', 'border-top' ], element ); // Removes both 'color' and 'border-top' styles.\n\t *\n\t * @param {Array.<String>|String} property\n\t * @param {module:engine/view/element~Element} element\n\t */\n\tremoveStyle( property, element ) {\n\t\telement._removeStyle( property );\n\t}\n\n\t/**\n\t * Sets a custom property on element. Unlike attributes, custom properties are not rendered to the DOM,\n\t * so they can be used to add special data to elements.\n\t *\n\t * @param {String|Symbol} key\n\t * @param {*} value\n\t * @param {module:engine/view/element~Element} element\n\t */\n\tsetCustomProperty( key, value, element ) {\n\t\telement._setCustomProperty( key, value );\n\t}\n\n\t/**\n\t * Removes a custom property stored under the given key.\n\t *\n\t * @param {String|Symbol} key\n\t * @param {module:engine/view/element~Element} element\n\t * @returns {Boolean} Returns true if property was removed.\n\t */\n\tremoveCustomProperty( key, element ) {\n\t\treturn element._removeCustomProperty( key );\n\t}\n\n\t/**\n\t * Breaks attribute nodes at provided position or at boundaries of provided range. It breaks attribute elements inside\n\t * up to a container element.\n\t *\n\t * In following examples `<p>` is a container, `<b>` and `<u>` are attribute nodes:\n\t *\n\t *\t\t<p>foo<b><u>bar{}</u></b></p> -> <p>foo<b><u>bar</u></b>[]</p>\n\t *\t\t<p>foo<b><u>{}bar</u></b></p> -> <p>foo{}<b><u>bar</u></b></p>\n\t *\t\t<p>foo<b><u>b{}ar</u></b></p> -> <p>foo<b><u>b</u></b>[]<b><u>ar</u></b></p>\n\t *\t\t<p><b>fo{o</b><u>ba}r</u></p> -> <p><b>fo</b><b>o</b><u>ba</u><u>r</u></b></p>\n\t *\n\t * **Note:** {@link module:engine/view/documentfragment~DocumentFragment DocumentFragment} is treated like a container.\n\t *\n\t * **Note:** Difference between {@link module:engine/view/downcastwriter~DowncastWriter#breakAttributes breakAttributes} and\n\t * {@link module:engine/view/downcastwriter~DowncastWriter#breakContainer breakContainer} is that `breakAttributes` breaks all\n\t * {@link module:engine/view/attributeelement~AttributeElement attribute elements} that are ancestors of given `position`,\n\t * up to the first encountered {@link module:engine/view/containerelement~ContainerElement container element}.\n\t * `breakContainer` assumes that given `position` is directly in container element and breaks that container element.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container`\n\t * when {@link module:engine/view/range~Range#start start}\n\t * and {@link module:engine/view/range~Range#end end} positions of a passed range are not placed inside same parent container.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-cannot-break-empty-element`\n\t * when trying to break attributes\n\t * inside {@link module:engine/view/emptyelement~EmptyElement EmptyElement}.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-cannot-break-ui-element`\n\t * when trying to break attributes\n\t * inside {@link module:engine/view/uielement~UIElement UIElement}.\n\t *\n\t * @see module:engine/view/attributeelement~AttributeElement\n\t * @see module:engine/view/containerelement~ContainerElement\n\t * @see module:engine/view/downcastwriter~DowncastWriter#breakContainer\n\t * @param {module:engine/view/position~Position|module:engine/view/range~Range} positionOrRange Position where\n\t * to break attribute elements.\n\t * @returns {module:engine/view/position~Position|module:engine/view/range~Range} New position or range, after breaking the attribute\n\t * elements.\n\t */\n\tbreakAttributes( positionOrRange ) {\n\t\tif ( positionOrRange instanceof Position ) {\n\t\t\treturn this._breakAttributes( positionOrRange );\n\t\t} else {\n\t\t\treturn this._breakAttributesRange( positionOrRange );\n\t\t}\n\t}\n\n\t/**\n\t * Breaks {@link module:engine/view/containerelement~ContainerElement container view element} into two, at the given position. Position\n\t * has to be directly inside container element and cannot be in root. Does not break if position is at the beginning\n\t * or at the end of it's parent element.\n\t *\n\t *\t\t<p>foo^bar</p> -> <p>foo</p><p>bar</p>\n\t *\t\t<div><p>foo</p>^<p>bar</p></div> -> <div><p>foo</p></div><div><p>bar</p></div>\n\t *\t\t<p>^foobar</p> -> ^<p>foobar</p>\n\t *\t\t<p>foobar^</p> -> <p>foobar</p>^\n\t *\n\t * **Note:** Difference between {@link module:engine/view/downcastwriter~DowncastWriter#breakAttributes breakAttributes} and\n\t * {@link module:engine/view/downcastwriter~DowncastWriter#breakContainer breakContainer} is that `breakAttributes` breaks all\n\t * {@link module:engine/view/attributeelement~AttributeElement attribute elements} that are ancestors of given `position`,\n\t * up to the first encountered {@link module:engine/view/containerelement~ContainerElement container element}.\n\t * `breakContainer` assumes that given `position` is directly in container element and breaks that container element.\n\t *\n\t * @see module:engine/view/attributeelement~AttributeElement\n\t * @see module:engine/view/containerelement~ContainerElement\n\t * @see module:engine/view/downcastwriter~DowncastWriter#breakAttributes\n\t * @param {module:engine/view/position~Position} position Position where to break element.\n\t * @returns {module:engine/view/position~Position} Position between broken elements. If element has not been broken,\n\t * the returned position is placed either before it or after it.\n\t */\n\tbreakContainer( position ) {\n\t\tconst element = position.parent;\n\n\t\tif ( !( element.is( 'containerElement' ) ) ) {\n\t\t\t/**\n\t\t\t * Trying to break an element which is not a container element.\n\t\t\t *\n\t\t\t * @error view-writer-break-non-container-element\n\t\t\t */\n\t\t\tthrow new CKEditorError(\n\t\t\t\t'view-writer-break-non-container-element: Trying to break an element which is not a container element.',\n\t\t\t\tthis.document\n\t\t\t);\n\t\t}\n\n\t\tif ( !element.parent ) {\n\t\t\t/**\n\t\t\t * Trying to break root element.\n\t\t\t *\n\t\t\t * @error view-writer-break-root\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'view-writer-break-root: Trying to break root element.', this.document );\n\t\t}\n\n\t\tif ( position.isAtStart ) {\n\t\t\treturn Position._createBefore( element );\n\t\t} else if ( !position.isAtEnd ) {\n\t\t\tconst newElement = element._clone( false );\n\n\t\t\tthis.insert( Position._createAfter( element ), newElement );\n\n\t\t\tconst sourceRange = new Range( position, Position._createAt( element, 'end' ) );\n\t\t\tconst targetPosition = new Position( newElement, 0 );\n\n\t\t\tthis.move( sourceRange, targetPosition );\n\t\t}\n\n\t\treturn Position._createAfter( element );\n\t}\n\n\t/**\n\t * Merges {@link module:engine/view/attributeelement~AttributeElement attribute elements}. It also merges text nodes if needed.\n\t * Only {@link module:engine/view/attributeelement~AttributeElement#isSimilar similar} attribute elements can be merged.\n\t *\n\t * In following examples `<p>` is a container and `<b>` is an attribute element:\n\t *\n\t *\t\t<p>foo[]bar</p> -> <p>foo{}bar</p>\n\t *\t\t<p><b>foo</b>[]<b>bar</b></p> -> <p><b>foo{}bar</b></p>\n\t *\t\t<p><b foo=\"bar\">a</b>[]<b foo=\"baz\">b</b></p> -> <p><b foo=\"bar\">a</b>[]<b foo=\"baz\">b</b></p>\n\t *\n\t * It will also take care about empty attributes when merging:\n\t *\n\t *\t\t<p><b>[]</b></p> -> <p>[]</p>\n\t *\t\t<p><b>foo</b><i>[]</i><b>bar</b></p> -> <p><b>foo{}bar</b></p>\n\t *\n\t * **Note:** Difference between {@link module:engine/view/downcastwriter~DowncastWriter#mergeAttributes mergeAttributes} and\n\t * {@link module:engine/view/downcastwriter~DowncastWriter#mergeContainers mergeContainers} is that `mergeAttributes` merges two\n\t * {@link module:engine/view/attributeelement~AttributeElement attribute elements} or {@link module:engine/view/text~Text text nodes}\n\t * while `mergeContainer` merges two {@link module:engine/view/containerelement~ContainerElement container elements}.\n\t *\n\t * @see module:engine/view/attributeelement~AttributeElement\n\t * @see module:engine/view/containerelement~ContainerElement\n\t * @see module:engine/view/downcastwriter~DowncastWriter#mergeContainers\n\t * @param {module:engine/view/position~Position} position Merge position.\n\t * @returns {module:engine/view/position~Position} Position after merge.\n\t */\n\tmergeAttributes( position ) {\n\t\tconst positionOffset = position.offset;\n\t\tconst positionParent = position.parent;\n\n\t\t// When inside text node - nothing to merge.\n\t\tif ( positionParent.is( 'text' ) ) {\n\t\t\treturn position;\n\t\t}\n\n\t\t// When inside empty attribute - remove it.\n\t\tif ( positionParent.is( 'attributeElement' ) && positionParent.childCount === 0 ) {\n\t\t\tconst parent = positionParent.parent;\n\t\t\tconst offset = positionParent.index;\n\n\t\t\tpositionParent._remove();\n\t\t\tthis._removeFromClonedElementsGroup( positionParent );\n\n\t\t\treturn this.mergeAttributes( new Position( parent, offset ) );\n\t\t}\n\n\t\tconst nodeBefore = positionParent.getChild( positionOffset - 1 );\n\t\tconst nodeAfter = positionParent.getChild( positionOffset );\n\n\t\t// Position should be placed between two nodes.\n\t\tif ( !nodeBefore || !nodeAfter ) {\n\t\t\treturn position;\n\t\t}\n\n\t\t// When position is between two text nodes.\n\t\tif ( nodeBefore.is( 'text' ) && nodeAfter.is( 'text' ) ) {\n\t\t\treturn mergeTextNodes( nodeBefore, nodeAfter );\n\t\t}\n\t\t// When position is between two same attribute elements.\n\t\telse if ( nodeBefore.is( 'attributeElement' ) && nodeAfter.is( 'attributeElement' ) && nodeBefore.isSimilar( nodeAfter ) ) {\n\t\t\t// Move all children nodes from node placed after selection and remove that node.\n\t\t\tconst count = nodeBefore.childCount;\n\t\t\tnodeBefore._appendChild( nodeAfter.getChildren() );\n\n\t\t\tnodeAfter._remove();\n\t\t\tthis._removeFromClonedElementsGroup( nodeAfter );\n\n\t\t\t// New position is located inside the first node, before new nodes.\n\t\t\t// Call this method recursively to merge again if needed.\n\t\t\treturn this.mergeAttributes( new Position( nodeBefore, count ) );\n\t\t}\n\n\t\treturn position;\n\t}\n\n\t/**\n\t * Merges two {@link module:engine/view/containerelement~ContainerElement container elements} that are before and after given position.\n\t * Precisely, the element after the position is removed and it's contents are moved to element before the position.\n\t *\n\t *\t\t<p>foo</p>^<p>bar</p> -> <p>foo^bar</p>\n\t *\t\t<div>foo</div>^<p>bar</p> -> <div>foo^bar</div>\n\t *\n\t * **Note:** Difference between {@link module:engine/view/downcastwriter~DowncastWriter#mergeAttributes mergeAttributes} and\n\t * {@link module:engine/view/downcastwriter~DowncastWriter#mergeContainers mergeContainers} is that `mergeAttributes` merges two\n\t * {@link module:engine/view/attributeelement~AttributeElement attribute elements} or {@link module:engine/view/text~Text text nodes}\n\t * while `mergeContainer` merges two {@link module:engine/view/containerelement~ContainerElement container elements}.\n\t *\n\t * @see module:engine/view/attributeelement~AttributeElement\n\t * @see module:engine/view/containerelement~ContainerElement\n\t * @see module:engine/view/downcastwriter~DowncastWriter#mergeAttributes\n\t * @param {module:engine/view/position~Position} position Merge position.\n\t * @returns {module:engine/view/position~Position} Position after merge.\n\t */\n\tmergeContainers( position ) {\n\t\tconst prev = position.nodeBefore;\n\t\tconst next = position.nodeAfter;\n\n\t\tif ( !prev || !next || !prev.is( 'containerElement' ) || !next.is( 'containerElement' ) ) {\n\t\t\t/**\n\t\t\t * Element before and after given position cannot be merged.\n\t\t\t *\n\t\t\t * @error view-writer-merge-containers-invalid-position\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'view-writer-merge-containers-invalid-position: ' +\n\t\t\t\t'Element before and after given position cannot be merged.', this.document );\n\t\t}\n\n\t\tconst lastChild = prev.getChild( prev.childCount - 1 );\n\t\tconst newPosition = lastChild instanceof Text ? Position._createAt( lastChild, 'end' ) : Position._createAt( prev, 'end' );\n\n\t\tthis.move( Range._createIn( next ), Position._createAt( prev, 'end' ) );\n\t\tthis.remove( Range._createOn( next ) );\n\n\t\treturn newPosition;\n\t}\n\n\t/**\n\t * Insert node or nodes at specified position. Takes care about breaking attributes before insertion\n\t * and merging them afterwards.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-insert-invalid-node` when nodes to insert\n\t * contains instances that are not {@link module:engine/view/text~Text Texts},\n\t * {@link module:engine/view/attributeelement~AttributeElement AttributeElements},\n\t * {@link module:engine/view/containerelement~ContainerElement ContainerElements},\n\t * {@link module:engine/view/emptyelement~EmptyElement EmptyElements} or\n\t * {@link module:engine/view/uielement~UIElement UIElements}.\n\t *\n\t * @param {module:engine/view/position~Position} position Insertion position.\n\t * @param {module:engine/view/text~Text|module:engine/view/attributeelement~AttributeElement|\n\t * module:engine/view/containerelement~ContainerElement|module:engine/view/emptyelement~EmptyElement|\n\t * module:engine/view/uielement~UIElement|Iterable.<module:engine/view/text~Text|\n\t * module:engine/view/attributeelement~AttributeElement|module:engine/view/containerelement~ContainerElement|\n\t * module:engine/view/emptyelement~EmptyElement|module:engine/view/uielement~UIElement>} nodes Node or nodes to insert.\n\t * @returns {module:engine/view/range~Range} Range around inserted nodes.\n\t */\n\tinsert( position, nodes ) {\n\t\tnodes = isIterable( nodes ) ? [ ...nodes ] : [ nodes ];\n\n\t\t// Check if nodes to insert are instances of AttributeElements, ContainerElements, EmptyElements, UIElements or Text.\n\t\tvalidateNodesToInsert( nodes, this.document );\n\n\t\tconst container = getParentContainer( position );\n\n\t\tif ( !container ) {\n\t\t\t/**\n\t\t\t * Position's parent container cannot be found.\n\t\t\t *\n\t\t\t * @error view-writer-invalid-position-container\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'view-writer-invalid-position-container', this.document );\n\t\t}\n\n\t\tconst insertionPosition = this._breakAttributes( position, true );\n\t\tconst length = container._insertChild( insertionPosition.offset, nodes );\n\n\t\tfor ( const node of nodes ) {\n\t\t\tthis._addToClonedElementsGroup( node );\n\t\t}\n\n\t\tconst endPosition = insertionPosition.getShiftedBy( length );\n\t\tconst start = this.mergeAttributes( insertionPosition );\n\n\t\t// When no nodes were inserted - return collapsed range.\n\t\tif ( length === 0 ) {\n\t\t\treturn new Range( start, start );\n\t\t} else {\n\t\t\t// If start position was merged - move end position.\n\t\t\tif ( !start.isEqual( insertionPosition ) ) {\n\t\t\t\tendPosition.offset--;\n\t\t\t}\n\n\t\t\tconst end = this.mergeAttributes( endPosition );\n\n\t\t\treturn new Range( start, end );\n\t\t}\n\t}\n\n\t/**\n\t * Removes provided range from the container.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when\n\t * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside\n\t * same parent container.\n\t *\n\t * @param {module:engine/view/range~Range|module:engine/view/item~Item} rangeOrItem Range to remove from container\n\t * or an {@link module:engine/view/item~Item item} to remove. If range is provided, after removing, it will be updated\n\t * to a collapsed range showing the new position.\n\t * @returns {module:engine/view/documentfragment~DocumentFragment} Document fragment containing removed nodes.\n\t */\n\tremove( rangeOrItem ) {\n\t\tconst range = rangeOrItem instanceof Range ? rangeOrItem : Range._createOn( rangeOrItem );\n\n\t\tvalidateRangeContainer( range, this.document );\n\n\t\t// If range is collapsed - nothing to remove.\n\t\tif ( range.isCollapsed ) {\n\t\t\treturn new DocumentFragment();\n\t\t}\n\n\t\t// Break attributes at range start and end.\n\t\tconst { start: breakStart, end: breakEnd } = this._breakAttributesRange( range, true );\n\t\tconst parentContainer = breakStart.parent;\n\n\t\tconst count = breakEnd.offset - breakStart.offset;\n\n\t\t// Remove nodes in range.\n\t\tconst removed = parentContainer._removeChildren( breakStart.offset, count );\n\n\t\tfor ( const node of removed ) {\n\t\t\tthis._removeFromClonedElementsGroup( node );\n\t\t}\n\n\t\t// Merge after removing.\n\t\tconst mergePosition = this.mergeAttributes( breakStart );\n\t\trange.start = mergePosition;\n\t\trange.end = mergePosition.clone();\n\n\t\t// Return removed nodes.\n\t\treturn new DocumentFragment( removed );\n\t}\n\n\t/**\n\t * Removes matching elements from given range.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when\n\t * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside\n\t * same parent container.\n\t *\n\t * @param {module:engine/view/range~Range} range Range to clear.\n\t * @param {module:engine/view/element~Element} element Element to remove.\n\t */\n\tclear( range, element ) {\n\t\tvalidateRangeContainer( range, this.document );\n\n\t\t// Create walker on given range.\n\t\t// We walk backward because when we remove element during walk it modifies range end position.\n\t\tconst walker = range.getWalker( {\n\t\t\tdirection: 'backward',\n\t\t\tignoreElementEnd: true\n\t\t} );\n\n\t\t// Let's walk.\n\t\tfor ( const current of walker ) {\n\t\t\tconst item = current.item;\n\t\t\tlet rangeToRemove;\n\n\t\t\t// When current item matches to the given element.\n\t\t\tif ( item.is( 'element' ) && element.isSimilar( item ) ) {\n\t\t\t\t// Create range on this element.\n\t\t\t\trangeToRemove = Range._createOn( item );\n\t\t\t\t// When range starts inside Text or TextProxy element.\n\t\t\t} else if ( !current.nextPosition.isAfter( range.start ) && item.is( 'textProxy' ) ) {\n\t\t\t\t// We need to check if parent of this text matches to given element.\n\t\t\t\tconst parentElement = item.getAncestors().find( ancestor => {\n\t\t\t\t\treturn ancestor.is( 'element' ) && element.isSimilar( ancestor );\n\t\t\t\t} );\n\n\t\t\t\t// If it is then create range inside this element.\n\t\t\t\tif ( parentElement ) {\n\t\t\t\t\trangeToRemove = Range._createIn( parentElement );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If we have found element to remove.\n\t\t\tif ( rangeToRemove ) {\n\t\t\t\t// We need to check if element range stick out of the given range and truncate if it is.\n\t\t\t\tif ( rangeToRemove.end.isAfter( range.end ) ) {\n\t\t\t\t\trangeToRemove.end = range.end;\n\t\t\t\t}\n\n\t\t\t\tif ( rangeToRemove.start.isBefore( range.start ) ) {\n\t\t\t\t\trangeToRemove.start = range.start;\n\t\t\t\t}\n\n\t\t\t\t// At the end we remove range with found element.\n\t\t\t\tthis.remove( rangeToRemove );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Moves nodes from provided range to target position.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when\n\t * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside\n\t * same parent container.\n\t *\n\t * @param {module:engine/view/range~Range} sourceRange Range containing nodes to move.\n\t * @param {module:engine/view/position~Position} targetPosition Position to insert.\n\t * @returns {module:engine/view/range~Range} Range in target container. Inserted nodes are placed between\n\t * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions.\n\t */\n\tmove( sourceRange, targetPosition ) {\n\t\tlet nodes;\n\n\t\tif ( targetPosition.isAfter( sourceRange.end ) ) {\n\t\t\ttargetPosition = this._breakAttributes( targetPosition, true );\n\n\t\t\tconst parent = targetPosition.parent;\n\t\t\tconst countBefore = parent.childCount;\n\n\t\t\tsourceRange = this._breakAttributesRange( sourceRange, true );\n\n\t\t\tnodes = this.remove( sourceRange );\n\n\t\t\ttargetPosition.offset += ( parent.childCount - countBefore );\n\t\t} else {\n\t\t\tnodes = this.remove( sourceRange );\n\t\t}\n\n\t\treturn this.insert( targetPosition, nodes );\n\t}\n\n\t/**\n\t * Wraps elements within range with provided {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.\n\t * If a collapsed range is provided, it will be wrapped only if it is equal to view selection.\n\t *\n\t * If a collapsed range was passed and is same as selection, the selection\n\t * will be moved to the inside of the wrapped attribute element.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-invalid-range-container`\n\t * when {@link module:engine/view/range~Range#start}\n\t * and {@link module:engine/view/range~Range#end} positions are not placed inside same parent container.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-invalid-attribute` when passed attribute element is not\n\t * an instance of {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-nonselection-collapsed-range` when passed range\n\t * is collapsed and different than view selection.\n\t *\n\t * @param {module:engine/view/range~Range} range Range to wrap.\n\t * @param {module:engine/view/attributeelement~AttributeElement} attribute Attribute element to use as wrapper.\n\t * @returns {module:engine/view/range~Range} range Range after wrapping, spanning over wrapping attribute element.\n\t*/\n\twrap( range, attribute ) {\n\t\tif ( !( attribute instanceof AttributeElement ) ) {\n\t\t\tthrow new CKEditorError( 'view-writer-wrap-invalid-attribute', this.document );\n\t\t}\n\n\t\tvalidateRangeContainer( range, this.document );\n\n\t\tif ( !range.isCollapsed ) {\n\t\t\t// Non-collapsed range. Wrap it with the attribute element.\n\t\t\treturn this._wrapRange( range, attribute );\n\t\t} else {\n\t\t\t// Collapsed range. Wrap position.\n\t\t\tlet position = range.start;\n\n\t\t\tif ( position.parent.is( 'element' ) && !_hasNonUiChildren( position.parent ) ) {\n\t\t\t\tposition = position.getLastMatchingPosition( value => value.item.is( 'uiElement' ) );\n\t\t\t}\n\n\t\t\tposition = this._wrapPosition( position, attribute );\n\t\t\tconst viewSelection = this.document.selection;\n\n\t\t\t// If wrapping position is equal to view selection, move view selection inside wrapping attribute element.\n\t\t\tif ( viewSelection.isCollapsed && viewSelection.getFirstPosition().isEqual( range.start ) ) {\n\t\t\t\tthis.setSelection( position );\n\t\t\t}\n\n\t\t\treturn new Range( position );\n\t\t}\n\t}\n\n\t/**\n\t * Unwraps nodes within provided range from attribute element.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when\n\t * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside\n\t * same parent container.\n\t *\n\t * @param {module:engine/view/range~Range} range\n\t * @param {module:engine/view/attributeelement~AttributeElement} attribute\n\t */\n\tunwrap( range, attribute ) {\n\t\tif ( !( attribute instanceof AttributeElement ) ) {\n\t\t\t/**\n\t\t\t * Attribute element need to be instance of attribute element.\n\t\t\t *\n\t\t\t * @error view-writer-unwrap-invalid-attribute\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'view-writer-unwrap-invalid-attribute', this.document );\n\t\t}\n\n\t\tvalidateRangeContainer( range, this.document );\n\n\t\t// If range is collapsed - nothing to unwrap.\n\t\tif ( range.isCollapsed ) {\n\t\t\treturn range;\n\t\t}\n\n\t\t// Break attributes at range start and end.\n\t\tconst { start: breakStart, end: breakEnd } = this._breakAttributesRange( range, true );\n\t\tconst parentContainer = breakStart.parent;\n\n\t\t// Unwrap children located between break points.\n\t\tconst newRange = this._unwrapChildren( parentContainer, breakStart.offset, breakEnd.offset, attribute );\n\n\t\t// Merge attributes at the both ends and return a new range.\n\t\tconst start = this.mergeAttributes( newRange.start );\n\n\t\t// If start position was merged - move end position back.\n\t\tif ( !start.isEqual( newRange.start ) ) {\n\t\t\tnewRange.end.offset--;\n\t\t}\n\n\t\tconst end = this.mergeAttributes( newRange.end );\n\n\t\treturn new Range( start, end );\n\t}\n\n\t/**\n\t * Renames element by creating a copy of renamed element but with changed name and then moving contents of the\n\t * old element to the new one. Keep in mind that this will invalidate all {@link module:engine/view/position~Position positions} which\n\t * has renamed element as {@link module:engine/view/position~Position#parent a parent}.\n\t *\n\t * New element has to be created because `Element#tagName` property in DOM is readonly.\n\t *\n\t * Since this function creates a new element and removes the given one, the new element is returned to keep reference.\n\t *\n\t * @param {String} newName New name for element.\n\t * @param {module:engine/view/containerelement~ContainerElement} viewElement Element to be renamed.\n\t */\n\trename( newName, viewElement ) {\n\t\tconst newElement = new ContainerElement( newName, viewElement.getAttributes() );\n\n\t\tthis.insert( Position._createAfter( viewElement ), newElement );\n\t\tthis.move( Range._createIn( viewElement ), Position._createAt( newElement, 0 ) );\n\t\tthis.remove( Range._createOn( viewElement ) );\n\n\t\treturn newElement;\n\t}\n\n\t/**\n\t * Cleans up memory by removing obsolete cloned elements group from the writer.\n\t *\n\t * Should be used whenever all {@link module:engine/view/attributeelement~AttributeElement attribute elements}\n\t * with the same {@link module:engine/view/attributeelement~AttributeElement#id id} are going to be removed from the view and\n\t * the group will no longer be needed.\n\t *\n\t * Cloned elements group are not removed automatically in case if the group is still needed after all its elements\n\t * were removed from the view.\n\t *\n\t * Keep in mind that group names are equal to the `id` property of the attribute element.\n\t *\n\t * @param {String} groupName Name of the group to clear.\n\t */\n\tclearClonedElementsGroup( groupName ) {\n\t\tthis._cloneGroups.delete( groupName );\n\t}\n\n\t/**\n\t * Creates position at the given location. The location can be specified as:\n\t *\n\t * * a {@link module:engine/view/position~Position position},\n\t * * parent element and offset (offset defaults to `0`),\n\t * * parent element and `'end'` (sets position at the end of that element),\n\t * * {@link module:engine/view/item~Item view item} and `'before'` or `'after'` (sets position before or after given view item).\n\t *\n\t * This method is a shortcut to other constructors such as:\n\t *\n\t * * {@link #createPositionBefore},\n\t * * {@link #createPositionAfter},\n\t *\n\t * @param {module:engine/view/item~Item|module:engine/model/position~Position} itemOrPosition\n\t * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when\n\t * first parameter is a {@link module:engine/view/item~Item view item}.\n\t */\n\tcreatePositionAt( itemOrPosition, offset ) {\n\t\treturn Position._createAt( itemOrPosition, offset );\n\t}\n\n\t/**\n\t * Creates a new position after given view item.\n\t *\n\t * @param {module:engine/view/item~Item} item View item after which the position should be located.\n\t * @returns {module:engine/view/position~Position}\n\t */\n\tcreatePositionAfter( item ) {\n\t\treturn Position._createAfter( item );\n\t}\n\n\t/**\n\t * Creates a new position before given view item.\n\t *\n\t * @param {module:engine/view/item~Item} item View item before which the position should be located.\n\t * @returns {module:engine/view/position~Position}\n\t */\n\tcreatePositionBefore( item ) {\n\t\treturn Position._createBefore( item );\n\t}\n\n\t/**\n\t * Creates a range spanning from `start` position to `end` position.\n\t *\n\t * **Note:** This factory method creates it's own {@link module:engine/view/position~Position} instances basing on passed values.\n\t *\n\t * @param {module:engine/view/position~Position} start Start position.\n\t * @param {module:engine/view/position~Position} [end] End position. If not set, range will be collapsed at `start` position.\n\t * @returns {module:engine/view/range~Range}\n\t */\n\tcreateRange( start, end ) {\n\t\treturn new Range( start, end );\n\t}\n\n\t/**\n\t * Creates a range that starts before given {@link module:engine/view/item~Item view item} and ends after it.\n\t *\n\t * @param {module:engine/view/item~Item} item\n\t * @returns {module:engine/view/range~Range}\n\t */\n\tcreateRangeOn( item ) {\n\t\treturn Range._createOn( item );\n\t}\n\n\t/**\n\t * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of\n\t * that element and ends after the last child of that element.\n\t *\n\t * @param {module:engine/view/element~Element} element Element which is a parent for the range.\n\t * @returns {module:engine/view/range~Range}\n\t */\n\tcreateRangeIn( element ) {\n\t\treturn Range._createIn( element );\n\t}\n\n\t/**\n\t Creates new {@link module:engine/view/selection~Selection} instance.\n\t *\n\t * \t\t// Creates empty selection without ranges.\n\t *\t\tconst selection = writer.createSelection();\n\t *\n\t *\t\t// Creates selection at the given range.\n\t *\t\tconst range = writer.createRange( start, end );\n\t *\t\tconst selection = writer.createSelection( range );\n\t *\n\t *\t\t// Creates selection at the given ranges\n\t * \t\tconst ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];\n\t *\t\tconst selection = writer.createSelection( ranges );\n\t *\n\t *\t\t// Creates selection from the other selection.\n\t *\t\tconst otherSelection = writer.createSelection();\n\t *\t\tconst selection = writer.createSelection( otherSelection );\n\t *\n\t *\t\t// Creates selection from the document selection.\n\t *\t\tconst selection = writer.createSelection( editor.editing.view.document.selection );\n\t *\n\t * \t\t// Creates selection at the given position.\n\t *\t\tconst position = writer.createPositionFromPath( root, path );\n\t *\t\tconst selection = writer.createSelection( position );\n\t *\n\t *\t\t// Creates collapsed selection at the position of given item and offset.\n\t *\t\tconst paragraph = writer.createContainerElement( 'p' );\n\t *\t\tconst selection = writer.createSelection( paragraph, offset );\n\t *\n\t *\t\t// Creates a range inside an {@link module:engine/view/element~Element element} which starts before the\n\t *\t\t// first child of that element and ends after the last child of that element.\n\t *\t\tconst selection = writer.createSelection( paragraph, 'in' );\n\t *\n\t *\t\t// Creates a range on an {@link module:engine/view/item~Item item} which starts before the item and ends\n\t *\t\t// just after the item.\n\t *\t\tconst selection = writer.createSelection( paragraph, 'on' );\n\t *\n\t * `Selection`'s constructor allow passing additional options (`backward`, `fake` and `label`) as the last argument.\n\t *\n\t *\t\t// Creates backward selection.\n\t *\t\tconst selection = writer.createSelection( range, { backward: true } );\n\t *\n\t * Fake selection does not render as browser native selection over selected elements and is hidden to the user.\n\t * This way, no native selection UI artifacts are displayed to the user and selection over elements can be\n\t * represented in other way, for example by applying proper CSS class.\n\t *\n\t * Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM\n\t * (and be  properly handled by screen readers).\n\t *\n\t *\t\t// Creates fake selection with label.\n\t *\t\tconst selection = writer.createSelection( range, { fake: true, label: 'foo' } );\n\t *\n\t * @param {module:engine/view/selection~Selectable} [selectable=null]\n\t * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Offset or place when selectable is an `Item`.\n\t * @param {Object} [options]\n\t * @param {Boolean} [options.backward] Sets this selection instance to be backward.\n\t * @param {Boolean} [options.fake] Sets this selection instance to be marked as `fake`.\n\t * @param {String} [options.label] Label for the fake selection.\n\t * @returns {module:engine/view/selection~Selection}\n\t */\n\tcreateSelection( selectable, placeOrOffset, options ) {\n\t\treturn new Selection( selectable, placeOrOffset, options );\n\t}\n\n\t/**\n\t * Wraps children with provided `wrapElement`. Only children contained in `parent` element between\n\t * `startOffset` and `endOffset` will be wrapped.\n\t *\n\t * @private\n\t * @param {module:engine/view/element~Element} parent\n\t * @param {Number} startOffset\n\t * @param {Number} endOffset\n\t * @param {module:engine/view/element~Element} wrapElement\n\t */\n\t_wrapChildren( parent, startOffset, endOffset, wrapElement ) {\n\t\tlet i = startOffset;\n\t\tconst wrapPositions = [];\n\n\t\twhile ( i < endOffset ) {\n\t\t\tconst child = parent.getChild( i );\n\t\t\tconst isText = child.is( 'text' );\n\t\t\tconst isAttribute = child.is( 'attributeElement' );\n\t\t\tconst isEmpty = child.is( 'emptyElement' );\n\t\t\tconst isUI = child.is( 'uiElement' );\n\n\t\t\t//\n\t\t\t// (In all examples, assume that `wrapElement` is `<span class=\"foo\">` element.)\n\t\t\t//\n\t\t\t// Check if `wrapElement` can be joined with the wrapped element. One of requirements is having same name.\n\t\t\t// If possible, join elements.\n\t\t\t//\n\t\t\t// <p><span class=\"bar\">abc</span></p>  -->  <p><span class=\"foo bar\">abc</span></p>\n\t\t\t//\n\t\t\tif ( isAttribute && this._wrapAttributeElement( wrapElement, child ) ) {\n\t\t\t\twrapPositions.push( new Position( parent, i ) );\n\t\t\t}\n\t\t\t//\n\t\t\t// Wrap the child if it is not an attribute element or if it is an attribute element that should be inside\n\t\t\t// `wrapElement` (due to priority).\n\t\t\t//\n\t\t\t// <p>abc</p>                   -->  <p><span class=\"foo\">abc</span></p>\n\t\t\t// <p><strong>abc</strong></p>  -->  <p><span class=\"foo\"><strong>abc</strong></span></p>\n\t\t\t//\n\t\t\telse if ( isText || isEmpty || isUI || ( isAttribute && shouldABeOutsideB( wrapElement, child ) ) ) {\n\t\t\t\t// Clone attribute.\n\t\t\t\tconst newAttribute = wrapElement._clone();\n\n\t\t\t\t// Wrap current node with new attribute.\n\t\t\t\tchild._remove();\n\t\t\t\tnewAttribute._appendChild( child );\n\n\t\t\t\tparent._insertChild( i, newAttribute );\n\t\t\t\tthis._addToClonedElementsGroup( newAttribute );\n\n\t\t\t\twrapPositions.push( new Position( parent, i ) );\n\t\t\t}\n\t\t\t//\n\t\t\t// If other nested attribute is found and it wasn't wrapped (see above), continue wrapping inside it.\n\t\t\t//\n\t\t\t// <p><a href=\"foo.html\">abc</a></p>  -->  <p><a href=\"foo.html\"><span class=\"foo\">abc</span></a></p>\n\t\t\t//\n\t\t\telse if ( isAttribute ) {\n\t\t\t\tthis._wrapChildren( child, 0, child.childCount, wrapElement );\n\t\t\t}\n\n\t\t\ti++;\n\t\t}\n\n\t\t// Merge at each wrap.\n\t\tlet offsetChange = 0;\n\n\t\tfor ( const position of wrapPositions ) {\n\t\t\tposition.offset -= offsetChange;\n\n\t\t\t// Do not merge with elements outside selected children.\n\t\t\tif ( position.offset == startOffset ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst newPosition = this.mergeAttributes( position );\n\n\t\t\t// If nodes were merged - other merge offsets will change.\n\t\t\tif ( !newPosition.isEqual( position ) ) {\n\t\t\t\toffsetChange++;\n\t\t\t\tendOffset--;\n\t\t\t}\n\t\t}\n\n\t\treturn Range._createFromParentsAndOffsets( parent, startOffset, parent, endOffset );\n\t}\n\n\t/**\n\t * Unwraps children from provided `unwrapElement`. Only children contained in `parent` element between\n\t * `startOffset` and `endOffset` will be unwrapped.\n\t *\n\t * @private\n\t * @param {module:engine/view/element~Element} parent\n\t * @param {Number} startOffset\n\t * @param {Number} endOffset\n\t * @param {module:engine/view/element~Element} unwrapElement\n\t */\n\t_unwrapChildren( parent, startOffset, endOffset, unwrapElement ) {\n\t\tlet i = startOffset;\n\t\tconst unwrapPositions = [];\n\n\t\t// Iterate over each element between provided offsets inside parent.\n\t\t// We don't use tree walker or range iterator because we will be removing and merging potentially multiple nodes,\n\t\t// so it could get messy. It is safer to it manually in this case.\n\t\twhile ( i < endOffset ) {\n\t\t\tconst child = parent.getChild( i );\n\n\t\t\t// Skip all text nodes. There should be no container element's here either.\n\t\t\tif ( !child.is( 'attributeElement' ) ) {\n\t\t\t\ti++;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//\n\t\t\t// (In all examples, assume that `unwrapElement` is `<span class=\"foo\">` element.)\n\t\t\t//\n\t\t\t// If the child is similar to the given attribute element, unwrap it - it will be completely removed.\n\t\t\t//\n\t\t\t// <p><span class=\"foo\">abc</span>xyz</p>  -->  <p>abcxyz</p>\n\t\t\t//\n\t\t\tif ( child.isSimilar( unwrapElement ) ) {\n\t\t\t\tconst unwrapped = child.getChildren();\n\t\t\t\tconst count = child.childCount;\n\n\t\t\t\t// Replace wrapper element with its children\n\t\t\t\tchild._remove();\n\t\t\t\tparent._insertChild( i, unwrapped );\n\n\t\t\t\tthis._removeFromClonedElementsGroup( child );\n\n\t\t\t\t// Save start and end position of moved items.\n\t\t\t\tunwrapPositions.push(\n\t\t\t\t\tnew Position( parent, i ),\n\t\t\t\t\tnew Position( parent, i + count )\n\t\t\t\t);\n\n\t\t\t\t// Skip elements that were unwrapped. Assuming there won't be another element to unwrap in child elements.\n\t\t\t\ti += count;\n\t\t\t\tendOffset += count - 1;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//\n\t\t\t// If the child is not similar but is an attribute element, try partial unwrapping - remove the same attributes/styles/classes.\n\t\t\t// Partial unwrapping will happen only if the elements have the same name.\n\t\t\t//\n\t\t\t// <p><span class=\"foo bar\">abc</span>xyz</p>  -->  <p><span class=\"bar\">abc</span>xyz</p>\n\t\t\t// <p><i class=\"foo\">abc</i>xyz</p>            -->  <p><i class=\"foo\">abc</i>xyz</p>\n\t\t\t//\n\t\t\tif ( this._unwrapAttributeElement( unwrapElement, child ) ) {\n\t\t\t\tunwrapPositions.push(\n\t\t\t\t\tnew Position( parent, i ),\n\t\t\t\t\tnew Position( parent, i + 1 )\n\t\t\t\t);\n\n\t\t\t\ti++;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//\n\t\t\t// If other nested attribute is found, look through it's children for elements to unwrap.\n\t\t\t//\n\t\t\t// <p><i><span class=\"foo\">abc</span></i><p>  -->  <p><i>abc</i><p>\n\t\t\t//\n\t\t\tthis._unwrapChildren( child, 0, child.childCount, unwrapElement );\n\n\t\t\ti++;\n\t\t}\n\n\t\t// Merge at each unwrap.\n\t\tlet offsetChange = 0;\n\n\t\tfor ( const position of unwrapPositions ) {\n\t\t\tposition.offset -= offsetChange;\n\n\t\t\t// Do not merge with elements outside selected children.\n\t\t\tif ( position.offset == startOffset || position.offset == endOffset ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst newPosition = this.mergeAttributes( position );\n\n\t\t\t// If nodes were merged - other merge offsets will change.\n\t\t\tif ( !newPosition.isEqual( position ) ) {\n\t\t\t\toffsetChange++;\n\t\t\t\tendOffset--;\n\t\t\t}\n\t\t}\n\n\t\treturn Range._createFromParentsAndOffsets( parent, startOffset, parent, endOffset );\n\t}\n\n\t/**\n\t * Helper function for `view.writer.wrap`. Wraps range with provided attribute element.\n\t * This method will also merge newly added attribute element with its siblings whenever possible.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-invalid-attribute` when passed attribute element is not\n\t * an instance of {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.\n\t *\n\t * @private\n\t * @param {module:engine/view/range~Range} range\n\t * @param {module:engine/view/attributeelement~AttributeElement} attribute\n\t * @returns {module:engine/view/range~Range} New range after wrapping, spanning over wrapping attribute element.\n\t */\n\t_wrapRange( range, attribute ) {\n\t\t// Break attributes at range start and end.\n\t\tconst { start: breakStart, end: breakEnd } = this._breakAttributesRange( range, true );\n\t\tconst parentContainer = breakStart.parent;\n\n\t\t// Wrap all children with attribute.\n\t\tconst newRange = this._wrapChildren( parentContainer, breakStart.offset, breakEnd.offset, attribute );\n\n\t\t// Merge attributes at the both ends and return a new range.\n\t\tconst start = this.mergeAttributes( newRange.start );\n\n\t\t// If start position was merged - move end position back.\n\t\tif ( !start.isEqual( newRange.start ) ) {\n\t\t\tnewRange.end.offset--;\n\t\t}\n\t\tconst end = this.mergeAttributes( newRange.end );\n\n\t\treturn new Range( start, end );\n\t}\n\n\t/**\n\t * Helper function for {@link #wrap}. Wraps position with provided attribute element.\n\t * This method will also merge newly added attribute element with its siblings whenever possible.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-invalid-attribute` when passed attribute element is not\n\t * an instance of {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.\n\t *\n\t * @private\n\t * @param {module:engine/view/position~Position} position\n\t * @param {module:engine/view/attributeelement~AttributeElement} attribute\n\t * @returns {module:engine/view/position~Position} New position after wrapping.\n\t */\n\t_wrapPosition( position, attribute ) {\n\t\t// Return same position when trying to wrap with attribute similar to position parent.\n\t\tif ( attribute.isSimilar( position.parent ) ) {\n\t\t\treturn movePositionToTextNode( position.clone() );\n\t\t}\n\n\t\t// When position is inside text node - break it and place new position between two text nodes.\n\t\tif ( position.parent.is( 'text' ) ) {\n\t\t\tposition = breakTextNode( position );\n\t\t}\n\n\t\t// Create fake element that will represent position, and will not be merged with other attributes.\n\t\tconst fakePosition = this.createAttributeElement();\n\t\tfakePosition._priority = Number.POSITIVE_INFINITY;\n\t\tfakePosition.isSimilar = () => false;\n\n\t\t// Insert fake element in position location.\n\t\tposition.parent._insertChild( position.offset, fakePosition );\n\n\t\t// Range around inserted fake attribute element.\n\t\tconst wrapRange = new Range( position, position.getShiftedBy( 1 ) );\n\n\t\t// Wrap fake element with attribute (it will also merge if possible).\n\t\tthis.wrap( wrapRange, attribute );\n\n\t\t// Remove fake element and place new position there.\n\t\tconst newPosition = new Position( fakePosition.parent, fakePosition.index );\n\t\tfakePosition._remove();\n\n\t\t// If position is placed between text nodes - merge them and return position inside.\n\t\tconst nodeBefore = newPosition.nodeBefore;\n\t\tconst nodeAfter = newPosition.nodeAfter;\n\n\t\tif ( nodeBefore instanceof Text && nodeAfter instanceof Text ) {\n\t\t\treturn mergeTextNodes( nodeBefore, nodeAfter );\n\t\t}\n\n\t\t// If position is next to text node - move position inside.\n\t\treturn movePositionToTextNode( newPosition );\n\t}\n\n\t/**\n\t * \tWraps one {@link module:engine/view/attributeelement~AttributeElement AttributeElement} into another by\n\t * \tmerging them if possible. When merging is possible - all attributes, styles and classes are moved from wrapper\n\t * \telement to element being wrapped.\n\t *\n\t * \t@private\n\t * \t@param {module:engine/view/attributeelement~AttributeElement} wrapper Wrapper AttributeElement.\n\t * \t@param {module:engine/view/attributeelement~AttributeElement} toWrap AttributeElement to wrap using wrapper element.\n\t * \t@returns {Boolean} Returns `true` if elements are merged.\n\t */\n\t_wrapAttributeElement( wrapper, toWrap ) {\n\t\tif ( !canBeJoined( wrapper, toWrap ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Can't merge if name or priority differs.\n\t\tif ( wrapper.name !== toWrap.name || wrapper.priority !== toWrap.priority ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check if attributes can be merged.\n\t\tfor ( const key of wrapper.getAttributeKeys() ) {\n\t\t\t// Classes and styles should be checked separately.\n\t\t\tif ( key === 'class' || key === 'style' ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If some attributes are different we cannot wrap.\n\t\t\tif ( toWrap.hasAttribute( key ) && toWrap.getAttribute( key ) !== wrapper.getAttribute( key ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// Check if styles can be merged.\n\t\tfor ( const key of wrapper.getStyleNames() ) {\n\t\t\tif ( toWrap.hasStyle( key ) && toWrap.getStyle( key ) !== wrapper.getStyle( key ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// Move all attributes/classes/styles from wrapper to wrapped AttributeElement.\n\t\tfor ( const key of wrapper.getAttributeKeys() ) {\n\t\t\t// Classes and styles should be checked separately.\n\t\t\tif ( key === 'class' || key === 'style' ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Move only these attributes that are not present - other are similar.\n\t\t\tif ( !toWrap.hasAttribute( key ) ) {\n\t\t\t\tthis.setAttribute( key, wrapper.getAttribute( key ), toWrap );\n\t\t\t}\n\t\t}\n\n\t\tfor ( const key of wrapper.getStyleNames() ) {\n\t\t\tif ( !toWrap.hasStyle( key ) ) {\n\t\t\t\tthis.setStyle( key, wrapper.getStyle( key ), toWrap );\n\t\t\t}\n\t\t}\n\n\t\tfor ( const key of wrapper.getClassNames() ) {\n\t\t\tif ( !toWrap.hasClass( key ) ) {\n\t\t\t\tthis.addClass( key, toWrap );\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Unwraps {@link module:engine/view/attributeelement~AttributeElement AttributeElement} from another by removing\n\t * corresponding attributes, classes and styles. All attributes, classes and styles from wrapper should be present\n\t * inside element being unwrapped.\n\t *\n\t * @private\n\t * @param {module:engine/view/attributeelement~AttributeElement} wrapper Wrapper AttributeElement.\n\t * @param {module:engine/view/attributeelement~AttributeElement} toUnwrap AttributeElement to unwrap using wrapper element.\n\t * @returns {Boolean} Returns `true` if elements are unwrapped.\n\t **/\n\t_unwrapAttributeElement( wrapper, toUnwrap ) {\n\t\tif ( !canBeJoined( wrapper, toUnwrap ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Can't unwrap if name or priority differs.\n\t\tif ( wrapper.name !== toUnwrap.name || wrapper.priority !== toUnwrap.priority ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check if AttributeElement has all wrapper attributes.\n\t\tfor ( const key of wrapper.getAttributeKeys() ) {\n\t\t\t// Classes and styles should be checked separately.\n\t\t\tif ( key === 'class' || key === 'style' ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If some attributes are missing or different we cannot unwrap.\n\t\t\tif ( !toUnwrap.hasAttribute( key ) || toUnwrap.getAttribute( key ) !== wrapper.getAttribute( key ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// Check if AttributeElement has all wrapper classes.\n\t\tif ( !toUnwrap.hasClass( ...wrapper.getClassNames() ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check if AttributeElement has all wrapper styles.\n\t\tfor ( const key of wrapper.getStyleNames() ) {\n\t\t\t// If some styles are missing or different we cannot unwrap.\n\t\t\tif ( !toUnwrap.hasStyle( key ) || toUnwrap.getStyle( key ) !== wrapper.getStyle( key ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// Remove all wrapper's attributes from unwrapped element.\n\t\tfor ( const key of wrapper.getAttributeKeys() ) {\n\t\t\t// Classes and styles should be checked separately.\n\t\t\tif ( key === 'class' || key === 'style' ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthis.removeAttribute( key, toUnwrap );\n\t\t}\n\n\t\t// Remove all wrapper's classes from unwrapped element.\n\t\tthis.removeClass( Array.from( wrapper.getClassNames() ), toUnwrap );\n\n\t\t// Remove all wrapper's styles from unwrapped element.\n\t\tthis.removeStyle( Array.from( wrapper.getStyleNames() ), toUnwrap );\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Helper function used by other `DowncastWriter` methods. Breaks attribute elements at the boundaries of given range.\n\t *\n\t * @private\n\t * @param {module:engine/view/range~Range} range Range which `start` and `end` positions will be used to break attributes.\n\t * @param {Boolean} [forceSplitText=false] If set to `true`, will break text nodes even if they are directly in container element.\n\t * This behavior will result in incorrect view state, but is needed by other view writing methods which then fixes view state.\n\t * @returns {module:engine/view/range~Range} New range with located at break positions.\n\t */\n\t_breakAttributesRange( range, forceSplitText = false ) {\n\t\tconst rangeStart = range.start;\n\t\tconst rangeEnd = range.end;\n\n\t\tvalidateRangeContainer( range, this.document );\n\n\t\t// Break at the collapsed position. Return new collapsed range.\n\t\tif ( range.isCollapsed ) {\n\t\t\tconst position = this._breakAttributes( range.start, forceSplitText );\n\n\t\t\treturn new Range( position, position );\n\t\t}\n\n\t\tconst breakEnd = this._breakAttributes( rangeEnd, forceSplitText );\n\t\tconst count = breakEnd.parent.childCount;\n\t\tconst breakStart = this._breakAttributes( rangeStart, forceSplitText );\n\n\t\t// Calculate new break end offset.\n\t\tbreakEnd.offset += breakEnd.parent.childCount - count;\n\n\t\treturn new Range( breakStart, breakEnd );\n\t}\n\n\t/**\n\t * Helper function used by other `DowncastWriter` methods. Breaks attribute elements at given position.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-cannot-break-empty-element` when break position\n\t * is placed inside {@link module:engine/view/emptyelement~EmptyElement EmptyElement}.\n\t *\n\t * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-cannot-break-ui-element` when break position\n\t * is placed inside {@link module:engine/view/uielement~UIElement UIElement}.\n\t *\n\t * @private\n\t * @param {module:engine/view/position~Position} position Position where to break attributes.\n\t * @param {Boolean} [forceSplitText=false] If set to `true`, will break text nodes even if they are directly in container element.\n\t * This behavior will result in incorrect view state, but is needed by other view writing methods which then fixes view state.\n\t * @returns {module:engine/view/position~Position} New position after breaking the attributes.\n\t */\n\t_breakAttributes( position, forceSplitText = false ) {\n\t\tconst positionOffset = position.offset;\n\t\tconst positionParent = position.parent;\n\n\t\t// If position is placed inside EmptyElement - throw an exception as we cannot break inside.\n\t\tif ( position.parent.is( 'emptyElement' ) ) {\n\t\t\t/**\n\t\t\t * Cannot break inside EmptyElement instance.\n\t\t\t *\n\t\t\t * @error view-writer-cannot-break-empty-element\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'view-writer-cannot-break-empty-element', this.document );\n\t\t}\n\n\t\t// If position is placed inside UIElement - throw an exception as we cannot break inside.\n\t\tif ( position.parent.is( 'uiElement' ) ) {\n\t\t\t/**\n\t\t\t * Cannot break inside UIElement instance.\n\t\t\t *\n\t\t\t * @error view-writer-cannot-break-ui-element\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'view-writer-cannot-break-ui-element', this.document );\n\t\t}\n\n\t\t// There are no attributes to break and text nodes breaking is not forced.\n\t\tif ( !forceSplitText && positionParent.is( 'text' ) && isContainerOrFragment( positionParent.parent ) ) {\n\t\t\treturn position.clone();\n\t\t}\n\n\t\t// Position's parent is container, so no attributes to break.\n\t\tif ( isContainerOrFragment( positionParent ) ) {\n\t\t\treturn position.clone();\n\t\t}\n\n\t\t// Break text and start again in new position.\n\t\tif ( positionParent.is( 'text' ) ) {\n\t\t\treturn this._breakAttributes( breakTextNode( position ), forceSplitText );\n\t\t}\n\n\t\tconst length = positionParent.childCount;\n\n\t\t// <p>foo<b><u>bar{}</u></b></p>\n\t\t// <p>foo<b><u>bar</u>[]</b></p>\n\t\t// <p>foo<b><u>bar</u></b>[]</p>\n\t\tif ( positionOffset == length ) {\n\t\t\tconst newPosition = new Position( positionParent.parent, positionParent.index + 1 );\n\n\t\t\treturn this._breakAttributes( newPosition, forceSplitText );\n\t\t} else {\n\t\t\t// <p>foo<b><u>{}bar</u></b></p>\n\t\t\t// <p>foo<b>[]<u>bar</u></b></p>\n\t\t\t// <p>foo{}<b><u>bar</u></b></p>\n\t\t\tif ( positionOffset === 0 ) {\n\t\t\t\tconst newPosition = new Position( positionParent.parent, positionParent.index );\n\n\t\t\t\treturn this._breakAttributes( newPosition, forceSplitText );\n\t\t\t}\n\t\t\t// <p>foo<b><u>b{}ar</u></b></p>\n\t\t\t// <p>foo<b><u>b[]ar</u></b></p>\n\t\t\t// <p>foo<b><u>b</u>[]<u>ar</u></b></p>\n\t\t\t// <p>foo<b><u>b</u></b>[]<b><u>ar</u></b></p>\n\t\t\telse {\n\t\t\t\tconst offsetAfter = positionParent.index + 1;\n\n\t\t\t\t// Break element.\n\t\t\t\tconst clonedNode = positionParent._clone();\n\n\t\t\t\t// Insert cloned node to position's parent node.\n\t\t\t\tpositionParent.parent._insertChild( offsetAfter, clonedNode );\n\t\t\t\tthis._addToClonedElementsGroup( clonedNode );\n\n\t\t\t\t// Get nodes to move.\n\t\t\t\tconst count = positionParent.childCount - positionOffset;\n\t\t\t\tconst nodesToMove = positionParent._removeChildren( positionOffset, count );\n\n\t\t\t\t// Move nodes to cloned node.\n\t\t\t\tclonedNode._appendChild( nodesToMove );\n\n\t\t\t\t// Create new position to work on.\n\t\t\t\tconst newPosition = new Position( positionParent.parent, offsetAfter );\n\n\t\t\t\treturn this._breakAttributes( newPosition, forceSplitText );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Stores the information that an {@link module:engine/view/attributeelement~AttributeElement attribute element} was\n\t * added to the tree. Saves the reference to the group in the given element and updates the group, so other elements\n\t * from the group now keep a reference to the given attribute element.\n\t *\n\t * The clones group can be obtained using {@link module:engine/view/attributeelement~AttributeElement#getElementsWithSameId}.\n\t *\n\t * Does nothing if added element has no {@link module:engine/view/attributeelement~AttributeElement#id id}.\n\t *\n\t * @private\n\t * @param {module:engine/view/attributeelement~AttributeElement} element Attribute element to save.\n\t */\n\t_addToClonedElementsGroup( element ) {\n\t\t// Add only if the element is in document tree.\n\t\tif ( !element.root.is( 'rootElement' ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Traverse the element's children recursively to find other attribute elements that also might got inserted.\n\t\t// The loop is at the beginning so we can make fast returns later in the code.\n\t\tif ( element.is( 'element' ) ) {\n\t\t\tfor ( const child of element.getChildren() ) {\n\t\t\t\tthis._addToClonedElementsGroup( child );\n\t\t\t}\n\t\t}\n\n\t\tconst id = element.id;\n\n\t\tif ( !id ) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet group = this._cloneGroups.get( id );\n\n\t\tif ( !group ) {\n\t\t\tgroup = new Set();\n\t\t\tthis._cloneGroups.set( id, group );\n\t\t}\n\n\t\tgroup.add( element );\n\t\telement._clonesGroup = group;\n\t}\n\n\t/**\n\t * Removes all the information about the given {@link module:engine/view/attributeelement~AttributeElement attribute element}\n\t * from its clones group.\n\t *\n\t * Keep in mind, that the element will still keep a reference to the group (but the group will not keep a reference to it).\n\t * This allows to reference the whole group even if the element was already removed from the tree.\n\t *\n\t * Does nothing if the element has no {@link module:engine/view/attributeelement~AttributeElement#id id}.\n\t *\n\t * @private\n\t * @param {module:engine/view/attributeelement~AttributeElement} element Attribute element to remove.\n\t */\n\t_removeFromClonedElementsGroup( element ) {\n\t\t// Traverse the element's children recursively to find other attribute elements that also got removed.\n\t\t// The loop is at the beginning so we can make fast returns later in the code.\n\t\tif ( element.is( 'element' ) ) {\n\t\t\tfor ( const child of element.getChildren() ) {\n\t\t\t\tthis._removeFromClonedElementsGroup( child );\n\t\t\t}\n\t\t}\n\n\t\tconst id = element.id;\n\n\t\tif ( !id ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst group = this._cloneGroups.get( id );\n\n\t\tif ( !group ) {\n\t\t\treturn;\n\t\t}\n\n\t\tgroup.delete( element );\n\t\t// Not removing group from element on purpose!\n\t\t// If other parts of code have reference to this element, they will be able to get references to other elements from the group.\n\t}\n}\n\n// Helper function for `view.writer.wrap`. Checks if given element has any children that are not ui elements.\nfunction _hasNonUiChildren( parent ) {\n\treturn Array.from( parent.getChildren() ).some( child => !child.is( 'uiElement' ) );\n}\n\n/**\n * Attribute element need to be instance of attribute element.\n *\n * @error view-writer-wrap-invalid-attribute\n */\n\n// Returns first parent container of specified {@link module:engine/view/position~Position Position}.\n// Position's parent node is checked as first, then next parents are checked.\n// Note that {@link module:engine/view/documentfragment~DocumentFragment DocumentFragment} is treated like a container.\n//\n// @param {module:engine/view/position~Position} position Position used as a start point to locate parent container.\n// @returns {module:engine/view/containerelement~ContainerElement|module:engine/view/documentfragment~DocumentFragment|undefined}\n// Parent container element or `undefined` if container is not found.\nfunction getParentContainer( position ) {\n\tlet parent = position.parent;\n\n\twhile ( !isContainerOrFragment( parent ) ) {\n\t\tif ( !parent ) {\n\t\t\treturn undefined;\n\t\t}\n\t\tparent = parent.parent;\n\t}\n\n\treturn parent;\n}\n\n// Checks if first {@link module:engine/view/attributeelement~AttributeElement AttributeElement} provided to the function\n// can be wrapped otuside second element. It is done by comparing elements'\n// {@link module:engine/view/attributeelement~AttributeElement#priority priorities}, if both have same priority\n// {@link module:engine/view/element~Element#getIdentity identities} are compared.\n//\n// @param {module:engine/view/attributeelement~AttributeElement} a\n// @param {module:engine/view/attributeelement~AttributeElement} b\n// @returns {Boolean}\nfunction shouldABeOutsideB( a, b ) {\n\tif ( a.priority < b.priority ) {\n\t\treturn true;\n\t} else if ( a.priority > b.priority ) {\n\t\treturn false;\n\t}\n\n\t// When priorities are equal and names are different - use identities.\n\treturn a.getIdentity() < b.getIdentity();\n}\n\n// Returns new position that is moved to near text node. Returns same position if there is no text node before of after\n// specified position.\n//\n//\t\t<p>foo[]</p>  ->  <p>foo{}</p>\n//\t\t<p>[]foo</p>  ->  <p>{}foo</p>\n//\n// @param {module:engine/view/position~Position} position\n// @returns {module:engine/view/position~Position} Position located inside text node or same position if there is no text nodes\n// before or after position location.\nfunction movePositionToTextNode( position ) {\n\tconst nodeBefore = position.nodeBefore;\n\n\tif ( nodeBefore && nodeBefore.is( 'text' ) ) {\n\t\treturn new Position( nodeBefore, nodeBefore.data.length );\n\t}\n\n\tconst nodeAfter = position.nodeAfter;\n\n\tif ( nodeAfter && nodeAfter.is( 'text' ) ) {\n\t\treturn new Position( nodeAfter, 0 );\n\t}\n\n\treturn position;\n}\n\n// Breaks text node into two text nodes when possible.\n//\n//\t\t<p>foo{}bar</p> -> <p>foo[]bar</p>\n//\t\t<p>{}foobar</p> -> <p>[]foobar</p>\n//\t\t<p>foobar{}</p> -> <p>foobar[]</p>\n//\n// @param {module:engine/view/position~Position} position Position that need to be placed inside text node.\n// @returns {module:engine/view/position~Position} New position after breaking text node.\nfunction breakTextNode( position ) {\n\tif ( position.offset == position.parent.data.length ) {\n\t\treturn new Position( position.parent.parent, position.parent.index + 1 );\n\t}\n\n\tif ( position.offset === 0 ) {\n\t\treturn new Position( position.parent.parent, position.parent.index );\n\t}\n\n\t// Get part of the text that need to be moved.\n\tconst textToMove = position.parent.data.slice( position.offset );\n\n\t// Leave rest of the text in position's parent.\n\tposition.parent._data = position.parent.data.slice( 0, position.offset );\n\n\t// Insert new text node after position's parent text node.\n\tposition.parent.parent._insertChild( position.parent.index + 1, new Text( textToMove ) );\n\n\t// Return new position between two newly created text nodes.\n\treturn new Position( position.parent.parent, position.parent.index + 1 );\n}\n\n// Merges two text nodes into first node. Removes second node and returns merge position.\n//\n// @param {module:engine/view/text~Text} t1 First text node to merge. Data from second text node will be moved at the end of\n// this text node.\n// @param {module:engine/view/text~Text} t2 Second text node to merge. This node will be removed after merging.\n// @returns {module:engine/view/position~Position} Position after merging text nodes.\nfunction mergeTextNodes( t1, t2 ) {\n\t// Merge text data into first text node and remove second one.\n\tconst nodeBeforeLength = t1.data.length;\n\tt1._data += t2.data;\n\tt2._remove();\n\n\treturn new Position( t1, nodeBeforeLength );\n}\n\n// Checks if provided nodes are valid to insert. Checks if each node is an instance of\n// {@link module:engine/view/text~Text Text} or {@link module:engine/view/attributeelement~AttributeElement AttributeElement},\n// {@link module:engine/view/containerelement~ContainerElement ContainerElement},\n// {@link module:engine/view/emptyelement~EmptyElement EmptyElement} or\n// {@link module:engine/view/uielement~UIElement UIElement}.\n//\n// Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-insert-invalid-node` when nodes to insert\n// contains instances that are not {@link module:engine/view/text~Text Texts},\n// {@link module:engine/view/emptyelement~EmptyElement EmptyElements},\n// {@link module:engine/view/uielement~UIElement UIElements},\n// {@link module:engine/view/attributeelement~AttributeElement AttributeElements} or\n// {@link module:engine/view/containerelement~ContainerElement ContainerElements}.\n//\n// @param Iterable.<module:engine/view/text~Text|module:engine/view/attributeelement~AttributeElement\n// |module:engine/view/containerelement~ContainerElement> nodes\n// @param {Object} errorContext\nfunction validateNodesToInsert( nodes, errorContext ) {\n\tfor ( const node of nodes ) {\n\t\tif ( !validNodesToInsert.some( ( validNode => node instanceof validNode ) ) ) { // eslint-disable-line no-use-before-define\n\t\t\t/**\n\t\t\t * Inserted nodes should be valid to insert. of {@link module:engine/view/attributeelement~AttributeElement AttributeElement},\n\t\t\t * {@link module:engine/view/containerelement~ContainerElement ContainerElement},\n\t\t\t * {@link module:engine/view/emptyelement~EmptyElement EmptyElement},\n\t\t\t * {@link module:engine/view/uielement~UIElement UIElement}, {@link module:engine/view/text~Text Text}.\n\t\t\t *\n\t\t\t * @error view-writer-insert-invalid-node\n\t\t\t */\n\t\t\tthrow new CKEditorError( 'view-writer-insert-invalid-node', errorContext );\n\t\t}\n\n\t\tif ( !node.is( 'text' ) ) {\n\t\t\tvalidateNodesToInsert( node.getChildren(), errorContext );\n\t\t}\n\t}\n}\n\nconst validNodesToInsert = [ Text, AttributeElement, ContainerElement, EmptyElement, UIElement ];\n\n// Checks if node is ContainerElement or DocumentFragment, because in most cases they should be treated the same way.\n//\n// @param {module:engine/view/node~Node} node\n// @returns {Boolean} Returns `true` if node is instance of ContainerElement or DocumentFragment.\nfunction isContainerOrFragment( node ) {\n\treturn node && ( node.is( 'containerElement' ) || node.is( 'documentFragment' ) );\n}\n\n// Checks if {@link module:engine/view/range~Range#start range start} and {@link module:engine/view/range~Range#end range end} are placed\n// inside same {@link module:engine/view/containerelement~ContainerElement container element}.\n// Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when validation fails.\n//\n// @param {module:engine/view/range~Range} range\n// @param {Object} errorContext\nfunction validateRangeContainer( range, errorContext ) {\n\tconst startContainer = getParentContainer( range.start );\n\tconst endContainer = getParentContainer( range.end );\n\n\tif ( !startContainer || !endContainer || startContainer !== endContainer ) {\n\t\t/**\n\t\t * Range container is invalid. This can happen if {@link module:engine/view/range~Range#start range start} and\n\t\t * {@link module:engine/view/range~Range#end range end} positions are not placed inside same container or\n\t\t * parent container for these positions cannot be found.\n\t\t *\n\t\t * @error view-writer-invalid-range-container\n\t\t */\n\n\t\tthrow new CKEditorError( 'view-writer-invalid-range-container', errorContext );\n\t}\n}\n\n// Checks if two attribute elements can be joined together. Elements can be joined together if, and only if\n// they do not have ids specified.\n//\n// @private\n// @param {module:engine/view/element~Element} a\n// @param {module:engine/view/element~Element} b\n// @returns {Boolean}\nfunction canBeJoined( a, b ) {\n\treturn a.id === null && b.id === null;\n}\n"]}]}