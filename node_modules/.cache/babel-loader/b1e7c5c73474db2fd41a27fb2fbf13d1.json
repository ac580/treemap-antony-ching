{"remainingRequest":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/babel-loader/lib/index.js!/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-engine/src/conversion/modelconsumable.js","dependencies":[{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-engine/src/conversion/modelconsumable.js","mtime":499162500000},{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js","mtime":499162500000},{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/babel-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:LyoqCiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDE5LCBDS1NvdXJjZSAtIEZyZWRlcmljbyBLbmFiYmVuLiBBbGwgcmlnaHRzIHJlc2VydmVkLgogKiBGb3IgbGljZW5zaW5nLCBzZWUgTElDRU5TRS5tZCBvciBodHRwczovL2NrZWRpdG9yLmNvbS9sZWdhbC9ja2VkaXRvci1vc3MtbGljZW5zZQogKi8KCi8qKgogKiBAbW9kdWxlIGVuZ2luZS9jb252ZXJzaW9uL21vZGVsY29uc3VtYWJsZQogKi8KaW1wb3J0IFRleHRQcm94eSBmcm9tICcuLi9tb2RlbC90ZXh0cHJveHknOwovKioKICogTWFuYWdlcyBhIGxpc3Qgb2YgY29uc3VtYWJsZSB2YWx1ZXMgZm9yIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbSBtb2RlbCBpdGVtc30uCiAqCiAqIENvbnN1bWFibGVzIGFyZSB2YXJpb3VzIGFzcGVjdHMgb2YgdGhlIG1vZGVsLiBBIG1vZGVsIGl0ZW0gY2FuIGJlIGJyb2tlbiBkb3duIGludG8gc2luZ3VsYXIgcHJvcGVydGllcyB0aGF0IG1pZ2h0IGJlCiAqIHRha2VuIGludG8gY29uc2lkZXJhdGlvbiB3aGVuIGNvbnZlcnRpbmcgdGhhdCBpdGVtLgogKgogKiBgTW9kZWxDb25zdW1hYmxlYCBpcyB1c2VkIGJ5IHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vZG93bmNhc3RkaXNwYXRjaGVyfkRvd25jYXN0RGlzcGF0Y2hlcn0gd2hpbGUgYW5hbHl6aW5nIGNoYW5nZWQKICogcGFydHMgb2Yge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvZG9jdW1lbnR+RG9jdW1lbnQgdGhlIGRvY3VtZW50fS4gVGhlIGFkZGVkIC8gY2hhbmdlZCAvIHJlbW92ZWQgbW9kZWwgaXRlbXMgYXJlIGJyb2tlbiBkb3duCiAqIGludG8gc2luZ3VsYXIgcHJvcGVydGllcyAodGhlIGl0ZW0gaXRzZWxmIGFuZCBpdCdzIGF0dHJpYnV0ZXMpLiBBbGwgdGhvc2UgcGFydHMgYXJlIHNhdmVkIGluIGBNb2RlbENvbnN1bWFibGVgLiBUaGVuLAogKiBkdXJpbmcgY29udmVyc2lvbiwgd2hlbiBnaXZlbiBwYXJ0IG9mIG1vZGVsIGl0ZW0gaXMgY29udmVydGVkIChpLmUuIHRoZSB2aWV3IGVsZW1lbnQgaGFzIGJlZW4gaW5zZXJ0ZWQgaW50byB0aGUgdmlldywKICogYnV0IHdpdGhvdXQgYXR0cmlidXRlcyksIGNvbnN1bWFibGUgdmFsdWUgaXMgcmVtb3ZlZCBmcm9tIGBNb2RlbENvbnN1bWFibGVgLgogKgogKiBGb3IgbW9kZWwgaXRlbXMsIGBNb2RlbENvbnN1bWFibGVgIHN0b3JlcyBjb25zdW1hYmxlIHZhbHVlcyBvZiBvbmUgb2YgZm9sbG93aW5nIHR5cGVzOiBgaW5zZXJ0YCwgYGFkZGF0dHJpYnV0ZTo8YXR0cmlidXRlS2V5PmAsCiAqIGBjaGFuZ2VhdHRyaWJ1dGVzOjxhdHRyaWJ1dGVLZXk+YCwgYHJlbW92ZWF0dHJpYnV0ZXM6PGF0dHJpYnV0ZUtleT5gLgogKgogKiBJbiBtb3N0IGNhc2VzLCBpdCBpcyBlbm91Z2ggdG8gbGV0IHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vZG93bmNhc3RkaXNwYXRjaGVyfkRvd25jYXN0RGlzcGF0Y2hlcn0KICogZ2F0aGVyIGNvbnN1bWFibGUgdmFsdWVzLCBzbyB0aGVyZSBpcyBubyBuZWVkIHRvIHVzZQogKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL21vZGVsY29uc3VtYWJsZX5Nb2RlbENvbnN1bWFibGUjYWRkIGFkZCBtZXRob2R9IGRpcmVjdGx5LgogKiBIb3dldmVyLCBpdCBpcyBpbXBvcnRhbnQgdG8gdW5kZXJzdGFuZCBob3cgY29uc3VtYWJsZSB2YWx1ZXMgY2FuIGJlCiAqIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vbW9kZWxjb25zdW1hYmxlfk1vZGVsQ29uc3VtYWJsZSNjb25zdW1lIGNvbnN1bWVkfS4KICogU2VlIHtAbGluayBtb2R1bGU6ZW5naW5lL2NvbnZlcnNpb24vZG93bmNhc3RoZWxwZXJzIGRlZmF1bHQgZG93bmNhc3QgY29udmVydGVyc30gZm9yIG1vcmUgaW5mb3JtYXRpb24uCiAqCiAqIEtlZXAgaW4gbWluZCwgdGhhdCBvbmUgY29udmVyc2lvbiBldmVudCBtYXkgaGF2ZSBtdWx0aXBsZSBjYWxsYmFja3MgKGNvbnZlcnRlcnMpIGF0dGFjaGVkIHRvIGl0LiBFYWNoIG9mIHRob3NlIGlzCiAqIGFibGUgdG8gY29udmVydCBvbmUgb3IgbW9yZSBwYXJ0cyBvZiB0aGUgbW9kZWwuIEhvd2V2ZXIsIHdoZW4gb25lIG9mIHRob3NlIGNhbGxiYWNrcyBhY3R1YWxseSBjb252ZXJ0cwogKiBzb21ldGhpbmcsIG90aGVyIHNob3VsZCBub3QsIGJlY2F1c2UgdGhleSB3b3VsZCBkdXBsaWNhdGUgdGhlIHJlc3VsdHMuIFVzaW5nIGBNb2RlbENvbnN1bWFibGVgIGhlbHBzIGF2b2lkaW5nCiAqIHRoaXMgc2l0dWF0aW9uLCBiZWNhdXNlIGNhbGxiYWNrcyBzaG91bGQgb25seSBjb252ZXJ0IHRob3NlIHZhbHVlcywgd2hpY2ggd2VyZSBub3QgeWV0IGNvbnN1bWVkIGZyb20gYE1vZGVsQ29uc3VtYWJsZWAuCiAqCiAqIENvbnN1bWluZyBtdWx0aXBsZSB2YWx1ZXMgaW4gYSBzaW5nbGUgY2FsbGJhY2s6CiAqCiAqCQkvLyBDb252ZXJ0ZXIgZm9yIGN1c3RvbSBgaW1hZ2VgIGVsZW1lbnQgdGhhdCBtaWdodCBoYXZlIGEgYGNhcHRpb25gIGVsZW1lbnQgaW5zaWRlIHdoaWNoIGNoYW5nZXMKICoJCS8vIGhvdyB0aGUgaW1hZ2UgaXMgZGlzcGxheWVkIGluIHRoZSB2aWV3OgogKgkJLy8KICoJCS8vIE1vZGVsOgogKgkJLy8KICoJCS8vIFtpbWFnZV0KICoJCS8vICAg4pSU4pSAIFtjYXB0aW9uXQogKgkJLy8gICAgICAg4pSU4pSAIGZvbwogKgkJLy8KICoJCS8vIFZpZXc6CiAqCQkvLwogKgkJLy8gPGZpZ3VyZT4KICoJCS8vICAg4pSc4pSAIDxpbWcgLz4KICoJCS8vICAg4pSU4pSAIDxjYXB0aW9uPgogKgkJLy8gICAgICAg4pSU4pSAIGZvbwogKgkJbW9kZWxDb252ZXJzaW9uRGlzcGF0Y2hlci5vbiggJ2luc2VydDppbWFnZScsICggZXZ0LCBkYXRhLCBjb252ZXJzaW9uQXBpICkgPT4gewogKgkJCS8vIEZpcnN0LCBjb25zdW1lIHRoZSBgaW1hZ2VgIGVsZW1lbnQuCiAqCQkJY29udmVyc2lvbkFwaS5jb25zdW1hYmxlLmNvbnN1bWUoIGRhdGEuaXRlbSwgJ2luc2VydCcgKTsKICoKICoJCQkvLyBKdXN0IGNyZWF0ZSBub3JtYWwgaW1hZ2UgZWxlbWVudCBmb3IgdGhlIHZpZXcuCiAqCQkJLy8gTWF5YmUgaXQgd2lsbCBiZSAiZGVjb3JhdGVkIiBsYXRlci4KICoJCQljb25zdCB2aWV3SW1hZ2UgPSBuZXcgVmlld0VsZW1lbnQoICdpbWcnICk7CiAqCQkJY29uc3QgaW5zZXJ0UG9zaXRpb24gPSBjb252ZXJzaW9uQXBpLm1hcHBlci50b1ZpZXdQb3NpdGlvbiggZGF0YS5yYW5nZS5zdGFydCApOwogKgkJCWNvbnN0IHZpZXdXcml0ZXIgPSBjb252ZXJzaW9uQXBpLndyaXRlcjsKICoKICoJCQkvLyBDaGVjayBpZiB0aGUgYGltYWdlYCBlbGVtZW50IGhhcyBjaGlsZHJlbi4KICoJCQlpZiAoIGRhdGEuaXRlbS5jaGlsZENvdW50ID4gMCApIHsKICoJCQkJY29uc3QgbW9kZWxDYXB0aW9uID0gZGF0YS5pdGVtLmdldENoaWxkKCAwICk7CiAqCiAqCQkJCS8vIGBtb2RlbENhcHRpb25gIGluc2VydGlvbiBjaGFuZ2UgaXMgY29uc3VtZWQgZnJvbSBjb25zdW1hYmxlIHZhbHVlcy4KICoJCQkJLy8gSXQgd2lsbCBub3QgYmUgY29udmVydGVkIGJ5IG90aGVyIGNvbnZlcnRlcnMsIGJ1dCBpdCdzIGNoaWxkcmVuIChwcm9iYWJseSBzb21lIHRleHQpIHdpbGwgYmUuCiAqCQkJCS8vIFRocm91Z2ggbWFwcGluZywgY29udmVydGVycyBmb3IgdGV4dCB3aWxsIGtub3cgd2hlcmUgdG8gaW5zZXJ0IGNvbnRlbnRzIG9mIGBtb2RlbENhcHRpb25gLgogKgkJCQlpZiAoIGNvbnZlcnNpb25BcGkuY29uc3VtYWJsZS5jb25zdW1lKCBtb2RlbENhcHRpb24sICdpbnNlcnQnICkgKSB7CiAqCQkJCQljb25zdCB2aWV3Q2FwdGlvbiA9IG5ldyBWaWV3RWxlbWVudCggJ2ZpZ2NhcHRpb24nICk7CiAqCiAqCQkJCQljb25zdCB2aWV3SW1hZ2VIb2xkZXIgPSBuZXcgVmlld0VsZW1lbnQoICdmaWd1cmUnLCBudWxsLCBbIHZpZXdJbWFnZSwgdmlld0NhcHRpb24gXSApOwogKgogKgkJCQkJY29udmVyc2lvbkFwaS5tYXBwZXIuYmluZEVsZW1lbnRzKCBtb2RlbENhcHRpb24sIHZpZXdDYXB0aW9uICk7CiAqCQkJCQljb252ZXJzaW9uQXBpLm1hcHBlci5iaW5kRWxlbWVudHMoIGRhdGEuaXRlbSwgdmlld0ltYWdlSG9sZGVyICk7CiAqCQkJCQl2aWV3V3JpdGVyLmluc2VydCggaW5zZXJ0UG9zaXRpb24sIHZpZXdJbWFnZUhvbGRlciApOwogKgkJCQl9CiAqCQkJfSBlbHNlIHsKICoJCQkJY29udmVyc2lvbkFwaS5tYXBwZXIuYmluZEVsZW1lbnRzKCBkYXRhLml0ZW0sIHZpZXdJbWFnZSApOwogKgkJCQl2aWV3V3JpdGVyLmluc2VydCggaW5zZXJ0UG9zaXRpb24sIHZpZXdJbWFnZSApOwogKgkJCX0KICoKICoJCQlldnQuc3RvcCgpOwogKgkJfSApOwogKi8KCmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1vZGVsQ29uc3VtYWJsZSB7CiAgLyoqCiAgICogQ3JlYXRlcyBhbiBlbXB0eSBjb25zdW1hYmxlcyBsaXN0LgogICAqLwogIGNvbnN0cnVjdG9yKCkgewogICAgLyoqCiAgICAgKiBDb250YWlucyBsaXN0IG9mIGNvbnN1bWFibGUgdmFsdWVzLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAbWVtYmVyIHtNYXB9IG1vZHVsZTplbmdpbmUvY29udmVyc2lvbi9tb2RlbGNvbnN1bWFibGV+TW9kZWxDb25zdW1hYmxlI19jb25zdW1hYmxlCiAgICAgKi8KICAgIHRoaXMuX2NvbnN1bWFibGUgPSBuZXcgTWFwKCk7CiAgICAvKioKICAgICAqIEZvciBlYWNoIHtAbGluayBtb2R1bGU6ZW5naW5lL21vZGVsL3RleHRwcm94eX5UZXh0UHJveHl9IGFkZGVkIHRvIGBNb2RlbENvbnN1bWFibGVgLCB0aGlzIHJlZ2lzdHJ5IGhvbGRzIHBhcmVudAogICAgICogb2YgdGhhdCBgVGV4dFByb3h5YCBhbmQgc3RhcnQgYW5kIGVuZCBpbmRpY2VzIG9mIHRoYXQgYFRleHRQcm94eWAuIFRoaXMgYWxsb3dzIGlkZW50aWZpY2F0aW9uIG9mIGBUZXh0UHJveHlgCiAgICAgKiBpbnN0YW5jZXMgdGhhdCBwb2ludHMgdG8gdGhlIHNhbWUgcGFydCBvZiB0aGUgbW9kZWwgYnV0IGFyZSBkaWZmZXJlbnQgaW5zdGFuY2VzLiBFYWNoIGRpc3RpbmN0IGBUZXh0UHJveHlgCiAgICAgKiBpcyBnaXZlbiB1bmlxdWUgYFN5bWJvbGAgd2hpY2ggaXMgdGhlbiByZWdpc3RlcmVkIGFzIGNvbnN1bWFibGUuIFRoaXMgcHJvY2VzcyBpcyB0cmFuc3BhcmVudCBmb3IgYE1vZGVsQ29uc3VtYWJsZWAKICAgICAqIEFQSSB1c2VyIGJlY2F1c2Ugd2hlbmV2ZXIgYFRleHRQcm94eWAgaXMgYWRkZWQsIHRlc3RlZCwgY29uc3VtZWQgb3IgcmV2ZXJ0ZWQsIGludGVybmFsIG1lY2hhbmlzbXMgb2YKICAgICAqIGBNb2RlbENvbnN1bWFibGVgIHRyYW5zbGF0ZXMgYFRleHRQcm94eWAgdG8gdGhhdCB1bmlxdWUgYFN5bWJvbGAuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEBtZW1iZXIge01hcH0gbW9kdWxlOmVuZ2luZS9jb252ZXJzaW9uL21vZGVsY29uc3VtYWJsZX5Nb2RlbENvbnN1bWFibGUjX3RleHRQcm94eVJlZ2lzdHJ5CiAgICAgKi8KCiAgICB0aGlzLl90ZXh0UHJveHlSZWdpc3RyeSA9IG5ldyBNYXAoKTsKICB9CiAgLyoqCiAgICogQWRkcyBhIGNvbnN1bWFibGUgdmFsdWUgdG8gdGhlIGNvbnN1bWFibGVzIGxpc3QgYW5kIGxpbmtzIGl0IHdpdGggZ2l2ZW4gbW9kZWwgaXRlbS4KICAgKgogICAqCQltb2RlbENvbnN1bWFibGUuYWRkKCBtb2RlbEVsZW1lbnQsICdpbnNlcnQnICk7IC8vIEFkZCBgbW9kZWxFbGVtZW50YCBpbnNlcnRpb24gY2hhbmdlIHRvIGNvbnN1bWFibGUgdmFsdWVzLgogICAqCQltb2RlbENvbnN1bWFibGUuYWRkKCBtb2RlbEVsZW1lbnQsICdhZGRBdHRyaWJ1dGU6Ym9sZCcgKTsgLy8gQWRkIGBib2xkYCBhdHRyaWJ1dGUgaW5zZXJ0aW9uIG9uIGBtb2RlbEVsZW1lbnRgIGNoYW5nZS4KICAgKgkJbW9kZWxDb25zdW1hYmxlLmFkZCggbW9kZWxFbGVtZW50LCAncmVtb3ZlQXR0cmlidXRlOmJvbGQnICk7IC8vIEFkZCBgYm9sZGAgYXR0cmlidXRlIHJlbW92YWwgb24gYG1vZGVsRWxlbWVudGAgY2hhbmdlLgogICAqCQltb2RlbENvbnN1bWFibGUuYWRkKCBtb2RlbFNlbGVjdGlvbiwgJ3NlbGVjdGlvbicgKTsgLy8gQWRkIGBtb2RlbFNlbGVjdGlvbmAgdG8gY29uc3VtYWJsZSB2YWx1ZXMuCiAgICoJCW1vZGVsQ29uc3VtYWJsZS5hZGQoIG1vZGVsUmFuZ2UsICdyYW5nZScgKTsgLy8gQWRkIGBtb2RlbFJhbmdlYCB0byBjb25zdW1hYmxlIHZhbHVlcy4KICAgKgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9pdGVtfkl0ZW18bW9kdWxlOmVuZ2luZS9tb2RlbC9zZWxlY3Rpb25+U2VsZWN0aW9ufG1vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2V9IGl0ZW0KICAgKiBNb2RlbCBpdGVtLCByYW5nZSBvciBzZWxlY3Rpb24gdGhhdCBoYXMgdGhlIGNvbnN1bWFibGUuCiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgQ29uc3VtYWJsZSB0eXBlLiBXaWxsIGJlIG5vcm1hbGl6ZWQgdG8gYSBwcm9wZXIgZm9ybSwgdGhhdCBpcyBlaXRoZXIgYDx3b3JkPmAgb3IgYDxwYXJ0Pjo8cGFydD5gLgogICAqIFNlY29uZCBjb2xvbiBhbmQgZXZlcnl0aGluZyBhZnRlciB3aWxsIGJlIGN1dC4gUGFzc2luZyBldmVudCBuYW1lIGlzIGEgc2FmZSBhbmQgZ29vZCBwcmFjdGljZS4KICAgKi8KCgogIGFkZChpdGVtLCB0eXBlKSB7CiAgICB0eXBlID0gX25vcm1hbGl6ZUNvbnN1bWFibGVUeXBlKHR5cGUpOwoKICAgIGlmIChpdGVtIGluc3RhbmNlb2YgVGV4dFByb3h5KSB7CiAgICAgIGl0ZW0gPSB0aGlzLl9nZXRTeW1ib2xGb3JUZXh0UHJveHkoaXRlbSk7CiAgICB9CgogICAgaWYgKCF0aGlzLl9jb25zdW1hYmxlLmhhcyhpdGVtKSkgewogICAgICB0aGlzLl9jb25zdW1hYmxlLnNldChpdGVtLCBuZXcgTWFwKCkpOwogICAgfQoKICAgIHRoaXMuX2NvbnN1bWFibGUuZ2V0KGl0ZW0pLnNldCh0eXBlLCB0cnVlKTsKICB9CiAgLyoqCiAgICogUmVtb3ZlcyBnaXZlbiBjb25zdW1hYmxlIHZhbHVlIGZyb20gZ2l2ZW4gbW9kZWwgaXRlbS4KICAgKgogICAqCQltb2RlbENvbnN1bWFibGUuY29uc3VtZSggbW9kZWxFbGVtZW50LCAnaW5zZXJ0JyApOyAvLyBSZW1vdmUgYG1vZGVsRWxlbWVudGAgaW5zZXJ0aW9uIGNoYW5nZSBmcm9tIGNvbnN1bWFibGUgdmFsdWVzLgogICAqCQltb2RlbENvbnN1bWFibGUuY29uc3VtZSggbW9kZWxFbGVtZW50LCAnYWRkQXR0cmlidXRlOmJvbGQnICk7IC8vIFJlbW92ZSBgYm9sZGAgYXR0cmlidXRlIGluc2VydGlvbiBvbiBgbW9kZWxFbGVtZW50YCBjaGFuZ2UuCiAgICoJCW1vZGVsQ29uc3VtYWJsZS5jb25zdW1lKCBtb2RlbEVsZW1lbnQsICdyZW1vdmVBdHRyaWJ1dGU6Ym9sZCcgKTsgLy8gUmVtb3ZlIGBib2xkYCBhdHRyaWJ1dGUgcmVtb3ZhbCBvbiBgbW9kZWxFbGVtZW50YCBjaGFuZ2UuCiAgICoJCW1vZGVsQ29uc3VtYWJsZS5jb25zdW1lKCBtb2RlbFNlbGVjdGlvbiwgJ3NlbGVjdGlvbicgKTsgLy8gUmVtb3ZlIGBtb2RlbFNlbGVjdGlvbmAgZnJvbSBjb25zdW1hYmxlIHZhbHVlcy4KICAgKgkJbW9kZWxDb25zdW1hYmxlLmNvbnN1bWUoIG1vZGVsUmFuZ2UsICdyYW5nZScgKTsgLy8gUmVtb3ZlICdtb2RlbFJhbmdlJyBmcm9tIGNvbnN1bWFibGUgdmFsdWVzLgogICAqCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL2l0ZW1+SXRlbXxtb2R1bGU6ZW5naW5lL21vZGVsL3NlbGVjdGlvbn5TZWxlY3Rpb258bW9kdWxlOmVuZ2luZS9tb2RlbC9yYW5nZX5SYW5nZX0gaXRlbQogICAqIE1vZGVsIGl0ZW0sIHJhbmdlIG9yIHNlbGVjdGlvbiBmcm9tIHdoaWNoIGNvbnN1bWFibGUgd2lsbCBiZSBjb25zdW1lZC4KICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBDb25zdW1hYmxlIHR5cGUuIFdpbGwgYmUgbm9ybWFsaXplZCB0byBhIHByb3BlciBmb3JtLCB0aGF0IGlzIGVpdGhlciBgPHdvcmQ+YCBvciBgPHBhcnQ+OjxwYXJ0PmAuCiAgICogU2Vjb25kIGNvbG9uIGFuZCBldmVyeXRoaW5nIGFmdGVyIHdpbGwgYmUgY3V0LiBQYXNzaW5nIGV2ZW50IG5hbWUgaXMgYSBzYWZlIGFuZCBnb29kIHByYWN0aWNlLgogICAqIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgY29uc3VtYWJsZSB2YWx1ZSB3YXMgYXZhaWxhYmxlIGFuZCB3YXMgY29uc3VtZWQsIGBmYWxzZWAgb3RoZXJ3aXNlLgogICAqLwoKCiAgY29uc3VtZShpdGVtLCB0eXBlKSB7CiAgICB0eXBlID0gX25vcm1hbGl6ZUNvbnN1bWFibGVUeXBlKHR5cGUpOwoKICAgIGlmIChpdGVtIGluc3RhbmNlb2YgVGV4dFByb3h5KSB7CiAgICAgIGl0ZW0gPSB0aGlzLl9nZXRTeW1ib2xGb3JUZXh0UHJveHkoaXRlbSk7CiAgICB9CgogICAgaWYgKHRoaXMudGVzdChpdGVtLCB0eXBlKSkgewogICAgICB0aGlzLl9jb25zdW1hYmxlLmdldChpdGVtKS5zZXQodHlwZSwgZmFsc2UpOwoKICAgICAgcmV0dXJuIHRydWU7CiAgICB9IGVsc2UgewogICAgICByZXR1cm4gZmFsc2U7CiAgICB9CiAgfQogIC8qKgogICAqIFRlc3RzIHdoZXRoZXIgdGhlcmUgaXMgYSBjb25zdW1hYmxlIHZhbHVlIG9mIGdpdmVuIHR5cGUgY29ubmVjdGVkIHdpdGggZ2l2ZW4gbW9kZWwgaXRlbS4KICAgKgogICAqCQltb2RlbENvbnN1bWFibGUudGVzdCggbW9kZWxFbGVtZW50LCAnaW5zZXJ0JyApOyAvLyBDaGVjayBmb3IgYG1vZGVsRWxlbWVudGAgaW5zZXJ0aW9uIGNoYW5nZS4KICAgKgkJbW9kZWxDb25zdW1hYmxlLnRlc3QoIG1vZGVsRWxlbWVudCwgJ2FkZEF0dHJpYnV0ZTpib2xkJyApOyAvLyBDaGVjayBmb3IgYGJvbGRgIGF0dHJpYnV0ZSBpbnNlcnRpb24gb24gYG1vZGVsRWxlbWVudGAgY2hhbmdlLgogICAqCQltb2RlbENvbnN1bWFibGUudGVzdCggbW9kZWxFbGVtZW50LCAncmVtb3ZlQXR0cmlidXRlOmJvbGQnICk7IC8vIENoZWNrIGZvciBgYm9sZGAgYXR0cmlidXRlIHJlbW92YWwgb24gYG1vZGVsRWxlbWVudGAgY2hhbmdlLgogICAqCQltb2RlbENvbnN1bWFibGUudGVzdCggbW9kZWxTZWxlY3Rpb24sICdzZWxlY3Rpb24nICk7IC8vIENoZWNrIGlmIGBtb2RlbFNlbGVjdGlvbmAgaXMgY29uc3VtYWJsZS4KICAgKgkJbW9kZWxDb25zdW1hYmxlLnRlc3QoIG1vZGVsUmFuZ2UsICdyYW5nZScgKTsgLy8gQ2hlY2sgaWYgYG1vZGVsUmFuZ2VgIGlzIGNvbnN1bWFibGUuCiAgICoKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvaXRlbX5JdGVtfG1vZHVsZTplbmdpbmUvbW9kZWwvc2VsZWN0aW9uflNlbGVjdGlvbnxtb2R1bGU6ZW5naW5lL21vZGVsL3JhbmdlflJhbmdlfSBpdGVtCiAgICogTW9kZWwgaXRlbSwgcmFuZ2Ugb3Igc2VsZWN0aW9uIHRvIGJlIHRlc3RlZC4KICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBDb25zdW1hYmxlIHR5cGUuIFdpbGwgYmUgbm9ybWFsaXplZCB0byBhIHByb3BlciBmb3JtLCB0aGF0IGlzIGVpdGhlciBgPHdvcmQ+YCBvciBgPHBhcnQ+OjxwYXJ0PmAuCiAgICogU2Vjb25kIGNvbG9uIGFuZCBldmVyeXRoaW5nIGFmdGVyIHdpbGwgYmUgY3V0LiBQYXNzaW5nIGV2ZW50IG5hbWUgaXMgYSBzYWZlIGFuZCBnb29kIHByYWN0aWNlLgogICAqIEByZXR1cm5zIHtudWxsfEJvb2xlYW59IGBudWxsYCBpZiBzdWNoIGNvbnN1bWFibGUgd2FzIG5ldmVyIGFkZGVkLCBgZmFsc2VgIGlmIHRoZSBjb25zdW1hYmxlIHZhbHVlcyB3YXMKICAgKiBhbHJlYWR5IGNvbnN1bWVkIG9yIGB0cnVlYCBpZiBpdCB3YXMgYWRkZWQgYW5kIG5vdCBjb25zdW1lZCB5ZXQuCiAgICovCgoKICB0ZXN0KGl0ZW0sIHR5cGUpIHsKICAgIHR5cGUgPSBfbm9ybWFsaXplQ29uc3VtYWJsZVR5cGUodHlwZSk7CgogICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBUZXh0UHJveHkpIHsKICAgICAgaXRlbSA9IHRoaXMuX2dldFN5bWJvbEZvclRleHRQcm94eShpdGVtKTsKICAgIH0KCiAgICBjb25zdCBpdGVtQ29uc3VtYWJsZXMgPSB0aGlzLl9jb25zdW1hYmxlLmdldChpdGVtKTsKCiAgICBpZiAoaXRlbUNvbnN1bWFibGVzID09PSB1bmRlZmluZWQpIHsKICAgICAgcmV0dXJuIG51bGw7CiAgICB9CgogICAgY29uc3QgdmFsdWUgPSBpdGVtQ29uc3VtYWJsZXMuZ2V0KHR5cGUpOwoKICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7CiAgICAgIHJldHVybiBudWxsOwogICAgfQoKICAgIHJldHVybiB2YWx1ZTsKICB9CiAgLyoqCiAgICogUmV2ZXJ0cyBjb25zdW1pbmcgb2YgY29uc3VtYWJsZSB2YWx1ZS4KICAgKgogICAqCQltb2RlbENvbnN1bWFibGUucmV2ZXJ0KCBtb2RlbEVsZW1lbnQsICdpbnNlcnQnICk7IC8vIFJldmVydCBjb25zdW1pbmcgYG1vZGVsRWxlbWVudGAgaW5zZXJ0aW9uIGNoYW5nZS4KICAgKgkJbW9kZWxDb25zdW1hYmxlLnJldmVydCggbW9kZWxFbGVtZW50LCAnYWRkQXR0cmlidXRlOmJvbGQnICk7IC8vIFJldmVydCBjb25zdW1pbmcgYGJvbGRgIGF0dHJpYnV0ZSBpbnNlcnQgZnJvbSBgbW9kZWxFbGVtZW50YC4KICAgKgkJbW9kZWxDb25zdW1hYmxlLnJldmVydCggbW9kZWxFbGVtZW50LCAncmVtb3ZlQXR0cmlidXRlOmJvbGQnICk7IC8vIFJldmVydCBjb25zdW1pbmcgYGJvbGRgIGF0dHJpYnV0ZSByZW1vdmUgZnJvbSBgbW9kZWxFbGVtZW50YC4KICAgKgkJbW9kZWxDb25zdW1hYmxlLnJldmVydCggbW9kZWxTZWxlY3Rpb24sICdzZWxlY3Rpb24nICk7IC8vIFJldmVydCBjb25zdW1pbmcgYG1vZGVsU2VsZWN0aW9uYC4KICAgKgkJbW9kZWxDb25zdW1hYmxlLnJldmVydCggbW9kZWxSYW5nZSwgJ3JhbmdlJyApOyAvLyBSZXZlcnQgY29uc3VtaW5nIGBtb2RlbFJhbmdlYC4KICAgKgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS9tb2RlbC9pdGVtfkl0ZW18bW9kdWxlOmVuZ2luZS9tb2RlbC9zZWxlY3Rpb25+U2VsZWN0aW9ufG1vZHVsZTplbmdpbmUvbW9kZWwvcmFuZ2V+UmFuZ2V9IGl0ZW0KICAgKiBNb2RlbCBpdGVtLCByYW5nZSBvciBzZWxlY3Rpb24gdG8gYmUgcmV2ZXJ0ZWQuCiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgQ29uc3VtYWJsZSB0eXBlLgogICAqIEByZXR1cm5zIHtudWxsfEJvb2xlYW59IGB0cnVlYCBpZiBjb25zdW1hYmxlIGhhcyBiZWVuIHJldmVyc2VkLCBgZmFsc2VgIG90aGVyd2lzZS4gYG51bGxgIGlmIHRoZSBjb25zdW1hYmxlIGhhcwogICAqIG5ldmVyIGJlZW4gYWRkZWQuCiAgICovCgoKICByZXZlcnQoaXRlbSwgdHlwZSkgewogICAgdHlwZSA9IF9ub3JtYWxpemVDb25zdW1hYmxlVHlwZSh0eXBlKTsKCiAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIFRleHRQcm94eSkgewogICAgICBpdGVtID0gdGhpcy5fZ2V0U3ltYm9sRm9yVGV4dFByb3h5KGl0ZW0pOwogICAgfQoKICAgIGNvbnN0IHRlc3QgPSB0aGlzLnRlc3QoaXRlbSwgdHlwZSk7CgogICAgaWYgKHRlc3QgPT09IGZhbHNlKSB7CiAgICAgIHRoaXMuX2NvbnN1bWFibGUuZ2V0KGl0ZW0pLnNldCh0eXBlLCB0cnVlKTsKCiAgICAgIHJldHVybiB0cnVlOwogICAgfSBlbHNlIGlmICh0ZXN0ID09PSB0cnVlKSB7CiAgICAgIHJldHVybiBmYWxzZTsKICAgIH0KCiAgICByZXR1cm4gbnVsbDsKICB9CiAgLyoqCiAgICogR2V0cyBhIHVuaXF1ZSBzeW1ib2wgZm9yIHBhc3NlZCB7QGxpbmsgbW9kdWxlOmVuZ2luZS9tb2RlbC90ZXh0cHJveHl+VGV4dFByb3h5fSBpbnN0YW5jZS4gQWxsIGBUZXh0UHJveHlgIGluc3RhbmNlcyB0aGF0CiAgICogaGF2ZSBzYW1lIHBhcmVudCwgc2FtZSBzdGFydCBpbmRleCBhbmQgc2FtZSBlbmQgaW5kZXggd2lsbCBnZXQgdGhlIHNhbWUgc3ltYm9sLgogICAqCiAgICogVXNlZCBpbnRlcm5hbGx5IHRvIGNvcnJlY3RseSBjb25zdW1lIGBUZXh0UHJveHlgIGluc3RhbmNlcy4KICAgKgogICAqIEBwcml2YXRlCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL21vZGVsL3RleHRwcm94eX5UZXh0UHJveHl9IHRleHRQcm94eSBgVGV4dFByb3h5YCBpbnN0YW5jZSB0byBnZXQgYSBzeW1ib2wgZm9yLgogICAqIEByZXR1cm5zIHtTeW1ib2x9IFN5bWJvbCByZXByZXNlbnRpbmcgYWxsIGVxdWFsIGluc3RhbmNlcyBvZiBgVGV4dFByb3h5YC4KICAgKi8KCgogIF9nZXRTeW1ib2xGb3JUZXh0UHJveHkodGV4dFByb3h5KSB7CiAgICBsZXQgc3ltYm9sID0gbnVsbDsKCiAgICBjb25zdCBzdGFydE1hcCA9IHRoaXMuX3RleHRQcm94eVJlZ2lzdHJ5LmdldCh0ZXh0UHJveHkuc3RhcnRPZmZzZXQpOwoKICAgIGlmIChzdGFydE1hcCkgewogICAgICBjb25zdCBlbmRNYXAgPSBzdGFydE1hcC5nZXQodGV4dFByb3h5LmVuZE9mZnNldCk7CgogICAgICBpZiAoZW5kTWFwKSB7CiAgICAgICAgc3ltYm9sID0gZW5kTWFwLmdldCh0ZXh0UHJveHkucGFyZW50KTsKICAgICAgfQogICAgfQoKICAgIGlmICghc3ltYm9sKSB7CiAgICAgIHN5bWJvbCA9IHRoaXMuX2FkZFN5bWJvbEZvclRleHRQcm94eSh0ZXh0UHJveHkuc3RhcnRPZmZzZXQsIHRleHRQcm94eS5lbmRPZmZzZXQsIHRleHRQcm94eS5wYXJlbnQpOwogICAgfQoKICAgIHJldHVybiBzeW1ib2w7CiAgfQogIC8qKgogICAqIEFkZHMgYSBzeW1ib2wgZm9yIGdpdmVuIHByb3BlcnRpZXMgdGhhdCBjaGFyYWN0ZXJpemVzIGEge0BsaW5rIG1vZHVsZTplbmdpbmUvbW9kZWwvdGV4dHByb3h5flRleHRQcm94eX0gaW5zdGFuY2UuCiAgICoKICAgKiBVc2VkIGludGVybmFsbHkgdG8gY29ycmVjdGx5IGNvbnN1bWUgYFRleHRQcm94eWAgaW5zdGFuY2VzLgogICAqCiAgICogQHByaXZhdGUKICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRJbmRleCBUZXh0IHByb3h5IHN0YXJ0IGluZGV4IGluIGl0J3MgcGFyZW50LgogICAqIEBwYXJhbSB7TnVtYmVyfSBlbmRJbmRleCBUZXh0IHByb3h5IGVuZCBpbmRleCBpbiBpdCdzIHBhcmVudC4KICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvbW9kZWwvZWxlbWVudH5FbGVtZW50fSBwYXJlbnQgVGV4dCBwcm94eSBwYXJlbnQuCiAgICogQHJldHVybnMge1N5bWJvbH0gU3ltYm9sIGdlbmVyYXRlZCBmb3IgZ2l2ZW4gcHJvcGVydGllcy4KICAgKi8KCgogIF9hZGRTeW1ib2xGb3JUZXh0UHJveHkoc3RhcnQsIGVuZCwgcGFyZW50KSB7CiAgICBjb25zdCBzeW1ib2wgPSBTeW1ib2woJ3RleHRQcm94eVN5bWJvbCcpOwogICAgbGV0IHN0YXJ0TWFwLCBlbmRNYXA7CiAgICBzdGFydE1hcCA9IHRoaXMuX3RleHRQcm94eVJlZ2lzdHJ5LmdldChzdGFydCk7CgogICAgaWYgKCFzdGFydE1hcCkgewogICAgICBzdGFydE1hcCA9IG5ldyBNYXAoKTsKCiAgICAgIHRoaXMuX3RleHRQcm94eVJlZ2lzdHJ5LnNldChzdGFydCwgc3RhcnRNYXApOwogICAgfQoKICAgIGVuZE1hcCA9IHN0YXJ0TWFwLmdldChlbmQpOwoKICAgIGlmICghZW5kTWFwKSB7CiAgICAgIGVuZE1hcCA9IG5ldyBNYXAoKTsKICAgICAgc3RhcnRNYXAuc2V0KGVuZCwgZW5kTWFwKTsKICAgIH0KCiAgICBlbmRNYXAuc2V0KHBhcmVudCwgc3ltYm9sKTsKICAgIHJldHVybiBzeW1ib2w7CiAgfQoKfSAvLyBSZXR1cm5zIGEgbm9ybWFsaXplZCBjb25zdW1hYmxlIHR5cGUgbmFtZSBmcm9tIGdpdmVuIHN0cmluZy4gQSBub3JtYWxpemVkIGNvbnN1bWFibGUgdHlwZSBuYW1lIGlzIGEgc3RyaW5nIHRoYXQgaGFzCi8vIGF0IG1vc3Qgb25lIGNvbG9uLCBmb3IgZXhhbXBsZTogYGluc2VydGAgb3IgYGFkZE1hcmtlcjpoaWdobGlnaHRgLiBJZiBzdHJpbmcgdG8gbm9ybWFsaXplIGhhcyBtb3JlICJwYXJ0cyIgKG1vcmUgY29sb25zKSwKLy8gdGhlIG90aGVyIHBhcnRzIGFyZSBkcm9wcGVkLCBmb3IgZXhhbXBsZTogYGFkZGF0dHJpYnV0ZTpib2xkOiR0ZXh0YCAtPiBgYWRkYXR0cmlidXRlczpib2xkYC4KLy8KLy8gQHBhcmFtIHtTdHJpbmd9IHR5cGUgQ29uc3VtYWJsZSB0eXBlLgovLyBAcmV0dXJucyB7U3RyaW5nfSBOb3JtYWxpemVkIGNvbnN1bWFibGUgdHlwZS4KCmZ1bmN0aW9uIF9ub3JtYWxpemVDb25zdW1hYmxlVHlwZSh0eXBlKSB7CiAgY29uc3QgcGFydHMgPSB0eXBlLnNwbGl0KCc6Jyk7CiAgcmV0dXJuIHBhcnRzLmxlbmd0aCA+IDEgPyBwYXJ0c1swXSArICc6JyArIHBhcnRzWzFdIDogcGFydHNbMF07Cn0="},{"version":3,"sources":["/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-engine/src/conversion/modelconsumable.js"],"names":["TextProxy","ModelConsumable","constructor","_consumable","Map","_textProxyRegistry","add","item","type","_normalizeConsumableType","_getSymbolForTextProxy","has","set","get","consume","test","itemConsumables","undefined","value","revert","textProxy","symbol","startMap","startOffset","endMap","endOffset","parent","_addSymbolForTextProxy","start","end","Symbol","parts","split","length"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/conversion/modelconsumable\n */\n\nimport TextProxy from '../model/textproxy';\n\n/**\n * Manages a list of consumable values for {@link module:engine/model/item~Item model items}.\n *\n * Consumables are various aspects of the model. A model item can be broken down into singular properties that might be\n * taken into consideration when converting that item.\n *\n * `ModelConsumable` is used by {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher} while analyzing changed\n * parts of {@link module:engine/model/document~Document the document}. The added / changed / removed model items are broken down\n * into singular properties (the item itself and it's attributes). All those parts are saved in `ModelConsumable`. Then,\n * during conversion, when given part of model item is converted (i.e. the view element has been inserted into the view,\n * but without attributes), consumable value is removed from `ModelConsumable`.\n *\n * For model items, `ModelConsumable` stores consumable values of one of following types: `insert`, `addattribute:<attributeKey>`,\n * `changeattributes:<attributeKey>`, `removeattributes:<attributeKey>`.\n *\n * In most cases, it is enough to let {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}\n * gather consumable values, so there is no need to use\n * {@link module:engine/conversion/modelconsumable~ModelConsumable#add add method} directly.\n * However, it is important to understand how consumable values can be\n * {@link module:engine/conversion/modelconsumable~ModelConsumable#consume consumed}.\n * See {@link module:engine/conversion/downcasthelpers default downcast converters} for more information.\n *\n * Keep in mind, that one conversion event may have multiple callbacks (converters) attached to it. Each of those is\n * able to convert one or more parts of the model. However, when one of those callbacks actually converts\n * something, other should not, because they would duplicate the results. Using `ModelConsumable` helps avoiding\n * this situation, because callbacks should only convert those values, which were not yet consumed from `ModelConsumable`.\n *\n * Consuming multiple values in a single callback:\n *\n *\t\t// Converter for custom `image` element that might have a `caption` element inside which changes\n *\t\t// how the image is displayed in the view:\n *\t\t//\n *\t\t// Model:\n *\t\t//\n *\t\t// [image]\n *\t\t//   └─ [caption]\n *\t\t//       └─ foo\n *\t\t//\n *\t\t// View:\n *\t\t//\n *\t\t// <figure>\n *\t\t//   ├─ <img />\n *\t\t//   └─ <caption>\n *\t\t//       └─ foo\n *\t\tmodelConversionDispatcher.on( 'insert:image', ( evt, data, conversionApi ) => {\n *\t\t\t// First, consume the `image` element.\n *\t\t\tconversionApi.consumable.consume( data.item, 'insert' );\n *\n *\t\t\t// Just create normal image element for the view.\n *\t\t\t// Maybe it will be \"decorated\" later.\n *\t\t\tconst viewImage = new ViewElement( 'img' );\n *\t\t\tconst insertPosition = conversionApi.mapper.toViewPosition( data.range.start );\n *\t\t\tconst viewWriter = conversionApi.writer;\n *\n *\t\t\t// Check if the `image` element has children.\n *\t\t\tif ( data.item.childCount > 0 ) {\n *\t\t\t\tconst modelCaption = data.item.getChild( 0 );\n *\n *\t\t\t\t// `modelCaption` insertion change is consumed from consumable values.\n *\t\t\t\t// It will not be converted by other converters, but it's children (probably some text) will be.\n *\t\t\t\t// Through mapping, converters for text will know where to insert contents of `modelCaption`.\n *\t\t\t\tif ( conversionApi.consumable.consume( modelCaption, 'insert' ) ) {\n *\t\t\t\t\tconst viewCaption = new ViewElement( 'figcaption' );\n *\n *\t\t\t\t\tconst viewImageHolder = new ViewElement( 'figure', null, [ viewImage, viewCaption ] );\n *\n *\t\t\t\t\tconversionApi.mapper.bindElements( modelCaption, viewCaption );\n *\t\t\t\t\tconversionApi.mapper.bindElements( data.item, viewImageHolder );\n *\t\t\t\t\tviewWriter.insert( insertPosition, viewImageHolder );\n *\t\t\t\t}\n *\t\t\t} else {\n *\t\t\t\tconversionApi.mapper.bindElements( data.item, viewImage );\n *\t\t\t\tviewWriter.insert( insertPosition, viewImage );\n *\t\t\t}\n *\n *\t\t\tevt.stop();\n *\t\t} );\n */\nexport default class ModelConsumable {\n\t/**\n\t * Creates an empty consumables list.\n\t */\n\tconstructor() {\n\t\t/**\n\t\t * Contains list of consumable values.\n\t\t *\n\t\t * @private\n\t\t * @member {Map} module:engine/conversion/modelconsumable~ModelConsumable#_consumable\n\t\t */\n\t\tthis._consumable = new Map();\n\n\t\t/**\n\t\t * For each {@link module:engine/model/textproxy~TextProxy} added to `ModelConsumable`, this registry holds parent\n\t\t * of that `TextProxy` and start and end indices of that `TextProxy`. This allows identification of `TextProxy`\n\t\t * instances that points to the same part of the model but are different instances. Each distinct `TextProxy`\n\t\t * is given unique `Symbol` which is then registered as consumable. This process is transparent for `ModelConsumable`\n\t\t * API user because whenever `TextProxy` is added, tested, consumed or reverted, internal mechanisms of\n\t\t * `ModelConsumable` translates `TextProxy` to that unique `Symbol`.\n\t\t *\n\t\t * @private\n\t\t * @member {Map} module:engine/conversion/modelconsumable~ModelConsumable#_textProxyRegistry\n\t\t */\n\t\tthis._textProxyRegistry = new Map();\n\t}\n\n\t/**\n\t * Adds a consumable value to the consumables list and links it with given model item.\n\t *\n\t *\t\tmodelConsumable.add( modelElement, 'insert' ); // Add `modelElement` insertion change to consumable values.\n\t *\t\tmodelConsumable.add( modelElement, 'addAttribute:bold' ); // Add `bold` attribute insertion on `modelElement` change.\n\t *\t\tmodelConsumable.add( modelElement, 'removeAttribute:bold' ); // Add `bold` attribute removal on `modelElement` change.\n\t *\t\tmodelConsumable.add( modelSelection, 'selection' ); // Add `modelSelection` to consumable values.\n\t *\t\tmodelConsumable.add( modelRange, 'range' ); // Add `modelRange` to consumable values.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/selection~Selection|module:engine/model/range~Range} item\n\t * Model item, range or selection that has the consumable.\n\t * @param {String} type Consumable type. Will be normalized to a proper form, that is either `<word>` or `<part>:<part>`.\n\t * Second colon and everything after will be cut. Passing event name is a safe and good practice.\n\t */\n\tadd( item, type ) {\n\t\ttype = _normalizeConsumableType( type );\n\n\t\tif ( item instanceof TextProxy ) {\n\t\t\titem = this._getSymbolForTextProxy( item );\n\t\t}\n\n\t\tif ( !this._consumable.has( item ) ) {\n\t\t\tthis._consumable.set( item, new Map() );\n\t\t}\n\n\t\tthis._consumable.get( item ).set( type, true );\n\t}\n\n\t/**\n\t * Removes given consumable value from given model item.\n\t *\n\t *\t\tmodelConsumable.consume( modelElement, 'insert' ); // Remove `modelElement` insertion change from consumable values.\n\t *\t\tmodelConsumable.consume( modelElement, 'addAttribute:bold' ); // Remove `bold` attribute insertion on `modelElement` change.\n\t *\t\tmodelConsumable.consume( modelElement, 'removeAttribute:bold' ); // Remove `bold` attribute removal on `modelElement` change.\n\t *\t\tmodelConsumable.consume( modelSelection, 'selection' ); // Remove `modelSelection` from consumable values.\n\t *\t\tmodelConsumable.consume( modelRange, 'range' ); // Remove 'modelRange' from consumable values.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/selection~Selection|module:engine/model/range~Range} item\n\t * Model item, range or selection from which consumable will be consumed.\n\t * @param {String} type Consumable type. Will be normalized to a proper form, that is either `<word>` or `<part>:<part>`.\n\t * Second colon and everything after will be cut. Passing event name is a safe and good practice.\n\t * @returns {Boolean} `true` if consumable value was available and was consumed, `false` otherwise.\n\t */\n\tconsume( item, type ) {\n\t\ttype = _normalizeConsumableType( type );\n\n\t\tif ( item instanceof TextProxy ) {\n\t\t\titem = this._getSymbolForTextProxy( item );\n\t\t}\n\n\t\tif ( this.test( item, type ) ) {\n\t\t\tthis._consumable.get( item ).set( type, false );\n\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Tests whether there is a consumable value of given type connected with given model item.\n\t *\n\t *\t\tmodelConsumable.test( modelElement, 'insert' ); // Check for `modelElement` insertion change.\n\t *\t\tmodelConsumable.test( modelElement, 'addAttribute:bold' ); // Check for `bold` attribute insertion on `modelElement` change.\n\t *\t\tmodelConsumable.test( modelElement, 'removeAttribute:bold' ); // Check for `bold` attribute removal on `modelElement` change.\n\t *\t\tmodelConsumable.test( modelSelection, 'selection' ); // Check if `modelSelection` is consumable.\n\t *\t\tmodelConsumable.test( modelRange, 'range' ); // Check if `modelRange` is consumable.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/selection~Selection|module:engine/model/range~Range} item\n\t * Model item, range or selection to be tested.\n\t * @param {String} type Consumable type. Will be normalized to a proper form, that is either `<word>` or `<part>:<part>`.\n\t * Second colon and everything after will be cut. Passing event name is a safe and good practice.\n\t * @returns {null|Boolean} `null` if such consumable was never added, `false` if the consumable values was\n\t * already consumed or `true` if it was added and not consumed yet.\n\t */\n\ttest( item, type ) {\n\t\ttype = _normalizeConsumableType( type );\n\n\t\tif ( item instanceof TextProxy ) {\n\t\t\titem = this._getSymbolForTextProxy( item );\n\t\t}\n\n\t\tconst itemConsumables = this._consumable.get( item );\n\n\t\tif ( itemConsumables === undefined ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst value = itemConsumables.get( type );\n\n\t\tif ( value === undefined ) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn value;\n\t}\n\n\t/**\n\t * Reverts consuming of consumable value.\n\t *\n\t *\t\tmodelConsumable.revert( modelElement, 'insert' ); // Revert consuming `modelElement` insertion change.\n\t *\t\tmodelConsumable.revert( modelElement, 'addAttribute:bold' ); // Revert consuming `bold` attribute insert from `modelElement`.\n\t *\t\tmodelConsumable.revert( modelElement, 'removeAttribute:bold' ); // Revert consuming `bold` attribute remove from `modelElement`.\n\t *\t\tmodelConsumable.revert( modelSelection, 'selection' ); // Revert consuming `modelSelection`.\n\t *\t\tmodelConsumable.revert( modelRange, 'range' ); // Revert consuming `modelRange`.\n\t *\n\t * @param {module:engine/model/item~Item|module:engine/model/selection~Selection|module:engine/model/range~Range} item\n\t * Model item, range or selection to be reverted.\n\t * @param {String} type Consumable type.\n\t * @returns {null|Boolean} `true` if consumable has been reversed, `false` otherwise. `null` if the consumable has\n\t * never been added.\n\t */\n\trevert( item, type ) {\n\t\ttype = _normalizeConsumableType( type );\n\n\t\tif ( item instanceof TextProxy ) {\n\t\t\titem = this._getSymbolForTextProxy( item );\n\t\t}\n\n\t\tconst test = this.test( item, type );\n\n\t\tif ( test === false ) {\n\t\t\tthis._consumable.get( item ).set( type, true );\n\n\t\t\treturn true;\n\t\t} else if ( test === true ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Gets a unique symbol for passed {@link module:engine/model/textproxy~TextProxy} instance. All `TextProxy` instances that\n\t * have same parent, same start index and same end index will get the same symbol.\n\t *\n\t * Used internally to correctly consume `TextProxy` instances.\n\t *\n\t * @private\n\t * @param {module:engine/model/textproxy~TextProxy} textProxy `TextProxy` instance to get a symbol for.\n\t * @returns {Symbol} Symbol representing all equal instances of `TextProxy`.\n\t */\n\t_getSymbolForTextProxy( textProxy ) {\n\t\tlet symbol = null;\n\n\t\tconst startMap = this._textProxyRegistry.get( textProxy.startOffset );\n\n\t\tif ( startMap ) {\n\t\t\tconst endMap = startMap.get( textProxy.endOffset );\n\n\t\t\tif ( endMap ) {\n\t\t\t\tsymbol = endMap.get( textProxy.parent );\n\t\t\t}\n\t\t}\n\n\t\tif ( !symbol ) {\n\t\t\tsymbol = this._addSymbolForTextProxy( textProxy.startOffset, textProxy.endOffset, textProxy.parent );\n\t\t}\n\n\t\treturn symbol;\n\t}\n\n\t/**\n\t * Adds a symbol for given properties that characterizes a {@link module:engine/model/textproxy~TextProxy} instance.\n\t *\n\t * Used internally to correctly consume `TextProxy` instances.\n\t *\n\t * @private\n\t * @param {Number} startIndex Text proxy start index in it's parent.\n\t * @param {Number} endIndex Text proxy end index in it's parent.\n\t * @param {module:engine/model/element~Element} parent Text proxy parent.\n\t * @returns {Symbol} Symbol generated for given properties.\n\t */\n\t_addSymbolForTextProxy( start, end, parent ) {\n\t\tconst symbol = Symbol( 'textProxySymbol' );\n\t\tlet startMap, endMap;\n\n\t\tstartMap = this._textProxyRegistry.get( start );\n\n\t\tif ( !startMap ) {\n\t\t\tstartMap = new Map();\n\t\t\tthis._textProxyRegistry.set( start, startMap );\n\t\t}\n\n\t\tendMap = startMap.get( end );\n\n\t\tif ( !endMap ) {\n\t\t\tendMap = new Map();\n\t\t\tstartMap.set( end, endMap );\n\t\t}\n\n\t\tendMap.set( parent, symbol );\n\n\t\treturn symbol;\n\t}\n}\n\n// Returns a normalized consumable type name from given string. A normalized consumable type name is a string that has\n// at most one colon, for example: `insert` or `addMarker:highlight`. If string to normalize has more \"parts\" (more colons),\n// the other parts are dropped, for example: `addattribute:bold:$text` -> `addattributes:bold`.\n//\n// @param {String} type Consumable type.\n// @returns {String} Normalized consumable type.\nfunction _normalizeConsumableType( type ) {\n\tconst parts = type.split( ':' );\n\n\treturn parts.length > 1 ? parts[ 0 ] + ':' + parts[ 1 ] : parts[ 0 ];\n}\n"]}]}