{"remainingRequest":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/babel-loader/lib/index.js!/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-engine/src/view/domconverter.js","dependencies":[{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-engine/src/view/domconverter.js","mtime":499162500000},{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-dev-webpack-plugin/lib/translatesourceloader.js","mtime":499162500000},{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/antonyching/Desktop/project/new-builder-demo/node_modules/babel-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:LyoqCiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDE5LCBDS1NvdXJjZSAtIEZyZWRlcmljbyBLbmFiYmVuLiBBbGwgcmlnaHRzIHJlc2VydmVkLgogKiBGb3IgbGljZW5zaW5nLCBzZWUgTElDRU5TRS5tZCBvciBodHRwczovL2NrZWRpdG9yLmNvbS9sZWdhbC9ja2VkaXRvci1vc3MtbGljZW5zZQogKi8KCi8qKgogKiBAbW9kdWxlIGVuZ2luZS92aWV3L2RvbWNvbnZlcnRlcgogKi8KCi8qIGdsb2JhbHMgZG9jdW1lbnQsIE5vZGUsIE5vZGVGaWx0ZXIsIFRleHQgKi8KaW1wb3J0IFZpZXdUZXh0IGZyb20gJy4vdGV4dCc7CmltcG9ydCBWaWV3RWxlbWVudCBmcm9tICcuL2VsZW1lbnQnOwppbXBvcnQgVmlld1Bvc2l0aW9uIGZyb20gJy4vcG9zaXRpb24nOwppbXBvcnQgVmlld1JhbmdlIGZyb20gJy4vcmFuZ2UnOwppbXBvcnQgVmlld1NlbGVjdGlvbiBmcm9tICcuL3NlbGVjdGlvbic7CmltcG9ydCBWaWV3RG9jdW1lbnRGcmFnbWVudCBmcm9tICcuL2RvY3VtZW50ZnJhZ21lbnQnOwppbXBvcnQgVmlld1RyZWVXYWxrZXIgZnJvbSAnLi90cmVld2Fsa2VyJzsKaW1wb3J0IHsgQlJfRklMTEVSLCBnZXREYXRhV2l0aG91dEZpbGxlciwgSU5MSU5FX0ZJTExFUl9MRU5HVEgsIGlzSW5saW5lRmlsbGVyLCBOQlNQX0ZJTExFUiwgc3RhcnRzV2l0aEZpbGxlciB9IGZyb20gJy4vZmlsbGVyJzsKaW1wb3J0IGdsb2JhbCBmcm9tICdAY2tlZGl0b3IvY2tlZGl0b3I1LXV0aWxzL3NyYy9kb20vZ2xvYmFsJzsKaW1wb3J0IGluZGV4T2YgZnJvbSAnQGNrZWRpdG9yL2NrZWRpdG9yNS11dGlscy9zcmMvZG9tL2luZGV4b2YnOwppbXBvcnQgZ2V0QW5jZXN0b3JzIGZyb20gJ0Bja2VkaXRvci9ja2VkaXRvcjUtdXRpbHMvc3JjL2RvbS9nZXRhbmNlc3RvcnMnOwppbXBvcnQgZ2V0Q29tbW9uQW5jZXN0b3IgZnJvbSAnQGNrZWRpdG9yL2NrZWRpdG9yNS11dGlscy9zcmMvZG9tL2dldGNvbW1vbmFuY2VzdG9yJzsKaW1wb3J0IGlzVGV4dCBmcm9tICdAY2tlZGl0b3IvY2tlZGl0b3I1LXV0aWxzL3NyYy9kb20vaXN0ZXh0JzsKaW1wb3J0IHsgaXNFbGVtZW50IH0gZnJvbSAnbG9kYXNoLWVzJzsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5ldy1jYXAKCmNvbnN0IEJSX0ZJTExFUl9SRUYgPSBCUl9GSUxMRVIoZG9jdW1lbnQpOwovKioKICogRG9tQ29udmVydGVyIGlzIGEgc2V0IG9mIHRvb2xzIHRvIGRvIHRyYW5zZm9ybWF0aW9ucyBiZXR3ZWVuIERPTSBub2RlcyBhbmQgdmlldyBub2Rlcy4gSXQgYWxzbyBoYW5kbGVzCiAqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZG9tY29udmVydGVyfkRvbUNvbnZlcnRlciNiaW5kRWxlbWVudHMgYmluZGluZ30gdGhlc2Ugbm9kZXMuCiAqCiAqIFRoZSBpbnN0YW5jZSBvZiBET01Db252ZXJ0ZXIgaXMgYXZhaWxhYmxlIGluIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdmlld35WaWV3I2RvbUNvbnZlcnRlciBgZWRpdG9yLmVkaXRpbmcudmlldy5kb21Db252ZXJ0ZXJgfS4KICoKICogRG9tQ29udmVydGVyIGRvZXMgbm90IGNoZWNrIHdoaWNoIG5vZGVzIHNob3VsZCBiZSByZW5kZXJlZCAodXNlIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvcmVuZGVyZXJ+UmVuZGVyZXJ9KSwgZG9lcyBub3Qga2VlcCBhCiAqIHN0YXRlIG9mIGEgdHJlZSBub3Iga2VlcHMgc3luY2hyb25pemF0aW9uIGJldHdlZW4gdHJlZSB2aWV3IGFuZCBET00gdHJlZSAodXNlIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZG9jdW1lbnR+RG9jdW1lbnR9KS4KICoKICogRG9tQ29udmVydGVyIGtlZXBzIERPTSBlbGVtZW50cyB0byBWaWV3IGVsZW1lbnQgYmluZGluZ3MsIHNvIHdoZW4gdGhlIGNvbnZlcnRlciB3aWxsIGJlIGRlc3Ryb3llZCwgdGhlIGJpbmRpbmcgd2lsbAogKiBiZSBsb3N0LiBUd28gY29udmVydGVycyB3aWxsIGtlZXAgc2VwYXJhdGUgYmluZGluZyBtYXBzLCBzbyBvbmUgdHJlZSB2aWV3IGNhbiBiZSBib3VuZCB3aXRoIHR3byBET00gdHJlZXMuCiAqLwoKZXhwb3J0IGRlZmF1bHQgY2xhc3MgRG9tQ29udmVydGVyIHsKICAvKioKICAgKiBDcmVhdGVzIERPTSBjb252ZXJ0ZXIuCiAgICoKICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPYmplY3Qgd2l0aCBjb25maWd1cmF0aW9uIG9wdGlvbnMuCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvZmlsbGVyfkJsb2NrRmlsbGVyTW9kZX0gW29wdGlvbnMuYmxvY2tGaWxsZXJNb2RlPSdiciddIFRoZSB0eXBlIG9mIHRoZSBibG9jayBmaWxsZXIgdG8gdXNlLgogICAqLwogIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkgewogICAgLyoqCiAgICAgKiBUaGUgbW9kZSBvZiBhIGJsb2NrIGZpbGxlciB1c2VkIGJ5IERPTSBjb252ZXJ0ZXIuCiAgICAgKgogICAgICogQHJlYWRvbmx5CiAgICAgKiBAbWVtYmVyIHsnYnInfCduYnNwJ30gbW9kdWxlOmVuZ2luZS92aWV3L2RvbWNvbnZlcnRlcn5Eb21Db252ZXJ0ZXIjYmxvY2tGaWxsZXJNb2RlCiAgICAgKi8KICAgIHRoaXMuYmxvY2tGaWxsZXJNb2RlID0gb3B0aW9ucy5ibG9ja0ZpbGxlck1vZGUgfHwgJ2JyJzsKICAgIC8qKgogICAgICogRWxlbWVudHMgd2hpY2ggYXJlIGNvbnNpZGVyZWQgcHJlLWZvcm1hdHRlZCBlbGVtZW50cy4KICAgICAqCiAgICAgKiBAcmVhZG9ubHkKICAgICAqIEBtZW1iZXIge0FycmF5LjxTdHJpbmc+fSBtb2R1bGU6ZW5naW5lL3ZpZXcvZG9tY29udmVydGVyfkRvbUNvbnZlcnRlciNwcmVFbGVtZW50cwogICAgICovCgogICAgdGhpcy5wcmVFbGVtZW50cyA9IFsncHJlJ107CiAgICAvKioKICAgICAqIEVsZW1lbnRzIHdoaWNoIGFyZSBjb25zaWRlcmVkIGJsb2NrIGVsZW1lbnRzIChhbmQgaGVuY2Ugc2hvdWxkIGJlIGZpbGxlZCB3aXRoIGEKICAgICAqIHtAbGluayAjaXNCbG9ja0ZpbGxlciBibG9jayBmaWxsZXJ9KS4KICAgICAqCiAgICAgKiBXaGV0aGVyIGFuIGVsZW1lbnQgaXMgY29uc2lkZXJlZCBhIGJsb2NrIGVsZW1lbnQgYWxzbyBhZmZlY3RzIGhhbmRsaW5nIG9mIHRyYWlsaW5nIHdoaXRlc3BhY2VzLgogICAgICoKICAgICAqIFlvdSBjYW4gZXh0ZW5kIHRoaXMgYXJyYXkgaWYgeW91IGludHJvZHVjZSBzdXBwb3J0IGZvciBibG9jayBlbGVtZW50cyB3aGljaCBhcmUgbm90IHlldCByZWNvZ25pemVkIGhlcmUuCiAgICAgKgogICAgICogQHJlYWRvbmx5CiAgICAgKiBAbWVtYmVyIHtBcnJheS48U3RyaW5nPn0gbW9kdWxlOmVuZ2luZS92aWV3L2RvbWNvbnZlcnRlcn5Eb21Db252ZXJ0ZXIjYmxvY2tFbGVtZW50cwogICAgICovCgogICAgdGhpcy5ibG9ja0VsZW1lbnRzID0gWydwJywgJ2RpdicsICdoMScsICdoMicsICdoMycsICdoNCcsICdoNScsICdoNicsICdsaScsICdkZCcsICdkdCcsICdmaWdjYXB0aW9uJ107CiAgICAvKioKICAgICAqIEJsb2NrIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZmlsbGVyIGZpbGxlcn0gY3JlYXRvciwgd2hpY2ggaXMgdXNlZCB0byBjcmVhdGUgYWxsIGJsb2NrIGZpbGxlcnMgZHVyaW5nIHRoZQogICAgICogdmlldyB0byBET00gY29udmVyc2lvbiBhbmQgdG8gcmVjb2duaXplIGJsb2NrIGZpbGxlcnMgZHVyaW5nIHRoZSBET00gdG8gdmlldyBjb252ZXJzaW9uLgogICAgICoKICAgICAqIEByZWFkb25seQogICAgICogQHByaXZhdGUKICAgICAqIEBtZW1iZXIge0Z1bmN0aW9ufSBtb2R1bGU6ZW5naW5lL3ZpZXcvZG9tY29udmVydGVyfkRvbUNvbnZlcnRlciNfYmxvY2tGaWxsZXIKICAgICAqLwoKICAgIHRoaXMuX2Jsb2NrRmlsbGVyID0gdGhpcy5ibG9ja0ZpbGxlck1vZGUgPT0gJ2JyJyA/IEJSX0ZJTExFUiA6IE5CU1BfRklMTEVSOwogICAgLyoqCiAgICAgKiBET00gdG8gVmlldyBtYXBwaW5nLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAbWVtYmVyIHtXZWFrTWFwfSBtb2R1bGU6ZW5naW5lL3ZpZXcvZG9tY29udmVydGVyfkRvbUNvbnZlcnRlciNfZG9tVG9WaWV3TWFwcGluZwogICAgICovCgogICAgdGhpcy5fZG9tVG9WaWV3TWFwcGluZyA9IG5ldyBXZWFrTWFwKCk7CiAgICAvKioKICAgICAqIFZpZXcgdG8gRE9NIG1hcHBpbmcuCiAgICAgKgogICAgICogQHByaXZhdGUKICAgICAqIEBtZW1iZXIge1dlYWtNYXB9IG1vZHVsZTplbmdpbmUvdmlldy9kb21jb252ZXJ0ZXJ+RG9tQ29udmVydGVyI192aWV3VG9Eb21NYXBwaW5nCiAgICAgKi8KCiAgICB0aGlzLl92aWV3VG9Eb21NYXBwaW5nID0gbmV3IFdlYWtNYXAoKTsKICAgIC8qKgogICAgICogSG9sZHMgbWFwcGluZyBiZXR3ZWVuIGZha2Ugc2VsZWN0aW9uIGNvbnRhaW5lcnMgYW5kIGNvcnJlc3BvbmRpbmcgdmlldyBzZWxlY3Rpb25zLgogICAgICoKICAgICAqIEBwcml2YXRlCiAgICAgKiBAbWVtYmVyIHtXZWFrTWFwfSBtb2R1bGU6ZW5naW5lL3ZpZXcvZG9tY29udmVydGVyfkRvbUNvbnZlcnRlciNfZmFrZVNlbGVjdGlvbk1hcHBpbmcKICAgICAqLwoKICAgIHRoaXMuX2Zha2VTZWxlY3Rpb25NYXBwaW5nID0gbmV3IFdlYWtNYXAoKTsKICB9CiAgLyoqCiAgICogQmluZHMgZ2l2ZW4gRE9NIGVsZW1lbnQgdGhhdCByZXByZXNlbnRzIGZha2Ugc2VsZWN0aW9uIHRvIGEgKipwb3NpdGlvbioqIG9mIGEKICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2RvY3VtZW50c2VsZWN0aW9ufkRvY3VtZW50U2VsZWN0aW9uIGRvY3VtZW50IHNlbGVjdGlvbn0uCiAgICogRG9jdW1lbnQgc2VsZWN0aW9uIGNvcHkgaXMgc3RvcmVkIGFuZCBjYW4gYmUgcmV0cmlldmVkIGJ5CiAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9kb21jb252ZXJ0ZXJ+RG9tQ29udmVydGVyI2Zha2VTZWxlY3Rpb25Ub1ZpZXd9IG1ldGhvZC4KICAgKgogICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRvbUVsZW1lbnQKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9kb2N1bWVudHNlbGVjdGlvbn5Eb2N1bWVudFNlbGVjdGlvbn0gdmlld0RvY3VtZW50U2VsZWN0aW9uCiAgICovCgoKICBiaW5kRmFrZVNlbGVjdGlvbihkb21FbGVtZW50LCB2aWV3RG9jdW1lbnRTZWxlY3Rpb24pIHsKICAgIHRoaXMuX2Zha2VTZWxlY3Rpb25NYXBwaW5nLnNldChkb21FbGVtZW50LCBuZXcgVmlld1NlbGVjdGlvbih2aWV3RG9jdW1lbnRTZWxlY3Rpb24pKTsKICB9CiAgLyoqCiAgICogUmV0dXJucyB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3NlbGVjdGlvbn5TZWxlY3Rpb24gdmlldyBzZWxlY3Rpb259IGluc3RhbmNlIGNvcnJlc3BvbmRpbmcgdG8KICAgKiBnaXZlbiBET00gZWxlbWVudCB0aGF0IHJlcHJlc2VudHMgZmFrZSBzZWxlY3Rpb24uIFJldHVybnMgYHVuZGVmaW5lZGAgaWYgYmluZGluZyB0byBnaXZlbiBET00gZWxlbWVudCBkb2VzIG5vdCBleGlzdHMuCiAgICoKICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBkb21FbGVtZW50CiAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy9zZWxlY3Rpb25+U2VsZWN0aW9ufHVuZGVmaW5lZH0KICAgKi8KCgogIGZha2VTZWxlY3Rpb25Ub1ZpZXcoZG9tRWxlbWVudCkgewogICAgcmV0dXJuIHRoaXMuX2Zha2VTZWxlY3Rpb25NYXBwaW5nLmdldChkb21FbGVtZW50KTsKICB9CiAgLyoqCiAgICogQmluZHMgRE9NIGFuZCBWaWV3IGVsZW1lbnRzLCBzbyBpdCB3aWxsIGJlIHBvc3NpYmxlIHRvIGdldCBjb3JyZXNwb25kaW5nIGVsZW1lbnRzIHVzaW5nCiAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9kb21jb252ZXJ0ZXJ+RG9tQ29udmVydGVyI21hcERvbVRvVmlld30gYW5kCiAgICoge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9kb21jb252ZXJ0ZXJ+RG9tQ29udmVydGVyI21hcFZpZXdUb0RvbX0uCiAgICoKICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBkb21FbGVtZW50IERPTSBlbGVtZW50IHRvIGJpbmQuCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50fSB2aWV3RWxlbWVudCBWaWV3IGVsZW1lbnQgdG8gYmluZC4KICAgKi8KCgogIGJpbmRFbGVtZW50cyhkb21FbGVtZW50LCB2aWV3RWxlbWVudCkgewogICAgdGhpcy5fZG9tVG9WaWV3TWFwcGluZy5zZXQoZG9tRWxlbWVudCwgdmlld0VsZW1lbnQpOwoKICAgIHRoaXMuX3ZpZXdUb0RvbU1hcHBpbmcuc2V0KHZpZXdFbGVtZW50LCBkb21FbGVtZW50KTsKICB9CiAgLyoqCiAgICogVW5iaW5kcyBnaXZlbiBgZG9tRWxlbWVudGAgZnJvbSB0aGUgdmlldyBlbGVtZW50IGl0IHdhcyBib3VuZCB0by4gVW5iaW5kaW5nIGlzIGRlZXAsIG1lYW5pbmcgdGhhdCBhbGwgY2hpbGRyZW4gb2YKICAgKiBgZG9tRWxlbWVudGAgd2lsbCBiZSB1bmJvdW5kIHRvby4KICAgKgogICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRvbUVsZW1lbnQgRE9NIGVsZW1lbnQgdG8gdW5iaW5kLgogICAqLwoKCiAgdW5iaW5kRG9tRWxlbWVudChkb21FbGVtZW50KSB7CiAgICBjb25zdCB2aWV3RWxlbWVudCA9IHRoaXMuX2RvbVRvVmlld01hcHBpbmcuZ2V0KGRvbUVsZW1lbnQpOwoKICAgIGlmICh2aWV3RWxlbWVudCkgewogICAgICB0aGlzLl9kb21Ub1ZpZXdNYXBwaW5nLmRlbGV0ZShkb21FbGVtZW50KTsKCiAgICAgIHRoaXMuX3ZpZXdUb0RvbU1hcHBpbmcuZGVsZXRlKHZpZXdFbGVtZW50KTsgLy8gVXNlIEFycmF5LmZyb20gYmVjYXVzZSBvZiBNUyBFZGdlICgjOTIzKS4KCgogICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIEFycmF5LmZyb20oZG9tRWxlbWVudC5jaGlsZE5vZGVzKSkgewogICAgICAgIHRoaXMudW5iaW5kRG9tRWxlbWVudChjaGlsZCk7CiAgICAgIH0KICAgIH0KICB9CiAgLyoqCiAgICogQmluZHMgRE9NIGFuZCBWaWV3IGRvY3VtZW50IGZyYWdtZW50cywgc28gaXQgd2lsbCBiZSBwb3NzaWJsZSB0byBnZXQgY29ycmVzcG9uZGluZyBkb2N1bWVudCBmcmFnbWVudHMgdXNpbmcKICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2RvbWNvbnZlcnRlcn5Eb21Db252ZXJ0ZXIjbWFwRG9tVG9WaWV3fSBhbmQKICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2RvbWNvbnZlcnRlcn5Eb21Db252ZXJ0ZXIjbWFwVmlld1RvRG9tfS4KICAgKgogICAqIEBwYXJhbSB7RG9jdW1lbnRGcmFnbWVudH0gZG9tRnJhZ21lbnQgRE9NIGRvY3VtZW50IGZyYWdtZW50IHRvIGJpbmQuCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50fSB2aWV3RnJhZ21lbnQgVmlldyBkb2N1bWVudCBmcmFnbWVudCB0byBiaW5kLgogICAqLwoKCiAgYmluZERvY3VtZW50RnJhZ21lbnRzKGRvbUZyYWdtZW50LCB2aWV3RnJhZ21lbnQpIHsKICAgIHRoaXMuX2RvbVRvVmlld01hcHBpbmcuc2V0KGRvbUZyYWdtZW50LCB2aWV3RnJhZ21lbnQpOwoKICAgIHRoaXMuX3ZpZXdUb0RvbU1hcHBpbmcuc2V0KHZpZXdGcmFnbWVudCwgZG9tRnJhZ21lbnQpOwogIH0KICAvKioKICAgKiBDb252ZXJ0cyB2aWV3IHRvIERPTS4gRm9yIGFsbCB0ZXh0IG5vZGVzLCBub3QgYm91bmQgZWxlbWVudHMgYW5kIGRvY3VtZW50IGZyYWdtZW50cyBuZXcgaXRlbXMgd2lsbAogICAqIGJlIGNyZWF0ZWQuIEZvciBib3VuZCBlbGVtZW50cyBhbmQgZG9jdW1lbnQgZnJhZ21lbnRzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIGNvcnJlc3BvbmRpbmcgaXRlbXMuCiAgICoKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9ub2Rlfk5vZGV8bW9kdWxlOmVuZ2luZS92aWV3L2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudH0gdmlld05vZGUKICAgKiBWaWV3IG5vZGUgb3IgZG9jdW1lbnQgZnJhZ21lbnQgdG8gdHJhbnNmb3JtLgogICAqIEBwYXJhbSB7RG9jdW1lbnR9IGRvbURvY3VtZW50IERvY3VtZW50IHdoaWNoIHdpbGwgYmUgdXNlZCB0byBjcmVhdGUgRE9NIG5vZGVzLgogICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zLgogICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYmluZD1mYWxzZV0gRGV0ZXJtaW5lcyB3aGV0aGVyIG5ldyBlbGVtZW50cyB3aWxsIGJlIGJvdW5kLgogICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMud2l0aENoaWxkcmVuPXRydWVdIElmIGB0cnVlYCwgbm9kZSdzIGFuZCBkb2N1bWVudCBmcmFnbWVudCdzIGNoaWxkcmVuIHdpbGwgYmUgY29udmVydGVkIHRvby4KICAgKiBAcmV0dXJucyB7Tm9kZXxEb2N1bWVudEZyYWdtZW50fSBDb252ZXJ0ZWQgbm9kZSBvciBEb2N1bWVudEZyYWdtZW50LgogICAqLwoKCiAgdmlld1RvRG9tKHZpZXdOb2RlLCBkb21Eb2N1bWVudCwgb3B0aW9ucyA9IHt9KSB7CiAgICBpZiAodmlld05vZGUuaXMoJ3RleHQnKSkgewogICAgICBjb25zdCB0ZXh0RGF0YSA9IHRoaXMuX3Byb2Nlc3NEYXRhRnJvbVZpZXdUZXh0KHZpZXdOb2RlKTsKCiAgICAgIHJldHVybiBkb21Eb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0RGF0YSk7CiAgICB9IGVsc2UgewogICAgICBpZiAodGhpcy5tYXBWaWV3VG9Eb20odmlld05vZGUpKSB7CiAgICAgICAgcmV0dXJuIHRoaXMubWFwVmlld1RvRG9tKHZpZXdOb2RlKTsKICAgICAgfQoKICAgICAgbGV0IGRvbUVsZW1lbnQ7CgogICAgICBpZiAodmlld05vZGUuaXMoJ2RvY3VtZW50RnJhZ21lbnQnKSkgewogICAgICAgIC8vIENyZWF0ZSBET00gZG9jdW1lbnQgZnJhZ21lbnQuCiAgICAgICAgZG9tRWxlbWVudCA9IGRvbURvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTsKCiAgICAgICAgaWYgKG9wdGlvbnMuYmluZCkgewogICAgICAgICAgdGhpcy5iaW5kRG9jdW1lbnRGcmFnbWVudHMoZG9tRWxlbWVudCwgdmlld05vZGUpOwogICAgICAgIH0KICAgICAgfSBlbHNlIGlmICh2aWV3Tm9kZS5pcygndWlFbGVtZW50JykpIHsKICAgICAgICAvLyBVSUVsZW1lbnQgaGFzIGl0cyBvd24gcmVuZGVyKCkgbWV0aG9kIChzZWUgIzc5OSkuCiAgICAgICAgZG9tRWxlbWVudCA9IHZpZXdOb2RlLnJlbmRlcihkb21Eb2N1bWVudCk7CgogICAgICAgIGlmIChvcHRpb25zLmJpbmQpIHsKICAgICAgICAgIHRoaXMuYmluZEVsZW1lbnRzKGRvbUVsZW1lbnQsIHZpZXdOb2RlKTsKICAgICAgICB9CgogICAgICAgIHJldHVybiBkb21FbGVtZW50OwogICAgICB9IGVsc2UgewogICAgICAgIC8vIENyZWF0ZSBET00gZWxlbWVudC4KICAgICAgICBpZiAodmlld05vZGUuaGFzQXR0cmlidXRlKCd4bWxucycpKSB7CiAgICAgICAgICBkb21FbGVtZW50ID0gZG9tRG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHZpZXdOb2RlLmdldEF0dHJpYnV0ZSgneG1sbnMnKSwgdmlld05vZGUubmFtZSk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGRvbUVsZW1lbnQgPSBkb21Eb2N1bWVudC5jcmVhdGVFbGVtZW50KHZpZXdOb2RlLm5hbWUpOwogICAgICAgIH0KCiAgICAgICAgaWYgKG9wdGlvbnMuYmluZCkgewogICAgICAgICAgdGhpcy5iaW5kRWxlbWVudHMoZG9tRWxlbWVudCwgdmlld05vZGUpOwogICAgICAgIH0gLy8gQ29weSBlbGVtZW50J3MgYXR0cmlidXRlcy4KCgogICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHZpZXdOb2RlLmdldEF0dHJpYnV0ZUtleXMoKSkgewogICAgICAgICAgZG9tRWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5LCB2aWV3Tm9kZS5nZXRBdHRyaWJ1dGUoa2V5KSk7CiAgICAgICAgfQogICAgICB9CgogICAgICBpZiAob3B0aW9ucy53aXRoQ2hpbGRyZW4gfHwgb3B0aW9ucy53aXRoQ2hpbGRyZW4gPT09IHVuZGVmaW5lZCkgewogICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy52aWV3Q2hpbGRyZW5Ub0RvbSh2aWV3Tm9kZSwgZG9tRG9jdW1lbnQsIG9wdGlvbnMpKSB7CiAgICAgICAgICBkb21FbGVtZW50LmFwcGVuZENoaWxkKGNoaWxkKTsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIHJldHVybiBkb21FbGVtZW50OwogICAgfQogIH0KICAvKioKICAgKiBDb252ZXJ0cyBjaGlsZHJlbiBvZiB0aGUgdmlldyBlbGVtZW50IHRvIERPTSB1c2luZyB0aGUKICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2RvbWNvbnZlcnRlcn5Eb21Db252ZXJ0ZXIjdmlld1RvRG9tfSBtZXRob2QuCiAgICogQWRkaXRpb25hbGx5LCB0aGlzIG1ldGhvZCBhZGRzIGJsb2NrIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZmlsbGVyIGZpbGxlcn0gdG8gdGhlIGxpc3Qgb2YgY2hpbGRyZW4sIGlmIG5lZWRlZC4KICAgKgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudHxtb2R1bGU6ZW5naW5lL3ZpZXcvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50fSB2aWV3RWxlbWVudCBQYXJlbnQgdmlldyBlbGVtZW50LgogICAqIEBwYXJhbSB7RG9jdW1lbnR9IGRvbURvY3VtZW50IERvY3VtZW50IHdoaWNoIHdpbGwgYmUgdXNlZCB0byBjcmVhdGUgRE9NIG5vZGVzLgogICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFNlZSB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2RvbWNvbnZlcnRlcn5Eb21Db252ZXJ0ZXIjdmlld1RvRG9tfSBvcHRpb25zIHBhcmFtZXRlci4KICAgKiBAcmV0dXJucyB7SXRlcmFibGUuPE5vZGU+fSBET00gbm9kZXMuCiAgICovCgoKICAqdmlld0NoaWxkcmVuVG9Eb20odmlld0VsZW1lbnQsIGRvbURvY3VtZW50LCBvcHRpb25zID0ge30pIHsKICAgIGNvbnN0IGZpbGxlclBvc2l0aW9uT2Zmc2V0ID0gdmlld0VsZW1lbnQuZ2V0RmlsbGVyT2Zmc2V0ICYmIHZpZXdFbGVtZW50LmdldEZpbGxlck9mZnNldCgpOwogICAgbGV0IG9mZnNldCA9IDA7CgogICAgZm9yIChjb25zdCBjaGlsZFZpZXcgb2Ygdmlld0VsZW1lbnQuZ2V0Q2hpbGRyZW4oKSkgewogICAgICBpZiAoZmlsbGVyUG9zaXRpb25PZmZzZXQgPT09IG9mZnNldCkgewogICAgICAgIHlpZWxkIHRoaXMuX2Jsb2NrRmlsbGVyKGRvbURvY3VtZW50KTsKICAgICAgfQoKICAgICAgeWllbGQgdGhpcy52aWV3VG9Eb20oY2hpbGRWaWV3LCBkb21Eb2N1bWVudCwgb3B0aW9ucyk7CiAgICAgIG9mZnNldCsrOwogICAgfQoKICAgIGlmIChmaWxsZXJQb3NpdGlvbk9mZnNldCA9PT0gb2Zmc2V0KSB7CiAgICAgIHlpZWxkIHRoaXMuX2Jsb2NrRmlsbGVyKGRvbURvY3VtZW50KTsKICAgIH0KICB9CiAgLyoqCiAgICogQ29udmVydHMgdmlldyB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3JhbmdlflJhbmdlfSB0byBET00gcmFuZ2UuCiAgICogSW5saW5lIGFuZCBibG9jayB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2ZpbGxlciBmaWxsZXJzfSBhcmUgaGFuZGxlZCBkdXJpbmcgdGhlIGNvbnZlcnNpb24uCiAgICoKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy9yYW5nZX5SYW5nZX0gdmlld1JhbmdlIFZpZXcgcmFuZ2UuCiAgICogQHJldHVybnMge1JhbmdlfSBET00gcmFuZ2UuCiAgICovCgoKICB2aWV3UmFuZ2VUb0RvbSh2aWV3UmFuZ2UpIHsKICAgIGNvbnN0IGRvbVN0YXJ0ID0gdGhpcy52aWV3UG9zaXRpb25Ub0RvbSh2aWV3UmFuZ2Uuc3RhcnQpOwogICAgY29uc3QgZG9tRW5kID0gdGhpcy52aWV3UG9zaXRpb25Ub0RvbSh2aWV3UmFuZ2UuZW5kKTsKICAgIGNvbnN0IGRvbVJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTsKICAgIGRvbVJhbmdlLnNldFN0YXJ0KGRvbVN0YXJ0LnBhcmVudCwgZG9tU3RhcnQub2Zmc2V0KTsKICAgIGRvbVJhbmdlLnNldEVuZChkb21FbmQucGFyZW50LCBkb21FbmQub2Zmc2V0KTsKICAgIHJldHVybiBkb21SYW5nZTsKICB9CiAgLyoqCiAgICogQ29udmVydHMgdmlldyB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3Bvc2l0aW9uflBvc2l0aW9ufSB0byBET00gcGFyZW50IGFuZCBvZmZzZXQuCiAgICoKICAgKiBJbmxpbmUgYW5kIGJsb2NrIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZmlsbGVyIGZpbGxlcnN9IGFyZSBoYW5kbGVkIGR1cmluZyB0aGUgY29udmVyc2lvbi4KICAgKiBJZiB0aGUgY29udmVydGVkIHBvc2l0aW9uIGlzIGRpcmVjdGx5IGJlZm9yZSBpbmxpbmUgZmlsbGVyIGl0IGlzIG1vdmVkIGluc2lkZSB0aGUgZmlsbGVyLgogICAqCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvcG9zaXRpb25+UG9zaXRpb259IHZpZXdQb3NpdGlvbiBWaWV3IHBvc2l0aW9uLgogICAqIEByZXR1cm5zIHtPYmplY3R8bnVsbH0gcG9zaXRpb24gRE9NIHBvc2l0aW9uIG9yIGBudWxsYCBpZiB2aWV3IHBvc2l0aW9uIGNvdWxkIG5vdCBiZSBjb252ZXJ0ZWQgdG8gRE9NLgogICAqIEByZXR1cm5zIHtOb2RlfSBwb3NpdGlvbi5wYXJlbnQgRE9NIHBvc2l0aW9uIHBhcmVudC4KICAgKiBAcmV0dXJucyB7TnVtYmVyfSBwb3NpdGlvbi5vZmZzZXQgRE9NIHBvc2l0aW9uIG9mZnNldC4KICAgKi8KCgogIHZpZXdQb3NpdGlvblRvRG9tKHZpZXdQb3NpdGlvbikgewogICAgY29uc3Qgdmlld1BhcmVudCA9IHZpZXdQb3NpdGlvbi5wYXJlbnQ7CgogICAgaWYgKHZpZXdQYXJlbnQuaXMoJ3RleHQnKSkgewogICAgICBjb25zdCBkb21QYXJlbnQgPSB0aGlzLmZpbmRDb3JyZXNwb25kaW5nRG9tVGV4dCh2aWV3UGFyZW50KTsKCiAgICAgIGlmICghZG9tUGFyZW50KSB7CiAgICAgICAgLy8gUG9zaXRpb24gaXMgaW4gYSB2aWV3IHRleHQgbm9kZSB0aGF0IGhhcyBub3QgYmVlbiByZW5kZXJlZCB0byBET00geWV0LgogICAgICAgIHJldHVybiBudWxsOwogICAgICB9CgogICAgICBsZXQgb2Zmc2V0ID0gdmlld1Bvc2l0aW9uLm9mZnNldDsKCiAgICAgIGlmIChzdGFydHNXaXRoRmlsbGVyKGRvbVBhcmVudCkpIHsKICAgICAgICBvZmZzZXQgKz0gSU5MSU5FX0ZJTExFUl9MRU5HVEg7CiAgICAgIH0KCiAgICAgIHJldHVybiB7CiAgICAgICAgcGFyZW50OiBkb21QYXJlbnQsCiAgICAgICAgb2Zmc2V0CiAgICAgIH07CiAgICB9IGVsc2UgewogICAgICAvLyB2aWV3UGFyZW50IGlzIGluc3RhbmNlIG9mIFZpZXdFbGVtZW50LgogICAgICBsZXQgZG9tUGFyZW50LCBkb21CZWZvcmUsIGRvbUFmdGVyOwoKICAgICAgaWYgKHZpZXdQb3NpdGlvbi5vZmZzZXQgPT09IDApIHsKICAgICAgICBkb21QYXJlbnQgPSB0aGlzLm1hcFZpZXdUb0RvbSh2aWV3UGFyZW50KTsKCiAgICAgICAgaWYgKCFkb21QYXJlbnQpIHsKICAgICAgICAgIC8vIFBvc2l0aW9uIGlzIGluIGEgdmlldyBlbGVtZW50IHRoYXQgaGFzIG5vdCBiZWVuIHJlbmRlcmVkIHRvIERPTSB5ZXQuCiAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICB9CgogICAgICAgIGRvbUFmdGVyID0gZG9tUGFyZW50LmNoaWxkTm9kZXNbMF07CiAgICAgIH0gZWxzZSB7CiAgICAgICAgY29uc3Qgbm9kZUJlZm9yZSA9IHZpZXdQb3NpdGlvbi5ub2RlQmVmb3JlOwogICAgICAgIGRvbUJlZm9yZSA9IG5vZGVCZWZvcmUuaXMoJ3RleHQnKSA/IHRoaXMuZmluZENvcnJlc3BvbmRpbmdEb21UZXh0KG5vZGVCZWZvcmUpIDogdGhpcy5tYXBWaWV3VG9Eb20odmlld1Bvc2l0aW9uLm5vZGVCZWZvcmUpOwoKICAgICAgICBpZiAoIWRvbUJlZm9yZSkgewogICAgICAgICAgLy8gUG9zaXRpb24gaXMgYWZ0ZXIgYSB2aWV3IGVsZW1lbnQgdGhhdCBoYXMgbm90IGJlZW4gcmVuZGVyZWQgdG8gRE9NIHlldC4KICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgIH0KCiAgICAgICAgZG9tUGFyZW50ID0gZG9tQmVmb3JlLnBhcmVudE5vZGU7CiAgICAgICAgZG9tQWZ0ZXIgPSBkb21CZWZvcmUubmV4dFNpYmxpbmc7CiAgICAgIH0gLy8gSWYgdGhlcmUgaXMgYW4gaW5saW5lIGZpbGxlciBhdCBwb3NpdGlvbiByZXR1cm4gcG9zaXRpb24gaW5zaWRlIHRoZSBmaWxsZXIuIFdlIHNob3VsZCBuZXZlciByZXR1cm4KICAgICAgLy8gdGhlIHBvc2l0aW9uIGJlZm9yZSB0aGUgaW5saW5lIGZpbGxlci4KCgogICAgICBpZiAoaXNUZXh0KGRvbUFmdGVyKSAmJiBzdGFydHNXaXRoRmlsbGVyKGRvbUFmdGVyKSkgewogICAgICAgIHJldHVybiB7CiAgICAgICAgICBwYXJlbnQ6IGRvbUFmdGVyLAogICAgICAgICAgb2Zmc2V0OiBJTkxJTkVfRklMTEVSX0xFTkdUSAogICAgICAgIH07CiAgICAgIH0KCiAgICAgIGNvbnN0IG9mZnNldCA9IGRvbUJlZm9yZSA/IGluZGV4T2YoZG9tQmVmb3JlKSArIDEgOiAwOwogICAgICByZXR1cm4gewogICAgICAgIHBhcmVudDogZG9tUGFyZW50LAogICAgICAgIG9mZnNldAogICAgICB9OwogICAgfQogIH0KICAvKioKICAgKiBDb252ZXJ0cyBET00gdG8gdmlldy4gRm9yIGFsbCB0ZXh0IG5vZGVzLCBub3QgYm91bmQgZWxlbWVudHMgYW5kIGRvY3VtZW50IGZyYWdtZW50cyBuZXcgaXRlbXMgd2lsbAogICAqIGJlIGNyZWF0ZWQuIEZvciBib3VuZCBlbGVtZW50cyBhbmQgZG9jdW1lbnQgZnJhZ21lbnRzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIGNvcnJlc3BvbmRpbmcgaXRlbXMuIEZvcgogICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZmlsbGVyIGZpbGxlcnN9IGBudWxsYCB3aWxsIGJlIHJldHVybmVkLgogICAqIEZvciBhbGwgRE9NIGVsZW1lbnRzIHJlbmRlcmVkIGJ5IHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdWllbGVtZW50flVJRWxlbWVudH0gdGhhdCBVSUVsZW1lbnQgd2lsbCBiZSByZXR1cm5lZC4KICAgKgogICAqIEBwYXJhbSB7Tm9kZXxEb2N1bWVudEZyYWdtZW50fSBkb21Ob2RlIERPTSBub2RlIG9yIGRvY3VtZW50IGZyYWdtZW50IHRvIHRyYW5zZm9ybS4KICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIENvbnZlcnNpb24gb3B0aW9ucy4KICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmJpbmQ9ZmFsc2VdIERldGVybWluZXMgd2hldGhlciBuZXcgZWxlbWVudHMgd2lsbCBiZSBib3VuZC4KICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLndpdGhDaGlsZHJlbj10cnVlXSBJZiBgdHJ1ZWAsIG5vZGUncyBhbmQgZG9jdW1lbnQgZnJhZ21lbnQncyBjaGlsZHJlbiB3aWxsIGJlIGNvbnZlcnRlZCB0b28uCiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5rZWVwT3JpZ2luYWxDYXNlPWZhbHNlXSBJZiBgZmFsc2VgLCBub2RlJ3MgdGFnIG5hbWUgd2lsbCBiZSBjb252ZXJ0ZXIgdG8gbG93ZXIgY2FzZS4KICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS92aWV3L25vZGV+Tm9kZXxtb2R1bGU6ZW5naW5lL3ZpZXcvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50fG51bGx9IENvbnZlcnRlZCBub2RlIG9yIGRvY3VtZW50IGZyYWdtZW50CiAgICogb3IgYG51bGxgIGlmIERPTSBub2RlIGlzIGEge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9maWxsZXIgZmlsbGVyfSBvciB0aGUgZ2l2ZW4gbm9kZSBpcyBhbiBlbXB0eSB0ZXh0IG5vZGUuCiAgICovCgoKICBkb21Ub1ZpZXcoZG9tTm9kZSwgb3B0aW9ucyA9IHt9KSB7CiAgICBpZiAodGhpcy5pc0Jsb2NrRmlsbGVyKGRvbU5vZGUsIHRoaXMuYmxvY2tGaWxsZXJNb2RlKSkgewogICAgICByZXR1cm4gbnVsbDsKICAgIH0gLy8gV2hlbiBub2RlIGlzIGluc2lkZSBVSUVsZW1lbnQgcmV0dXJuIHRoYXQgVUlFbGVtZW50IGFzIGl0J3MgdmlldyByZXByZXNlbnRhdGlvbi4KCgogICAgY29uc3QgdWlFbGVtZW50ID0gdGhpcy5nZXRQYXJlbnRVSUVsZW1lbnQoZG9tTm9kZSwgdGhpcy5fZG9tVG9WaWV3TWFwcGluZyk7CgogICAgaWYgKHVpRWxlbWVudCkgewogICAgICByZXR1cm4gdWlFbGVtZW50OwogICAgfQoKICAgIGlmIChpc1RleHQoZG9tTm9kZSkpIHsKICAgICAgaWYgKGlzSW5saW5lRmlsbGVyKGRvbU5vZGUpKSB7CiAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgY29uc3QgdGV4dERhdGEgPSB0aGlzLl9wcm9jZXNzRGF0YUZyb21Eb21UZXh0KGRvbU5vZGUpOwoKICAgICAgICByZXR1cm4gdGV4dERhdGEgPT09ICcnID8gbnVsbCA6IG5ldyBWaWV3VGV4dCh0ZXh0RGF0YSk7CiAgICAgIH0KICAgIH0gZWxzZSBpZiAodGhpcy5pc0NvbW1lbnQoZG9tTm9kZSkpIHsKICAgICAgcmV0dXJuIG51bGw7CiAgICB9IGVsc2UgewogICAgICBpZiAodGhpcy5tYXBEb21Ub1ZpZXcoZG9tTm9kZSkpIHsKICAgICAgICByZXR1cm4gdGhpcy5tYXBEb21Ub1ZpZXcoZG9tTm9kZSk7CiAgICAgIH0KCiAgICAgIGxldCB2aWV3RWxlbWVudDsKCiAgICAgIGlmICh0aGlzLmlzRG9jdW1lbnRGcmFnbWVudChkb21Ob2RlKSkgewogICAgICAgIC8vIENyZWF0ZSB2aWV3IGRvY3VtZW50IGZyYWdtZW50LgogICAgICAgIHZpZXdFbGVtZW50ID0gbmV3IFZpZXdEb2N1bWVudEZyYWdtZW50KCk7CgogICAgICAgIGlmIChvcHRpb25zLmJpbmQpIHsKICAgICAgICAgIHRoaXMuYmluZERvY3VtZW50RnJhZ21lbnRzKGRvbU5vZGUsIHZpZXdFbGVtZW50KTsKICAgICAgICB9CiAgICAgIH0gZWxzZSB7CiAgICAgICAgLy8gQ3JlYXRlIHZpZXcgZWxlbWVudC4KICAgICAgICBjb25zdCB2aWV3TmFtZSA9IG9wdGlvbnMua2VlcE9yaWdpbmFsQ2FzZSA/IGRvbU5vZGUudGFnTmFtZSA6IGRvbU5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpOwogICAgICAgIHZpZXdFbGVtZW50ID0gbmV3IFZpZXdFbGVtZW50KHZpZXdOYW1lKTsKCiAgICAgICAgaWYgKG9wdGlvbnMuYmluZCkgewogICAgICAgICAgdGhpcy5iaW5kRWxlbWVudHMoZG9tTm9kZSwgdmlld0VsZW1lbnQpOwogICAgICAgIH0gLy8gQ29weSBlbGVtZW50J3MgYXR0cmlidXRlcy4KCgogICAgICAgIGNvbnN0IGF0dHJzID0gZG9tTm9kZS5hdHRyaWJ1dGVzOwoKICAgICAgICBmb3IgKGxldCBpID0gYXR0cnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHsKICAgICAgICAgIHZpZXdFbGVtZW50Ll9zZXRBdHRyaWJ1dGUoYXR0cnNbaV0ubmFtZSwgYXR0cnNbaV0udmFsdWUpOwogICAgICAgIH0KICAgICAgfQoKICAgICAgaWYgKG9wdGlvbnMud2l0aENoaWxkcmVuIHx8IG9wdGlvbnMud2l0aENoaWxkcmVuID09PSB1bmRlZmluZWQpIHsKICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuZG9tQ2hpbGRyZW5Ub1ZpZXcoZG9tTm9kZSwgb3B0aW9ucykpIHsKICAgICAgICAgIHZpZXdFbGVtZW50Ll9hcHBlbmRDaGlsZChjaGlsZCk7CiAgICAgICAgfQogICAgICB9CgogICAgICByZXR1cm4gdmlld0VsZW1lbnQ7CiAgICB9CiAgfQogIC8qKgogICAqIENvbnZlcnRzIGNoaWxkcmVuIG9mIHRoZSBET00gZWxlbWVudCB0byB2aWV3IG5vZGVzIHVzaW5nCiAgICogdGhlIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZG9tY29udmVydGVyfkRvbUNvbnZlcnRlciNkb21Ub1ZpZXd9IG1ldGhvZC4KICAgKiBBZGRpdGlvbmFsbHkgdGhpcyBtZXRob2Qgb21pdHMgYmxvY2sge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9maWxsZXIgZmlsbGVyfSwgaWYgaXQgZXhpc3RzIGluIHRoZSBET00gcGFyZW50LgogICAqCiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZG9tRWxlbWVudCBQYXJlbnQgRE9NIGVsZW1lbnQuCiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgU2VlIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZG9tY29udmVydGVyfkRvbUNvbnZlcnRlciNkb21Ub1ZpZXd9IG9wdGlvbnMgcGFyYW1ldGVyLgogICAqIEByZXR1cm5zIHtJdGVyYWJsZS48bW9kdWxlOmVuZ2luZS92aWV3L25vZGV+Tm9kZT59IFZpZXcgbm9kZXMuCiAgICovCgoKICAqZG9tQ2hpbGRyZW5Ub1ZpZXcoZG9tRWxlbWVudCwgb3B0aW9ucyA9IHt9KSB7CiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRvbUVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykgewogICAgICBjb25zdCBkb21DaGlsZCA9IGRvbUVsZW1lbnQuY2hpbGROb2Rlc1tpXTsKICAgICAgY29uc3Qgdmlld0NoaWxkID0gdGhpcy5kb21Ub1ZpZXcoZG9tQ2hpbGQsIG9wdGlvbnMpOwoKICAgICAgaWYgKHZpZXdDaGlsZCAhPT0gbnVsbCkgewogICAgICAgIHlpZWxkIHZpZXdDaGlsZDsKICAgICAgfQogICAgfQogIH0KICAvKioKICAgKiBDb252ZXJ0cyBET00gc2VsZWN0aW9uIHRvIHZpZXcge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9zZWxlY3Rpb25+U2VsZWN0aW9ufS4KICAgKiBSYW5nZXMgd2hpY2ggY2Fubm90IGJlIGNvbnZlcnRlZCB3aWxsIGJlIG9taXR0ZWQuCiAgICoKICAgKiBAcGFyYW0ge1NlbGVjdGlvbn0gZG9tU2VsZWN0aW9uIERPTSBzZWxlY3Rpb24uCiAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy9zZWxlY3Rpb25+U2VsZWN0aW9ufSBWaWV3IHNlbGVjdGlvbi4KICAgKi8KCgogIGRvbVNlbGVjdGlvblRvVmlldyhkb21TZWxlY3Rpb24pIHsKICAgIC8vIERPTSBzZWxlY3Rpb24gbWlnaHQgYmUgcGxhY2VkIGluIGZha2Ugc2VsZWN0aW9uIGNvbnRhaW5lci4KICAgIC8vIElmIGNvbnRhaW5lciBjb250YWlucyBmYWtlIHNlbGVjdGlvbiAtIHJldHVybiBjb3JyZXNwb25kaW5nIHZpZXcgc2VsZWN0aW9uLgogICAgaWYgKGRvbVNlbGVjdGlvbi5yYW5nZUNvdW50ID09PSAxKSB7CiAgICAgIGxldCBjb250YWluZXIgPSBkb21TZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKS5zdGFydENvbnRhaW5lcjsgLy8gVGhlIERPTSBzZWxlY3Rpb24gbWlnaHQgYmUgbW92ZWQgdG8gdGhlIHRleHQgbm9kZSBpbnNpZGUgdGhlIGZha2Ugc2VsZWN0aW9uIGNvbnRhaW5lci4KCiAgICAgIGlmIChpc1RleHQoY29udGFpbmVyKSkgewogICAgICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lci5wYXJlbnROb2RlOwogICAgICB9CgogICAgICBjb25zdCB2aWV3U2VsZWN0aW9uID0gdGhpcy5mYWtlU2VsZWN0aW9uVG9WaWV3KGNvbnRhaW5lcik7CgogICAgICBpZiAodmlld1NlbGVjdGlvbikgewogICAgICAgIHJldHVybiB2aWV3U2VsZWN0aW9uOwogICAgICB9CiAgICB9CgogICAgY29uc3QgaXNCYWNrd2FyZCA9IHRoaXMuaXNEb21TZWxlY3Rpb25CYWNrd2FyZChkb21TZWxlY3Rpb24pOwogICAgY29uc3Qgdmlld1JhbmdlcyA9IFtdOwoKICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZG9tU2VsZWN0aW9uLnJhbmdlQ291bnQ7IGkrKykgewogICAgICAvLyBET00gUmFuZ2UgaGF2ZSBjb3JyZWN0IHN0YXJ0IGFuZCBlbmQsIG5vIG1hdHRlciB3aGF0IGlzIHRoZSBET00gU2VsZWN0aW9uIGRpcmVjdGlvbi4gU28gd2UgZG9uJ3QgaGF2ZSB0byBmaXggYW55dGhpbmcuCiAgICAgIGNvbnN0IGRvbVJhbmdlID0gZG9tU2VsZWN0aW9uLmdldFJhbmdlQXQoaSk7CiAgICAgIGNvbnN0IHZpZXdSYW5nZSA9IHRoaXMuZG9tUmFuZ2VUb1ZpZXcoZG9tUmFuZ2UpOwoKICAgICAgaWYgKHZpZXdSYW5nZSkgewogICAgICAgIHZpZXdSYW5nZXMucHVzaCh2aWV3UmFuZ2UpOwogICAgICB9CiAgICB9CgogICAgcmV0dXJuIG5ldyBWaWV3U2VsZWN0aW9uKHZpZXdSYW5nZXMsIHsKICAgICAgYmFja3dhcmQ6IGlzQmFja3dhcmQKICAgIH0pOwogIH0KICAvKioKICAgKiBDb252ZXJ0cyBET00gUmFuZ2UgdG8gdmlldyB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3JhbmdlflJhbmdlfS4KICAgKiBJZiB0aGUgc3RhcnQgb3IgZW5kIHBvc2l0aW9uIGNhbiBub3QgYmUgY29udmVydGVkIGBudWxsYCBpcyByZXR1cm5lZC4KICAgKgogICAqIEBwYXJhbSB7UmFuZ2V9IGRvbVJhbmdlIERPTSByYW5nZS4KICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS92aWV3L3JhbmdlflJhbmdlfG51bGx9IFZpZXcgcmFuZ2UuCiAgICovCgoKICBkb21SYW5nZVRvVmlldyhkb21SYW5nZSkgewogICAgY29uc3Qgdmlld1N0YXJ0ID0gdGhpcy5kb21Qb3NpdGlvblRvVmlldyhkb21SYW5nZS5zdGFydENvbnRhaW5lciwgZG9tUmFuZ2Uuc3RhcnRPZmZzZXQpOwogICAgY29uc3Qgdmlld0VuZCA9IHRoaXMuZG9tUG9zaXRpb25Ub1ZpZXcoZG9tUmFuZ2UuZW5kQ29udGFpbmVyLCBkb21SYW5nZS5lbmRPZmZzZXQpOwoKICAgIGlmICh2aWV3U3RhcnQgJiYgdmlld0VuZCkgewogICAgICByZXR1cm4gbmV3IFZpZXdSYW5nZSh2aWV3U3RhcnQsIHZpZXdFbmQpOwogICAgfQoKICAgIHJldHVybiBudWxsOwogIH0KICAvKioKICAgKiBDb252ZXJ0cyBET00gcGFyZW50IGFuZCBvZmZzZXQgdG8gdmlldyB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3Bvc2l0aW9uflBvc2l0aW9ufS4KICAgKgogICAqIElmIHRoZSBwb3NpdGlvbiBpcyBpbnNpZGUgYSB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2ZpbGxlciBmaWxsZXJ9IHdoaWNoIGhhcyBubyBjb3JyZXNwb25kaW5nIHZpZXcgbm9kZSwKICAgKiBwb3NpdGlvbiBvZiB0aGUgZmlsbGVyIHdpbGwgYmUgY29udmVydGVkIGFuZCByZXR1cm5lZC4KICAgKgogICAqIElmIHRoZSBwb3NpdGlvbiBpcyBpbnNpZGUgRE9NIGVsZW1lbnQgcmVuZGVyZWQgYnkge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy91aWVsZW1lbnR+VUlFbGVtZW50fQogICAqIHRoYXQgcG9zaXRpb24gd2lsbCBiZSBjb252ZXJ0ZWQgdG8gdmlldyBwb3NpdGlvbiBiZWZvcmUgdGhhdCBVSUVsZW1lbnQuCiAgICoKICAgKiBJZiBzdHJ1Y3R1cmVzIGFyZSB0b28gZGlmZmVyZW50IGFuZCBpdCBpcyBub3QgcG9zc2libGUgdG8gZmluZCBjb3JyZXNwb25kaW5nIHBvc2l0aW9uIHRoZW4gYG51bGxgIHdpbGwgYmUgcmV0dXJuZWQuCiAgICoKICAgKiBAcGFyYW0ge05vZGV9IGRvbVBhcmVudCBET00gcG9zaXRpb24gcGFyZW50LgogICAqIEBwYXJhbSB7TnVtYmVyfSBkb21PZmZzZXQgRE9NIHBvc2l0aW9uIG9mZnNldC4KICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS92aWV3L3Bvc2l0aW9uflBvc2l0aW9ufSB2aWV3UG9zaXRpb24gVmlldyBwb3NpdGlvbi4KICAgKi8KCgogIGRvbVBvc2l0aW9uVG9WaWV3KGRvbVBhcmVudCwgZG9tT2Zmc2V0KSB7CiAgICBpZiAodGhpcy5pc0Jsb2NrRmlsbGVyKGRvbVBhcmVudCwgdGhpcy5ibG9ja0ZpbGxlck1vZGUpKSB7CiAgICAgIHJldHVybiB0aGlzLmRvbVBvc2l0aW9uVG9WaWV3KGRvbVBhcmVudC5wYXJlbnROb2RlLCBpbmRleE9mKGRvbVBhcmVudCkpOwogICAgfSAvLyBJZiBwb3NpdGlvbiBpcyBzb21ld2hlcmUgaW5zaWRlIFVJRWxlbWVudCAtIHJldHVybiBwb3NpdGlvbiBiZWZvcmUgdGhhdCBlbGVtZW50LgoKCiAgICBjb25zdCB2aWV3RWxlbWVudCA9IHRoaXMubWFwRG9tVG9WaWV3KGRvbVBhcmVudCk7CgogICAgaWYgKHZpZXdFbGVtZW50ICYmIHZpZXdFbGVtZW50LmlzKCd1aUVsZW1lbnQnKSkgewogICAgICByZXR1cm4gVmlld1Bvc2l0aW9uLl9jcmVhdGVCZWZvcmUodmlld0VsZW1lbnQpOwogICAgfQoKICAgIGlmIChpc1RleHQoZG9tUGFyZW50KSkgewogICAgICBpZiAoaXNJbmxpbmVGaWxsZXIoZG9tUGFyZW50KSkgewogICAgICAgIHJldHVybiB0aGlzLmRvbVBvc2l0aW9uVG9WaWV3KGRvbVBhcmVudC5wYXJlbnROb2RlLCBpbmRleE9mKGRvbVBhcmVudCkpOwogICAgICB9CgogICAgICBjb25zdCB2aWV3UGFyZW50ID0gdGhpcy5maW5kQ29ycmVzcG9uZGluZ1ZpZXdUZXh0KGRvbVBhcmVudCk7CiAgICAgIGxldCBvZmZzZXQgPSBkb21PZmZzZXQ7CgogICAgICBpZiAoIXZpZXdQYXJlbnQpIHsKICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgfQoKICAgICAgaWYgKHN0YXJ0c1dpdGhGaWxsZXIoZG9tUGFyZW50KSkgewogICAgICAgIG9mZnNldCAtPSBJTkxJTkVfRklMTEVSX0xFTkdUSDsKICAgICAgICBvZmZzZXQgPSBvZmZzZXQgPCAwID8gMCA6IG9mZnNldDsKICAgICAgfQoKICAgICAgcmV0dXJuIG5ldyBWaWV3UG9zaXRpb24odmlld1BhcmVudCwgb2Zmc2V0KTsKICAgIH0gLy8gZG9tUGFyZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQuCiAgICBlbHNlIHsKICAgICAgICBpZiAoZG9tT2Zmc2V0ID09PSAwKSB7CiAgICAgICAgICBjb25zdCB2aWV3UGFyZW50ID0gdGhpcy5tYXBEb21Ub1ZpZXcoZG9tUGFyZW50KTsKCiAgICAgICAgICBpZiAodmlld1BhcmVudCkgewogICAgICAgICAgICByZXR1cm4gbmV3IFZpZXdQb3NpdGlvbih2aWV3UGFyZW50LCAwKTsKICAgICAgICAgIH0KICAgICAgICB9IGVsc2UgewogICAgICAgICAgY29uc3QgZG9tQmVmb3JlID0gZG9tUGFyZW50LmNoaWxkTm9kZXNbZG9tT2Zmc2V0IC0gMV07CiAgICAgICAgICBjb25zdCB2aWV3QmVmb3JlID0gaXNUZXh0KGRvbUJlZm9yZSkgPyB0aGlzLmZpbmRDb3JyZXNwb25kaW5nVmlld1RleHQoZG9tQmVmb3JlKSA6IHRoaXMubWFwRG9tVG9WaWV3KGRvbUJlZm9yZSk7IC8vIFRPRE8gIzY2MwoKICAgICAgICAgIGlmICh2aWV3QmVmb3JlICYmIHZpZXdCZWZvcmUucGFyZW50KSB7CiAgICAgICAgICAgIHJldHVybiBuZXcgVmlld1Bvc2l0aW9uKHZpZXdCZWZvcmUucGFyZW50LCB2aWV3QmVmb3JlLmluZGV4ICsgMSk7CiAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgfQogIH0KICAvKioKICAgKiBSZXR1cm5zIGNvcnJlc3BvbmRpbmcgdmlldyB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudCBFbGVtZW50fSBvcgogICAqIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50fSBmb3IgcHJvdmlkZWQgRE9NIGVsZW1lbnQgb3IKICAgKiBkb2N1bWVudCBmcmFnbWVudC4gSWYgdGhlcmUgaXMgbm8gdmlldyBpdGVtIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZG9tY29udmVydGVyfkRvbUNvbnZlcnRlciNiaW5kRWxlbWVudHMgYm91bmR9CiAgICogdG8gdGhlIGdpdmVuIERPTSAtIGB1bmRlZmluZWRgIGlzIHJldHVybmVkLgogICAqIEZvciBhbGwgRE9NIGVsZW1lbnRzIHJlbmRlcmVkIGJ5IHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdWllbGVtZW50flVJRWxlbWVudH0gdGhhdCBVSUVsZW1lbnQgd2lsbCBiZSByZXR1cm5lZC4KICAgKgogICAqIEBwYXJhbSB7RG9jdW1lbnRGcmFnbWVudHxFbGVtZW50fSBkb21FbGVtZW50T3JEb2N1bWVudEZyYWdtZW50IERPTSBlbGVtZW50IG9yIGRvY3VtZW50IGZyYWdtZW50LgogICAqIEByZXR1cm5zIHttb2R1bGU6ZW5naW5lL3ZpZXcvZWxlbWVudH5FbGVtZW50fG1vZHVsZTplbmdpbmUvdmlldy9kb2N1bWVudGZyYWdtZW50fkRvY3VtZW50RnJhZ21lbnR8dW5kZWZpbmVkfQogICAqIENvcnJlc3BvbmRpbmcgdmlldyBlbGVtZW50LCBkb2N1bWVudCBmcmFnbWVudCBvciBgdW5kZWZpbmVkYCBpZiBubyBlbGVtZW50IHdhcyBib3VuZC4KICAgKi8KCgogIG1hcERvbVRvVmlldyhkb21FbGVtZW50T3JEb2N1bWVudEZyYWdtZW50KSB7CiAgICByZXR1cm4gdGhpcy5nZXRQYXJlbnRVSUVsZW1lbnQoZG9tRWxlbWVudE9yRG9jdW1lbnRGcmFnbWVudCkgfHwgdGhpcy5fZG9tVG9WaWV3TWFwcGluZy5nZXQoZG9tRWxlbWVudE9yRG9jdW1lbnRGcmFnbWVudCk7CiAgfQogIC8qKgogICAqIEZpbmRzIGNvcnJlc3BvbmRpbmcgdGV4dCBub2RlLiBUZXh0IG5vZGVzIGFyZSBub3Qge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9kb21jb252ZXJ0ZXJ+RG9tQ29udmVydGVyI2JpbmRFbGVtZW50cyBib3VuZH0sCiAgICogY29ycmVzcG9uZGluZyB0ZXh0IG5vZGUgaXMgcmV0dXJuZWQgYmFzZWQgb24gdGhlIHNpYmxpbmcgb3IgcGFyZW50LgogICAqCiAgICogSWYgdGhlIGRpcmVjdGx5IHByZXZpb3VzIHNpYmxpbmcgaXMgYSB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2RvbWNvbnZlcnRlcn5Eb21Db252ZXJ0ZXIjYmluZEVsZW1lbnRzIGJvdW5kfSBlbGVtZW50LCBpdCBpcyB1c2VkCiAgICogdG8gZmluZCB0aGUgY29ycmVzcG9uZGluZyB0ZXh0IG5vZGUuCiAgICoKICAgKiBJZiB0aGlzIGlzIGEgZmlyc3QgY2hpbGQgaW4gdGhlIHBhcmVudCBhbmQgdGhlIHBhcmVudCBpcyBhIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZG9tY29udmVydGVyfkRvbUNvbnZlcnRlciNiaW5kRWxlbWVudHMgYm91bmR9CiAgICogZWxlbWVudCwgaXQgaXMgdXNlZCB0byBmaW5kIHRoZSBjb3JyZXNwb25kaW5nIHRleHQgbm9kZS4KICAgKgogICAqIEZvciBhbGwgdGV4dCBub2RlcyByZW5kZXJlZCBieSB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3VpZWxlbWVudH5VSUVsZW1lbnR9IHRoYXQgVUlFbGVtZW50IHdpbGwgYmUgcmV0dXJuZWQuCiAgICoKICAgKiBPdGhlcndpc2UgYG51bGxgIGlzIHJldHVybmVkLgogICAqCiAgICogTm90ZSB0aGF0IGZvciB0aGUgYmxvY2sgb3IgaW5saW5lIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZmlsbGVyIGZpbGxlcn0gdGhpcyBtZXRob2QgcmV0dXJucyBgbnVsbGAuCiAgICoKICAgKiBAcGFyYW0ge1RleHR9IGRvbVRleHQgRE9NIHRleHQgbm9kZS4KICAgKiBAcmV0dXJucyB7bW9kdWxlOmVuZ2luZS92aWV3L3RleHR+VGV4dHxudWxsfSBDb3JyZXNwb25kaW5nIHZpZXcgdGV4dCBub2RlIG9yIGBudWxsYCwgaWYgaXQgd2FzIG5vdCBwb3NzaWJsZSB0byBmaW5kIGEKICAgKiBjb3JyZXNwb25kaW5nIG5vZGUuCiAgICovCgoKICBmaW5kQ29ycmVzcG9uZGluZ1ZpZXdUZXh0KGRvbVRleHQpIHsKICAgIGlmIChpc0lubGluZUZpbGxlcihkb21UZXh0KSkgewogICAgICByZXR1cm4gbnVsbDsKICAgIH0gLy8gSWYgRE9NIHRleHQgd2FzIHJlbmRlcmVkIGJ5IFVJRWxlbWVudCAtIHJldHVybiB0aGF0IGVsZW1lbnQuCgoKICAgIGNvbnN0IHVpRWxlbWVudCA9IHRoaXMuZ2V0UGFyZW50VUlFbGVtZW50KGRvbVRleHQpOwoKICAgIGlmICh1aUVsZW1lbnQpIHsKICAgICAgcmV0dXJuIHVpRWxlbWVudDsKICAgIH0KCiAgICBjb25zdCBwcmV2aW91c1NpYmxpbmcgPSBkb21UZXh0LnByZXZpb3VzU2libGluZzsgLy8gVHJ5IHRvIHVzZSBwcmV2aW91cyBzaWJsaW5nIHRvIGZpbmQgdGhlIGNvcnJlc3BvbmRpbmcgdGV4dCBub2RlLgoKICAgIGlmIChwcmV2aW91c1NpYmxpbmcpIHsKICAgICAgaWYgKCF0aGlzLmlzRWxlbWVudChwcmV2aW91c1NpYmxpbmcpKSB7CiAgICAgICAgLy8gVGhlIHByZXZpb3VzIGlzIHRleHQgb3IgY29tbWVudC4KICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgfQoKICAgICAgY29uc3Qgdmlld0VsZW1lbnQgPSB0aGlzLm1hcERvbVRvVmlldyhwcmV2aW91c1NpYmxpbmcpOwoKICAgICAgaWYgKHZpZXdFbGVtZW50KSB7CiAgICAgICAgY29uc3QgbmV4dFNpYmxpbmcgPSB2aWV3RWxlbWVudC5uZXh0U2libGluZzsgLy8gSXQgbWlnaHQgYmUgZmlsbGVyIHdoaWNoIGhhcyBubyBjb3JyZXNwb25kaW5nIHZpZXcgbm9kZS4KCiAgICAgICAgaWYgKG5leHRTaWJsaW5nIGluc3RhbmNlb2YgVmlld1RleHQpIHsKICAgICAgICAgIHJldHVybiB2aWV3RWxlbWVudC5uZXh0U2libGluZzsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgICAgfQogICAgICB9CiAgICB9IC8vIFRyeSB0byB1c2UgcGFyZW50IHRvIGZpbmQgdGhlIGNvcnJlc3BvbmRpbmcgdGV4dCBub2RlLgogICAgZWxzZSB7CiAgICAgICAgY29uc3Qgdmlld0VsZW1lbnQgPSB0aGlzLm1hcERvbVRvVmlldyhkb21UZXh0LnBhcmVudE5vZGUpOwoKICAgICAgICBpZiAodmlld0VsZW1lbnQpIHsKICAgICAgICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSB2aWV3RWxlbWVudC5nZXRDaGlsZCgwKTsgLy8gSXQgbWlnaHQgYmUgZmlsbGVyIHdoaWNoIGhhcyBubyBjb3JyZXNwb25kaW5nIHZpZXcgbm9kZS4KCiAgICAgICAgICBpZiAoZmlyc3RDaGlsZCBpbnN0YW5jZW9mIFZpZXdUZXh0KSB7CiAgICAgICAgICAgIHJldHVybiBmaXJzdENoaWxkOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CgogICAgcmV0dXJuIG51bGw7CiAgfQogIC8qKgogICAqIFJldHVybnMgY29ycmVzcG9uZGluZyBET00gaXRlbSBmb3IgcHJvdmlkZWQge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9lbGVtZW50fkVsZW1lbnQgRWxlbWVudH0gb3IKICAgKiB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2RvY3VtZW50ZnJhZ21lbnR+RG9jdW1lbnRGcmFnbWVudCBEb2N1bWVudEZyYWdtZW50fS4KICAgKiBUbyBmaW5kIGEgY29ycmVzcG9uZGluZyB0ZXh0IGZvciB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3RleHR+VGV4dCB2aWV3IFRleHQgaW5zdGFuY2V9CiAgICogdXNlIHtAbGluayAjZmluZENvcnJlc3BvbmRpbmdEb21UZXh0fS4KICAgKgogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L2VsZW1lbnR+RWxlbWVudHxtb2R1bGU6ZW5naW5lL3ZpZXcvZG9jdW1lbnRmcmFnbWVudH5Eb2N1bWVudEZyYWdtZW50fSB2aWV3Tm9kZQogICAqIFZpZXcgZWxlbWVudCBvciBkb2N1bWVudCBmcmFnbWVudC4KICAgKiBAcmV0dXJucyB7Tm9kZXxEb2N1bWVudEZyYWdtZW50fHVuZGVmaW5lZH0gQ29ycmVzcG9uZGluZyBET00gbm9kZSBvciBkb2N1bWVudCBmcmFnbWVudC4KICAgKi8KCgogIG1hcFZpZXdUb0RvbShkb2N1bWVudEZyYWdtZW50T3JFbGVtZW50KSB7CiAgICByZXR1cm4gdGhpcy5fdmlld1RvRG9tTWFwcGluZy5nZXQoZG9jdW1lbnRGcmFnbWVudE9yRWxlbWVudCk7CiAgfQogIC8qKgogICAqIEZpbmRzIGNvcnJlc3BvbmRpbmcgdGV4dCBub2RlLiBUZXh0IG5vZGVzIGFyZSBub3Qge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy9kb21jb252ZXJ0ZXJ+RG9tQ29udmVydGVyI2JpbmRFbGVtZW50cyBib3VuZH0sCiAgICogY29ycmVzcG9uZGluZyB0ZXh0IG5vZGUgaXMgcmV0dXJuZWQgYmFzZWQgb24gdGhlIHNpYmxpbmcgb3IgcGFyZW50LgogICAqCiAgICogSWYgdGhlIGRpcmVjdGx5IHByZXZpb3VzIHNpYmxpbmcgaXMgYSB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2RvbWNvbnZlcnRlcn5Eb21Db252ZXJ0ZXIjYmluZEVsZW1lbnRzIGJvdW5kfSBlbGVtZW50LCBpdCBpcyB1c2VkCiAgICogdG8gZmluZCB0aGUgY29ycmVzcG9uZGluZyB0ZXh0IG5vZGUuCiAgICoKICAgKiBJZiB0aGlzIGlzIGEgZmlyc3QgY2hpbGQgaW4gdGhlIHBhcmVudCBhbmQgdGhlIHBhcmVudCBpcyBhIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvZG9tY29udmVydGVyfkRvbUNvbnZlcnRlciNiaW5kRWxlbWVudHMgYm91bmR9CiAgICogZWxlbWVudCwgaXQgaXMgdXNlZCB0byBmaW5kIHRoZSBjb3JyZXNwb25kaW5nIHRleHQgbm9kZS4KICAgKgogICAqIE90aGVyd2lzZSBgbnVsbGAgaXMgcmV0dXJuZWQuCiAgICoKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy90ZXh0flRleHR9IHZpZXdUZXh0IFZpZXcgdGV4dCBub2RlLgogICAqIEByZXR1cm5zIHtUZXh0fG51bGx9IENvcnJlc3BvbmRpbmcgRE9NIHRleHQgbm9kZSBvciBgbnVsbGAsIGlmIGl0IHdhcyBub3QgcG9zc2libGUgdG8gZmluZCBhIGNvcnJlc3BvbmRpbmcgbm9kZS4KICAgKi8KCgogIGZpbmRDb3JyZXNwb25kaW5nRG9tVGV4dCh2aWV3VGV4dCkgewogICAgY29uc3QgcHJldmlvdXNTaWJsaW5nID0gdmlld1RleHQucHJldmlvdXNTaWJsaW5nOyAvLyBUcnkgdG8gdXNlIHByZXZpb3VzIHNpYmxpbmcgdG8gZmluZCB0aGUgY29ycmVzcG9uZGluZyB0ZXh0IG5vZGUuCgogICAgaWYgKHByZXZpb3VzU2libGluZyAmJiB0aGlzLm1hcFZpZXdUb0RvbShwcmV2aW91c1NpYmxpbmcpKSB7CiAgICAgIHJldHVybiB0aGlzLm1hcFZpZXdUb0RvbShwcmV2aW91c1NpYmxpbmcpLm5leHRTaWJsaW5nOwogICAgfSAvLyBJZiB0aGlzIGlzIGEgZmlyc3Qgbm9kZSwgdHJ5IHRvIHVzZSBwYXJlbnQgdG8gZmluZCB0aGUgY29ycmVzcG9uZGluZyB0ZXh0IG5vZGUuCgoKICAgIGlmICghcHJldmlvdXNTaWJsaW5nICYmIHZpZXdUZXh0LnBhcmVudCAmJiB0aGlzLm1hcFZpZXdUb0RvbSh2aWV3VGV4dC5wYXJlbnQpKSB7CiAgICAgIHJldHVybiB0aGlzLm1hcFZpZXdUb0RvbSh2aWV3VGV4dC5wYXJlbnQpLmNoaWxkTm9kZXNbMF07CiAgICB9CgogICAgcmV0dXJuIG51bGw7CiAgfQogIC8qKgogICAqIEZvY3VzZXMgRE9NIGVkaXRhYmxlIHRoYXQgaXMgY29ycmVzcG9uZGluZyB0byBwcm92aWRlZCB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L2VkaXRhYmxlZWxlbWVudH5FZGl0YWJsZUVsZW1lbnR9LgogICAqCiAgICogQHBhcmFtIHttb2R1bGU6ZW5naW5lL3ZpZXcvZWRpdGFibGVlbGVtZW50fkVkaXRhYmxlRWxlbWVudH0gdmlld0VkaXRhYmxlCiAgICovCgoKICBmb2N1cyh2aWV3RWRpdGFibGUpIHsKICAgIGNvbnN0IGRvbUVkaXRhYmxlID0gdGhpcy5tYXBWaWV3VG9Eb20odmlld0VkaXRhYmxlKTsKCiAgICBpZiAoZG9tRWRpdGFibGUgJiYgZG9tRWRpdGFibGUub3duZXJEb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSBkb21FZGl0YWJsZSkgewogICAgICAvLyBTYXZlIHRoZSBzY3JvbGxYIGFuZCBzY3JvbGxZIHBvc2l0aW9ucyBiZWZvcmUgdGhlIGZvY3VzLgogICAgICBjb25zdCB7CiAgICAgICAgc2Nyb2xsWCwKICAgICAgICBzY3JvbGxZCiAgICAgIH0gPSBnbG9iYWwud2luZG93OwogICAgICBjb25zdCBzY3JvbGxQb3NpdGlvbnMgPSBbXTsgLy8gU2F2ZSBhbGwgc2Nyb2xsTGVmdCBhbmQgc2Nyb2xsVG9wIHZhbHVlcyBzdGFydGluZyBmcm9tIGRvbUVkaXRhYmxlIHVwIHRvCiAgICAgIC8vIGRvY3VtZW50I2RvY3VtZW50RWxlbWVudC4KCiAgICAgIGZvckVhY2hEb21Ob2RlQW5jZXN0b3IoZG9tRWRpdGFibGUsIG5vZGUgPT4gewogICAgICAgIGNvbnN0IHsKICAgICAgICAgIHNjcm9sbExlZnQsCiAgICAgICAgICBzY3JvbGxUb3AKICAgICAgICB9ID0gbm9kZTsKICAgICAgICBzY3JvbGxQb3NpdGlvbnMucHVzaChbc2Nyb2xsTGVmdCwgc2Nyb2xsVG9wXSk7CiAgICAgIH0pOwogICAgICBkb21FZGl0YWJsZS5mb2N1cygpOyAvLyBSZXN0b3JlIHNjcm9sbExlZnQgYW5kIHNjcm9sbFRvcCB2YWx1ZXMgc3RhcnRpbmcgZnJvbSBkb21FZGl0YWJsZSB1cCB0bwogICAgICAvLyBkb2N1bWVudCNkb2N1bWVudEVsZW1lbnQuCiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ja2VkaXRvci9ja2VkaXRvcjUtZW5naW5lL2lzc3Vlcy85NTEKICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NrZWRpdG9yL2NrZWRpdG9yNS1lbmdpbmUvaXNzdWVzLzk1NwoKICAgICAgZm9yRWFjaERvbU5vZGVBbmNlc3Rvcihkb21FZGl0YWJsZSwgbm9kZSA9PiB7CiAgICAgICAgY29uc3QgW3Njcm9sbExlZnQsIHNjcm9sbFRvcF0gPSBzY3JvbGxQb3NpdGlvbnMuc2hpZnQoKTsKICAgICAgICBub2RlLnNjcm9sbExlZnQgPSBzY3JvbGxMZWZ0OwogICAgICAgIG5vZGUuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wOwogICAgICB9KTsgLy8gUmVzdG9yZSB0aGUgc2Nyb2xsWCBhbmQgc2Nyb2xsWSBwb3NpdGlvbnMgYWZ0ZXIgdGhlIGZvY3VzLgogICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2tlZGl0b3IvY2tlZGl0b3I1LWVuZ2luZS9pc3N1ZXMvOTUxCgogICAgICBnbG9iYWwud2luZG93LnNjcm9sbFRvKHNjcm9sbFgsIHNjcm9sbFkpOwogICAgfQogIH0KICAvKioKICAgKiBSZXR1cm5zIGB0cnVlYCB3aGVuIGBub2RlLm5vZGVUeXBlYCBlcXVhbHMgYE5vZGUuRUxFTUVOVF9OT0RFYC4KICAgKgogICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlIHRvIGNoZWNrLgogICAqIEByZXR1cm5zIHtCb29sZWFufQogICAqLwoKCiAgaXNFbGVtZW50KG5vZGUpIHsKICAgIHJldHVybiBub2RlICYmIG5vZGUubm9kZVR5cGUgPT0gTm9kZS5FTEVNRU5UX05PREU7CiAgfQogIC8qKgogICAqIFJldHVybnMgYHRydWVgIHdoZW4gYG5vZGUubm9kZVR5cGVgIGVxdWFscyBgTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFYC4KICAgKgogICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlIHRvIGNoZWNrLgogICAqIEByZXR1cm5zIHtCb29sZWFufQogICAqLwoKCiAgaXNEb2N1bWVudEZyYWdtZW50KG5vZGUpIHsKICAgIHJldHVybiBub2RlICYmIG5vZGUubm9kZVR5cGUgPT0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFOwogIH0KICAvKioKICAgKiBSZXR1cm5zIGB0cnVlYCB3aGVuIGBub2RlLm5vZGVUeXBlYCBlcXVhbHMgYE5vZGUuQ09NTUVOVF9OT0RFYC4KICAgKgogICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlIHRvIGNoZWNrLgogICAqIEByZXR1cm5zIHtCb29sZWFufQogICAqLwoKCiAgaXNDb21tZW50KG5vZGUpIHsKICAgIHJldHVybiBub2RlICYmIG5vZGUubm9kZVR5cGUgPT0gTm9kZS5DT01NRU5UX05PREU7CiAgfQogIC8qKgogICAqIENoZWNrcyBpZiB0aGUgbm9kZSBpcyBhbiBpbnN0YW5jZSBvZiB0aGUgYmxvY2sgZmlsbGVyIGZvciB0aGlzIERPTSBjb252ZXJ0ZXIuCiAgICoKICAgKgkJY29uc3QgY29udmVydGVyID0gbmV3IERvbUNvbnZlcnRlciggeyBibG9ja0ZpbGxlck1vZGU6ICdicicgfSApOwogICAqCiAgICoJCWNvbnZlcnRlci5pc0Jsb2NrRmlsbGVyKCBCUl9GSUxMRVIoIGRvY3VtZW50ICkgKTsgLy8gdHJ1ZQogICAqCQljb252ZXJ0ZXIuaXNCbG9ja0ZpbGxlciggTkJTUF9GSUxMRVIoIGRvY3VtZW50ICkgKTsgLy8gZmFsc2UKICAgKgogICAqICoqTm90ZToqKjogRm9yIHRoZSBgJ25ic3AnYCBtb2RlIHRoZSBtZXRob2QgYWxzbyBjaGVja3MgY29udGV4dCBvZiBhIG5vZGUgc28gaXQgY2Fubm90IGJlIGEgZGV0YWNoZWQgbm9kZS4KICAgKgogICAqICoqTm90ZToqKiBBIHNwZWNpYWwgY2FzZSBpbiB0aGUgYCduYnNwJ2AgbW9kZSBleGlzdHMgd2hlcmUgdGhlIGA8YnI+YCBpbiBgPHA+PGJyPjwvcD5gIGlzIHRyZWF0ZWQgYXMgYSBibG9jayBmaWxsZXIuCiAgICoKICAgKiBAcGFyYW0ge05vZGV9IGRvbU5vZGUgRE9NIG5vZGUgdG8gY2hlY2suCiAgICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgYSBub2RlIGlzIGNvbnNpZGVyZWQgYSBibG9jayBmaWxsZXIgZm9yIGdpdmVuIG1vZGUuCiAgICovCgoKICBpc0Jsb2NrRmlsbGVyKGRvbU5vZGUpIHsKICAgIGlmICh0aGlzLmJsb2NrRmlsbGVyTW9kZSA9PSAnYnInKSB7CiAgICAgIHJldHVybiBkb21Ob2RlLmlzRXF1YWxOb2RlKEJSX0ZJTExFUl9SRUYpOwogICAgfSAvLyBTcGVjaWFsIGNhc2UgZm9yIDxwPjxicj48L3A+IGluIHdoaWNoIGNhc2UgdGhlIDxicj4gc2hvdWxkIGJlIHRyZWF0ZWQgYXMgZmlsbGVyIGV2ZW4KICAgIC8vIHdoZW4gd2UncmUgaW4gdGhlICduYnNwJyBtb2RlLiBTZWUgY2tlZGl0b3I1IzU1NjQuCgoKICAgIGlmIChkb21Ob2RlLnRhZ05hbWUgPT09ICdCUicgJiYgaGFzQmxvY2tQYXJlbnQoZG9tTm9kZSwgdGhpcy5ibG9ja0VsZW1lbnRzKSAmJiBkb21Ob2RlLnBhcmVudE5vZGUuY2hpbGROb2Rlcy5sZW5ndGggPT09IDEpIHsKICAgICAgcmV0dXJuIHRydWU7CiAgICB9CgogICAgcmV0dXJuIGlzTmJzcEJsb2NrRmlsbGVyKGRvbU5vZGUsIHRoaXMuYmxvY2tFbGVtZW50cyk7CiAgfQogIC8qKgogICAqIFJldHVybnMgYHRydWVgIGlmIGdpdmVuIHNlbGVjdGlvbiBpcyBhIGJhY2t3YXJkIHNlbGVjdGlvbiwgdGhhdCBpcywgaWYgaXQncyBgZm9jdXNgIGlzIGJlZm9yZSBgYW5jaG9yYC4KICAgKgogICAqIEBwYXJhbSB7U2VsZWN0aW9ufSBET00gU2VsZWN0aW9uIGluc3RhbmNlIHRvIGNoZWNrLgogICAqIEByZXR1cm5zIHtCb29sZWFufQogICAqLwoKCiAgaXNEb21TZWxlY3Rpb25CYWNrd2FyZChzZWxlY3Rpb24pIHsKICAgIGlmIChzZWxlY3Rpb24uaXNDb2xsYXBzZWQpIHsKICAgICAgcmV0dXJuIGZhbHNlOwogICAgfSAvLyBTaW5jZSBpdCB0YWtlcyBtdWx0aXBsZSBsaW5lcyBvZiBjb2RlIHRvIGNoZWNrIHdoZXRoZXIgYSAiRE9NIFBvc2l0aW9uIiBpcyBiZWZvcmUvYWZ0ZXIgYW5vdGhlciAiRE9NIFBvc2l0aW9uIiwKICAgIC8vIHdlIHdpbGwgdXNlIHRoZSBmYWN0IHRoYXQgcmFuZ2Ugd2lsbCBjb2xsYXBzZSBpZiBpdCdzIGVuZCBpcyBiZWZvcmUgaXQncyBzdGFydC4KCgogICAgY29uc3QgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpOwogICAgcmFuZ2Uuc2V0U3RhcnQoc2VsZWN0aW9uLmFuY2hvck5vZGUsIHNlbGVjdGlvbi5hbmNob3JPZmZzZXQpOwogICAgcmFuZ2Uuc2V0RW5kKHNlbGVjdGlvbi5mb2N1c05vZGUsIHNlbGVjdGlvbi5mb2N1c09mZnNldCk7CiAgICBjb25zdCBiYWNrd2FyZCA9IHJhbmdlLmNvbGxhcHNlZDsKICAgIHJhbmdlLmRldGFjaCgpOwogICAgcmV0dXJuIGJhY2t3YXJkOwogIH0KICAvKioKICAgKiBSZXR1cm5zIHBhcmVudCB7QGxpbmsgbW9kdWxlOmVuZ2luZS92aWV3L3VpZWxlbWVudH5VSUVsZW1lbnR9IGZvciBwcm92aWRlZCBET00gbm9kZS4gUmV0dXJucyBgbnVsbGAgaWYgdGhlcmUgaXMgbm8KICAgKiBwYXJlbnQgVUlFbGVtZW50LgogICAqCiAgICogQHBhcmFtIHtOb2RlfSBkb21Ob2RlCiAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy91aWVsZW1lbnR+VUlFbGVtZW50fG51bGx9CiAgICovCgoKICBnZXRQYXJlbnRVSUVsZW1lbnQoZG9tTm9kZSkgewogICAgY29uc3QgYW5jZXN0b3JzID0gZ2V0QW5jZXN0b3JzKGRvbU5vZGUpOyAvLyBSZW1vdmUgZG9tTm9kZSBmcm9tIHRoZSBsaXN0LgoKICAgIGFuY2VzdG9ycy5wb3AoKTsKCiAgICB3aGlsZSAoYW5jZXN0b3JzLmxlbmd0aCkgewogICAgICBjb25zdCBkb21Ob2RlID0gYW5jZXN0b3JzLnBvcCgpOwoKICAgICAgY29uc3Qgdmlld05vZGUgPSB0aGlzLl9kb21Ub1ZpZXdNYXBwaW5nLmdldChkb21Ob2RlKTsKCiAgICAgIGlmICh2aWV3Tm9kZSAmJiB2aWV3Tm9kZS5pcygndWlFbGVtZW50JykpIHsKICAgICAgICByZXR1cm4gdmlld05vZGU7CiAgICAgIH0KICAgIH0KCiAgICByZXR1cm4gbnVsbDsKICB9CiAgLyoqCiAgICogQ2hlY2tzIGlmIGdpdmVuIHNlbGVjdGlvbidzIGJvdW5kYXJpZXMgYXJlIGF0IGNvcnJlY3QgcGxhY2VzLgogICAqCiAgICogVGhlIGZvbGxvd2luZyBwbGFjZXMgYXJlIGNvbnNpZGVyZWQgYXMgaW5jb3JyZWN0IGZvciBzZWxlY3Rpb24gYm91bmRhcmllczoKICAgKiAqIGJlZm9yZSBvciBpbiB0aGUgbWlkZGxlIG9mIHRoZSBpbmxpbmUgZmlsbGVyIHNlcXVlbmNlLAogICAqICogaW5zaWRlIHRoZSBET00gZWxlbWVudCB3aGljaCByZXByZXNlbnRzIHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdWllbGVtZW50flVJRWxlbWVudCBhIHZpZXcgdWkgZWxlbWVudH0uCiAgICoKICAgKiBAcGFyYW0ge1NlbGVjdGlvbn0gZG9tU2VsZWN0aW9uIERPTSBTZWxlY3Rpb24gb2JqZWN0IHRvIGJlIGNoZWNrZWQuCiAgICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgZ2l2ZW4gc2VsZWN0aW9uIGlzIGF0IGEgY29ycmVjdCBwbGFjZSwgYGZhbHNlYCBvdGhlcndpc2UuCiAgICovCgoKICBpc0RvbVNlbGVjdGlvbkNvcnJlY3QoZG9tU2VsZWN0aW9uKSB7CiAgICByZXR1cm4gdGhpcy5faXNEb21TZWxlY3Rpb25Qb3NpdGlvbkNvcnJlY3QoZG9tU2VsZWN0aW9uLmFuY2hvck5vZGUsIGRvbVNlbGVjdGlvbi5hbmNob3JPZmZzZXQpICYmIHRoaXMuX2lzRG9tU2VsZWN0aW9uUG9zaXRpb25Db3JyZWN0KGRvbVNlbGVjdGlvbi5mb2N1c05vZGUsIGRvbVNlbGVjdGlvbi5mb2N1c09mZnNldCk7CiAgfQogIC8qKgogICAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gRE9NIHBvc2l0aW9uIGlzIGEgY29ycmVjdCBwbGFjZSBmb3Igc2VsZWN0aW9uIGJvdW5kYXJ5LiBTZWUge0BsaW5rICNpc0RvbVNlbGVjdGlvbkNvcnJlY3R9LgogICAqCiAgICogQHByaXZhdGUKICAgKiBAcGFyYW0ge0VsZW1lbnR9IGRvbVBhcmVudCBQb3NpdGlvbiBwYXJlbnQuCiAgICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBQb3NpdGlvbiBvZmZzZXQuCiAgICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiBnaXZlbiBwb3NpdGlvbiBpcyBhdCBhIGNvcnJlY3QgcGxhY2UgZm9yIHNlbGVjdGlvbiBib3VuZGFyeSwgYGZhbHNlYCBvdGhlcndpc2UuCiAgICovCgoKICBfaXNEb21TZWxlY3Rpb25Qb3NpdGlvbkNvcnJlY3QoZG9tUGFyZW50LCBvZmZzZXQpIHsKICAgIC8vIElmIHNlbGVjdGlvbiBpcyBiZWZvcmUgb3IgaW4gdGhlIG1pZGRsZSBvZiBpbmxpbmUgZmlsbGVyIHN0cmluZywgaXQgaXMgaW5jb3JyZWN0LgogICAgaWYgKGlzVGV4dChkb21QYXJlbnQpICYmIHN0YXJ0c1dpdGhGaWxsZXIoZG9tUGFyZW50KSAmJiBvZmZzZXQgPCBJTkxJTkVfRklMTEVSX0xFTkdUSCkgewogICAgICAvLyBTZWxlY3Rpb24gaW4gYSB0ZXh0IG5vZGUsIGF0IHdyb25nIHBvc2l0aW9uIChiZWZvcmUgb3IgaW4gdGhlIG1pZGRsZSBvZiBmaWxsZXIpLgogICAgICByZXR1cm4gZmFsc2U7CiAgICB9CgogICAgaWYgKHRoaXMuaXNFbGVtZW50KGRvbVBhcmVudCkgJiYgc3RhcnRzV2l0aEZpbGxlcihkb21QYXJlbnQuY2hpbGROb2Rlc1tvZmZzZXRdKSkgewogICAgICAvLyBTZWxlY3Rpb24gaW4gYW4gZWxlbWVudCBub2RlLCBiZWZvcmUgZmlsbGVyIHRleHQgbm9kZS4KICAgICAgcmV0dXJuIGZhbHNlOwogICAgfQoKICAgIGNvbnN0IHZpZXdQYXJlbnQgPSB0aGlzLm1hcERvbVRvVmlldyhkb21QYXJlbnQpOyAvLyBJZiBzZWxlY3Rpb24gaXMgaW4gYHZpZXcuVUlFbGVtZW50YCwgaXQgaXMgaW5jb3JyZWN0LiBOb3RlIHRoYXQgYG1hcERvbVRvVmlldygpYCByZXR1cm5zIGB2aWV3LlVJRWxlbWVudGAKICAgIC8vIGFsc28gZm9yIGFueSBkb20gZWxlbWVudCB0aGF0IGlzIGluc2lkZSB0aGUgdmlldyB1aSBlbGVtZW50IChzbyB3ZSBkb24ndCBuZWVkIHRvIHBlcmZvcm0gYW55IGFkZGl0aW9uYWwgY2hlY2tzKS4KCiAgICBpZiAodmlld1BhcmVudCAmJiB2aWV3UGFyZW50LmlzKCd1aUVsZW1lbnQnKSkgewogICAgICByZXR1cm4gZmFsc2U7CiAgICB9CgogICAgcmV0dXJuIHRydWU7CiAgfQogIC8qKgogICAqIFRha2VzIHRleHQgZGF0YSBmcm9tIGEgZ2l2ZW4ge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy90ZXh0flRleHQjZGF0YX0gYW5kIHByb2Nlc3NlcyBpdCBzbwogICAqIGl0IGlzIGNvcnJlY3RseSBkaXNwbGF5ZWQgaW4gdGhlIERPTS4KICAgKgogICAqIEZvbGxvd2luZyBjaGFuZ2VzIGFyZSBkb25lOgogICAqCiAgICogKiBhIHNwYWNlIGF0IHRoZSBiZWdpbm5pbmcgaXMgY2hhbmdlZCB0byBgJm5ic3A7YCBpZiB0aGlzIGlzIHRoZSBmaXJzdCB0ZXh0IG5vZGUgaW4gaXRzIGNvbnRhaW5lcgogICAqIGVsZW1lbnQgb3IgaWYgYSBwcmV2aW91cyB0ZXh0IG5vZGUgZW5kcyB3aXRoIGEgc3BhY2UgY2hhcmFjdGVyLAogICAqICogc3BhY2UgYXQgdGhlIGVuZCBvZiB0aGUgdGV4dCBub2RlIGlzIGNoYW5nZWQgdG8gYCZuYnNwO2AgaWYgdGhlcmUgYXJlIHR3byBzcGFjZXMgYXQgdGhlIGVuZCBvZiBhIG5vZGUgb3IgaWYgbmV4dCBub2RlCiAgICogc3RhcnRzIHdpdGggYSBzcGFjZSBvciBpZiBpdCBpcyB0aGUgbGFzdCB0ZXh0IG5vZGUgaW4gaXRzIGNvbnRhaW5lciwKICAgKiAqIHJlbWFpbmluZyBzcGFjZXMgYXJlIHJlcGxhY2VkIHRvIGEgY2hhaW4gb2Ygc3BhY2VzIGFuZCBgJm5ic3A7YCAoZS5nLiBgJ3ggICB4J2AgYmVjb21lcyBgJ3ggJm5ic3A7IHgnYCkuCiAgICoKICAgKiBDb250ZW50IG9mIHtAbGluayAjcHJlRWxlbWVudHN9IGlzIG5vdCBwcm9jZXNzZWQuCiAgICoKICAgKiBAcHJpdmF0ZQogICAqIEBwYXJhbSB7bW9kdWxlOmVuZ2luZS92aWV3L3RleHR+VGV4dH0gbm9kZSBWaWV3IHRleHQgbm9kZSB0byBwcm9jZXNzLgogICAqIEByZXR1cm5zIHtTdHJpbmd9IFByb2Nlc3NlZCB0ZXh0IGRhdGEuCiAgICovCgoKICBfcHJvY2Vzc0RhdGFGcm9tVmlld1RleHQobm9kZSkgewogICAgbGV0IGRhdGEgPSBub2RlLmRhdGE7IC8vIElmIGFueSBvZiBub2RlIGFuY2VzdG9ycyBoYXMgYSBuYW1lIHdoaWNoIGlzIGluIGBwcmVFbGVtZW50c2AgYXJyYXksIHRoZW4gY3VycmVudGx5IHByb2Nlc3NlZAogICAgLy8gdmlldyB0ZXh0IG5vZGUgaXMgKHdpbGwgYmUpIGluIHByZWZvcm1hdHRlZCBlbGVtZW50LiBXZSBzaG91bGQgbm90IGNoYW5nZSB3aGl0ZXNwYWNlcyB0aGVuLgoKICAgIGlmIChub2RlLmdldEFuY2VzdG9ycygpLnNvbWUocGFyZW50ID0+IHRoaXMucHJlRWxlbWVudHMuaW5jbHVkZXMocGFyZW50Lm5hbWUpKSkgewogICAgICByZXR1cm4gZGF0YTsKICAgIH0gLy8gMS4gUmVwbGFjZSB0aGUgZmlyc3Qgc3BhY2Ugd2l0aCBhIG5ic3AgaWYgdGhlIHByZXZpb3VzIG5vZGUgZW5kcyB3aXRoIGEgc3BhY2Ugb3IgdGhlcmUgaXMgbm8gcHJldmlvdXMgbm9kZQogICAgLy8gKGNvbnRhaW5lciBlbGVtZW50IGJvdW5kYXJ5KS4KCgogICAgaWYgKGRhdGEuY2hhckF0KDApID09ICcgJykgewogICAgICBjb25zdCBwcmV2Tm9kZSA9IHRoaXMuX2dldFRvdWNoaW5nVmlld1RleHROb2RlKG5vZGUsIGZhbHNlKTsKCiAgICAgIGNvbnN0IHByZXZFbmRzV2l0aFNwYWNlID0gcHJldk5vZGUgJiYgdGhpcy5fbm9kZUVuZHNXaXRoU3BhY2UocHJldk5vZGUpOwoKICAgICAgaWYgKHByZXZFbmRzV2l0aFNwYWNlIHx8ICFwcmV2Tm9kZSkgewogICAgICAgIGRhdGEgPSAnXHUwMEEwJyArIGRhdGEuc3Vic3RyKDEpOwogICAgICB9CiAgICB9IC8vIDIuIFJlcGxhY2UgdGhlIGxhc3Qgc3BhY2Ugd2l0aCBuYnNwIGlmIHRoZXJlIGFyZSB0d28gc3BhY2VzIGF0IHRoZSBlbmQgb3IgaWYgdGhlIG5leHQgbm9kZSBzdGFydHMgd2l0aCBzcGFjZSBvciB0aGVyZSBpcyBubwogICAgLy8gbmV4dCBub2RlIChjb250YWluZXIgZWxlbWVudCBib3VuZGFyeSkuCiAgICAvLwogICAgLy8gS2VlcCBpbiBtaW5kIHRoYXQgRmlyZWZveCBwcmVmZXJzICRuYnNwOyBiZWZvcmUgdGFnLCBub3QgaW5zaWRlIGl0OgogICAgLy8KICAgIC8vIEZvbyA8c3Bhbj4mbmJzcDtiYXI8L3NwYW4+ICA8LS0gYmFkLgogICAgLy8gRm9vJm5ic3A7PHNwYW4+IGJhcjwvc3Bhbj4gIDwtLSBnb29kLgogICAgLy8KICAgIC8vIE1vcmUgaGVyZTogaHR0cHM6Ly9naXRodWIuY29tL2NrZWRpdG9yL2NrZWRpdG9yNS1lbmdpbmUvaXNzdWVzLzE3NDcuCgoKICAgIGlmIChkYXRhLmNoYXJBdChkYXRhLmxlbmd0aCAtIDEpID09ICcgJykgewogICAgICBjb25zdCBuZXh0Tm9kZSA9IHRoaXMuX2dldFRvdWNoaW5nVmlld1RleHROb2RlKG5vZGUsIHRydWUpOwoKICAgICAgaWYgKGRhdGEuY2hhckF0KGRhdGEubGVuZ3RoIC0gMikgPT0gJyAnIHx8ICFuZXh0Tm9kZSB8fCBuZXh0Tm9kZS5kYXRhLmNoYXJBdCgwKSA9PSAnICcpIHsKICAgICAgICBkYXRhID0gZGF0YS5zdWJzdHIoMCwgZGF0YS5sZW5ndGggLSAxKSArICdcdTAwQTAnOwogICAgICB9CiAgICB9IC8vIDMuIENyZWF0ZSBzcGFjZStuYnNwIHBhaXJzLgoKCiAgICByZXR1cm4gZGF0YS5yZXBsYWNlKC8gezJ9L2csICcgXHUwMEEwJyk7CiAgfQogIC8qKgogICAqIENoZWNrcyB3aGV0aGVyIGdpdmVuIG5vZGUgZW5kcyB3aXRoIGEgc3BhY2UgY2hhcmFjdGVyIGFmdGVyIGNoYW5naW5nIGFwcHJvcHJpYXRlIHNwYWNlIGNoYXJhY3RlcnMgdG8gYCZuYnNwO2BzLgogICAqCiAgICogQHByaXZhdGUKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy90ZXh0flRleHR9IG5vZGUgTm9kZSB0byBjaGVjay4KICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIGdpdmVuIGBub2RlYCBlbmRzIHdpdGggc3BhY2UsIGBmYWxzZWAgb3RoZXJ3aXNlLgogICAqLwoKCiAgX25vZGVFbmRzV2l0aFNwYWNlKG5vZGUpIHsKICAgIGlmIChub2RlLmdldEFuY2VzdG9ycygpLnNvbWUocGFyZW50ID0+IHRoaXMucHJlRWxlbWVudHMuaW5jbHVkZXMocGFyZW50Lm5hbWUpKSkgewogICAgICByZXR1cm4gZmFsc2U7CiAgICB9CgogICAgY29uc3QgZGF0YSA9IHRoaXMuX3Byb2Nlc3NEYXRhRnJvbVZpZXdUZXh0KG5vZGUpOwoKICAgIHJldHVybiBkYXRhLmNoYXJBdChkYXRhLmxlbmd0aCAtIDEpID09ICcgJzsKICB9CiAgLyoqCiAgICogVGFrZXMgdGV4dCBkYXRhIGZyb20gbmF0aXZlIGBUZXh0YCBub2RlIGFuZCBwcm9jZXNzZXMgaXQgdG8gYSBjb3JyZWN0IHtAbGluayBtb2R1bGU6ZW5naW5lL3ZpZXcvdGV4dH5UZXh0IHZpZXcgdGV4dCBub2RlfSBkYXRhLgogICAqCiAgICogRm9sbG93aW5nIGNoYW5nZXMgYXJlIGRvbmU6CiAgICoKICAgKiAqIG11bHRpcGxlIHdoaXRlc3BhY2VzIGFyZSByZXBsYWNlZCB0byBhIHNpbmdsZSBzcGFjZSwKICAgKiAqIHNwYWNlIGF0IHRoZSBiZWdpbm5pbmcgb2YgYSB0ZXh0IG5vZGUgaXMgcmVtb3ZlZCBpZiBpdCBpcyB0aGUgZmlyc3QgdGV4dCBub2RlIGluIGl0cyBjb250YWluZXIKICAgKiBlbGVtZW50IG9yIGlmIHRoZSBwcmV2aW91cyB0ZXh0IG5vZGUgZW5kcyB3aXRoIGEgc3BhY2UgY2hhcmFjdGVyLAogICAqICogc3BhY2UgYXQgdGhlIGVuZCBvZiB0aGUgdGV4dCBub2RlIGlzIHJlbW92ZWQgaWYgdGhlcmUgYXJlIHR3byBzcGFjZXMgYXQgdGhlIGVuZCBvZiBhIG5vZGUgb3IgaWYgbmV4dCBub2RlCiAgICogc3RhcnRzIHdpdGggYSBzcGFjZSBvciBpZiBpdCBpcyB0aGUgbGFzdCB0ZXh0IG5vZGUgaW4gaXRzIGNvbnRhaW5lcgogICAqICogbmJzcHMgYXJlIGNvbnZlcnRlZCB0byBzcGFjZXMuCiAgICoKICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgRE9NIHRleHQgbm9kZSB0byBwcm9jZXNzLgogICAqIEByZXR1cm5zIHtTdHJpbmd9IFByb2Nlc3NlZCBkYXRhLgogICAqIEBwcml2YXRlCiAgICovCgoKICBfcHJvY2Vzc0RhdGFGcm9tRG9tVGV4dChub2RlKSB7CiAgICBsZXQgZGF0YSA9IG5vZGUuZGF0YTsKCiAgICBpZiAoX2hhc0RvbVBhcmVudE9mVHlwZShub2RlLCB0aGlzLnByZUVsZW1lbnRzKSkgewogICAgICByZXR1cm4gZ2V0RGF0YVdpdGhvdXRGaWxsZXIobm9kZSk7CiAgICB9IC8vIENoYW5nZSBhbGwgY29uc2VjdXRpdmUgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzIChmcm9tIHRoZSBbIFxuXHRccl0gc2V0IOKAkwogICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ja2VkaXRvci9ja2VkaXRvcjUtZW5naW5lL2lzc3Vlcy84MjIjaXNzdWVjb21tZW50LTMxMTY3MDI0OSkgdG8gYSBzaW5nbGUgc3BhY2UgY2hhcmFjdGVyLgogICAgLy8gVGhhdCdzIGhvdyBtdWx0aXBsZSB3aGl0ZXNwYWNlcyBhcmUgdHJlYXRlZCB3aGVuIHJlbmRlcmVkLCBzbyB3ZSBub3JtYWxpemUgdGhvc2Ugd2hpdGVzcGFjZXMuCiAgICAvLyBXZSdyZSByZXBsYWNpbmcgMSsgKGFuZCBub3QgMispIHRvIGFsc28gbm9ybWFsaXplIHNpbmd1bGFyIFxuXHRcciBjaGFyYWN0ZXJzICgjODIyKS4KCgogICAgZGF0YSA9IGRhdGEucmVwbGFjZSgvWyBcblx0XHJdezEsfS9nLCAnICcpOwoKICAgIGNvbnN0IHByZXZOb2RlID0gdGhpcy5fZ2V0VG91Y2hpbmdJbmxpbmVEb21Ob2RlKG5vZGUsIGZhbHNlKTsKCiAgICBjb25zdCBuZXh0Tm9kZSA9IHRoaXMuX2dldFRvdWNoaW5nSW5saW5lRG9tTm9kZShub2RlLCB0cnVlKTsKCiAgICBjb25zdCBzaG91bGRMZWZ0VHJpbSA9IHRoaXMuX2NoZWNrU2hvdWxkTGVmdFRyaW1Eb21UZXh0KHByZXZOb2RlKTsKCiAgICBjb25zdCBzaG91bGRSaWdodFRyaW0gPSB0aGlzLl9jaGVja1Nob3VsZFJpZ2h0VHJpbURvbVRleHQobm9kZSwgbmV4dE5vZGUpOyAvLyBJZiB0aGUgcHJldmlvdXMgZG9tIHRleHQgbm9kZSBkb2VzIG5vdCBleGlzdCBvciBpdCBlbmRzIGJ5IHdoaXRlc3BhY2UgY2hhcmFjdGVyLCByZW1vdmUgc3BhY2UgY2hhcmFjdGVyIGZyb20gdGhlIGJlZ2lubmluZwogICAgLy8gb2YgdGhpcyB0ZXh0IG5vZGUuIFN1Y2ggc3BhY2UgY2hhcmFjdGVyIGlzIHRyZWF0ZWQgYXMgYSB3aGl0ZXNwYWNlLgoKCiAgICBpZiAoc2hvdWxkTGVmdFRyaW0pIHsKICAgICAgZGF0YSA9IGRhdGEucmVwbGFjZSgvXiAvLCAnJyk7CiAgICB9IC8vIElmIHRoZSBuZXh0IHRleHQgbm9kZSBkb2VzIG5vdCBleGlzdCByZW1vdmUgc3BhY2UgY2hhcmFjdGVyIGZyb20gdGhlIGVuZCBvZiB0aGlzIHRleHQgbm9kZS4KCgogICAgaWYgKHNob3VsZFJpZ2h0VHJpbSkgewogICAgICBkYXRhID0gZGF0YS5yZXBsYWNlKC8gJC8sICcnKTsKICAgIH0gLy8gQXQgdGhlIGJlZ2lubmluZyBhbmQgZW5kIG9mIGEgYmxvY2sgZWxlbWVudCwgRmlyZWZveCBpbnNlcnRzIG5vcm1hbCBzcGFjZSArIDxicj4gaW5zdGVhZCBvZiBub24tYnJlYWtpbmcgc3BhY2UuCiAgICAvLyBUaGlzIG1lYW5zIHRoYXQgdGhlIHRleHQgbm9kZSBzdGFydHMvZW5kIHdpdGggbm9ybWFsIHNwYWNlIGluc3RlYWQgb2Ygbm9uLWJyZWFraW5nIHNwYWNlLgogICAgLy8gVGhpcyBjYXVzZXMgYSBwcm9ibGVtIGJlY2F1c2UgdGhlIG5vcm1hbCBzcGFjZSB3b3VsZCBiZSByZW1vdmVkIGluIGAucmVwbGFjZWAgY2FsbHMgYWJvdmUuIFRvIHByZXZlbnQgdGhhdCwKICAgIC8vIHRoZSBpbmxpbmUgZmlsbGVyIGlzIHJlbW92ZWQgb25seSBhZnRlciB0aGUgZGF0YSBpcyBpbml0aWFsbHkgcHJvY2Vzc2VkIChieSB0aGUgYC5yZXBsYWNlYCBhYm92ZSkuIFNlZSBja2VkaXRvcjUjNjkyLgoKCiAgICBkYXRhID0gZ2V0RGF0YVdpdGhvdXRGaWxsZXIobmV3IFRleHQoZGF0YSkpOyAvLyBBdCB0aGlzIHBvaW50IHdlIHNob3VsZCBoYXZlIHJlbW92ZWQgYWxsIHdoaXRlc3BhY2VzIGZyb20gRE9NIHRleHQgZGF0YS4KICAgIC8vCiAgICAvLyBOb3csIFdlIHdpbGwgcmV2ZXJzZSB0aGUgcHJvY2VzcyB0aGF0IGhhcHBlbnMgaW4gYF9wcm9jZXNzRGF0YUZyb21WaWV3VGV4dGAuCiAgICAvLwogICAgLy8gV2UgaGF2ZSB0byBjaGFuZ2UgJm5ic3A7IGNoYXJzLCB0aGF0IHdlcmUgaW4gRE9NIHRleHQgZGF0YSBiZWNhdXNlIG9mIHJlbmRlcmluZyByZWFzb25zLCB0byBzcGFjZXMuCiAgICAvLyBGaXJzdCwgY2hhbmdlIGFsbCBgIFx1MDBBMGAgcGFpcnMgKHNwYWNlICsgJm5ic3A7KSB0byB0d28gc3BhY2VzLiBET00gY29udmVydGVyIGNoYW5nZXMgdHdvIHNwYWNlcyBmcm9tIG1vZGVsL3ZpZXcgdG8KICAgIC8vIGAgXHUwMEEwYCB0byBlbnN1cmUgcHJvcGVyIHJlbmRlcmluZy4gU2luY2UgaGVyZSB3ZSBjb252ZXJ0IGJhY2ssIHdlIHJlY29nbml6ZSB0aG9zZSBwYWlycyBhbmQgY2hhbmdlIHRoZW0gYmFjayB0byBgICBgLgoKICAgIGRhdGEgPSBkYXRhLnJlcGxhY2UoLyBcdTAwQTAvZywgJyAgJyk7IC8vIFRoZW4sIGxldCdzIGNoYW5nZSB0aGUgbGFzdCBuYnNwIHRvIGEgc3BhY2UuCgogICAgaWYgKC8oIHxcdTAwQTApXHUwMEEwJC8udGVzdChkYXRhKSB8fCAhbmV4dE5vZGUgfHwgbmV4dE5vZGUuZGF0YSAmJiBuZXh0Tm9kZS5kYXRhLmNoYXJBdCgwKSA9PSAnICcpIHsKICAgICAgZGF0YSA9IGRhdGEucmVwbGFjZSgvXHUwMEEwJC8sICcgJyk7CiAgICB9IC8vIFRoZW4sIGNoYW5nZSAmbmJzcDsgY2hhcmFjdGVyIHRoYXQgaXMgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgdGV4dCBub2RlIHRvIHNwYWNlIGNoYXJhY3Rlci4KICAgIC8vIFdlIGRvIHRoYXQgcmVwbGFjZW1lbnQgb25seSBpZiB0aGlzIGlzIHRoZSBmaXJzdCBub2RlIG9yIHRoZSBwcmV2aW91cyBub2RlIGVuZHMgb24gd2hpdGVzcGFjZSBjaGFyYWN0ZXIuCgoKICAgIGlmIChzaG91bGRMZWZ0VHJpbSkgewogICAgICBkYXRhID0gZGF0YS5yZXBsYWNlKC9eXHUwMEEwLywgJyAnKTsKICAgIH0gLy8gQXQgdGhpcyBwb2ludCwgYWxsIHdoaXRlc3BhY2VzIHNob3VsZCBiZSByZW1vdmVkIGFuZCBhbGwgJm5ic3A7IGNyZWF0ZWQgZm9yIHJlbmRlcmluZyByZWFzb25zIHNob3VsZCBiZQogICAgLy8gY2hhbmdlZCB0byBub3JtYWwgc3BhY2UuIEFsbCBsZWZ0ICZuYnNwOyBhcmUgJm5ic3A7IGluc2VydGVkIGludGVudGlvbmFsbHkuCgoKICAgIHJldHVybiBkYXRhOwogIH0KICAvKioKICAgKiBIZWxwZXIgZnVuY3Rpb24gd2hpY2ggY2hlY2tzIGlmIGEgRE9NIHRleHQgbm9kZSwgcHJlY2VkZWQgYnkgdGhlIGdpdmVuIGBwcmV2Tm9kZWAgc2hvdWxkCiAgICogYmUgdHJpbW1lZCBmcm9tIHRoZSBsZWZ0IHNpZGUuCiAgICoKICAgKiBAcGFyYW0ge05vZGV9IHByZXZOb2RlCiAgICovCgoKICBfY2hlY2tTaG91bGRMZWZ0VHJpbURvbVRleHQocHJldk5vZGUpIHsKICAgIGlmICghcHJldk5vZGUpIHsKICAgICAgcmV0dXJuIHRydWU7CiAgICB9CgogICAgaWYgKGlzRWxlbWVudChwcmV2Tm9kZSkpIHsKICAgICAgcmV0dXJuIHRydWU7CiAgICB9CgogICAgcmV0dXJuIC9bXlxTXHUwMEEwXS8udGVzdChwcmV2Tm9kZS5kYXRhLmNoYXJBdChwcmV2Tm9kZS5kYXRhLmxlbmd0aCAtIDEpKTsKICB9CiAgLyoqCiAgICogSGVscGVyIGZ1bmN0aW9uIHdoaWNoIGNoZWNrcyBpZiBhIERPTSB0ZXh0IG5vZGUsIHN1Y2NlZWRlZCBieSB0aGUgZ2l2ZW4gYG5leHROb2RlYCBzaG91bGQKICAgKiBiZSB0cmltbWVkIGZyb20gdGhlIHJpZ2h0IHNpZGUuCiAgICoKICAgKiBAcGFyYW0ge05vZGV9IG5vZGUKICAgKiBAcGFyYW0ge05vZGV9IG5leHROb2RlCiAgICovCgoKICBfY2hlY2tTaG91bGRSaWdodFRyaW1Eb21UZXh0KG5vZGUsIG5leHROb2RlKSB7CiAgICBpZiAobmV4dE5vZGUpIHsKICAgICAgcmV0dXJuIGZhbHNlOwogICAgfQoKICAgIHJldHVybiAhc3RhcnRzV2l0aEZpbGxlcihub2RlKTsKICB9CiAgLyoqCiAgICogSGVscGVyIGZ1bmN0aW9uLiBGb3IgZ2l2ZW4ge0BsaW5rIG1vZHVsZTplbmdpbmUvdmlldy90ZXh0flRleHQgdmlldyB0ZXh0IG5vZGV9LCBpdCBmaW5kcyBwcmV2aW91cyBvciBuZXh0IHNpYmxpbmcKICAgKiB0aGF0IGlzIGNvbnRhaW5lZCBpbiB0aGUgc2FtZSBjb250YWluZXIgZWxlbWVudC4gSWYgdGhlcmUgaXMgbm8gc3VjaCBzaWJsaW5nLCBgbnVsbGAgaXMgcmV0dXJuZWQuCiAgICoKICAgKiBAcGFyYW0ge21vZHVsZTplbmdpbmUvdmlldy90ZXh0flRleHR9IG5vZGUgUmVmZXJlbmNlIG5vZGUuCiAgICogQHBhcmFtIHtCb29sZWFufSBnZXROZXh0CiAgICogQHJldHVybnMge21vZHVsZTplbmdpbmUvdmlldy90ZXh0flRleHR8bnVsbH0gVG91Y2hpbmcgdGV4dCBub2RlIG9yIGBudWxsYCBpZiB0aGVyZSBpcyBubyBuZXh0IG9yIHByZXZpb3VzIHRvdWNoaW5nIHRleHQgbm9kZS4KICAgKi8KCgogIF9nZXRUb3VjaGluZ1ZpZXdUZXh0Tm9kZShub2RlLCBnZXROZXh0KSB7CiAgICBjb25zdCB0cmVlV2Fsa2VyID0gbmV3IFZpZXdUcmVlV2Fsa2VyKHsKICAgICAgc3RhcnRQb3NpdGlvbjogZ2V0TmV4dCA/IFZpZXdQb3NpdGlvbi5fY3JlYXRlQWZ0ZXIobm9kZSkgOiBWaWV3UG9zaXRpb24uX2NyZWF0ZUJlZm9yZShub2RlKSwKICAgICAgZGlyZWN0aW9uOiBnZXROZXh0ID8gJ2ZvcndhcmQnIDogJ2JhY2t3YXJkJwogICAgfSk7CgogICAgZm9yIChjb25zdCB2YWx1ZSBvZiB0cmVlV2Fsa2VyKSB7CiAgICAgIC8vIFZpZXdDb250YWluZXJFbGVtZW50IGlzIGZvdW5kIG9uIGEgd2F5IHRvIG5leHQgVmlld1RleHQgbm9kZSwgc28gZ2l2ZW4gYG5vZGVgIHdhcyBmaXJzdC9sYXN0CiAgICAgIC8vIHRleHQgbm9kZSBpbiBpdHMgY29udGFpbmVyIGVsZW1lbnQuCiAgICAgIGlmICh2YWx1ZS5pdGVtLmlzKCdjb250YWluZXJFbGVtZW50JykpIHsKICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgfSAvLyA8YnI+IGZvdW5kIOKAkyBpdCB3b3JrcyBsaWtlIGEgYmxvY2sgYm91bmRhcnksIHNvIGRvIG5vdCBzY2FuIGZ1cnRoZXIuCiAgICAgIGVsc2UgaWYgKHZhbHVlLml0ZW0uaXMoJ2JyJykpIHsKICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgIH0gLy8gRm91bmQgYSB0ZXh0IG5vZGUgaW4gdGhlIHNhbWUgY29udGFpbmVyIGVsZW1lbnQuCiAgICAgICAgZWxzZSBpZiAodmFsdWUuaXRlbS5pcygndGV4dFByb3h5JykpIHsKICAgICAgICAgICAgcmV0dXJuIHZhbHVlLml0ZW07CiAgICAgICAgICB9CiAgICB9CgogICAgcmV0dXJuIG51bGw7CiAgfQogIC8qKgogICAqIEhlbHBlciBmdW5jdGlvbi4gRm9yIHRoZSBnaXZlbiB0ZXh0IG5vZGUsIGl0IGZpbmRzIHRoZSBjbG9zZXN0IHRvdWNoaW5nIG5vZGUgd2hpY2ggaXMgZWl0aGVyCiAgICogYSB0ZXh0IG5vZGUgb3IgYSBgPGJyPmAuIFRoZSBzZWFyY2ggaXMgdGVybWluYXRlZCBhdCBibG9jayBlbGVtZW50IGJvdW5kYXJpZXMgYW5kIGlmIGEgbWF0Y2hpbmcgbm9kZQogICAqIHdhc24ndCBmb3VuZCBzbyBmYXIsIGBudWxsYCBpcyByZXR1cm5lZC4KICAgKgogICAqIEluIHRoZSBmb2xsb3dpbmcgRE9NIHN0cnVjdHVyZToKICAgKgogICAqCQk8cD5mb288Yj5iYXI8L2I+PGJyPmJvbTwvcD4KICAgKgogICAqICogYGZvb2AgZG9lc24ndCBoYXZlIGl0cyBwcmV2aW91cyB0b3VjaGluZyBpbmxpbmUgbm9kZSAoYG51bGxgIGlzIHJldHVybmVkKSwKICAgKiAqIGBmb29gJ3MgbmV4dCB0b3VjaGluZyBpbmxpbmUgbm9kZSBpcyBgYmFyYAogICAqICogYGJhcmAncyBuZXh0IHRvdWNoaW5nIGlubGluZSBub2RlIGlzIGA8YnI+YAogICAqCiAgICogVGhpcyBtZXRob2QgcmV0dXJucyB0ZXh0IG5vZGVzIGFuZCBgPGJyPmAgZWxlbWVudHMgYmVjYXVzZSB0aGVzZSB0eXBlcyBvZiBub2RlcyBhZmZlY3QgaG93CiAgICogc3BhY2VzIGluIHRoZSBnaXZlbiB0ZXh0IG5vZGUgbmVlZCB0byBiZSBjb252ZXJ0ZWQuCiAgICoKICAgKiBAcHJpdmF0ZQogICAqIEBwYXJhbSB7VGV4dH0gbm9kZQogICAqIEBwYXJhbSB7Qm9vbGVhbn0gZ2V0TmV4dAogICAqIEByZXR1cm5zIHtUZXh0fEVsZW1lbnR8bnVsbH0KICAgKi8KCgogIF9nZXRUb3VjaGluZ0lubGluZURvbU5vZGUobm9kZSwgZ2V0TmV4dCkgewogICAgaWYgKCFub2RlLnBhcmVudE5vZGUpIHsKICAgICAgcmV0dXJuIG51bGw7CiAgICB9CgogICAgY29uc3QgZGlyZWN0aW9uID0gZ2V0TmV4dCA/ICduZXh0Tm9kZScgOiAncHJldmlvdXNOb2RlJzsKICAgIGNvbnN0IGRvY3VtZW50ID0gbm9kZS5vd25lckRvY3VtZW50OwogICAgY29uc3QgdG9wbW9zdFBhcmVudCA9IGdldEFuY2VzdG9ycyhub2RlKVswXTsKICAgIGNvbnN0IHRyZWVXYWxrZXIgPSBkb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKHRvcG1vc3RQYXJlbnQsIE5vZGVGaWx0ZXIuU0hPV19URVhUIHwgTm9kZUZpbHRlci5TSE9XX0VMRU1FTlQsIHsKICAgICAgYWNjZXB0Tm9kZShub2RlKSB7CiAgICAgICAgaWYgKGlzVGV4dChub2RlKSkgewogICAgICAgICAgcmV0dXJuIE5vZGVGaWx0ZXIuRklMVEVSX0FDQ0VQVDsKICAgICAgICB9CgogICAgICAgIGlmIChub2RlLnRhZ05hbWUgPT0gJ0JSJykgewogICAgICAgICAgcmV0dXJuIE5vZGVGaWx0ZXIuRklMVEVSX0FDQ0VQVDsKICAgICAgICB9CgogICAgICAgIHJldHVybiBOb2RlRmlsdGVyLkZJTFRFUl9TS0lQOwogICAgICB9CgogICAgfSk7CiAgICB0cmVlV2Fsa2VyLmN1cnJlbnROb2RlID0gbm9kZTsKICAgIGNvbnN0IHRvdWNoaW5nTm9kZSA9IHRyZWVXYWxrZXJbZGlyZWN0aW9uXSgpOwoKICAgIGlmICh0b3VjaGluZ05vZGUgIT09IG51bGwpIHsKICAgICAgY29uc3QgbGNhID0gZ2V0Q29tbW9uQW5jZXN0b3Iobm9kZSwgdG91Y2hpbmdOb2RlKTsgLy8gSWYgdGhlcmUgaXMgY29tbW9uIGFuY2VzdG9yIGJldHdlZW4gdGhlIHRleHQgbm9kZSBhbmQgbmV4dC9wcmV2IHRleHQgbm9kZSwKICAgICAgLy8gYW5kIHRoZXJlIGFyZSBubyBibG9jayBlbGVtZW50cyBvbiBhIHdheSBmcm9tIHRoZSB0ZXh0IG5vZGUgdG8gdGhhdCBhbmNlc3RvciwKICAgICAgLy8gYW5kIHRoZXJlIGFyZSBubyBibG9jayBlbGVtZW50cyBvbiBhIHdheSBmcm9tIG5leHQvcHJldiB0ZXh0IG5vZGUgdG8gdGhhdCBhbmNlc3Rvci4uLgoKICAgICAgaWYgKGxjYSAmJiAhX2hhc0RvbVBhcmVudE9mVHlwZShub2RlLCB0aGlzLmJsb2NrRWxlbWVudHMsIGxjYSkgJiYgIV9oYXNEb21QYXJlbnRPZlR5cGUodG91Y2hpbmdOb2RlLCB0aGlzLmJsb2NrRWxlbWVudHMsIGxjYSkpIHsKICAgICAgICAvLyBUaGVuIHRoZXkgYXJlIGluIHRoZSBzYW1lIGNvbnRhaW5lciBlbGVtZW50LgogICAgICAgIHJldHVybiB0b3VjaGluZ05vZGU7CiAgICAgIH0KICAgIH0KCiAgICByZXR1cm4gbnVsbDsKICB9Cgp9IC8vIEhlbHBlciBmdW5jdGlvbi4KLy8gVXNlZCB0byBjaGVjayBpZiBnaXZlbiBuYXRpdmUgYEVsZW1lbnRgIG9yIGBUZXh0YCBub2RlIGhhcyBwYXJlbnQgd2l0aCB0YWcgbmFtZSBmcm9tIGB0eXBlc2AgYXJyYXkuCi8vCi8vIEBwYXJhbSB7Tm9kZX0gbm9kZQovLyBAcGFyYW0ge0FycmF5LjxTdHJpbmc+fSB0eXBlcwovLyBAcGFyYW0ge0Jvb2xlYW59IFtib3VuZGFyeVBhcmVudF0gQ2FuIGJlIGdpdmVuIGlmIHBhcmVudHMgc2hvdWxkIGJlIGNoZWNrZWQgdXAgdG8gYSBnaXZlbiBlbGVtZW50IChleGNsdWRpbmcgdGhhdCBlbGVtZW50KS4KLy8gQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiBzdWNoIHBhcmVudCBleGlzdHMgb3IgYGZhbHNlYCBpZiBpdCBkb2VzIG5vdC4KCmZ1bmN0aW9uIF9oYXNEb21QYXJlbnRPZlR5cGUobm9kZSwgdHlwZXMsIGJvdW5kYXJ5UGFyZW50KSB7CiAgbGV0IHBhcmVudHMgPSBnZXRBbmNlc3RvcnMobm9kZSk7CgogIGlmIChib3VuZGFyeVBhcmVudCkgewogICAgcGFyZW50cyA9IHBhcmVudHMuc2xpY2UocGFyZW50cy5pbmRleE9mKGJvdW5kYXJ5UGFyZW50KSArIDEpOwogIH0KCiAgcmV0dXJuIHBhcmVudHMuc29tZShwYXJlbnQgPT4gcGFyZW50LnRhZ05hbWUgJiYgdHlwZXMuaW5jbHVkZXMocGFyZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSkpOwp9IC8vIEEgaGVscGVyIHRoYXQgZXhlY3V0ZXMgZ2l2ZW4gY2FsbGJhY2sgZm9yIGVhY2ggRE9NIG5vZGUncyBhbmNlc3Rvciwgc3RhcnRpbmcgZnJvbSB0aGUgZ2l2ZW4gbm9kZQovLyBhbmQgZW5kaW5nIGluIGRvY3VtZW50I2RvY3VtZW50RWxlbWVudC4KLy8KLy8gQHBhcmFtIHtOb2RlfSBub2RlCi8vIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIEEgY2FsbGJhY2sgdG8gYmUgZXhlY3V0ZWQgZm9yIGVhY2ggYW5jZXN0b3IuCgoKZnVuY3Rpb24gZm9yRWFjaERvbU5vZGVBbmNlc3Rvcihub2RlLCBjYWxsYmFjaykgewogIHdoaWxlIChub2RlICYmIG5vZGUgIT0gZ2xvYmFsLmRvY3VtZW50KSB7CiAgICBjYWxsYmFjayhub2RlKTsKICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7CiAgfQp9IC8vIENoZWNrcyBpZiBnaXZlbiBub2RlIGlzIGEgbmJzcCBibG9jayBmaWxsZXIuCi8vCi8vIEEgJm5ic3A7IGlzIGEgYmxvY2sgZmlsbGVyIG9ubHkgaWYgaXQgaXMgYSBzaW5nbGUgY2hpbGQgb2YgYSBibG9jayBlbGVtZW50LgovLwovLyBAcGFyYW0ge05vZGV9IGRvbU5vZGUgRE9NIG5vZGUuCi8vIEByZXR1cm5zIHtCb29sZWFufQoKCmZ1bmN0aW9uIGlzTmJzcEJsb2NrRmlsbGVyKGRvbU5vZGUsIGJsb2NrRWxlbWVudHMpIHsKICBjb25zdCBpc05CU1AgPSBpc1RleHQoZG9tTm9kZSkgJiYgZG9tTm9kZS5kYXRhID09ICdcdTAwQTAnOwogIHJldHVybiBpc05CU1AgJiYgaGFzQmxvY2tQYXJlbnQoZG9tTm9kZSwgYmxvY2tFbGVtZW50cykgJiYgZG9tTm9kZS5wYXJlbnROb2RlLmNoaWxkTm9kZXMubGVuZ3RoID09PSAxOwp9IC8vIENoZWNrcyBpZiBkb21Ob2RlIGhhcyBibG9jayBwYXJlbnQuCi8vCi8vIEBwYXJhbSB7Tm9kZX0gZG9tTm9kZSBET00gbm9kZS4KLy8gQHJldHVybnMge0Jvb2xlYW59CgoKZnVuY3Rpb24gaGFzQmxvY2tQYXJlbnQoZG9tTm9kZSwgYmxvY2tFbGVtZW50cykgewogIGNvbnN0IHBhcmVudCA9IGRvbU5vZGUucGFyZW50Tm9kZTsKICByZXR1cm4gcGFyZW50ICYmIHBhcmVudC50YWdOYW1lICYmIGJsb2NrRWxlbWVudHMuaW5jbHVkZXMocGFyZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSk7Cn0KLyoqCiAqIEVudW0gcmVwcmVzZW50aW5nIHR5cGUgb2YgdGhlIGJsb2NrIGZpbGxlci4KICoKICogUG9zc2libGUgdmFsdWVzOgogKgogKiAqIGBicmAgLSBmb3IgYDxicj5gIGJsb2NrIGZpbGxlciB1c2VkIGluIGVkaXRpbmcgdmlldywKICogKiBgbmJzcGAgLSBmb3IgYCZuYnNwO2AgYmxvY2sgZmlsbGVycyB1c2VkIGluIHRoZSBkYXRhLgogKgogKiBAdHlwZWRlZiB7U3RyaW5nfSBtb2R1bGU6ZW5naW5lL3ZpZXcvZmlsbGVyfkJsb2NrRmlsbGVyTW9kZQogKi8="},{"version":3,"sources":["/Users/antonyching/Desktop/project/new-builder-demo/node_modules/@ckeditor/ckeditor5-engine/src/view/domconverter.js"],"names":["ViewText","ViewElement","ViewPosition","ViewRange","ViewSelection","ViewDocumentFragment","ViewTreeWalker","BR_FILLER","getDataWithoutFiller","INLINE_FILLER_LENGTH","isInlineFiller","NBSP_FILLER","startsWithFiller","global","indexOf","getAncestors","getCommonAncestor","isText","isElement","BR_FILLER_REF","document","DomConverter","constructor","options","blockFillerMode","preElements","blockElements","_blockFiller","_domToViewMapping","WeakMap","_viewToDomMapping","_fakeSelectionMapping","bindFakeSelection","domElement","viewDocumentSelection","set","fakeSelectionToView","get","bindElements","viewElement","unbindDomElement","delete","child","Array","from","childNodes","bindDocumentFragments","domFragment","viewFragment","viewToDom","viewNode","domDocument","is","textData","_processDataFromViewText","createTextNode","mapViewToDom","createDocumentFragment","bind","render","hasAttribute","createElementNS","getAttribute","name","createElement","key","getAttributeKeys","setAttribute","withChildren","undefined","viewChildrenToDom","appendChild","fillerPositionOffset","getFillerOffset","offset","childView","getChildren","viewRangeToDom","viewRange","domStart","viewPositionToDom","start","domEnd","end","domRange","createRange","setStart","parent","setEnd","viewPosition","viewParent","domParent","findCorrespondingDomText","domBefore","domAfter","nodeBefore","parentNode","nextSibling","domToView","domNode","isBlockFiller","uiElement","getParentUIElement","_processDataFromDomText","isComment","mapDomToView","isDocumentFragment","viewName","keepOriginalCase","tagName","toLowerCase","attrs","attributes","i","length","_setAttribute","value","domChildrenToView","_appendChild","domChild","viewChild","domSelectionToView","domSelection","rangeCount","container","getRangeAt","startContainer","viewSelection","isBackward","isDomSelectionBackward","viewRanges","domRangeToView","push","backward","viewStart","domPositionToView","startOffset","viewEnd","endContainer","endOffset","domOffset","_createBefore","findCorrespondingViewText","viewBefore","index","domElementOrDocumentFragment","domText","previousSibling","firstChild","getChild","documentFragmentOrElement","viewText","focus","viewEditable","domEditable","ownerDocument","activeElement","scrollX","scrollY","window","scrollPositions","forEachDomNodeAncestor","node","scrollLeft","scrollTop","shift","scrollTo","nodeType","Node","ELEMENT_NODE","DOCUMENT_FRAGMENT_NODE","COMMENT_NODE","isEqualNode","hasBlockParent","isNbspBlockFiller","selection","isCollapsed","range","anchorNode","anchorOffset","focusNode","focusOffset","collapsed","detach","ancestors","pop","isDomSelectionCorrect","_isDomSelectionPositionCorrect","data","some","includes","charAt","prevNode","_getTouchingViewTextNode","prevEndsWithSpace","_nodeEndsWithSpace","substr","nextNode","replace","_hasDomParentOfType","_getTouchingInlineDomNode","shouldLeftTrim","_checkShouldLeftTrimDomText","shouldRightTrim","_checkShouldRightTrimDomText","Text","test","getNext","treeWalker","startPosition","_createAfter","direction","item","topmostParent","createTreeWalker","NodeFilter","SHOW_TEXT","SHOW_ELEMENT","acceptNode","FILTER_ACCEPT","FILTER_SKIP","currentNode","touchingNode","lca","types","boundaryParent","parents","slice","callback","isNBSP"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2019, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * @module engine/view/domconverter\n */\n\n/* globals document, Node, NodeFilter, Text */\n\nimport ViewText from './text';\nimport ViewElement from './element';\nimport ViewPosition from './position';\nimport ViewRange from './range';\nimport ViewSelection from './selection';\nimport ViewDocumentFragment from './documentfragment';\nimport ViewTreeWalker from './treewalker';\nimport { BR_FILLER, getDataWithoutFiller, INLINE_FILLER_LENGTH, isInlineFiller, NBSP_FILLER, startsWithFiller } from './filler';\n\nimport global from '@ckeditor/ckeditor5-utils/src/dom/global';\nimport indexOf from '@ckeditor/ckeditor5-utils/src/dom/indexof';\nimport getAncestors from '@ckeditor/ckeditor5-utils/src/dom/getancestors';\nimport getCommonAncestor from '@ckeditor/ckeditor5-utils/src/dom/getcommonancestor';\nimport isText from '@ckeditor/ckeditor5-utils/src/dom/istext';\nimport { isElement } from 'lodash-es';\n\n// eslint-disable-next-line new-cap\nconst BR_FILLER_REF = BR_FILLER( document );\n\n/**\n * DomConverter is a set of tools to do transformations between DOM nodes and view nodes. It also handles\n * {@link module:engine/view/domconverter~DomConverter#bindElements binding} these nodes.\n *\n * The instance of DOMConverter is available in {@link module:engine/view/view~View#domConverter `editor.editing.view.domConverter`}.\n *\n * DomConverter does not check which nodes should be rendered (use {@link module:engine/view/renderer~Renderer}), does not keep a\n * state of a tree nor keeps synchronization between tree view and DOM tree (use {@link module:engine/view/document~Document}).\n *\n * DomConverter keeps DOM elements to View element bindings, so when the converter will be destroyed, the binding will\n * be lost. Two converters will keep separate binding maps, so one tree view can be bound with two DOM trees.\n */\nexport default class DomConverter {\n\t/**\n\t * Creates DOM converter.\n\t *\n\t * @param {Object} options Object with configuration options.\n\t * @param {module:engine/view/filler~BlockFillerMode} [options.blockFillerMode='br'] The type of the block filler to use.\n\t */\n\tconstructor( options = {} ) {\n\t\t/**\n\t\t * The mode of a block filler used by DOM converter.\n\t\t *\n\t\t * @readonly\n\t\t * @member {'br'|'nbsp'} module:engine/view/domconverter~DomConverter#blockFillerMode\n\t\t */\n\t\tthis.blockFillerMode = options.blockFillerMode || 'br';\n\n\t\t/**\n\t\t * Elements which are considered pre-formatted elements.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Array.<String>} module:engine/view/domconverter~DomConverter#preElements\n\t\t */\n\t\tthis.preElements = [ 'pre' ];\n\n\t\t/**\n\t\t * Elements which are considered block elements (and hence should be filled with a\n\t\t * {@link #isBlockFiller block filler}).\n\t\t *\n\t\t * Whether an element is considered a block element also affects handling of trailing whitespaces.\n\t\t *\n\t\t * You can extend this array if you introduce support for block elements which are not yet recognized here.\n\t\t *\n\t\t * @readonly\n\t\t * @member {Array.<String>} module:engine/view/domconverter~DomConverter#blockElements\n\t\t */\n\t\tthis.blockElements = [ 'p', 'div', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'li', 'dd', 'dt', 'figcaption' ];\n\n\t\t/**\n\t\t * Block {@link module:engine/view/filler filler} creator, which is used to create all block fillers during the\n\t\t * view to DOM conversion and to recognize block fillers during the DOM to view conversion.\n\t\t *\n\t\t * @readonly\n\t\t * @private\n\t\t * @member {Function} module:engine/view/domconverter~DomConverter#_blockFiller\n\t\t */\n\t\tthis._blockFiller = this.blockFillerMode == 'br' ? BR_FILLER : NBSP_FILLER;\n\n\t\t/**\n\t\t * DOM to View mapping.\n\t\t *\n\t\t * @private\n\t\t * @member {WeakMap} module:engine/view/domconverter~DomConverter#_domToViewMapping\n\t\t */\n\t\tthis._domToViewMapping = new WeakMap();\n\n\t\t/**\n\t\t * View to DOM mapping.\n\t\t *\n\t\t * @private\n\t\t * @member {WeakMap} module:engine/view/domconverter~DomConverter#_viewToDomMapping\n\t\t */\n\t\tthis._viewToDomMapping = new WeakMap();\n\n\t\t/**\n\t\t * Holds mapping between fake selection containers and corresponding view selections.\n\t\t *\n\t\t * @private\n\t\t * @member {WeakMap} module:engine/view/domconverter~DomConverter#_fakeSelectionMapping\n\t\t */\n\t\tthis._fakeSelectionMapping = new WeakMap();\n\t}\n\n\t/**\n\t * Binds given DOM element that represents fake selection to a **position** of a\n\t * {@link module:engine/view/documentselection~DocumentSelection document selection}.\n\t * Document selection copy is stored and can be retrieved by\n\t * {@link module:engine/view/domconverter~DomConverter#fakeSelectionToView} method.\n\t *\n\t * @param {HTMLElement} domElement\n\t * @param {module:engine/view/documentselection~DocumentSelection} viewDocumentSelection\n\t */\n\tbindFakeSelection( domElement, viewDocumentSelection ) {\n\t\tthis._fakeSelectionMapping.set( domElement, new ViewSelection( viewDocumentSelection ) );\n\t}\n\n\t/**\n\t * Returns {@link module:engine/view/selection~Selection view selection} instance corresponding to\n\t * given DOM element that represents fake selection. Returns `undefined` if binding to given DOM element does not exists.\n\t *\n\t * @param {HTMLElement} domElement\n\t * @returns {module:engine/view/selection~Selection|undefined}\n\t */\n\tfakeSelectionToView( domElement ) {\n\t\treturn this._fakeSelectionMapping.get( domElement );\n\t}\n\n\t/**\n\t * Binds DOM and View elements, so it will be possible to get corresponding elements using\n\t * {@link module:engine/view/domconverter~DomConverter#mapDomToView} and\n\t * {@link module:engine/view/domconverter~DomConverter#mapViewToDom}.\n\t *\n\t * @param {HTMLElement} domElement DOM element to bind.\n\t * @param {module:engine/view/element~Element} viewElement View element to bind.\n\t */\n\tbindElements( domElement, viewElement ) {\n\t\tthis._domToViewMapping.set( domElement, viewElement );\n\t\tthis._viewToDomMapping.set( viewElement, domElement );\n\t}\n\n\t/**\n\t * Unbinds given `domElement` from the view element it was bound to. Unbinding is deep, meaning that all children of\n\t * `domElement` will be unbound too.\n\t *\n\t * @param {HTMLElement} domElement DOM element to unbind.\n\t */\n\tunbindDomElement( domElement ) {\n\t\tconst viewElement = this._domToViewMapping.get( domElement );\n\n\t\tif ( viewElement ) {\n\t\t\tthis._domToViewMapping.delete( domElement );\n\t\t\tthis._viewToDomMapping.delete( viewElement );\n\n\t\t\t// Use Array.from because of MS Edge (#923).\n\t\t\tfor ( const child of Array.from( domElement.childNodes ) ) {\n\t\t\t\tthis.unbindDomElement( child );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Binds DOM and View document fragments, so it will be possible to get corresponding document fragments using\n\t * {@link module:engine/view/domconverter~DomConverter#mapDomToView} and\n\t * {@link module:engine/view/domconverter~DomConverter#mapViewToDom}.\n\t *\n\t * @param {DocumentFragment} domFragment DOM document fragment to bind.\n\t * @param {module:engine/view/documentfragment~DocumentFragment} viewFragment View document fragment to bind.\n\t */\n\tbindDocumentFragments( domFragment, viewFragment ) {\n\t\tthis._domToViewMapping.set( domFragment, viewFragment );\n\t\tthis._viewToDomMapping.set( viewFragment, domFragment );\n\t}\n\n\t/**\n\t * Converts view to DOM. For all text nodes, not bound elements and document fragments new items will\n\t * be created. For bound elements and document fragments function will return corresponding items.\n\t *\n\t * @param {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment} viewNode\n\t * View node or document fragment to transform.\n\t * @param {Document} domDocument Document which will be used to create DOM nodes.\n\t * @param {Object} [options] Conversion options.\n\t * @param {Boolean} [options.bind=false] Determines whether new elements will be bound.\n\t * @param {Boolean} [options.withChildren=true] If `true`, node's and document fragment's children will be converted too.\n\t * @returns {Node|DocumentFragment} Converted node or DocumentFragment.\n\t */\n\tviewToDom( viewNode, domDocument, options = {} ) {\n\t\tif ( viewNode.is( 'text' ) ) {\n\t\t\tconst textData = this._processDataFromViewText( viewNode );\n\n\t\t\treturn domDocument.createTextNode( textData );\n\t\t} else {\n\t\t\tif ( this.mapViewToDom( viewNode ) ) {\n\t\t\t\treturn this.mapViewToDom( viewNode );\n\t\t\t}\n\n\t\t\tlet domElement;\n\n\t\t\tif ( viewNode.is( 'documentFragment' ) ) {\n\t\t\t\t// Create DOM document fragment.\n\t\t\t\tdomElement = domDocument.createDocumentFragment();\n\n\t\t\t\tif ( options.bind ) {\n\t\t\t\t\tthis.bindDocumentFragments( domElement, viewNode );\n\t\t\t\t}\n\t\t\t} else if ( viewNode.is( 'uiElement' ) ) {\n\t\t\t\t// UIElement has its own render() method (see #799).\n\t\t\t\tdomElement = viewNode.render( domDocument );\n\n\t\t\t\tif ( options.bind ) {\n\t\t\t\t\tthis.bindElements( domElement, viewNode );\n\t\t\t\t}\n\n\t\t\t\treturn domElement;\n\t\t\t} else {\n\t\t\t\t// Create DOM element.\n\t\t\t\tif ( viewNode.hasAttribute( 'xmlns' ) ) {\n\t\t\t\t\tdomElement = domDocument.createElementNS( viewNode.getAttribute( 'xmlns' ), viewNode.name );\n\t\t\t\t} else {\n\t\t\t\t\tdomElement = domDocument.createElement( viewNode.name );\n\t\t\t\t}\n\n\t\t\t\tif ( options.bind ) {\n\t\t\t\t\tthis.bindElements( domElement, viewNode );\n\t\t\t\t}\n\n\t\t\t\t// Copy element's attributes.\n\t\t\t\tfor ( const key of viewNode.getAttributeKeys() ) {\n\t\t\t\t\tdomElement.setAttribute( key, viewNode.getAttribute( key ) );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( options.withChildren || options.withChildren === undefined ) {\n\t\t\t\tfor ( const child of this.viewChildrenToDom( viewNode, domDocument, options ) ) {\n\t\t\t\t\tdomElement.appendChild( child );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn domElement;\n\t\t}\n\t}\n\n\t/**\n\t * Converts children of the view element to DOM using the\n\t * {@link module:engine/view/domconverter~DomConverter#viewToDom} method.\n\t * Additionally, this method adds block {@link module:engine/view/filler filler} to the list of children, if needed.\n\t *\n\t * @param {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment} viewElement Parent view element.\n\t * @param {Document} domDocument Document which will be used to create DOM nodes.\n\t * @param {Object} options See {@link module:engine/view/domconverter~DomConverter#viewToDom} options parameter.\n\t * @returns {Iterable.<Node>} DOM nodes.\n\t */\n\t* viewChildrenToDom( viewElement, domDocument, options = {} ) {\n\t\tconst fillerPositionOffset = viewElement.getFillerOffset && viewElement.getFillerOffset();\n\t\tlet offset = 0;\n\n\t\tfor ( const childView of viewElement.getChildren() ) {\n\t\t\tif ( fillerPositionOffset === offset ) {\n\t\t\t\tyield this._blockFiller( domDocument );\n\t\t\t}\n\n\t\t\tyield this.viewToDom( childView, domDocument, options );\n\n\t\t\toffset++;\n\t\t}\n\n\t\tif ( fillerPositionOffset === offset ) {\n\t\t\tyield this._blockFiller( domDocument );\n\t\t}\n\t}\n\n\t/**\n\t * Converts view {@link module:engine/view/range~Range} to DOM range.\n\t * Inline and block {@link module:engine/view/filler fillers} are handled during the conversion.\n\t *\n\t * @param {module:engine/view/range~Range} viewRange View range.\n\t * @returns {Range} DOM range.\n\t */\n\tviewRangeToDom( viewRange ) {\n\t\tconst domStart = this.viewPositionToDom( viewRange.start );\n\t\tconst domEnd = this.viewPositionToDom( viewRange.end );\n\n\t\tconst domRange = document.createRange();\n\t\tdomRange.setStart( domStart.parent, domStart.offset );\n\t\tdomRange.setEnd( domEnd.parent, domEnd.offset );\n\n\t\treturn domRange;\n\t}\n\n\t/**\n\t * Converts view {@link module:engine/view/position~Position} to DOM parent and offset.\n\t *\n\t * Inline and block {@link module:engine/view/filler fillers} are handled during the conversion.\n\t * If the converted position is directly before inline filler it is moved inside the filler.\n\t *\n\t * @param {module:engine/view/position~Position} viewPosition View position.\n\t * @returns {Object|null} position DOM position or `null` if view position could not be converted to DOM.\n\t * @returns {Node} position.parent DOM position parent.\n\t * @returns {Number} position.offset DOM position offset.\n\t */\n\tviewPositionToDom( viewPosition ) {\n\t\tconst viewParent = viewPosition.parent;\n\n\t\tif ( viewParent.is( 'text' ) ) {\n\t\t\tconst domParent = this.findCorrespondingDomText( viewParent );\n\n\t\t\tif ( !domParent ) {\n\t\t\t\t// Position is in a view text node that has not been rendered to DOM yet.\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tlet offset = viewPosition.offset;\n\n\t\t\tif ( startsWithFiller( domParent ) ) {\n\t\t\t\toffset += INLINE_FILLER_LENGTH;\n\t\t\t}\n\n\t\t\treturn { parent: domParent, offset };\n\t\t} else {\n\t\t\t// viewParent is instance of ViewElement.\n\t\t\tlet domParent, domBefore, domAfter;\n\n\t\t\tif ( viewPosition.offset === 0 ) {\n\t\t\t\tdomParent = this.mapViewToDom( viewParent );\n\n\t\t\t\tif ( !domParent ) {\n\t\t\t\t\t// Position is in a view element that has not been rendered to DOM yet.\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tdomAfter = domParent.childNodes[ 0 ];\n\t\t\t} else {\n\t\t\t\tconst nodeBefore = viewPosition.nodeBefore;\n\n\t\t\t\tdomBefore = nodeBefore.is( 'text' ) ?\n\t\t\t\t\tthis.findCorrespondingDomText( nodeBefore ) :\n\t\t\t\t\tthis.mapViewToDom( viewPosition.nodeBefore );\n\n\t\t\t\tif ( !domBefore ) {\n\t\t\t\t\t// Position is after a view element that has not been rendered to DOM yet.\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tdomParent = domBefore.parentNode;\n\t\t\t\tdomAfter = domBefore.nextSibling;\n\t\t\t}\n\n\t\t\t// If there is an inline filler at position return position inside the filler. We should never return\n\t\t\t// the position before the inline filler.\n\t\t\tif ( isText( domAfter ) && startsWithFiller( domAfter ) ) {\n\t\t\t\treturn { parent: domAfter, offset: INLINE_FILLER_LENGTH };\n\t\t\t}\n\n\t\t\tconst offset = domBefore ? indexOf( domBefore ) + 1 : 0;\n\n\t\t\treturn { parent: domParent, offset };\n\t\t}\n\t}\n\n\t/**\n\t * Converts DOM to view. For all text nodes, not bound elements and document fragments new items will\n\t * be created. For bound elements and document fragments function will return corresponding items. For\n\t * {@link module:engine/view/filler fillers} `null` will be returned.\n\t * For all DOM elements rendered by {@link module:engine/view/uielement~UIElement} that UIElement will be returned.\n\t *\n\t * @param {Node|DocumentFragment} domNode DOM node or document fragment to transform.\n\t * @param {Object} [options] Conversion options.\n\t * @param {Boolean} [options.bind=false] Determines whether new elements will be bound.\n\t * @param {Boolean} [options.withChildren=true] If `true`, node's and document fragment's children will be converted too.\n\t * @param {Boolean} [options.keepOriginalCase=false] If `false`, node's tag name will be converter to lower case.\n\t * @returns {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment|null} Converted node or document fragment\n\t * or `null` if DOM node is a {@link module:engine/view/filler filler} or the given node is an empty text node.\n\t */\n\tdomToView( domNode, options = {} ) {\n\t\tif ( this.isBlockFiller( domNode, this.blockFillerMode ) ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// When node is inside UIElement return that UIElement as it's view representation.\n\t\tconst uiElement = this.getParentUIElement( domNode, this._domToViewMapping );\n\n\t\tif ( uiElement ) {\n\t\t\treturn uiElement;\n\t\t}\n\n\t\tif ( isText( domNode ) ) {\n\t\t\tif ( isInlineFiller( domNode ) ) {\n\t\t\t\treturn null;\n\t\t\t} else {\n\t\t\t\tconst textData = this._processDataFromDomText( domNode );\n\n\t\t\t\treturn textData === '' ? null : new ViewText( textData );\n\t\t\t}\n\t\t} else if ( this.isComment( domNode ) ) {\n\t\t\treturn null;\n\t\t} else {\n\t\t\tif ( this.mapDomToView( domNode ) ) {\n\t\t\t\treturn this.mapDomToView( domNode );\n\t\t\t}\n\n\t\t\tlet viewElement;\n\n\t\t\tif ( this.isDocumentFragment( domNode ) ) {\n\t\t\t\t// Create view document fragment.\n\t\t\t\tviewElement = new ViewDocumentFragment();\n\n\t\t\t\tif ( options.bind ) {\n\t\t\t\t\tthis.bindDocumentFragments( domNode, viewElement );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Create view element.\n\t\t\t\tconst viewName = options.keepOriginalCase ? domNode.tagName : domNode.tagName.toLowerCase();\n\t\t\t\tviewElement = new ViewElement( viewName );\n\n\t\t\t\tif ( options.bind ) {\n\t\t\t\t\tthis.bindElements( domNode, viewElement );\n\t\t\t\t}\n\n\t\t\t\t// Copy element's attributes.\n\t\t\t\tconst attrs = domNode.attributes;\n\n\t\t\t\tfor ( let i = attrs.length - 1; i >= 0; i-- ) {\n\t\t\t\t\tviewElement._setAttribute( attrs[ i ].name, attrs[ i ].value );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( options.withChildren || options.withChildren === undefined ) {\n\t\t\t\tfor ( const child of this.domChildrenToView( domNode, options ) ) {\n\t\t\t\t\tviewElement._appendChild( child );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn viewElement;\n\t\t}\n\t}\n\n\t/**\n\t * Converts children of the DOM element to view nodes using\n\t * the {@link module:engine/view/domconverter~DomConverter#domToView} method.\n\t * Additionally this method omits block {@link module:engine/view/filler filler}, if it exists in the DOM parent.\n\t *\n\t * @param {HTMLElement} domElement Parent DOM element.\n\t * @param {Object} options See {@link module:engine/view/domconverter~DomConverter#domToView} options parameter.\n\t * @returns {Iterable.<module:engine/view/node~Node>} View nodes.\n\t */\n\t* domChildrenToView( domElement, options = {} ) {\n\t\tfor ( let i = 0; i < domElement.childNodes.length; i++ ) {\n\t\t\tconst domChild = domElement.childNodes[ i ];\n\t\t\tconst viewChild = this.domToView( domChild, options );\n\n\t\t\tif ( viewChild !== null ) {\n\t\t\t\tyield viewChild;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Converts DOM selection to view {@link module:engine/view/selection~Selection}.\n\t * Ranges which cannot be converted will be omitted.\n\t *\n\t * @param {Selection} domSelection DOM selection.\n\t * @returns {module:engine/view/selection~Selection} View selection.\n\t */\n\tdomSelectionToView( domSelection ) {\n\t\t// DOM selection might be placed in fake selection container.\n\t\t// If container contains fake selection - return corresponding view selection.\n\t\tif ( domSelection.rangeCount === 1 ) {\n\t\t\tlet container = domSelection.getRangeAt( 0 ).startContainer;\n\n\t\t\t// The DOM selection might be moved to the text node inside the fake selection container.\n\t\t\tif ( isText( container ) ) {\n\t\t\t\tcontainer = container.parentNode;\n\t\t\t}\n\n\t\t\tconst viewSelection = this.fakeSelectionToView( container );\n\n\t\t\tif ( viewSelection ) {\n\t\t\t\treturn viewSelection;\n\t\t\t}\n\t\t}\n\n\t\tconst isBackward = this.isDomSelectionBackward( domSelection );\n\n\t\tconst viewRanges = [];\n\n\t\tfor ( let i = 0; i < domSelection.rangeCount; i++ ) {\n\t\t\t// DOM Range have correct start and end, no matter what is the DOM Selection direction. So we don't have to fix anything.\n\t\t\tconst domRange = domSelection.getRangeAt( i );\n\t\t\tconst viewRange = this.domRangeToView( domRange );\n\n\t\t\tif ( viewRange ) {\n\t\t\t\tviewRanges.push( viewRange );\n\t\t\t}\n\t\t}\n\n\t\treturn new ViewSelection( viewRanges, { backward: isBackward } );\n\t}\n\n\t/**\n\t * Converts DOM Range to view {@link module:engine/view/range~Range}.\n\t * If the start or end position can not be converted `null` is returned.\n\t *\n\t * @param {Range} domRange DOM range.\n\t * @returns {module:engine/view/range~Range|null} View range.\n\t */\n\tdomRangeToView( domRange ) {\n\t\tconst viewStart = this.domPositionToView( domRange.startContainer, domRange.startOffset );\n\t\tconst viewEnd = this.domPositionToView( domRange.endContainer, domRange.endOffset );\n\n\t\tif ( viewStart && viewEnd ) {\n\t\t\treturn new ViewRange( viewStart, viewEnd );\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Converts DOM parent and offset to view {@link module:engine/view/position~Position}.\n\t *\n\t * If the position is inside a {@link module:engine/view/filler filler} which has no corresponding view node,\n\t * position of the filler will be converted and returned.\n\t *\n\t * If the position is inside DOM element rendered by {@link module:engine/view/uielement~UIElement}\n\t * that position will be converted to view position before that UIElement.\n\t *\n\t * If structures are too different and it is not possible to find corresponding position then `null` will be returned.\n\t *\n\t * @param {Node} domParent DOM position parent.\n\t * @param {Number} domOffset DOM position offset.\n\t * @returns {module:engine/view/position~Position} viewPosition View position.\n\t */\n\tdomPositionToView( domParent, domOffset ) {\n\t\tif ( this.isBlockFiller( domParent, this.blockFillerMode ) ) {\n\t\t\treturn this.domPositionToView( domParent.parentNode, indexOf( domParent ) );\n\t\t}\n\n\t\t// If position is somewhere inside UIElement - return position before that element.\n\t\tconst viewElement = this.mapDomToView( domParent );\n\n\t\tif ( viewElement && viewElement.is( 'uiElement' ) ) {\n\t\t\treturn ViewPosition._createBefore( viewElement );\n\t\t}\n\n\t\tif ( isText( domParent ) ) {\n\t\t\tif ( isInlineFiller( domParent ) ) {\n\t\t\t\treturn this.domPositionToView( domParent.parentNode, indexOf( domParent ) );\n\t\t\t}\n\n\t\t\tconst viewParent = this.findCorrespondingViewText( domParent );\n\t\t\tlet offset = domOffset;\n\n\t\t\tif ( !viewParent ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif ( startsWithFiller( domParent ) ) {\n\t\t\t\toffset -= INLINE_FILLER_LENGTH;\n\t\t\t\toffset = offset < 0 ? 0 : offset;\n\t\t\t}\n\n\t\t\treturn new ViewPosition( viewParent, offset );\n\t\t}\n\t\t// domParent instanceof HTMLElement.\n\t\telse {\n\t\t\tif ( domOffset === 0 ) {\n\t\t\t\tconst viewParent = this.mapDomToView( domParent );\n\n\t\t\t\tif ( viewParent ) {\n\t\t\t\t\treturn new ViewPosition( viewParent, 0 );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst domBefore = domParent.childNodes[ domOffset - 1 ];\n\t\t\t\tconst viewBefore = isText( domBefore ) ?\n\t\t\t\t\tthis.findCorrespondingViewText( domBefore ) :\n\t\t\t\t\tthis.mapDomToView( domBefore );\n\n\t\t\t\t// TODO #663\n\t\t\t\tif ( viewBefore && viewBefore.parent ) {\n\t\t\t\t\treturn new ViewPosition( viewBefore.parent, viewBefore.index + 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Returns corresponding view {@link module:engine/view/element~Element Element} or\n\t * {@link module:engine/view/documentfragment~DocumentFragment} for provided DOM element or\n\t * document fragment. If there is no view item {@link module:engine/view/domconverter~DomConverter#bindElements bound}\n\t * to the given DOM - `undefined` is returned.\n\t * For all DOM elements rendered by {@link module:engine/view/uielement~UIElement} that UIElement will be returned.\n\t *\n\t * @param {DocumentFragment|Element} domElementOrDocumentFragment DOM element or document fragment.\n\t * @returns {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment|undefined}\n\t * Corresponding view element, document fragment or `undefined` if no element was bound.\n\t */\n\tmapDomToView( domElementOrDocumentFragment ) {\n\t\treturn this.getParentUIElement( domElementOrDocumentFragment ) || this._domToViewMapping.get( domElementOrDocumentFragment );\n\t}\n\n\t/**\n\t * Finds corresponding text node. Text nodes are not {@link module:engine/view/domconverter~DomConverter#bindElements bound},\n\t * corresponding text node is returned based on the sibling or parent.\n\t *\n\t * If the directly previous sibling is a {@link module:engine/view/domconverter~DomConverter#bindElements bound} element, it is used\n\t * to find the corresponding text node.\n\t *\n\t * If this is a first child in the parent and the parent is a {@link module:engine/view/domconverter~DomConverter#bindElements bound}\n\t * element, it is used to find the corresponding text node.\n\t *\n\t * For all text nodes rendered by {@link module:engine/view/uielement~UIElement} that UIElement will be returned.\n\t *\n\t * Otherwise `null` is returned.\n\t *\n\t * Note that for the block or inline {@link module:engine/view/filler filler} this method returns `null`.\n\t *\n\t * @param {Text} domText DOM text node.\n\t * @returns {module:engine/view/text~Text|null} Corresponding view text node or `null`, if it was not possible to find a\n\t * corresponding node.\n\t */\n\tfindCorrespondingViewText( domText ) {\n\t\tif ( isInlineFiller( domText ) ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// If DOM text was rendered by UIElement - return that element.\n\t\tconst uiElement = this.getParentUIElement( domText );\n\n\t\tif ( uiElement ) {\n\t\t\treturn uiElement;\n\t\t}\n\n\t\tconst previousSibling = domText.previousSibling;\n\n\t\t// Try to use previous sibling to find the corresponding text node.\n\t\tif ( previousSibling ) {\n\t\t\tif ( !( this.isElement( previousSibling ) ) ) {\n\t\t\t\t// The previous is text or comment.\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst viewElement = this.mapDomToView( previousSibling );\n\n\t\t\tif ( viewElement ) {\n\t\t\t\tconst nextSibling = viewElement.nextSibling;\n\n\t\t\t\t// It might be filler which has no corresponding view node.\n\t\t\t\tif ( nextSibling instanceof ViewText ) {\n\t\t\t\t\treturn viewElement.nextSibling;\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Try to use parent to find the corresponding text node.\n\t\telse {\n\t\t\tconst viewElement = this.mapDomToView( domText.parentNode );\n\n\t\t\tif ( viewElement ) {\n\t\t\t\tconst firstChild = viewElement.getChild( 0 );\n\n\t\t\t\t// It might be filler which has no corresponding view node.\n\t\t\t\tif ( firstChild instanceof ViewText ) {\n\t\t\t\t\treturn firstChild;\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Returns corresponding DOM item for provided {@link module:engine/view/element~Element Element} or\n\t * {@link module:engine/view/documentfragment~DocumentFragment DocumentFragment}.\n\t * To find a corresponding text for {@link module:engine/view/text~Text view Text instance}\n\t * use {@link #findCorrespondingDomText}.\n\t *\n\t * @param {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment} viewNode\n\t * View element or document fragment.\n\t * @returns {Node|DocumentFragment|undefined} Corresponding DOM node or document fragment.\n\t */\n\tmapViewToDom( documentFragmentOrElement ) {\n\t\treturn this._viewToDomMapping.get( documentFragmentOrElement );\n\t}\n\n\t/**\n\t * Finds corresponding text node. Text nodes are not {@link module:engine/view/domconverter~DomConverter#bindElements bound},\n\t * corresponding text node is returned based on the sibling or parent.\n\t *\n\t * If the directly previous sibling is a {@link module:engine/view/domconverter~DomConverter#bindElements bound} element, it is used\n\t * to find the corresponding text node.\n\t *\n\t * If this is a first child in the parent and the parent is a {@link module:engine/view/domconverter~DomConverter#bindElements bound}\n\t * element, it is used to find the corresponding text node.\n\t *\n\t * Otherwise `null` is returned.\n\t *\n\t * @param {module:engine/view/text~Text} viewText View text node.\n\t * @returns {Text|null} Corresponding DOM text node or `null`, if it was not possible to find a corresponding node.\n\t */\n\tfindCorrespondingDomText( viewText ) {\n\t\tconst previousSibling = viewText.previousSibling;\n\n\t\t// Try to use previous sibling to find the corresponding text node.\n\t\tif ( previousSibling && this.mapViewToDom( previousSibling ) ) {\n\t\t\treturn this.mapViewToDom( previousSibling ).nextSibling;\n\t\t}\n\n\t\t// If this is a first node, try to use parent to find the corresponding text node.\n\t\tif ( !previousSibling && viewText.parent && this.mapViewToDom( viewText.parent ) ) {\n\t\t\treturn this.mapViewToDom( viewText.parent ).childNodes[ 0 ];\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Focuses DOM editable that is corresponding to provided {@link module:engine/view/editableelement~EditableElement}.\n\t *\n\t * @param {module:engine/view/editableelement~EditableElement} viewEditable\n\t */\n\tfocus( viewEditable ) {\n\t\tconst domEditable = this.mapViewToDom( viewEditable );\n\n\t\tif ( domEditable && domEditable.ownerDocument.activeElement !== domEditable ) {\n\t\t\t// Save the scrollX and scrollY positions before the focus.\n\t\t\tconst { scrollX, scrollY } = global.window;\n\t\t\tconst scrollPositions = [];\n\n\t\t\t// Save all scrollLeft and scrollTop values starting from domEditable up to\n\t\t\t// document#documentElement.\n\t\t\tforEachDomNodeAncestor( domEditable, node => {\n\t\t\t\tconst { scrollLeft, scrollTop } = node;\n\n\t\t\t\tscrollPositions.push( [ scrollLeft, scrollTop ] );\n\t\t\t} );\n\n\t\t\tdomEditable.focus();\n\n\t\t\t// Restore scrollLeft and scrollTop values starting from domEditable up to\n\t\t\t// document#documentElement.\n\t\t\t// https://github.com/ckeditor/ckeditor5-engine/issues/951\n\t\t\t// https://github.com/ckeditor/ckeditor5-engine/issues/957\n\t\t\tforEachDomNodeAncestor( domEditable, node => {\n\t\t\t\tconst [ scrollLeft, scrollTop ] = scrollPositions.shift();\n\n\t\t\t\tnode.scrollLeft = scrollLeft;\n\t\t\t\tnode.scrollTop = scrollTop;\n\t\t\t} );\n\n\t\t\t// Restore the scrollX and scrollY positions after the focus.\n\t\t\t// https://github.com/ckeditor/ckeditor5-engine/issues/951\n\t\t\tglobal.window.scrollTo( scrollX, scrollY );\n\t\t}\n\t}\n\n\t/**\n\t * Returns `true` when `node.nodeType` equals `Node.ELEMENT_NODE`.\n\t *\n\t * @param {Node} node Node to check.\n\t * @returns {Boolean}\n\t */\n\tisElement( node ) {\n\t\treturn node && node.nodeType == Node.ELEMENT_NODE;\n\t}\n\n\t/**\n\t * Returns `true` when `node.nodeType` equals `Node.DOCUMENT_FRAGMENT_NODE`.\n\t *\n\t * @param {Node} node Node to check.\n\t * @returns {Boolean}\n\t */\n\tisDocumentFragment( node ) {\n\t\treturn node && node.nodeType == Node.DOCUMENT_FRAGMENT_NODE;\n\t}\n\n\t/**\n\t * Returns `true` when `node.nodeType` equals `Node.COMMENT_NODE`.\n\t *\n\t * @param {Node} node Node to check.\n\t * @returns {Boolean}\n\t */\n\tisComment( node ) {\n\t\treturn node && node.nodeType == Node.COMMENT_NODE;\n\t}\n\n\t/**\n\t * Checks if the node is an instance of the block filler for this DOM converter.\n\t *\n\t *\t\tconst converter = new DomConverter( { blockFillerMode: 'br' } );\n\t *\n\t *\t\tconverter.isBlockFiller( BR_FILLER( document ) ); // true\n\t *\t\tconverter.isBlockFiller( NBSP_FILLER( document ) ); // false\n\t *\n\t * **Note:**: For the `'nbsp'` mode the method also checks context of a node so it cannot be a detached node.\n\t *\n\t * **Note:** A special case in the `'nbsp'` mode exists where the `<br>` in `<p><br></p>` is treated as a block filler.\n\t *\n\t * @param {Node} domNode DOM node to check.\n\t * @returns {Boolean} True if a node is considered a block filler for given mode.\n\t */\n\tisBlockFiller( domNode ) {\n\t\tif ( this.blockFillerMode == 'br' ) {\n\t\t\treturn domNode.isEqualNode( BR_FILLER_REF );\n\t\t}\n\n\t\t// Special case for <p><br></p> in which case the <br> should be treated as filler even\n\t\t// when we're in the 'nbsp' mode. See ckeditor5#5564.\n\t\tif ( domNode.tagName === 'BR' && hasBlockParent( domNode, this.blockElements ) && domNode.parentNode.childNodes.length === 1 ) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn isNbspBlockFiller( domNode, this.blockElements );\n\t}\n\n\t/**\n\t * Returns `true` if given selection is a backward selection, that is, if it's `focus` is before `anchor`.\n\t *\n\t * @param {Selection} DOM Selection instance to check.\n\t * @returns {Boolean}\n\t */\n\tisDomSelectionBackward( selection ) {\n\t\tif ( selection.isCollapsed ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Since it takes multiple lines of code to check whether a \"DOM Position\" is before/after another \"DOM Position\",\n\t\t// we will use the fact that range will collapse if it's end is before it's start.\n\t\tconst range = document.createRange();\n\n\t\trange.setStart( selection.anchorNode, selection.anchorOffset );\n\t\trange.setEnd( selection.focusNode, selection.focusOffset );\n\n\t\tconst backward = range.collapsed;\n\n\t\trange.detach();\n\n\t\treturn backward;\n\t}\n\n\t/**\n\t * Returns parent {@link module:engine/view/uielement~UIElement} for provided DOM node. Returns `null` if there is no\n\t * parent UIElement.\n\t *\n\t * @param {Node} domNode\n\t * @returns {module:engine/view/uielement~UIElement|null}\n\t */\n\tgetParentUIElement( domNode ) {\n\t\tconst ancestors = getAncestors( domNode );\n\n\t\t// Remove domNode from the list.\n\t\tancestors.pop();\n\n\t\twhile ( ancestors.length ) {\n\t\t\tconst domNode = ancestors.pop();\n\t\t\tconst viewNode = this._domToViewMapping.get( domNode );\n\n\t\t\tif ( viewNode && viewNode.is( 'uiElement' ) ) {\n\t\t\t\treturn viewNode;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Checks if given selection's boundaries are at correct places.\n\t *\n\t * The following places are considered as incorrect for selection boundaries:\n\t * * before or in the middle of the inline filler sequence,\n\t * * inside the DOM element which represents {@link module:engine/view/uielement~UIElement a view ui element}.\n\t *\n\t * @param {Selection} domSelection DOM Selection object to be checked.\n\t * @returns {Boolean} `true` if the given selection is at a correct place, `false` otherwise.\n\t */\n\tisDomSelectionCorrect( domSelection ) {\n\t\treturn this._isDomSelectionPositionCorrect( domSelection.anchorNode, domSelection.anchorOffset ) &&\n\t\t\tthis._isDomSelectionPositionCorrect( domSelection.focusNode, domSelection.focusOffset );\n\t}\n\n\t/**\n\t * Checks if the given DOM position is a correct place for selection boundary. See {@link #isDomSelectionCorrect}.\n\t *\n\t * @private\n\t * @param {Element} domParent Position parent.\n\t * @param {Number} offset Position offset.\n\t * @returns {Boolean} `true` if given position is at a correct place for selection boundary, `false` otherwise.\n\t */\n\t_isDomSelectionPositionCorrect( domParent, offset ) {\n\t\t// If selection is before or in the middle of inline filler string, it is incorrect.\n\t\tif ( isText( domParent ) && startsWithFiller( domParent ) && offset < INLINE_FILLER_LENGTH ) {\n\t\t\t// Selection in a text node, at wrong position (before or in the middle of filler).\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( this.isElement( domParent ) && startsWithFiller( domParent.childNodes[ offset ] ) ) {\n\t\t\t// Selection in an element node, before filler text node.\n\t\t\treturn false;\n\t\t}\n\n\t\tconst viewParent = this.mapDomToView( domParent );\n\n\t\t// If selection is in `view.UIElement`, it is incorrect. Note that `mapDomToView()` returns `view.UIElement`\n\t\t// also for any dom element that is inside the view ui element (so we don't need to perform any additional checks).\n\t\tif ( viewParent && viewParent.is( 'uiElement' ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Takes text data from a given {@link module:engine/view/text~Text#data} and processes it so\n\t * it is correctly displayed in the DOM.\n\t *\n\t * Following changes are done:\n\t *\n\t * * a space at the beginning is changed to `&nbsp;` if this is the first text node in its container\n\t * element or if a previous text node ends with a space character,\n\t * * space at the end of the text node is changed to `&nbsp;` if there are two spaces at the end of a node or if next node\n\t * starts with a space or if it is the last text node in its container,\n\t * * remaining spaces are replaced to a chain of spaces and `&nbsp;` (e.g. `'x   x'` becomes `'x &nbsp; x'`).\n\t *\n\t * Content of {@link #preElements} is not processed.\n\t *\n\t * @private\n\t * @param {module:engine/view/text~Text} node View text node to process.\n\t * @returns {String} Processed text data.\n\t */\n\t_processDataFromViewText( node ) {\n\t\tlet data = node.data;\n\n\t\t// If any of node ancestors has a name which is in `preElements` array, then currently processed\n\t\t// view text node is (will be) in preformatted element. We should not change whitespaces then.\n\t\tif ( node.getAncestors().some( parent => this.preElements.includes( parent.name ) ) ) {\n\t\t\treturn data;\n\t\t}\n\n\t\t// 1. Replace the first space with a nbsp if the previous node ends with a space or there is no previous node\n\t\t// (container element boundary).\n\t\tif ( data.charAt( 0 ) == ' ' ) {\n\t\t\tconst prevNode = this._getTouchingViewTextNode( node, false );\n\t\t\tconst prevEndsWithSpace = prevNode && this._nodeEndsWithSpace( prevNode );\n\n\t\t\tif ( prevEndsWithSpace || !prevNode ) {\n\t\t\t\tdata = '\\u00A0' + data.substr( 1 );\n\t\t\t}\n\t\t}\n\n\t\t// 2. Replace the last space with nbsp if there are two spaces at the end or if the next node starts with space or there is no\n\t\t// next node (container element boundary).\n\t\t//\n\t\t// Keep in mind that Firefox prefers $nbsp; before tag, not inside it:\n\t\t//\n\t\t// Foo <span>&nbsp;bar</span>  <-- bad.\n\t\t// Foo&nbsp;<span> bar</span>  <-- good.\n\t\t//\n\t\t// More here: https://github.com/ckeditor/ckeditor5-engine/issues/1747.\n\t\tif ( data.charAt( data.length - 1 ) == ' ' ) {\n\t\t\tconst nextNode = this._getTouchingViewTextNode( node, true );\n\n\t\t\tif ( data.charAt( data.length - 2 ) == ' ' || !nextNode || nextNode.data.charAt( 0 ) == ' ' ) {\n\t\t\t\tdata = data.substr( 0, data.length - 1 ) + '\\u00A0';\n\t\t\t}\n\t\t}\n\n\t\t// 3. Create space+nbsp pairs.\n\t\treturn data.replace( / {2}/g, ' \\u00A0' );\n\t}\n\n\t/**\n\t * Checks whether given node ends with a space character after changing appropriate space characters to `&nbsp;`s.\n\t *\n\t * @private\n\t * @param {module:engine/view/text~Text} node Node to check.\n\t * @returns {Boolean} `true` if given `node` ends with space, `false` otherwise.\n\t */\n\t_nodeEndsWithSpace( node ) {\n\t\tif ( node.getAncestors().some( parent => this.preElements.includes( parent.name ) ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst data = this._processDataFromViewText( node );\n\n\t\treturn data.charAt( data.length - 1 ) == ' ';\n\t}\n\n\t/**\n\t * Takes text data from native `Text` node and processes it to a correct {@link module:engine/view/text~Text view text node} data.\n\t *\n\t * Following changes are done:\n\t *\n\t * * multiple whitespaces are replaced to a single space,\n\t * * space at the beginning of a text node is removed if it is the first text node in its container\n\t * element or if the previous text node ends with a space character,\n\t * * space at the end of the text node is removed if there are two spaces at the end of a node or if next node\n\t * starts with a space or if it is the last text node in its container\n\t * * nbsps are converted to spaces.\n\t *\n\t * @param {Node} node DOM text node to process.\n\t * @returns {String} Processed data.\n\t * @private\n\t */\n\t_processDataFromDomText( node ) {\n\t\tlet data = node.data;\n\n\t\tif ( _hasDomParentOfType( node, this.preElements ) ) {\n\t\t\treturn getDataWithoutFiller( node );\n\t\t}\n\n\t\t// Change all consecutive whitespace characters (from the [ \\n\\t\\r] set \n\t\t// see https://github.com/ckeditor/ckeditor5-engine/issues/822#issuecomment-311670249) to a single space character.\n\t\t// That's how multiple whitespaces are treated when rendered, so we normalize those whitespaces.\n\t\t// We're replacing 1+ (and not 2+) to also normalize singular \\n\\t\\r characters (#822).\n\t\tdata = data.replace( /[ \\n\\t\\r]{1,}/g, ' ' );\n\n\t\tconst prevNode = this._getTouchingInlineDomNode( node, false );\n\t\tconst nextNode = this._getTouchingInlineDomNode( node, true );\n\n\t\tconst shouldLeftTrim = this._checkShouldLeftTrimDomText( prevNode );\n\t\tconst shouldRightTrim = this._checkShouldRightTrimDomText( node, nextNode );\n\n\t\t// If the previous dom text node does not exist or it ends by whitespace character, remove space character from the beginning\n\t\t// of this text node. Such space character is treated as a whitespace.\n\t\tif ( shouldLeftTrim ) {\n\t\t\tdata = data.replace( /^ /, '' );\n\t\t}\n\n\t\t// If the next text node does not exist remove space character from the end of this text node.\n\t\tif ( shouldRightTrim ) {\n\t\t\tdata = data.replace( / $/, '' );\n\t\t}\n\n\t\t// At the beginning and end of a block element, Firefox inserts normal space + <br> instead of non-breaking space.\n\t\t// This means that the text node starts/end with normal space instead of non-breaking space.\n\t\t// This causes a problem because the normal space would be removed in `.replace` calls above. To prevent that,\n\t\t// the inline filler is removed only after the data is initially processed (by the `.replace` above). See ckeditor5#692.\n\t\tdata = getDataWithoutFiller( new Text( data ) );\n\n\t\t// At this point we should have removed all whitespaces from DOM text data.\n\t\t//\n\t\t// Now, We will reverse the process that happens in `_processDataFromViewText`.\n\t\t//\n\t\t// We have to change &nbsp; chars, that were in DOM text data because of rendering reasons, to spaces.\n\t\t// First, change all ` \\u00A0` pairs (space + &nbsp;) to two spaces. DOM converter changes two spaces from model/view to\n\t\t// ` \\u00A0` to ensure proper rendering. Since here we convert back, we recognize those pairs and change them back to `  `.\n\t\tdata = data.replace( / \\u00A0/g, '  ' );\n\n\t\t// Then, let's change the last nbsp to a space.\n\t\tif ( /( |\\u00A0)\\u00A0$/.test( data ) || !nextNode || ( nextNode.data && nextNode.data.charAt( 0 ) == ' ' ) ) {\n\t\t\tdata = data.replace( /\\u00A0$/, ' ' );\n\t\t}\n\n\t\t// Then, change &nbsp; character that is at the beginning of the text node to space character.\n\t\t// We do that replacement only if this is the first node or the previous node ends on whitespace character.\n\t\tif ( shouldLeftTrim ) {\n\t\t\tdata = data.replace( /^\\u00A0/, ' ' );\n\t\t}\n\n\t\t// At this point, all whitespaces should be removed and all &nbsp; created for rendering reasons should be\n\t\t// changed to normal space. All left &nbsp; are &nbsp; inserted intentionally.\n\t\treturn data;\n\t}\n\n\t/**\n\t * Helper function which checks if a DOM text node, preceded by the given `prevNode` should\n\t * be trimmed from the left side.\n\t *\n\t * @param {Node} prevNode\n\t */\n\t_checkShouldLeftTrimDomText( prevNode ) {\n\t\tif ( !prevNode ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif ( isElement( prevNode ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn /[^\\S\\u00A0]/.test( prevNode.data.charAt( prevNode.data.length - 1 ) );\n\t}\n\n\t/**\n\t * Helper function which checks if a DOM text node, succeeded by the given `nextNode` should\n\t * be trimmed from the right side.\n\t *\n\t * @param {Node} node\n\t * @param {Node} nextNode\n\t */\n\t_checkShouldRightTrimDomText( node, nextNode ) {\n\t\tif ( nextNode ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn !startsWithFiller( node );\n\t}\n\n\t/**\n\t * Helper function. For given {@link module:engine/view/text~Text view text node}, it finds previous or next sibling\n\t * that is contained in the same container element. If there is no such sibling, `null` is returned.\n\t *\n\t * @param {module:engine/view/text~Text} node Reference node.\n\t * @param {Boolean} getNext\n\t * @returns {module:engine/view/text~Text|null} Touching text node or `null` if there is no next or previous touching text node.\n\t */\n\t_getTouchingViewTextNode( node, getNext ) {\n\t\tconst treeWalker = new ViewTreeWalker( {\n\t\t\tstartPosition: getNext ? ViewPosition._createAfter( node ) : ViewPosition._createBefore( node ),\n\t\t\tdirection: getNext ? 'forward' : 'backward'\n\t\t} );\n\n\t\tfor ( const value of treeWalker ) {\n\t\t\t// ViewContainerElement is found on a way to next ViewText node, so given `node` was first/last\n\t\t\t// text node in its container element.\n\t\t\tif ( value.item.is( 'containerElement' ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t// <br> found  it works like a block boundary, so do not scan further.\n\t\t\telse if ( value.item.is( 'br' ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t// Found a text node in the same container element.\n\t\t\telse if ( value.item.is( 'textProxy' ) ) {\n\t\t\t\treturn value.item;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Helper function. For the given text node, it finds the closest touching node which is either\n\t * a text node or a `<br>`. The search is terminated at block element boundaries and if a matching node\n\t * wasn't found so far, `null` is returned.\n\t *\n\t * In the following DOM structure:\n\t *\n\t *\t\t<p>foo<b>bar</b><br>bom</p>\n\t *\n\t * * `foo` doesn't have its previous touching inline node (`null` is returned),\n\t * * `foo`'s next touching inline node is `bar`\n\t * * `bar`'s next touching inline node is `<br>`\n\t *\n\t * This method returns text nodes and `<br>` elements because these types of nodes affect how\n\t * spaces in the given text node need to be converted.\n\t *\n\t * @private\n\t * @param {Text} node\n\t * @param {Boolean} getNext\n\t * @returns {Text|Element|null}\n\t */\n\t_getTouchingInlineDomNode( node, getNext ) {\n\t\tif ( !node.parentNode ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst direction = getNext ? 'nextNode' : 'previousNode';\n\t\tconst document = node.ownerDocument;\n\t\tconst topmostParent = getAncestors( node )[ 0 ];\n\n\t\tconst treeWalker = document.createTreeWalker( topmostParent, NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT, {\n\t\t\tacceptNode( node ) {\n\t\t\t\tif ( isText( node ) ) {\n\t\t\t\t\treturn NodeFilter.FILTER_ACCEPT;\n\t\t\t\t}\n\n\t\t\t\tif ( node.tagName == 'BR' ) {\n\t\t\t\t\treturn NodeFilter.FILTER_ACCEPT;\n\t\t\t\t}\n\n\t\t\t\treturn NodeFilter.FILTER_SKIP;\n\t\t\t}\n\t\t} );\n\n\t\ttreeWalker.currentNode = node;\n\n\t\tconst touchingNode = treeWalker[ direction ]();\n\n\t\tif ( touchingNode !== null ) {\n\t\t\tconst lca = getCommonAncestor( node, touchingNode );\n\n\t\t\t// If there is common ancestor between the text node and next/prev text node,\n\t\t\t// and there are no block elements on a way from the text node to that ancestor,\n\t\t\t// and there are no block elements on a way from next/prev text node to that ancestor...\n\t\t\tif (\n\t\t\t\tlca &&\n\t\t\t\t!_hasDomParentOfType( node, this.blockElements, lca ) &&\n\t\t\t\t!_hasDomParentOfType( touchingNode, this.blockElements, lca )\n\t\t\t) {\n\t\t\t\t// Then they are in the same container element.\n\t\t\t\treturn touchingNode;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n}\n\n// Helper function.\n// Used to check if given native `Element` or `Text` node has parent with tag name from `types` array.\n//\n// @param {Node} node\n// @param {Array.<String>} types\n// @param {Boolean} [boundaryParent] Can be given if parents should be checked up to a given element (excluding that element).\n// @returns {Boolean} `true` if such parent exists or `false` if it does not.\nfunction _hasDomParentOfType( node, types, boundaryParent ) {\n\tlet parents = getAncestors( node );\n\n\tif ( boundaryParent ) {\n\t\tparents = parents.slice( parents.indexOf( boundaryParent ) + 1 );\n\t}\n\n\treturn parents.some( parent => parent.tagName && types.includes( parent.tagName.toLowerCase() ) );\n}\n\n// A helper that executes given callback for each DOM node's ancestor, starting from the given node\n// and ending in document#documentElement.\n//\n// @param {Node} node\n// @param {Function} callback A callback to be executed for each ancestor.\nfunction forEachDomNodeAncestor( node, callback ) {\n\twhile ( node && node != global.document ) {\n\t\tcallback( node );\n\t\tnode = node.parentNode;\n\t}\n}\n\n// Checks if given node is a nbsp block filler.\n//\n// A &nbsp; is a block filler only if it is a single child of a block element.\n//\n// @param {Node} domNode DOM node.\n// @returns {Boolean}\nfunction isNbspBlockFiller( domNode, blockElements ) {\n\tconst isNBSP = isText( domNode ) && domNode.data == '\\u00A0';\n\n\treturn isNBSP && hasBlockParent( domNode, blockElements ) && domNode.parentNode.childNodes.length === 1;\n}\n\n// Checks if domNode has block parent.\n//\n// @param {Node} domNode DOM node.\n// @returns {Boolean}\nfunction hasBlockParent( domNode, blockElements ) {\n\tconst parent = domNode.parentNode;\n\n\treturn parent && parent.tagName && blockElements.includes( parent.tagName.toLowerCase() );\n}\n\n/**\n * Enum representing type of the block filler.\n *\n * Possible values:\n *\n * * `br` - for `<br>` block filler used in editing view,\n * * `nbsp` - for `&nbsp;` block fillers used in the data.\n *\n * @typedef {String} module:engine/view/filler~BlockFillerMode\n */\n"]}]}